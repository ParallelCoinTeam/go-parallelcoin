//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct vtable_3010_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_3028_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_3058_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_3098_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

// ------------------------- Classes --------------------------

// N5boost10lock_errorE (base classes: N5boost16thread_exceptionE)
// N5boost16exception_detail10clone_baseE
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE (base classes: N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE (base classes: N5boost10lock_errorE, N5boost9exceptionE)
// N5boost16thread_exceptionE
// N5boost9exceptionE

// ------------------- Function Prototypes --------------------

void _7e_clone_impl(int32_t this, int32_t __in_chrg);
int32_t _GLOBAL__sub_I__ZN8CCrypter20SetKeyFromPassphraseERKSbIcSt11char_traitsIcE16secure_allocatorIcEERKSt6vectorIhSaIhEEjj(void);
bool _Z13DecryptSecretRKSt6vectorIh16secure_allocatorIhEERKS_IhSaIhEERK7uint256RS2_(int32_t vMasterKey, int32_t vchCiphertext, int32_t nIV, uint32_t vchPlaintext);
bool _Z13EncryptSecretRKSt6vectorIh16secure_allocatorIhEES4_RK7uint256RS_IhSaIhEE(int32_t vMasterKey, int32_t vchPlaintext, int32_t nIV, uint32_t vchCiphertext);
int32_t _ZN21LockedPageManagerBaseI16MemoryPageLockerE11UnlockRangeEPvj(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZN5boost10lock_errorD0Ev(int32_t * a1);
int32_t _ZN5boost10lock_errorD1Ev(int32_t * a1);
int32_t _ZN5boost11unique_lockINS_5mutexEED2Ev_part_36(void);
int32_t _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(int32_t a1);
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEEaSERKS3_(int32_t * a1, int32_t a2);
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEEC1ERKS3_(int32_t * a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t * a1);
int32_t _ZN5boost16thread_exceptionD0Ev(int32_t * a1);
int32_t _ZN5boost16thread_exceptionD1Ev(int32_t * a1);
int32_t _ZN8CCrypter20SetKeyFromPassphraseERKSbIcSt11char_traitsIcE16secure_allocatorIcEERKSt6vectorIhSaIhEEjj(void);
void _ZN8CCrypter6SetKeyERKSt6vectorIh16secure_allocatorIhEERKS0_IhSaIhEE(int32_t this, int32_t chNewKey, int32_t chNewIV);
void _ZN8CCrypter7DecryptERKSt6vectorIhSaIhEERS0_Ih16secure_allocatorIhEE(int32_t this, int32_t vchCiphertext, int32_t vchPlaintext);
void _ZN8CCrypter7EncryptERKSt6vectorIh16secure_allocatorIhEERS0_IhSaIhEE(int32_t this, int32_t vchPlaintext, int32_t vchCiphertext);
int32_t _ZN8CCrypterD1Ev(int32_t a1);
int32_t _ZNK5boost10lock_error4whatEv(void);
void _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t this);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZNSt6vectorIh16secure_allocatorIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS2_EEjRKh(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t _ZNSt6vectorIh16secure_allocatorIhEEaSERKS2_(int32_t * a1, int32_t a2);
int32_t _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t _ZNSt6vectorIhSaIhEEaSERKS1_(int32_t * a1, int32_t a2);
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE10_M_insert_EPKSt18_Rb_tree_node_baseSB_RKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE16_M_insert_uniqueERKS2_(int32_t * a1, int32_t a2);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t a1);
int32_t _ZTSN5boost16exception_detail10clone_baseE(int32_t a1);
int32_t function_10b2(int16_t a1);
int32_t function_10c2(void);
int32_t function_10da(void);
int32_t function_10e8(void);
int32_t function_10fb(void);
int32_t function_1167(void);
int32_t function_1194(void);
int32_t function_11aa(void);
int32_t function_11cd(void);
int32_t function_1245(void);
int32_t function_1250(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1280(void);
int32_t function_12a8(void);
int32_t function_12b8(void);
int32_t function_12e8(void);
int32_t function_12f8(void);
int32_t function_1339(void);
int32_t function_133a(void);
int32_t function_134b(void);
int32_t function_1353(void);
int32_t function_1355(void);
int32_t function_1367(void);
int32_t function_136b(void);
int32_t function_13ac(void);
int32_t function_13b3(void);
int32_t function_13bf(void);
int32_t function_13d4(void);
int32_t function_1414(void);
int32_t function_1523(int32_t a1);
int32_t function_1563(int32_t a1);
int32_t function_1603(int32_t a1);
int32_t function_16e0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1998(int32_t a1);
int32_t function_19a1(void);
int32_t function_19a7(void);
int32_t function_1a30(int32_t a1);
int32_t function_1a3f(void);
int32_t function_1ad0(int32_t a1);
int32_t function_1ad9(void);
int32_t function_1adf(void);
int32_t function_1b78(int32_t a1);
int32_t function_1b87(void);
int32_t function_1d10(void);
int32_t function_1db0(void);
int32_t function_1e88(void);
int32_t function_1eba(void);
int32_t function_1f30(void);
int32_t function_1faf(void);
int32_t function_1fbd(void);
int32_t function_2000(void);
int32_t function_2077(void);
int32_t function_2085(void);
int32_t function_2090(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_20b0(void);
int32_t function_20ec(void);
int32_t function_20f1(void);
int32_t function_211b(int32_t a1);
int32_t function_21a3(int32_t a1, int32_t a2);
int32_t function_21a6(int32_t a1);
int32_t function_21d0(void);
int32_t function_21f5(void);
int32_t function_2200(int32_t a1, int32_t a2);
int32_t function_2257(void);
int32_t function_2274(void);
int32_t function_22ad(void);
int32_t function_2342(void);
int32_t function_2349(void);
int32_t function_2354(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2370(void);
int32_t function_2494(void);
int32_t function_24dc(int32_t a1);
int32_t function_2508(void);
int32_t function_2579(void);
int32_t function_2598(void);
int32_t function_25fc(int32_t a1, int32_t a2);
int32_t function_2618(void);
int32_t function_2620(int32_t a1);
int32_t function_263b(void);
int32_t function_2640(void);
int32_t function_26d2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2708(int32_t a1, int32_t a2);
int32_t function_2720(void);
int32_t function_27e0(int32_t result);
int32_t function_2813(void);
int32_t function_2920(void);
int32_t function_2966(void);
int32_t function_2976(void);
int32_t function_298a(char * a1);
int32_t function_29cc(int16_t a1);
int32_t function_29de(void);
int32_t function_29f5(int32_t a1);
int32_t function_2a09(int32_t a1);
int32_t function_2a17(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a26(void);
int32_t function_2a48(void);
int32_t function_2a6(int32_t a1);
int32_t function_2a89(void);
int32_t function_2a93(void);
int32_t function_2ad5(void);
int32_t function_2ada(int32_t a1);
int32_t function_2be8(void);
int32_t function_2c2e(void);
int32_t function_2c40(void);
int32_t function_2c54(char * a1, int32_t a2);
int32_t function_2cfb(void);
int32_t function_2d0c(int32_t a1);
int32_t function_2d28(void);
int32_t function_2d91(void);
int32_t function_2da8(char * a1);
int32_t function_2e0a(void);
int32_t function_2e28(void);
int32_t function_2e69(int32_t a1, int32_t a2);
int32_t function_2e96(void);
int32_t function_2e9c(void);
int32_t function_2ede(void);
int32_t function_2f36(void);
int32_t function_33a(void);
int32_t function_34c0(int32_t a1);
int32_t function_394(void);
int32_t function_39b(int32_t a1, int32_t a2);
int32_t function_3f4(int32_t a1);
int32_t function_3f9(void);
int32_t function_405(void);
int32_t function_4b0(void);
int32_t function_500(void);
int32_t function_558(void);
int32_t function_59e(void);
int32_t function_5a8(void);
int32_t function_5e4(void);
int32_t function_64(void);
int32_t function_6c2(int16_t a1);
int32_t function_6f8(void);
int32_t function_777(void);
int32_t function_785(void);
int32_t function_7c8(void);
int32_t function_847(void);
int32_t function_855(void);
int32_t function_860(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_890(void);
int32_t function_8b8(void);
int32_t function_8f(void);
int32_t function_8f8(void);
int32_t function_949(void);
int32_t function_94a(void);
int32_t function_95b(void);
int32_t function_963(void);
int32_t function_965(void);
int32_t function_977(void);
int32_t function_97b(void);
int32_t function_9bc(void);
int32_t function_9c3(void);
int32_t function_9cf(void);
int32_t function_9e4(void);
int32_t function_a24(void);
int32_t function_b18(void);
int32_t function_b5e(void);
int32_t function_b68(void);
int32_t function_ba3(int32_t a1);
int32_t function_bf1(void);
int32_t function_c10(void);
int32_t function_c35(void);
int32_t function_c40(void);
int32_t function_cdc(int32_t a1, int32_t a2);
int32_t function_d1c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d2b(int32_t a1);
int32_t function_d78(void);
int32_t function_d91(int32_t a1, int32_t a2, int32_t a3);
int32_t function_d96(void);
int32_t function_df5(void);
int32_t function_e5(void);
int32_t function_ea0(void);
int32_t function_ef0(void);
int32_t function_f0f(void);
int32_t function_f631f201(void);
int32_t function_fd(void);
int32_t function_fd4(void);
int32_t unknown_3454(void);
int32_t unknown_3490(int32_t a1);
int32_t unknown_3814(void);
int32_t unknown_3850(int32_t a1);
int32_t unknown_3900(int32_t a1);
int32_t unknown_3c20(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_3df0(int32_t a1);
int32_t unknown_3fe0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_4580(int32_t a1);
int32_t unknown_4d80(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_89c09704(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // ecx
int32_t g5 = 0; // edi
int32_t g6 = 0; // edx
int32_t g7 = 0; // esi
int32_t g8 = 0x24448900;
int32_t g11 = 0;
int32_t g13 = 0x1930;
int32_t g14 = 0;
int32_t g16 = 0x1a60;
int32_t g17 = 0x16b0;
int32_t g18 = 0x656c245c;
int32_t g19 = 0x14a1;
bool g20 = false; // zf
struct vtable_3010_type g9 = {
    .e0 = _ZN5boost16thread_exceptionD1Ev,
    .e1 = _ZN5boost16thread_exceptionD0Ev,
    .e2 = _ZN8CCrypter20SetKeyFromPassphraseERKSbIcSt11char_traitsIcE16secure_allocatorIcEERKSt6vectorIhSaIhEEjj
};
struct vtable_3028_type g10 = {
    .e0 = _ZN5boost10lock_errorD1Ev,
    .e1 = _ZN5boost10lock_errorD0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv
};
struct vtable_3058_type g12 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv
};
struct vtable_3098_type g15 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv
};

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x3
// From class:    N5boost16thread_exceptionE
// Type:          virtual member function
// Demangled:     CCrypter::SetKeyFromPassphrase(std::string<char, std::char_traits<char>, secure_allocator<char> > const &, std::vector<unsigned char, std::allocator<unsigned char> > const &, unsigned int, unsigned int)
int32_t _ZN8CCrypter20SetKeyFromPassphraseERKSbIcSt11char_traitsIcE16secure_allocatorIcEERKSt6vectorIhSaIhEEjj(void) {
    // 0x0
    return 0;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x10 - 0x11
// Line range:    411 - 98
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::clone() const
void _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t this) {
    // 0x10
    return;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x20 - 0x21
// Line range:    404 - 429
void _7e_clone_impl(int32_t this, int32_t __in_chrg) {
    // 0x20
    return;
}

// Address range: 0x64 - 0x68
int32_t function_64(void) {
    // 0x64
    return 0;
}

// Address range: 0x8f - 0x93
int32_t function_8f(void) {
    // 0x8f
    return 0;
}

// Address range: 0xe5 - 0xf9
int32_t function_e5(void) {
    int32_t * v1 = (int32_t *)-0x7b8adf08;
    *v1 = *v1 + 1;
    *(char *)64 = 1;
    return 1;
}

// Address range: 0xfd - 0x100
int32_t function_fd(void) {
    // 0xfd
    return 0;
}

// From module:   /parallelcoin/src/crypter.h
// Address range: 0x100 - 0x1d0
// Line range:    36 - 177
// Demangled:     CCrypter::SetKey(std::vector<unsigned char, secure_allocator<unsigned char> > const &, std::vector<unsigned char, std::allocator<unsigned char> > const &)
void _ZN8CCrypter6SetKeyERKSt6vectorIh16secure_allocatorIhEERKS0_IhSaIhEE(int32_t this, int32_t chNewKey, int32_t chNewIV) {
    int32_t v1 = *(int32_t *)chNewKey; // bp+124
    if (*(int32_t *)(chNewKey + 4) - v1 != 32) {
        // 0x143
        return;
    }
    // 0x150
    if (*(int32_t *)(chNewIV + 4) - *(int32_t *)chNewIV == 32) {
        // 0x15a
        *(int32_t *)this = *(int32_t *)v1;
        *(int32_t *)(this + 4) = *(int32_t *)(v1 + 4);
        int32_t v2 = *(int32_t *)(v1 + (int32_t)&g18); // bp+164
        *(int32_t *)(this + (int32_t)&g18) = v2;
        int32_t v3 = *(int32_t *)(v1 + (int32_t)&g19);
        *(int32_t *)(this + (int32_t)&g19) = v3;
        int32_t v4 = *(int32_t *)(v1 + (int32_t)&g8); // bp+170
        *(int32_t *)(this + (int32_t)&g8) = v4;
        *(int32_t *)(this + 20) = *(int32_t *)(v1 + 20);
        *(int32_t *)(this + 24) = *(int32_t *)(v1 + 24);
        *(int32_t *)(this + 28) = *(int32_t *)(v1 + 28);
        int32_t v5 = *(int32_t *)chNewIV; // bp+188
        *(int32_t *)(this + 32) = *(int32_t *)v5;
        *(int32_t *)(this + 36) = *(int32_t *)(v5 + 4);
        int32_t v6 = *(int32_t *)(v5 + (int32_t)&g18); // bp+195
        *(int32_t *)(this + 40) = v6;
        int32_t v7 = *(int32_t *)(v5 + (int32_t)&g19);
        *(int32_t *)(this + 44) = v7;
        int32_t v8 = *(int32_t *)(v5 + (int32_t)&g8);
        *(int32_t *)(this + 48) = v8;
        *(int32_t *)(this + 52) = *(int32_t *)(v5 + 20);
        *(int32_t *)(this + 56) = *(int32_t *)(v5 + 24);
        *(int32_t *)(this + 60) = *(int32_t *)(v5 + 28);
        *(char *)(this + 64) = 1;
        // branch -> 0x132
    }
}

// From module:   /parallelcoin/src/crypter.h
// Address range: 0x1d0 - 0x299
// Line range:    48 - 98
// Demangled:     CCrypter::Encrypt(std::vector<unsigned char, secure_allocator<unsigned char> > const &, std::vector<unsigned char, std::allocator<unsigned char> > &)
void _ZN8CCrypter7EncryptERKSt6vectorIh16secure_allocatorIhEERS0_IhSaIhEE(int32_t this, int32_t vchPlaintext, int32_t vchCiphertext) {
    // 0x1d0
    g1 = 0;
    if (*(char *)(this + 64) == 0) {
        // 0x230
        return;
    }
    // 0x258
    g1 = 0;
    int32_t v1 = *(int32_t *)(vchPlaintext + 4) - *(int32_t *)vchPlaintext;
    int32_t v2 = v1 + (int32_t)&g8;
    g6 = v2;
    if (v2 == 0) {
        // bb115
        function_2a6(0);
        // branch -> 0x292
    }
}

// Address range: 0x2a6 - 0x2c9
int32_t function_2a6(int32_t a1) {
    // 0x2a6
    return g1;
}

// Address range: 0x33a - 0x341
int32_t function_33a(void) {
    // 0x33a
    return 0;
}

// Address range: 0x394 - 0x397
int32_t function_394(void) {
    // 0x394
    return 0;
}

// Address range: 0x39b - 0x3f4
int32_t function_39b(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)-0x74a68b25;
    *v1 = *v1 + 1;
    int32_t v2 = 0;
    int32_t v3 = v2 + 1;
    int32_t v4 = 0;
    int32_t v5 = (v4 + 139) % 256 | v4 & -256;
    uint32_t v6 = a2 + a1;
    int32_t v7 = 0; // ecx
    uint32_t v8 = v5 - v7;
    char v9 = 0; // bp+77
    if (v6 <= v8) {
        // 0x3ba
        *(int32_t *)(v2 + 5) = v7 + v6;
        return 1;
    }
    int32_t v10 = &v9;
    _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh((int32_t *)(0x10000 * v3 / 0x10000), v5, v6 - v8, v10);
    return 1;
}

// Address range: 0x3f4 - 0x3f5
int32_t function_3f4(int32_t a1) {
    // 0x3f4
    return g1;
}

// Address range: 0x3f9 - 0x400
int32_t function_3f9(void) {
    // 0x3f9
    return 0;
}

// Address range: 0x405 - 0x406
int32_t function_405(void) {
    // 0x405
    return 0;
}

// From module:   /parallelcoin/src/crypter.cpp
// Address range: 0x420 - 0x475
// Line range:    103 - 61
// Demangled:     EncryptSecret(std::vector<unsigned char, secure_allocator<unsigned char> > const &, std::vector<unsigned char, secure_allocator<unsigned char> > const &, uint256 const &, std::vector<unsigned char, std::allocator<unsigned char> > &)
bool _Z13EncryptSecretRKSt6vectorIh16secure_allocatorIhEES4_RK7uint256RS_IhSaIhEE(int32_t vMasterKey, int32_t vchPlaintext, int32_t nIV, uint32_t vchCiphertext) {
    // 0x420
    return vchCiphertext % 2 != 0;
}

// Address range: 0x4b0 - 0x4b1
int32_t function_4b0(void) {
    // 0x4b0
    return 0;
}

// Address range: 0x500 - 0x501
int32_t function_500(void) {
    // 0x500
    return 0;
}

// Address range: 0x558 - 0x559
int32_t function_558(void) {
    // 0x558
    return 0;
}

// Address range: 0x59e - 0x59f
int32_t function_59e(void) {
    // 0x59e
    return 0;
}

// Address range: 0x5a8 - 0x5a9
int32_t function_5a8(void) {
    // 0x5a8
    return 0;
}

// Address range: 0x5e4 - 0x5e5
int32_t function_5e4(void) {
    // 0x5e4
    return 0;
}

// Address range: 0x6c2 - 0x6c3
int32_t function_6c2(int16_t a1) {
    // 0x6c2
    return 0;
}

// Address range: 0x6f8 - 0x6f9
int32_t function_6f8(void) {
    // 0x6f8
    return 0;
}

// Address range: 0x777 - 0x778
int32_t function_777(void) {
    // 0x777
    return 0;
}

// Address range: 0x785 - 0x78c
int32_t function_785(void) {
    // 0x785
    return 0;
}

// Address range: 0x7c8 - 0x7c9
int32_t function_7c8(void) {
    // 0x7c8
    return 0;
}

// Address range: 0x847 - 0x848
int32_t function_847(void) {
    // 0x847
    return 0;
}

// Address range: 0x855 - 0x856
int32_t function_855(void) {
    // 0x855
    return 0;
}

// Address range: 0x860 - 0x88a
int32_t function_860(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x34850fc0; // bp+860
    *v1 = *v1 + 1;
    int32_t v2 = 0; // eax
    *(int32_t *)v2 = 2 * v2;
    char * v3 = (char *)0xcc2494; // bp+868
    *v3 = (char)0 + *v3;
    *(char *)v2 = (char)v2 + *(char *)&g1;
    int32_t result = 0; // esi
    g1 = result;
    if (*(int32_t *)20 != 0) {
        // bb
        result = function_977();
        // branch -> 0x87f
    }
    // 0x87f
    return result;
}

// Address range: 0x890 - 0x8af
int32_t function_890(void) {
    // 0x890
    return 0;
}

// Address range: 0x8b8 - 0x8b9
int32_t function_8b8(void) {
    // 0x8b8
    return 0;
}

// Address range: 0x8f8 - 0x8f9
int32_t function_8f8(void) {
    // 0x8f8
    return 0;
}

// Address range: 0x949 - 0x94a
int32_t function_949(void) {
    // 0x949
    return g1;
}

// Address range: 0x94a - 0x94b
int32_t function_94a(void) {
    // 0x94a
    return 0;
}

// Address range: 0x95b - 0x95c
int32_t function_95b(void) {
    // 0x95b
    return g1;
}

// Address range: 0x963 - 0x965
int32_t function_963(void) {
    // 0x963
    return function_949();
}

// Address range: 0x965 - 0x966
int32_t function_965(void) {
    // 0x965
    return g1;
}

// Address range: 0x977 - 0x978
int32_t function_977(void) {
    // 0x977
    return g1;
}

// Address range: 0x97b - 0x9bc
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_97b(void) {
    int32_t * v1 = (int32_t *)0x80249c;
    *v1 = *v1 - 1;
    char v2 = *(char *)&g1; // bp+981
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + v2;
    _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(0);
    _ZN5boost11unique_lockINS_5mutexEED2Ev_part_36();
    int32_t v4; // bp+120
    int32_t v5 = &v4;
    v4 = (int32_t)&g10;
    g1 = _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(v5);
    return function_965();
}

// Address range: 0x9bc - 0x9be
int32_t function_9bc(void) {
    // 0x9bc
    return function_965();
}

// Address range: 0x9c3 - 0x9c4
int32_t function_9c3(void) {
    // 0x9c3
    return 0;
}

// Address range: 0x9cf - 0x9e4
int32_t function_9cf(void) {
    // 0x9cf
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + 0x8b248c);
    *v2 = *v2 - 1;
    char v3 = *(char *)&g1;
    int32_t v4 = 0; // eax
    *(char *)v4 = (char)v4 + v3;
    g1 = _ZN8CCrypterD1Ev(0);
    return function_95b();
}

// Address range: 0x9e4 - 0x9e8
int32_t function_9e4(void) {
    // 0x9e4
    return 0;
}

// Address range: 0xa24 - 0xa29
int32_t function_a24(void) {
    // 0xa24
    return function_965();
}

// From module:   /parallelcoin/src/crypter.h
// Address range: 0xa30 - 0xadc
// Line range:    75 - 55
// Demangled:     CCrypter::Decrypt(std::vector<unsigned char, std::allocator<unsigned char> > const &, std::vector<unsigned char, secure_allocator<unsigned char> > &)
void _ZN8CCrypter7DecryptERKSt6vectorIhSaIhEERS0_Ih16secure_allocatorIhEE(int32_t this, int32_t vchCiphertext, int32_t vchPlaintext) {
    // 0xa30
    g1 = 0;
    if (*(char *)(this + 64) == 0) {
        // 0xa88
        return;
    }
    int32_t v1 = *(int32_t *)(vchCiphertext + 4) - *(int32_t *)vchCiphertext;
    g5 = v1;
    if (v1 == 0) {
        // bb121
        function_d1c(0, this, vchPlaintext, vchCiphertext);
        // branch -> 0xad9
    }
}

// Address range: 0xb18 - 0xb19
int32_t function_b18(void) {
    // 0xb18
    return 0;
}

// Address range: 0xb5e - 0xb5f
int32_t function_b5e(void) {
    // 0xb5e
    return 0;
}

// Address range: 0xb68 - 0xb69
int32_t function_b68(void) {
    // 0xb68
    return 0;
}

// Address range: 0xba3 - 0xbd0
int32_t function_ba3(int32_t a1) {
    // 0xba3
    g3 = a1;
    int32_t v1; // bp+72
    int32_t result = _ZNSt6vectorIh16secure_allocatorIhEEaSERKS2_((int32_t *)a1, (int32_t)&v1);
    g1 = result;
    if (v1 == 0) {
        // bb
        result = function_bf1();
        // branch -> 0xbc7
    }
    // 0xbc7
    return result;
}

// Address range: 0xbf1 - 0xbf8
int32_t function_bf1(void) {
    // 0xbf1
    return g1;
}

// Address range: 0xc10 - 0xc15
int32_t function_c10(void) {
    // 0xc10
    return 0;
}

// Address range: 0xc35 - 0xc3c
int32_t function_c35(void) {
    // 0xc35
    return 0;
}

// Address range: 0xc40 - 0xc41
int32_t function_c40(void) {
    // 0xc40
    return 0;
}

// Address range: 0xcdc - 0xd1c
int32_t function_cdc(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)-0x4e7bf00a;
    *v1 = *v1 + 1;
    int32_t v2 = 0;
    *(char *)v2 = (char)v2 + *(char *)&g1;
    int32_t v3 = 0; // ebx
    char * v4 = (char *)(v3 - 0x74cfdba4);
    *v4 = (char)0 + *v4;
    g6 = a2;
    int32_t v5 = *(int32_t *)(v3 + 4);
    g1 = v5;
    int32_t v6 = v5 - v3;
    g3 = v6;
    int32_t v7 = a2;
    if (a2 > v6) {
        // bb
        int32_t v8;
        function_d2b((int32_t)&v8);
        v3 = g4;
        v7 = g6;
        // branch -> 0xd03
    }
    // 0xd03
    *(int32_t *)(a1 + 4) = v7 + v3;
    return 1;
}

// Address range: 0xd1c - 0xd2b
int32_t function_d1c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xd1c
    return function_ba3(0);
}

// Address range: 0xd2b - 0xd53
int32_t function_d2b(int32_t a1) {
    // 0xd2b
    int32_t v1; // bp+111
    _ZNSt6vectorIh16secure_allocatorIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS2_EEjRKh((int32_t *)a1, g1, g6 - g3, (int32_t)&v1);
    return 1;
}

// Address range: 0xd78 - 0xd79
int32_t function_d78(void) {
    // 0xd78
    return 0;
}

// Address range: 0xd91 - 0xd92
int32_t function_d91(int32_t a1, int32_t a2, int32_t a3) {
    // 0xd91
    return g1;
}

// Address range: 0xd96 - 0xd9d
int32_t function_d96(void) {
    // 0xd96
    return 0;
}

// Address range: 0xdf5 - 0xe07
int32_t function_df5(void) {
    // 0xdf5
    _ZN5boost11unique_lockINS_5mutexEED2Ev_part_36();
    return _ZN5boost10lock_errorD1Ev((int32_t *)0);
}

// From module:   /parallelcoin/src/crypter.cpp
// Address range: 0xe10 - 0xe65
// Line range:    113 - 61
// Demangled:     DecryptSecret(std::vector<unsigned char, secure_allocator<unsigned char> > const &, std::vector<unsigned char, std::allocator<unsigned char> > const &, uint256 const &, std::vector<unsigned char, secure_allocator<unsigned char> > &)
bool _Z13DecryptSecretRKSt6vectorIh16secure_allocatorIhEERKS_IhSaIhEERK7uint256RS2_(int32_t vMasterKey, int32_t vchCiphertext, int32_t nIV, uint32_t vchPlaintext) {
    // 0xe10
    return vchPlaintext % 2 != 0;
}

// Address range: 0xea0 - 0xea1
int32_t function_ea0(void) {
    // 0xea0
    return 0;
}

// Address range: 0xef0 - 0xef7
int32_t function_ef0(void) {
    // 0xef0
    return 0;
}

// Address range: 0xf0f - 0xf9f
int32_t function_f0f(void) {
    int32_t v1 = 0; // ebp
    int32_t * v2 = (int32_t *)(v1 - 0x3f7af040);
    *v2 = *v2 + 1;
    char * v3 = (char *)0x2035;
    int32_t v4 = 0; // ecx
    *v3 = (char)v4 + *v3;
    char * v5 = (char *)(v1 + 0xab2494);
    *v5 = (char)v4 + *v5;
    int32_t result = 0; // eax
    int32_t v6 = result;
    char * v7 = (char *)v6;
    *v7 = *v7 + (char)v6;
    int32_t v8 = 0;
    int32_t v9 = v8; // ebx
    int32_t v10; // bp+202
    int32_t v11 = 0;
    if (v8 > v11) {
        // 0xf98
        return result;
    }
    // branch -> 0xf48
  lab_0xf48:
    while (true) {
        int32_t v12 = *(int32_t *)44;
        int32_t v13 = v8;
        int32_t v14 = v12; // 0xf693
        if (v12 == 0) {
            // bb
            v13 = v9;
            v14 = function_12e8();
            // branch -> 0xf55
        }
        // branch -> 0xf69
      lab_0xf69:
        while (true) {
            int32_t v15 = v14;
            // branch -> 0xf69
            while (true) {
                // 0xf69
                int32_t v16; // edx
                int32_t v17;
                if (*(int32_t *)(v15 + (int32_t)&g8) >= v13) {
                    // 0xf60
                    v16 = v15;
                    int32_t v18 = *(int32_t *)(v15 + 8);
                    result = v18;
                    if (v18 == 0) {
                        v17 = v15;
                        // break (via goto) -> 0xf75
                        goto lab_0xf75;
                    }
                    v14 = v18;
                    // continue (via goto) -> 0xf69
                    goto lab_0xf69;
                } else {
                    int32_t v19 = *(int32_t *)(v15 + 12);
                    result = v19;
                    if (v19 == 0) {
                        // break -> 0xf75
                        break;
                    }
                    v15 = v19;
                    // continue -> 0xf69
                    continue;
                }
              lab_0xf75:;
                int32_t v20 = v17;
                if (v17 == 40) {
                    // bb116
                    result = function_12e8();
                    v13 = v9;
                    v20 = v16;
                    // branch -> 0xf81
                }
                int32_t v21 = v20;
                if (*(int32_t *)(v20 + 16) > v13) {
                    // bb118
                    result = function_12e8();
                    v21 = v16;
                    // branch -> 0xf8a
                }
                int32_t * v22 = (int32_t *)(v21 + 20);
                *v22 = *v22 + 1;
                int32_t v23 = *(int32_t *)28 + v9;
                v9 = v23;
                if (v11 < v23) {
                    // break (via goto) -> 0xf98
                    goto lab_0xf98;
                }
                v8 = v23;
                // continue (via goto) -> 0xf48
                goto lab_0xf48;
            }
          lab_0xf98:
            // 0xf98
            return result;
        }
    }
}

// Address range: 0xfd4 - 0xfd5
int32_t function_fd4(void) {
    // 0xfd4
    return 0;
}

// Address range: 0x10b2 - 0x10b3
int32_t function_10b2(int16_t a1) {
    // 0x10b2
    return 0;
}

// Address range: 0x10c2 - 0x10d8
int32_t function_10c2(void) {
    int32_t * v1 = (int32_t *)(g2 - 0x387af040); // 0x10c2
    *v1 = *v1 + 1;
    int32_t v2 = 0; // eax
    g1 = 2 * v2 & 254 | v2 & -256;
    char * v3 = (char *)(g3 + 0x202d); // 0x10ca
    int32_t v4 = 0; // ecx
    *v3 = (char)v4 + *v3;
    char * v5 = (char *)(g3 + 0x211c245c); // 0x10d0
    *v5 = (char)v4 + *v5;
    return function_10fb();
}

// Address range: 0x10da - 0x10de
int32_t function_10da(void) {
    // 0x10da
    return 0;
}

// Address range: 0x10e8 - 0x10fa
int32_t function_10e8(void) {
    int32_t v1 = *(int32_t *)44; // 0x10e8
    g1 = v1;
    int32_t result = v1; // 0x10f5
    if (v1 == 0) {
        // bb
        result = function_1280();
        // branch -> 0x10f5
    }
    // 0x10f5
    return result;
}

// Address range: 0x10fb - 0x1143
int32_t function_10fb(void) {
    int32_t v1 = g1 | 0x26748d; // 0x10fb
    int32_t v2 = v1; // edi
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x11025
    g1 = v3;
    if (v3 == 0) {
        // branch -> 0x1121
    } else {
        // branch -> 0x1109
      lab_0x1109:
        while (true) {
            int32_t v4 = v3; // 0x1100
            // branch -> 0x1109
            int32_t v5; // 0x1115
            while (true) {
                // 0x1109
                if (*(int32_t *)(v4 + 16) >= g3) {
                    // 0x1100
                    v2 = v4;
                    int32_t v6 = *(int32_t *)(v4 + 8); // 0x1102
                    g1 = v6;
                    if (v6 == 0) {
                        v5 = v4;
                        // break (via goto) -> 0x1115
                        goto lab_0x1115;
                    }
                    v1 = v4;
                    v3 = v6;
                    // continue (via goto) -> 0x1109
                    goto lab_0x1109;
                } else {
                    int32_t v7 = *(int32_t *)(v4 + 12); // 0x110e
                    g1 = v7;
                    if (v7 == 0) {
                        // break -> 0x1115
                        break;
                    }
                    v4 = v7;
                    // continue -> 0x1109
                    continue;
                }
                // 0x1115
                if (v5 == 40) {
                    // bb
                    g1 = function_1280();
                    int32_t v8 = v2;
                    v1 = v8;
                    // branch -> 0x1121
                } else {
                    v1 = v5;
                }
            }
            // 0x1115
            v5 = v1;
            // branch -> 0x1115
          lab_0x1115:
            // 0x1115
            if (v5 == 40) {
                // bb
                g1 = function_1280();
                v1 = v2;
                // branch -> 0x1121
            } else {
                v1 = v5;
            }
        }
    }
    int32_t v9 = v1; // 0x1132
    if (*(int32_t *)(v1 + 16) > g3) {
        // bb24
        function_1280();
        v9 = v2;
        // branch -> 0x112a
    }
    int32_t * v10 = (int32_t *)(v9 + 20); // 0x112a
    int32_t v11 = *v10 - 1; // 0x112d
    g1 = v11;
    *v10 = v11;
    if (v11 != 0) {
        // bb25
        function_1167();
        // branch -> 0x1137
    }
    // 0x1137
    return *(int32_t *)28;
}

// Address range: 0x1167 - 0x117c
int32_t function_1167(void) {
    // 0x1167
    int32_t result; // 0x1175
    if (g2 >= *(int32_t *)28 + g3) {
        // bb
        result = function_10e8();
        // branch -> 0x1175
    } else {
        // 0x1167
        result = g1;
        // branch -> 0x1175
    }
    // 0x1175
    return result;
}

// Address range: 0x1194 - 0x11aa
int32_t function_1194(void) {
    int32_t * v1 = (int32_t *)-0x307af040; // 0x1194
    *v1 = *v1 + 1;
    int32_t v2 = g1; // 0x119a
    *(int32_t *)v2 = 2 * v2;
    char * v3 = (char *)(g3 + 0x202d); // 0x119c
    *v3 = (char)g4 + *v3;
    char * v4 = (char *)(g3 + 0x2118245c); // 0x11a2
    char v5 = (char)g4 + *v4; // 0x11a2
    g20 = v5 == 0;
    *v4 = v5;
    return function_11cd();
}

// Address range: 0x11aa - 0x11cc
int32_t function_11aa(void) {
    // 0x11aa
    int32_t v1;
    *(char *)v1 = __asm_insb((int16_t)0);
    g1 = 0;
    int32_t v2 = *(int32_t *)44; // 0x11b8
    g1 = v2;
    int32_t result = v2; // 0x11ca
    if (v2 == 0) {
        // bb98
        result = function_1280();
        // branch -> 0x11c5
    }
    // 0x11c5
    return result;
}

// Address range: 0x11cd - 0x1213
int32_t function_11cd(void) {
    // 0x11cd
    if (g20) {
        char * v1 = (char *)(g7 - 0x75000000); // 0x11f5
        unsigned char v2 = *v1; // 0x11f5
        bool v3 = v2 > 184; // cf
        *v1 = v2 + 71;
        unsigned char v4 = (char)g1; // 0x11fc
        v3 = v3 ? v4 - 125 + (char)v3 <= v4 : v4 > 124;
        uint32_t v5 = unknown_89c09704(); // 0x11fe
        unsigned char v6 = (char)v5 + 117 + (char)v3; // 0x1204
        char * v7 = (char *)(g4 + 28); // 0x1206
        *v7 = *v7 ^ (char)(v5 / 256);
        return (int32_t)v6 | v5 & -256;
    }
    char * v8 = (char *)(g4 + 0x8408bc7); // 0x11cf
    *v8 = *v8 + (char)g4;
    int32_t v9 = g1; // 0x11d5
    int32_t result = 0; // 0x11f14
    if (v9 != 0) {
        int32_t v10 = *(int32_t *)(v9 + (int32_t)&g19); // 0x11de
        g1 = v10;
        while (v10 != 0) {
            // 0x11d9
            v10 += (int32_t)&g19;
            g1 = v10;
            // continue -> 0x11d9
        }
        // 0x11e5
        result = v10;
        // branch -> 0x11e5
    }
    if (g5 == 40) {
        // bb
        result = function_1280();
        // branch -> 0x11f1
    }
    // 0x11f1
    return result;
}

// Address range: 0x1245 - 0x124c
int32_t function_1245(void) {
    // 0x1245
    return g1;
}

// Address range: 0x1250 - 0x127a
int32_t function_1250(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x34850fc0; // 0x1250
    *v1 = *v1 + 1;
    int32_t v2 = 0; // eax
    *(int32_t *)v2 = 2 * v2;
    char * v3 = (char *)0xcc2494; // 0x1258
    *v3 = (char)0 + *v3;
    *(char *)v2 = (char)v2 + *(char *)&g1;
    int32_t result = 0; // esi
    g1 = result;
    if (*(int32_t *)20 != 0) {
        // bb
        result = function_1367();
        // branch -> 0x126f
    }
    // 0x126f
    return result;
}

// Address range: 0x1280 - 0x129f
int32_t function_1280(void) {
    // 0x1280
    return g1;
}

// Address range: 0x12a8 - 0x12b4
int32_t function_12a8(void) {
    // 0x12a8
    return *(int32_t *)28;
}

// Address range: 0x12b8 - 0x12e1
int32_t function_12b8(void) {
    int32_t * v1 = (int32_t *)-0x38a7dba4; // 0x12b8
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x12bf
    int32_t * v3 = (int32_t *)v2; // 0x12c1
    *v3 = *v3 + v2;
    char * v4 = (char *)v2; // 0x12c3
    *v4 = *v4 + (char)v2;
    return _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE16_M_insert_uniqueERKS2_((int32_t *)g5, 36);
}

// Address range: 0x12e8 - 0x12f4
int32_t function_12e8(void) {
    // 0x12e8
    return *(int32_t *)28;
}

// Address range: 0x12f8 - 0x1321
int32_t function_12f8(void) {
    int32_t * v1 = (int32_t *)-0x3897dba4; // 0x12f8
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x12ff
    int32_t * v3 = (int32_t *)v2; // 0x1301
    *v3 = *v3 + v2;
    char * v4 = (char *)v2; // 0x1303
    *v4 = *v4 + (char)v2;
    return _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE16_M_insert_uniqueERKS2_((int32_t *)g5, 36);
}

// Address range: 0x1339 - 0x133a
int32_t function_1339(void) {
    // 0x1339
    return g1;
}

// Address range: 0x133a - 0x133b
int32_t function_133a(void) {
    // 0x133a
    return 0;
}

// Address range: 0x134b - 0x134c
int32_t function_134b(void) {
    // 0x134b
    return g1;
}

// Address range: 0x1353 - 0x1355
int32_t function_1353(void) {
    // 0x1353
    return function_1339();
}

// Address range: 0x1355 - 0x1356
int32_t function_1355(void) {
    // 0x1355
    return g1;
}

// Address range: 0x1367 - 0x1368
int32_t function_1367(void) {
    // 0x1367
    return g1;
}

// Address range: 0x136b - 0x13ac
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_136b(void) {
    int32_t * v1 = (int32_t *)0x80249c; // 0x136b
    *v1 = *v1 - 1;
    char v2 = *(char *)&g1; // 0x1371
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + v2;
    _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(0);
    _ZN5boost11unique_lockINS_5mutexEED2Ev_part_36();
    int32_t v4; // bp+120
    int32_t v5 = &v4; // 0x1392
    v4 = (int32_t)&g10;
    g1 = _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(v5);
    return function_1355();
}

// Address range: 0x13ac - 0x13ae
int32_t function_13ac(void) {
    // 0x13ac
    return function_1355();
}

// Address range: 0x13b3 - 0x13b4
int32_t function_13b3(void) {
    // 0x13b3
    return 0;
}

// Address range: 0x13bf - 0x13d4
int32_t function_13bf(void) {
    // 0x13bf
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + 0x8b248c); // 0x13bf
    *v2 = *v2 - 1;
    char v3 = *(char *)&g1; // 0x13c5
    int32_t v4 = 0; // eax
    *(char *)v4 = (char)v4 + v3;
    g1 = _ZN8CCrypterD1Ev(0);
    return function_134b();
}

// Address range: 0x13d4 - 0x13d8
int32_t function_13d4(void) {
    // 0x13d4
    return 0;
}

// Address range: 0x1414 - 0x1419
int32_t function_1414(void) {
    // 0x1414
    return function_1355();
}

// Address range: 0x1420 - 0x144a
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1) {
    // 0x1420
    *a1 = (int32_t)&g14;
    // 0x1446
    return 0;
}

// Address range: 0x14c0 - 0x14e5
// From class:    N5boost10lock_errorE
// Type:          virtual member function
// Demangled:     boost::lock_error::what() const
int32_t _ZNK5boost10lock_error4whatEv(void) {
    // 0x14e1
    return (int32_t)"boost::lock_error";
}

// Address range: 0x14f0 - 0x151e
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1) {
    // 0x14f0
    g1 = (int32_t)a1;
    *a1 = (int32_t)&g14;
    int32_t result;
    // 0x14f0
    result = g1;
    // branch -> 0x1517
    // 0x1517
    return result;
}

// Address range: 0x1523 - 0x1524
int32_t function_1523(int32_t a1) {
    // 0x1523
    return g1;
}

// Address range: 0x1530 - 0x155e
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_exception::~thread_exception()
int32_t _ZN5boost16thread_exceptionD1Ev(int32_t * a1) {
    // 0x1530
    g1 = (int32_t)a1;
    *a1 = (int32_t)&g9;
    int32_t result;
    // 0x1530
    result = g1;
    // branch -> 0x1557
    // 0x1557
    return result;
}

// Address range: 0x1563 - 0x1564
int32_t function_1563(int32_t a1) {
    // 0x1563
    return g1;
}

// Address range: 0x1594 - 0x15c2
int32_t _ZN5boost11unique_lockINS_5mutexEED2Ev_part_36(void) {
    // 0x1594
    return 0;
}

// Address range: 0x15d0 - 0x15fe
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::lock_error::~lock_error()
int32_t _ZN5boost10lock_errorD1Ev(int32_t * a1) {
    // 0x15d0
    g1 = (int32_t)a1;
    *a1 = (int32_t)&g9;
    int32_t result;
    // 0x15d0
    result = g1;
    // branch -> 0x15f7
    // 0x15f7
    return result;
}

// Address range: 0x1603 - 0x1604
int32_t function_1603(int32_t a1) {
    // 0x1603
    return g1;
}

// Address range: 0x1610 - 0x162d
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_exception::~thread_exception()
int32_t _ZN5boost16thread_exceptionD0Ev(int32_t * a1) {
    // 0x1610
    *a1 = (int32_t)&g9;
    return 0;
}

// Address range: 0x1660 - 0x167d
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::lock_error::~lock_error()
int32_t _ZN5boost10lock_errorD0Ev(int32_t * a1) {
    // 0x1660
    *a1 = (int32_t)&g9;
    return 0;
}

// Address range: 0x16b0 - 0x16b7
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1) {
    // 0x16b0
    return _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2(a1 - 28);
}

// Address range: 0x16c0 - 0x16dc
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          virtual member function
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2(int32_t a1) {
    // 0x16c0
    return 0;
}

// Address range: 0x16e0 - 0x1744
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_16e0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x4468bc3; // 0x16e0
    *v1 = *v1 - 1;
    int32_t v2 = 0; // ebx
    *(int32_t *)v2 = (int32_t)&g10;
    *(int32_t *)(v2 + (int32_t)&g18) = (int32_t)&g11;
    *(int32_t *)(v2 + 4) = 0;
    int32_t v3 = 0; // esi
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g19); // 0x16f6
    *(int32_t *)(v2 + (int32_t)&g19) = v4;
    if (v4 != 0) {
        // 0x1700
        // branch -> 0x1708
    }
    int32_t v5 = *(int32_t *)(v3 + (int32_t)&g8); // 0x1708
    *(int32_t *)(v2 + (int32_t)&g18) = (int32_t)&g16;
    *(int32_t *)(v2 + (int32_t)&g8) = v5;
    *(int32_t *)(v2 + 20) = *(int32_t *)(v3 + 20);
    *(int32_t *)v2 = (int32_t)&g15;
    *(int32_t *)(v2 + 28) = (int32_t)&g17;
    *(int32_t *)(v2 + 24) = *(int32_t *)(v3 + 24);
    int32_t result = v2 + 28; // 0x1739
    if (*(int32_t *)20 != a1) {
        // 0x1744
        return result;
    }
    // 0x173e
    return result;
}

// Address range: 0x1930 - 0x193a
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t a1) {
    // 0x1930
    return _ZTSN5boost16exception_detail10clone_baseE(a1 - (int32_t)&g18);
}

// Address range: 0x1940 - 0x198f
// From class:    N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g3 = v1;
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g19); // 0x1954
    g1 = v2;
    *a1 = (int32_t)&g12;
    *(int32_t *)(g3 + (int32_t)&g18) = (int32_t)&g11;
    if (v2 != 0) {
        // 0x1968
        if ((char)v2 != 0) {
            // bb
            function_1998(v2);
            // branch -> 0x1974
        }
    }
    // 0x1974
    g1 = 0;
    *(int32_t *)g3 = (int32_t)&g9;
    int32_t result;
    // 0x1974
    result = g1;
    // branch -> 0x1987
    // 0x1987
    return result;
}

// Address range: 0x1998 - 0x19a1
int32_t function_1998(int32_t a1) {
    // 0x1998
    *(int32_t *)(g3 + (int32_t)&g19) = 0;
    return g1;
}

// Address range: 0x19a1 - 0x19a2
int32_t function_19a1(void) {
    // 0x19a1
    return g1;
}

// Address range: 0x19a7 - 0x19aa
int32_t function_19a7(void) {
    // 0x19a7
    return 0;
}

// Address range: 0x19c0 - 0x19c7
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev((int32_t *)(a1 - (int32_t)&g18)); // 0x19c5
    return result;
}

// Address range: 0x19d0 - 0x1a0d
// From class:    N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g3 = v1;
    g1 = *(int32_t *)(v1 + (int32_t)&g19);
    *a1 = (int32_t)&g12;
    *(int32_t *)(g3 + (int32_t)&g18) = (int32_t)&g11;
    int32_t v2 = g1; // 0x19f4
    if (v2 == 0) {
        // 0x1a04
        *(int32_t *)g3 = (int32_t)&g9;
        return g1;
    }
    // 0x19f8
    if ((char)v2 != 0) {
        // bb
        g1 = function_1a30(v2);
        // branch -> 0x1a04
    }
    // 0x1a04
    *(int32_t *)g3 = (int32_t)&g9;
    return g1;
}

// Address range: 0x1a30 - 0x1a39
int32_t function_1a30(int32_t a1) {
    // 0x1a30
    *(int32_t *)(g3 + (int32_t)&g19) = 0;
    return g1;
}

// Address range: 0x1a3f - 0x1a42
int32_t function_1a3f(void) {
    // 0x1a3f
    return 0;
}

// Address range: 0x1a50 - 0x1a5a
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1) {
    // 0x1a50
    return function_34c0(a1 - 28);
}

// Address range: 0x1a60 - 0x1a6a
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1) {
    // 0x1a60
    return function_34c0(a1 - (int32_t)&g18);
}

// Address range: 0x1a70 - 0x1ac6
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g3 = v1;
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g19); // 0x1a84
    g1 = v2;
    *(int32_t *)(v1 + 28) = (int32_t)&g14;
    *(int32_t *)g3 = (int32_t)&g12;
    *(int32_t *)(g3 + (int32_t)&g18) = (int32_t)&g11;
    if (v2 != 0) {
        // 0x1a9f
        if ((char)v2 != 0) {
            // bb
            function_1ad0(v2);
            // branch -> 0x1aab
        }
    }
    // 0x1aab
    g1 = 0;
    *(int32_t *)g3 = (int32_t)&g9;
    int32_t result;
    // 0x1aab
    result = g1;
    // branch -> 0x1abe
    // 0x1abe
    return result;
}

// Address range: 0x1ad0 - 0x1ad9
int32_t function_1ad0(int32_t a1) {
    // 0x1ad0
    *(int32_t *)(g3 + (int32_t)&g19) = 0;
    return g1;
}

// Address range: 0x1ad9 - 0x1ada
int32_t function_1ad9(void) {
    // 0x1ad9
    return g1;
}

// Address range: 0x1adf - 0x1ae2
int32_t function_1adf(void) {
    // 0x1adf
    return 0;
}

// Address range: 0x1af0 - 0x1af7
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1) {
    // 0x1af0
    return _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev((int32_t *)(a1 - 28));
}

// Address range: 0x1b00 - 0x1b07
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev((int32_t *)(a1 - (int32_t)&g18)); // 0x1b05
    return result;
}

// Address range: 0x1b10 - 0x1b54
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g3 = v1;
    g1 = *(int32_t *)(v1 + (int32_t)&g19);
    *(int32_t *)(v1 + 28) = (int32_t)&g14;
    *(int32_t *)g3 = (int32_t)&g12;
    *(int32_t *)(g3 + (int32_t)&g18) = (int32_t)&g11;
    int32_t v2 = g1; // 0x1b3b
    if (v2 == 0) {
        // 0x1b4b
        *(int32_t *)g3 = (int32_t)&g9;
        return g1;
    }
    // 0x1b3f
    if ((char)v2 != 0) {
        // bb
        g1 = function_1b78(v2);
        // branch -> 0x1b4b
    }
    // 0x1b4b
    *(int32_t *)g3 = (int32_t)&g9;
    return g1;
}

// Address range: 0x1b78 - 0x1b81
int32_t function_1b78(int32_t a1) {
    // 0x1b78
    *(int32_t *)(g3 + (int32_t)&g19) = 0;
    return g1;
}

// Address range: 0x1b87 - 0x1b8a
int32_t function_1b87(void) {
    // 0x1b87
    return 0;
}

// Address range: 0x1ba0 - 0x1be0
// Demangled:     boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr()
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0x1bb4
    if (v1 != 0) {
        // 0x1bba
        if ((char)v1 != 0) {
            // 0x1bd8
            *a1 = 0;
            // branch -> 0x1bc6
        }
    }
    // 0x1bd3
    return 0;
}

// Address range: 0x1bf0 - 0x1c48
// Demangled:     boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::operator=(boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container> const &)
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEEaSERKS3_(int32_t * a1, int32_t a2) {
    int32_t v1 = *(int32_t *)a2; // 0x1c0f
    if (*a1 != 0) {
        // 0x1c17
        // branch -> 0x1c1f
    }
    // 0x1c1f
    *a1 = v1;
    if (v1 != 0) {
        // 0x1c25
        // branch -> 0x1c2d
    }
    int32_t result = (int32_t)a1; // 0x1c38
    // 0x1c3c
    return result;
}

// Address range: 0x1c50 - 0x1cc0
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::error_info_injector(boost::exception_detail::error_info_injector<boost::lock_error> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEEC1ERKS3_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1; // ebx
    *a1 = (int32_t)&g10;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g11;
    *(int32_t *)(v1 + 4) = *(int32_t *)(a2 + 4);
    int32_t v2 = *(int32_t *)(a2 + (int32_t)&g19); // 0x1c7c
    *(int32_t *)(v1 + (int32_t)&g19) = v2;
    if (v2 != 0) {
        // 0x1c86
        // branch -> 0x1c8e
    }
    int32_t v3 = *(int32_t *)(a2 + (int32_t)&g8); // 0x1c8e
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g13;
    *(int32_t *)(v1 + (int32_t)&g8) = v3;
    *(int32_t *)(v1 + 20) = *(int32_t *)(a2 + 20);
    *(int32_t *)v1 = (int32_t)&g12;
    *(int32_t *)(v1 + 24) = *(int32_t *)(a2 + 24);
    // 0x1cba
    return 0;
}

// Address range: 0x1ce0 - 0x1ce7
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1) {
    // 0x1ce0
    return _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(a1 - 28);
}

// Address range: 0x1cf0 - 0x1d0c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1) {
    // 0x1cf0
    return 0;
}

// Address range: 0x1d10 - 0x1d17
int32_t function_1d10(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb8c; // 0x1d10
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x1d60 - 0x1d82
// Demangled:     void boost::throw_exception<boost::lock_error>(boost::lock_error const &)
int32_t _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(int32_t a1) {
    // 0x1d60
    return 0;
}

// Address range: 0x1db0 - 0x1db1
int32_t function_1db0(void) {
    // 0x1db0
    return 0;
}

// Address range: 0x1e88 - 0x1eba
int32_t function_1e88(void) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 + 0x1c43c7c6); // 0x1e88
    *v2 = *v2 - 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = *(char *)&g1;
    char * v4 = (char *)(v1 + 0x6e8241c); // 0x1e91
    unsigned char v5 = *v4; // 0x1e91
    unsigned char v6 = v5 + (char)v1; // 0x1e91
    bool v7 = v6 < v5; // cf
    *v4 = v6;
    char v8 = *(char *)&g1; // 0x1e97
    *(char *)v3 = v8 - (char)v3 + (char)v7;
    unsigned char v9 = -119 * (char)(v3 >> (int32_t)&g18) + (char)v3; // 0x1e9b
    unknown_3900((int32_t)v9 | v3 & -0x10000);
    return unknown_3900(0);
}

// Address range: 0x1eba - 0x1ebe
int32_t function_1eba(void) {
    // 0x1eba
    return 0;
}

// Address range: 0x1ec0 - 0x1ee2
// Demangled:     CCrypter::~CCrypter()
int32_t _ZN8CCrypterD1Ev(int32_t a1) {
    // 0x1ec0
    return 0;
}

// Address range: 0x1f30 - 0x1f31
int32_t function_1f30(void) {
    // 0x1f30
    return 0;
}

// Address range: 0x1faf - 0x1fb0
int32_t function_1faf(void) {
    // 0x1faf
    return 0;
}

// Address range: 0x1fbd - 0x1fd8
int32_t function_1fbd(void) {
    int32_t v1 = 0; // 0x1fc9
    int32_t result = v1; // 0x1fd1
    if (v1 != 0) {
        // bb
        result = function_211b(4);
        // branch -> 0x1fd1
    }
    // 0x1fd1
    return result;
}

// Address range: 0x2000 - 0x2001
int32_t function_2000(void) {
    // 0x2000
    return 0;
}

// Address range: 0x2077 - 0x2078
int32_t function_2077(void) {
    // 0x2077
    return 0;
}

// Address range: 0x2085 - 0x208c
int32_t function_2085(void) {
    // 0x2085
    return 0;
}

// Address range: 0x2090 - 0x20ae
int32_t function_2090(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)-0x7d7af040; // 0x2090
    *v1 = *v1 + 1;
    int32_t v2 = 0; // eax
    *(char *)v2 = (char)v2 + *(char *)&g1;
    char * v3 = (char *)0x653c2444; // 0x2098
    *v3 = (char)0 + *v3;
    int32_t v4 = *(int32_t *)20 ^ v2; // 0x209e
    g1 = v4;
    int32_t result = v4; // 0x20ad
    if (v4 != 0) {
        // bb
        result = function_20ec();
        // branch -> 0x20a6
    }
    // 0x20a6
    return result;
}

// Address range: 0x20b0 - 0x20ec
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_20b0(void) {
    int32_t v1 = (int32_t)&g10; // bp+44
    int32_t result = unknown_3c20((int32_t)&v1, (int32_t)"allocators.h", 90, (int32_t)"void LockedPageManagerBase<Locker>::UnlockRange(void*, size_t) [with Locker = MemoryPageLocker, size_t = unsigned int]"); // 0x20e7
    return result;
}

// Address range: 0x20ec - 0x20ed
int32_t function_20ec(void) {
    // 0x20ec
    return g1;
}

// Address range: 0x20f1 - 0x20fe
int32_t function_20f1(void) {
    // 0x20f1
    return unknown_3490(g3);
}

// Address range: 0x211b - 0x2122
int32_t function_211b(int32_t a1) {
    // 0x211b
    g1 = unknown_3454();
    return function_20f1();
}

// Address range: 0x2130 - 0x2172
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::operator=(std::vector<unsigned char, std::allocator<unsigned char> > const &)
int32_t _ZNSt6vectorIhSaIhEEaSERKS1_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    g3 = v1;
    int32_t v2 = v1; // 0x2160
    int32_t v3 = a2; // 0x215b
    if (v1 == a2) {
        // bb
        function_21a6(*(int32_t *)20);
        v2 = g3;
        v3 = g5;
        // branch -> 0x215b
    }
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x215b
    g6 = v4;
    int32_t v5 = *(int32_t *)v3; // 0x215e
    g2 = v5;
    int32_t v6 = *(int32_t *)v2; // 0x2160
    g1 = v6;
    int32_t v7 = v4 - v5; // 0x2167
    g7 = v7;
    int32_t result; // 0x216f
    if (v7 <= *(int32_t *)(v2 + (int32_t)&g18) - v6) {
        // bb110
        result = function_21d0();
        // branch -> 0x216f
    } else {
        result = v6;
    }
    // 0x216f
    return result;
}

// Address range: 0x21a3 - 0x21a6
int32_t function_21a3(int32_t a1, int32_t a2) {
    // 0x21a3
    *(int32_t *)(g3 + 4) = g1;
    return g1;
}

// Address range: 0x21a6 - 0x21cd
int32_t function_21a6(int32_t a1) {
    // 0x21a6
    g1 = g3;
    int32_t result = g3; // 0x21cc
    if (*(int32_t *)20 != a1) {
        // bb
        result = function_2274();
        // branch -> 0x21b9
    }
    // 0x21b9
    return result;
}

// Address range: 0x21d0 - 0x21f0
int32_t function_21d0(void) {
    int32_t v1 = *(int32_t *)(g3 + 4); // 0x21d0
    int32_t result = g1; // 0x21d7
    uint32_t v2 = v1 - result; // 0x21d7
    int32_t v3 = g7; // 0x21d9
    int32_t v4 = v3; // 0x21e1
    if (v3 > v2) {
        int32_t v5 = function_2200(v1, v2); // 0x21df
        g1 = v5;
        result = v5;
        v4 = g7;
        // branch -> 0x21e1
    }
    if (v4 == 0) {
        // bb9
        int32_t * v6;
        result = function_21a3(v2, (int32_t)&v6);
        // branch -> 0x21e5
    }
    // 0x21e5
    return result;
}

// Address range: 0x21f5 - 0x21fb
int32_t function_21f5(void) {
    // 0x21f5
    int32_t v1;
    g1 = v1 + g3;
    int32_t * v2;
    return function_21a3((int32_t)&v2, (int32_t)&v2);
}

// Address range: 0x2200 - 0x2253
int32_t function_2200(int32_t a1, int32_t a2) {
    int32_t v1 = g2 + a2; // 0x2204
    if (a2 != 0) {
        // 0x2248
        return g1;
    }
    // 0x2212
    if (g6 != v1) {
        // 0x2220
        g1 = g7 + g3;
        return function_21a3(a1, v1);
    }
    // 0x2218
    g1 += g7;
    return function_21a3(v1, a2);
}

// Address range: 0x2257 - 0x2274
int32_t function_2257(void) {
    int32_t result = 0; // ebx
    int32_t * v1 = (int32_t *)(result + 0xf8b0443); // 0x2257
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x2274 - 0x2279
int32_t function_2274(void) {
    // 0x2274
    return g1;
}

// Address range: 0x2280 - 0x22a9
// Demangled:     LockedPageManagerBase<MemoryPageLocker>::UnlockRange(void *, unsigned int)
int32_t _ZN21LockedPageManagerBaseI16MemoryPageLockerE11UnlockRangeEPvj(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2280
    return a1 + 4;
}

// Address range: 0x22ad - 0x2321
int32_t function_22ad(void) {
    int32_t v1 = 0; // ebp
    int32_t * v2 = (int32_t *)(v1 - 0x217af040); // 0x22ad
    *v2 = *v2 + 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + *(char *)&g1;
    char * v4 = (char *)(v1 - 0x747bf00a); // 0x22b5
    *v4 = (char)v3 + *v4;
    *(char *)v3 = (char)v3 + *(char *)&g1;
    int32_t v5 = 0; // ebx
    char * v6 = (char *)(v5 - 0x1476dfb9); // 0x22bd
    *v6 = (char)0 + *v6;
    int32_t v7 = v3 & v5; // 0x22c7
    g3 = v7;
    int32_t v8 = v3 & v1 - 1; // 0x22c9
    g6 = v8;
    if (v7 > v8) {
        // bb
        function_2349();
        // branch -> 0x22cf
    }
    int32_t v9 = g5 + 40; // 0x22cf
    int32_t v10 = *(int32_t *)(g5 + 44); // 0x22d8
    int32_t v11 = v10; // 0x22f14
    int32_t v12 = v9; // 0x22fd
    if (v10 == 0) {
        // bb113
        v11 = function_2370();
        v12 = v9;
        // branch -> 0x22e3
    }
    int32_t v13 = g3;
    int32_t v14 = v12;
    // branch -> 0x22f1
  lab_0x22f1:
    while (true) {
        int32_t v15 = v11; // 0x22e8
        // branch -> 0x22f1
        int32_t v16; // 0x2301
        int32_t v17; // 0x22fd
        int32_t v18; // 0x2309
        int32_t v19; // 0x230e
        int32_t * v20; // 0x2306
        while (true) {
            // 0x22f1
            if (*(int32_t *)(v15 + 16) >= v13) {
                int32_t v21 = *(int32_t *)(v15 + 8); // 0x22ea
                if (v21 == 0) {
                    v17 = v15;
                    // break (via goto) -> 0x22fd
                    goto lab_0x22fd;
                }
                v14 = v15;
                v11 = v21;
                // continue (via goto) -> 0x22f1
                goto lab_0x22f1;
            } else {
                int32_t v22 = *(int32_t *)(v15 + 12); // 0x22f6
                if (v22 == 0) {
                    v17 = v14;
                    // break -> 0x22fd
                    break;
                }
                v15 = v22;
                // continue -> 0x22f1
                continue;
            }
            v16 = v17;
            if (v12 == v17) {
                // bb114
                v3 = function_2370();
                int32_t v23 = g7;
                int32_t v24 = g3;
                v13 = v24;
                v16 = v23;
                // branch -> 0x2301
            }
            uint32_t v25 = *(int32_t *)(v16 + 16); // 0x2301
            v19 = v16;
            if (v25 > v13) {
                // bb116
                v3 = function_2370();
                int32_t v26 = g7;
                v19 = v26;
                // branch -> 0x2306
            }
            // 0x2306
            v20 = (int32_t *)(v19 + 20);
            int32_t v27 = *v20; // 0x2306
            v18 = v27 - 1;
            g1 = v18;
            *v20 = v18;
            int32_t v28; // 0x2313
            int32_t result; // 0x2313
            if (v18 == 0) {
                // 0x2313
                v28 = g5;
                result = *(int32_t *)(v28 + 28);
                v3 = result;
                return result;
            }
            // bb117
            v3 = function_2342();
            // branch -> 0x2313
            // 0x2313
            v28 = g5;
            result = *(int32_t *)(v28 + 28);
            v3 = result;
            return result;
        }
      lab_0x22fd:
        // 0x22fd
        v16 = v17;
        if (v12 == v17) {
            // bb114
            function_2370();
            v13 = g3;
            v16 = g7;
            // branch -> 0x2301
        }
        // 0x2301
        v19 = v16;
        if (*(int32_t *)(v16 + 16) > v13) {
            // bb116
            function_2370();
            v19 = g7;
            // branch -> 0x2306
        }
        // 0x2306
        v20 = (int32_t *)(v19 + 20);
        v18 = *v20 - 1;
        g1 = v18;
        *v20 = v18;
        if (v18 == 0) {
            // 0x2313
            return *(int32_t *)(g5 + 28);
        }
        // bb117
        function_2342();
        // branch -> 0x2313
        // 0x2313
        return *(int32_t *)(g5 + 28);
    }
}

// Address range: 0x2342 - 0x2349
int32_t function_2342(void) {
    // 0x2342
    return g1;
}

// Address range: 0x2349 - 0x2350
int32_t function_2349(void) {
    // 0x2349
    int32_t result;
    return result;
}

// Address range: 0x2354 - 0x236e
int32_t function_2354(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)-0x74a78a40; // 0x2354
    *v1 = *v1 + 1;
    return *(int32_t *)20;
}

// Address range: 0x2370 - 0x23c8
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_2370(void) {
    // 0x2370
    int32_t v1; // bp+36
    int32_t v2 = &v1; // 0x2394
    g3 = v2;
    v1 = (int32_t)&g10;
    unknown_3fe0(v2, (int32_t)"allocators.h", 90, (int32_t)"void LockedPageManagerBase<Locker>::UnlockRange(void*, size_t) [with Locker = MemoryPageLocker, size_t = unsigned int]");
    g7 = unknown_3814();
    return unknown_3850(v2);
}

// Address range: 0x23d0 - 0x2472
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::_M_fill_insert(__gnu_cxx::__normal_iterator<unsigned char *, std::vector<unsigned char, std::allocator<unsigned char> > >, unsigned int, unsigned char const &)
int32_t _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    g7 = a3;
    g6 = a4;
    g3 = v1;
    g5 = a2;
    if (a3 == 0) {
        // bb
        function_24dc(*(int32_t *)20);
        v1 = g3;
        // branch -> 0x2407
    }
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x2407
    g2 = v2;
    int32_t v3 = *(int32_t *)(v1 + (int32_t)&g18) - v2; // 0x240d
    g1 = v3;
    if (v3 >= a3) {
        // bb26
        function_2508();
        v2 = g2;
        v1 = g3;
        // branch -> 0x2417
    }
    int32_t v4 = *(int32_t *)v1; // 0x2417
    g1 = v4;
    int32_t v5 = v2 - v4; // 0x2419
    uint32_t v6 = v5; // 0x2436
    if (-1 - v5 < a3) {
        int32_t v7 = function_2640(); // 0x2421
        g1 = v7;
        v4 = v7;
        v6 = v5;
        // branch -> 0x2427
    }
    int32_t v8 = v6 >= a3 ? v6 : a3; // 0x242b
    int32_t v9 = v8 + v6; // 0x2436
    if (v9 < v6) {
        // bb29
        g1 = function_2620(v8);
        // branch -> 0x244c
    }
    // 0x244c
    if (v9 != 0) {
        // bb30
        function_2618();
        // branch -> 0x2454
    }
    // 0x2454
    return g5 - v4;
}

// Address range: 0x2494 - 0x24a4
int32_t function_2494(void) {
    int32_t * v1 = (int32_t *)-0x74dfdbac; // 0x2494
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    g1 = v2 + 1 & 255 | v2 & -256;
    return function_f631f201();
}

// Address range: 0x24dc - 0x2501
int32_t function_24dc(int32_t a1) {
    int32_t v1 = *(int32_t *)20 ^ a1; // 0x24e0
    g1 = v1;
    int32_t result = v1; // 0x2500
    if (v1 != 0) {
        // bb
        result = function_263b();
        // branch -> 0x24ed
    }
    // 0x24ed
    return result;
}

// Address range: 0x2508 - 0x256f
int32_t function_2508(void) {
    // 0x2508
    g4 = (int32_t)*(char *)&g6;
    int32_t v1 = g2 - g5; // 0x250d
    g6 = v1;
    int32_t v2 = g7; // 0x250f
    int32_t v3 = v2; // 0x2555
    int32_t v4 = g2; // 0x251f
    if (v2 >= v1) {
        // bb
        function_2598();
        v3 = g7;
        v4 = g2;
        // branch -> 0x2517
    }
    // 0x2517
    int32_t v5;
    int32_t v6; // 0x2559
    if (v3 == 0) {
        // 0x2517
        v6 = g3;
        v5 = v4;
        // branch -> 0x2551
    } else {
        int32_t v7 = g3; // 0x2541
        g4 %= 256;
        v6 = v7;
        v5 = *(int32_t *)(v7 + 4);
        // branch -> 0x2551
    }
    int32_t v8 = v5 + v3; // 0x2555
    int32_t v9 = v4 - v3 - g5; // 0x2557
    g6 = v9;
    *(int32_t *)(v6 + 4) = v8;
    int32_t result; // 0x256c
    if (v9 == 0) {
        // bb12
        result = function_2579();
        // branch -> 0x255e
    } else {
        // 0x2551
        result = v8;
        // branch -> 0x255e
    }
    // 0x255e
    g2 -= g6;
    return result;
}

// Address range: 0x2579 - 0x2597
int32_t function_2579(void) {
    // 0x2579
    int32_t v1;
    int32_t v2 = *(int32_t *)20 ^ v1; // 0x257d
    g1 = v2;
    if (v2 != 0) {
        // bb
        g1 = function_263b();
        // branch -> 0x258a
    }
    // 0x258a
    return function_25fc(g4 % 256, g7);
}

// Address range: 0x2598 - 0x25b4
int32_t function_2598(void) {
    int32_t v1 = g7; // 0x2598
    g7 = g4 % 256;
    g4 = v1 - g6;
    return g1;
}

// Address range: 0x25fc - 0x2613
int32_t function_25fc(int32_t a1, int32_t a2) {
    // 0x25fc
    g3 = a1;
    return g1;
}

// Address range: 0x2618 - 0x2620
int32_t function_2618(void) {
    // 0x2618
    return g1;
}

// Address range: 0x2620 - 0x263b
int32_t function_2620(int32_t a1) {
    // 0x2620
    return g1;
}

// Address range: 0x263b - 0x2640
int32_t function_263b(void) {
    // 0x263b
    return g1;
}

// Address range: 0x2640 - 0x264c
int32_t function_2640(void) {
    // 0x2640
    return g1;
}

// Address range: 0x2650 - 0x269d
// Demangled:     std::_Rb_tree<unsigned int, std::pair<unsigned int const, int>, std::_Select1st<std::pair<unsigned int const, int> >, std::less<unsigned int>, std::allocator<std::pair<unsigned int const, int> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<unsigned int const, int> const &)
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE10_M_insert_EPKSt18_Rb_tree_node_baseSB_RKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x2650
    g1 = a3;
    g5 = a4;
    g2 = a5;
    int32_t result = a3; // 0x2696
    if (a3 == 0) {
        // bb
        result = function_2708(a2 + 4, 1);
        // branch -> 0x2696
    }
    // 0x2696
    return result;
}

// Address range: 0x26d2 - 0x2702
int32_t function_26d2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7ce3dbbc; // 0x26d2
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x26d9
    int32_t v3 = (v2 + 1 + (int32_t)false) % 256 | v2 & -256; // 0x26d9
    int32_t result = 0; // esi
    *(int32_t *)result = v3;
    g1 = result;
    if (*(int32_t *)20 != a1) {
        // bb
        result = function_2720();
        // branch -> 0x26ec
    }
    // 0x26ec
    return result;
}

// Address range: 0x2708 - 0x2720
int32_t function_2708(int32_t a1, int32_t a2) {
    // 0x2708
    return g1;
}

// Address range: 0x2720 - 0x2721
int32_t function_2720(void) {
    // 0x2720
    return g1;
}

// Address range: 0x2730 - 0x27c8
// Demangled:     std::_Rb_tree<unsigned int, std::pair<unsigned int const, int>, std::_Select1st<std::pair<unsigned int const, int> >, std::less<unsigned int>, std::allocator<std::pair<unsigned int const, int> > >::_M_insert_unique(std::pair<unsigned int const, int> const &)
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE16_M_insert_uniqueERKS2_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    g5 = a2;
    g3 = v1;
    int32_t result = *(int32_t *)(a2 + (int32_t)&g18); // 0x274f
    g7 = result;
    int32_t v2; // 0x27b7
    if (result == 0) {
        // 0x27b7
        v2 = a2 + 4;
        g7 = v2;
        // branch -> 0x27c0
    } else {
        // 0x275a
        int32_t v3;
        uint32_t v4 = *(int32_t *)v3; // 0x275e
        // branch -> 0x2776
        while (true) {
            uint32_t v5 = *(int32_t *)(result + (int32_t)&g8); // 0x2776
            int32_t v6; // 0x2768
            if (v5 > v4) {
                // 0x2768
                v6 = *(int32_t *)(result + (int32_t)&g18);
                if (v6 == 0) {
                    // 0x2786
                    // branch -> 0x27c0
                    // 0x27c0
                    if (result != *(int32_t *)(a2 + (int32_t)&g19)) {
                        // 0x27c5
                        return result;
                    }
                    // bb28
                    // branch -> 0x27c5
                    // 0x27c5
                    return function_27e0(v5);
                }
            } else {
                int32_t v7 = *(int32_t *)(result + (int32_t)&g19); // 0x277d
                if (v7 == 0) {
                    if (v5 < v4) {
                        int32_t v8 = function_27e0(v5); // 0x2796
                        v1 = g3;
                        result = v8;
                        // branch -> 0x2798
                    }
                    // 0x2798
                    *(int32_t *)v1 = result;
                    *(char *)(g3 + 4) = 0;
                    g1 = g3;
                    // 0x27ad
                    return g3;
                }
                v6 = v7;
            }
            // 0x2774
            g7 = v6;
            result = v6;
            // branch -> 0x2776
        }
    }
    int32_t result2 = 0; // 0x27c5
    if (v2 == *(int32_t *)(a2 + (int32_t)&g19)) {
        // bb28
        int32_t v9;
        result2 = function_27e0(v9);
        // branch -> 0x27c5
    }
    // 0x27c5
    return result2;
}

// Address range: 0x27e0 - 0x2813
int32_t function_27e0(int32_t result) {
    // 0x27e0
    int32_t v1; // bp+44
    unknown_4d80((int32_t)&v1, g5, 0, g7, result);
    *(char *)(g3 + 4) = 1;
    *(int32_t *)g3 = result;
    return result;
}

// Address range: 0x2813 - 0x2814
int32_t function_2813(void) {
    // 0x2813
    return g1;
}

// Address range: 0x2820 - 0x2904
// Demangled:     std::vector<unsigned char, secure_allocator<unsigned char> >::operator=(std::vector<unsigned char, secure_allocator<unsigned char> > const &)
int32_t _ZNSt6vectorIh16secure_allocatorIhEEaSERKS2_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    g5 = v1;
    int32_t result; // 0x287e
    if (v1 == a2) {
        // 0x2873
        result = g5;
        g1 = result;
        // 0x2886
        return result;
    }
    int32_t v2 = *(int32_t *)(a2 + 4); // 0x283f
    g2 = v2;
    int32_t v3 = *(int32_t *)a2; // 0x2842
    g7 = v3;
    int32_t v4 = *a1; // 0x2844
    g4 = v4;
    int32_t v5 = v2 - v3; // 0x284b
    int32_t result2 = *(int32_t *)(v1 + (int32_t)&g18) - v4; // 0x2851
    g1 = result2;
    if (v5 > result2) {
        // 0x28d0
        if (result2 == 0) {
            // 0x28e4
            if (function_298a((char *)v5) == 0) {
                // 0x28f8
                return result2;
            }
        }
        // bb33
        function_2ada(4);
        // branch -> 0x28f8
        // 0x28f8
        return result2;
    }
    int32_t v6 = *(int32_t *)(v1 + 4); // 0x2857
    int32_t v7 = v6; // edx
    int32_t v8 = v6 - v4; // 0x285c
    g1 = v8;
    if (v5 > v8) {
        int32_t v9 = v8 + v3; // 0x2890
        g1 = v8;
        if (v8 != 0) {
            // bb31
            function_2a17(v5, v8, v9);
            v2 = g2;
            // branch -> 0x28a2
        }
        // 0x28a2
        g1 = v9;
        int32_t v10 = v9; // 0x28b47
        if (v9 == v2) {
            int32_t v11 = function_2a89(); // 0x28aa
            g1 = v11;
            v10 = v11;
            // branch -> 0x28b0
        }
        int32_t v12 = v7; // 0x28b7
        // branch -> 0x28b0
        while (true) {
            int32_t v13 = 0; // 0x28bc
            int32_t v14 = v10; // 0x28b9
            if (v12 != 0) {
                // 0x28b4
                *(char *)v12 = *(char *)v10;
                v13 = v7;
                v14 = g1;
                // branch -> 0x28b9
            }
            int32_t v15 = v14 + 1; // 0x28b9
            g1 = v15;
            int32_t v16 = v13 + 1; // 0x28bc
            v7 = v16;
            if (v15 == g2) {
                // break -> 0x28c3
                break;
            }
            v10 = v15;
            v12 = v16;
            // continue -> 0x28b0
        }
        // 0x28c3
        *(int32_t *)(g5 + 4) = *(int32_t *)g5 + v5;
        // branch -> 0x2873
    } else {
        if (v5 != 0) {
            // bb
            function_29f5(v5);
            v1 = g5;
            v4 = g4;
            // branch -> 0x2870
        }
        // 0x2870
        *(int32_t *)(v1 + 4) = v4;
        // branch -> 0x2873
    }
    // 0x2873
    result = g5;
    g1 = result;
    // 0x2886
    return result;
}

// Address range: 0x2920 - 0x2921
int32_t function_2920(void) {
    // 0x2920
    return 0;
}

// Address range: 0x2966 - 0x2967
int32_t function_2966(void) {
    // 0x2966
    return 0;
}

// Address range: 0x2976 - 0x2977
int32_t function_2976(void) {
    // 0x2976
    return 0;
}

// Address range: 0x298a - 0x29bd
int32_t function_298a(char * a1) {
    int32_t v1 = g7; // 0x298a
    int32_t result; // 0x29ba
    if (v1 == g2) {
        // 0x29ab
        if (g5 == 0) {
            // bb
            result = function_29de();
            // branch -> 0x29b4
        } else {
            // 0x29ab
            result = g1;
            // branch -> 0x29b4
        }
        // 0x29b4
        return result;
    }
    int32_t v2 = (int32_t)a1; // 0x298e
    g1 = v2;
    int32_t v3 = g2; // 0x29a74
    // branch -> 0x2998
    while (true) {
        int32_t v4 = v3; // 0x29a7
        int32_t v5 = 0; // 0x29a4
        int32_t v6 = v1; // 0x29a1
        if (v2 != 0) {
            // 0x299c
            *(char *)v2 = *(char *)v1;
            v4 = g2;
            v5 = g1;
            v6 = g7;
            // branch -> 0x29a1
        }
        int32_t v7 = v6 + 1; // 0x29a1
        g7 = v7;
        int32_t v8 = v5 + 1; // 0x29a4
        g1 = v8;
        if (v7 == v4) {
            // break -> 0x29ab
            break;
        }
        v3 = v4;
        v1 = v7;
        v2 = v8;
        // continue -> 0x2998
    }
    // 0x29ab
    if (g5 == 0) {
        // bb
        result = function_29de();
        // branch -> 0x29b4
    } else {
        // 0x29ab
        result = g1;
        // branch -> 0x29b4
    }
    // 0x29b4
    return result;
}

// Address range: 0x29cc - 0x29d5
int32_t function_29cc(int16_t a1) {
    // 0x29cc
    return (0 >> (int32_t)&g18) % 256;
}

// Address range: 0x29de - 0x29f5
int32_t function_29de(void) {
    int32_t result = 0; // eax
    *(int32_t *)(g5 + (int32_t)&g18) = result;
    *(int32_t *)(g5 + 4) = result;
    return result;
}

// Address range: 0x29f5 - 0x2a04
int32_t function_29f5(int32_t a1) {
    // 0x29f5
    return g1;
}

// Address range: 0x2a09 - 0x2a17
int32_t function_2a09(int32_t a1) {
    // 0x2a09
    int32_t v1;
    *(int32_t *)(v1 + 4) = v1 + a1;
    return 0;
}

// Address range: 0x2a17 - 0x2a22
int32_t function_2a17(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a17
    return g1;
}

// Address range: 0x2a26 - 0x2a42
int32_t function_2a26(void) {
    int32_t result = 0; // ebx
    int32_t * v1 = (int32_t *)(result + 0xf8b0457); // 0x2a26
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x2a48 - 0x2a49
int32_t function_2a48(void) {
    // 0x2a48
    return 0;
}

// Address range: 0x2a89 - 0x2a92
int32_t function_2a89(void) {
    // 0x2a89
    return g1;
}

// Address range: 0x2a93 - 0x2a94
int32_t function_2a93(void) {
    // 0x2a93
    return 0;
}

// Address range: 0x2ad5 - 0x2ad6
int32_t function_2ad5(void) {
    // 0x2ad5
    return g1;
}

// Address range: 0x2ada - 0x2aff
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_2ada(int32_t a1) {
    // 0x2ada
    int32_t v1; // bp+68
    int32_t v2 = &v1; // 0x2ada
    v1 = (int32_t)&g10;
    unknown_4580(v2);
    return unknown_3df0(v2);
}

// Address range: 0x2b10 - 0x2b94
// Demangled:     std::vector<unsigned char, secure_allocator<unsigned char> >::_M_fill_insert(__gnu_cxx::__normal_iterator<unsigned char *, std::vector<unsigned char, secure_allocator<unsigned char> > >, unsigned int, unsigned char const &)
int32_t _ZNSt6vectorIh16secure_allocatorIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS2_EEjRKh(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    g1 = 0;
    g2 = v1;
    g5 = a2;
    if (a3 == 0) {
        // bb
        function_2d0c(0);
        v1 = g2;
        // branch -> 0x2b3f
    }
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x2b3f
    g6 = v2;
    int32_t v3 = v2; // 0x2b52
    int32_t v4 = v1; // 0x2b4f
    if (*(int32_t *)(v1 + (int32_t)&g18) - v2 >= a3) {
        // bb23
        function_2d28();
        v3 = g6;
        v4 = g2;
        // branch -> 0x2b4f
    }
    int32_t result = *(int32_t *)v4; // 0x2b4f
    g1 = result;
    int32_t v5 = v3 - result; // 0x2b52
    uint32_t v6 = v5; // 0x2b79
    if (-1 - v5 < a3) {
        // bb25
        result = function_2ede();
        v6 = v5;
        // branch -> 0x2b62
    }
    int32_t v7 = v6 >= a3 ? v6 : a3; // 0x2b74
    g4 = v7;
    int32_t v8 = v7 + v6; // 0x2b79
    g6 = v8;
    if (v8 < v6) {
        // 0x2b8d
        return result;
    }
    int32_t result2 = result; // 0x2b91
    if (v8 == 0) {
        // bb26
        result2 = function_2e69(-1, g5 - result);
        // branch -> 0x2b8d
    }
    // 0x2b8d
    return result2;
}

// Address range: 0x2be8 - 0x2be9
int32_t function_2be8(void) {
    // 0x2be8
    return 0;
}

// Address range: 0x2c2e - 0x2c2f
int32_t function_2c2e(void) {
    // 0x2c2e
    return 0;
}

// Address range: 0x2c40 - 0x2c41
int32_t function_2c40(void) {
    // 0x2c40
    return 0;
}

// Address range: 0x2c54 - 0x2cda
int32_t function_2c54(char * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1; // 0x2c58
    g6 = v1;
    int32_t v2;
    int32_t v3 = v2 + a2; // 0x2c5c
    int32_t v4 = v1; // 0x2c6c4
    // branch -> 0x2c60
    int32_t v5; // 0x2c69
    while (true) {
        int32_t v6 = v4; // 0x2c6c
        int32_t v7 = 0; // 0x2c69
        if (v3 != 0) {
            unsigned char v8 = *(char *)&g7; // 0x2c64
            g4 = v8;
            *(char *)v3 = v8;
            v6 = g6;
            v7 = v3;
            // branch -> 0x2c69
        }
        // 0x2c69
        v5 = v7 + 1;
        int32_t v9 = v6 - 1; // 0x2c6c
        g6 = v9;
        if (v9 == 0) {
            // break -> 0x2c71
            break;
        }
        v4 = v9;
        v3 = v5;
        // continue -> 0x2c60
    }
    int32_t result = v5; // 0x2cd723
    int32_t v10 = g2; // 0x2ca6
    int32_t v11 = a2; // 0x2c9e
    if (g2 != g5) {
        // 0x2c7c
        g6 = g2;
        v3 = a2;
        int32_t v12 = g5; // 0x2c8f9
        int32_t v13 = g2; // 0x2c84
        int32_t v14 = a2; // 0x2c87
        // branch -> 0x2c80
        int32_t v15; // 0x2c93
        int32_t v16; // 0x2c8c
        while (true) {
            // 0x2c80
            v15 = v12;
            int32_t v17 = 0; // 0x2c8c
            int32_t v18 = v13; // 0x2c89
            if (v14 != 0) {
                unsigned char v19 = *(char *)v13; // 0x2c84
                g4 = v19;
                *(char *)v14 = v19;
                v15 = g5;
                v17 = v3;
                v18 = g6;
                // branch -> 0x2c89
            }
            int32_t v20 = v18 + 1; // 0x2c89
            g6 = v20;
            v16 = v17 + 1;
            v3 = v16;
            if (v20 == v15) {
                // break -> 0x2c93
                break;
            }
            v12 = v15;
            v13 = v20;
            v14 = v16;
            // continue -> 0x2c80
        }
        // 0x2c93
        result = v16;
        v10 = v15;
        v11 = v15 - g2 + a2;
        // branch -> 0x2c9b
    }
    int32_t v21 = *(int32_t *)(g2 + 4); // 0x2c9b
    int32_t v22 = v11 + v1; // 0x2c9e
    g7 = v22;
    if (v21 != v10) {
        // 0x2ca6
        v3 = v10;
        g6 = v22;
        int32_t v23 = v21; // 0x2cbf17
        int32_t v24 = v22; // 0x2cb7
        // branch -> 0x2cb0
        int32_t v25; // 0x2cb9
        while (true) {
            int32_t v26 = v23; // 0x2cbf
            int32_t v27 = 0; // 0x2cbc
            int32_t v28 = v10; // 0x2cb9
            if (v24 != 0) {
                unsigned char v29 = *(char *)v10; // 0x2cb4
                g4 = v29;
                *(char *)v24 = v29;
                v26 = v21;
                v27 = g6;
                v28 = v3;
                // branch -> 0x2cb9
            }
            // 0x2cb9
            v25 = v28 + 1;
            v3 = v25;
            int32_t v30 = v27 + 1; // 0x2cbc
            g6 = v30;
            if (v25 == v26) {
                // break -> 0x2cc3
                break;
            }
            v23 = v26;
            v10 = v25;
            v24 = v30;
            // continue -> 0x2cb0
        }
        int32_t v31 = v25 - g5; // 0x2cc3
        g7 = v22 + v31;
        result = v31;
        // branch -> 0x2cc7
    }
    if (g2 == 0) {
        // bb
        result = function_2cfb();
        // branch -> 0x2cd1
    }
    // 0x2cd1
    return result;
}

// Address range: 0x2cfb - 0x2d0c
int32_t function_2cfb(void) {
    // 0x2cfb
    *(int32_t *)(g2 + 4) = g7;
    int32_t v1 = 0; // eax
    *(int32_t *)g2 = v1;
    int32_t v2;
    int32_t result = v1 + v2; // 0x2d05
    *(int32_t *)(g2 + (int32_t)&g18) = result;
    return result;
}

// Address range: 0x2d0c - 0x2d25
int32_t function_2d0c(int32_t a1) {
    // 0x2d0c
    int32_t result; // 0x2d24
    if (*(int32_t *)20 != a1) {
        // bb
        result = function_2e96();
        // branch -> 0x2d1d
    } else {
        // 0x2d0c
        result = g1;
        // branch -> 0x2d1d
    }
    // 0x2d1d
    return result;
}

// Address range: 0x2d28 - 0x2d8c
int32_t function_2d28(void) {
    int32_t v1 = g6; // 0x2d28
    g3 = (int32_t)*(char *)&g7;
    g1 = v1;
    int32_t v2 = v1 - g5; // 0x2d2f
    uint32_t v3;
    if (v3 >= v2) {
        // bb
        v1 = function_2da8((char *)v2);
        // branch -> 0x2d3b
    }
    int32_t v4 = v1 - v3; // 0x2d3b
    int32_t v5 = v1; // eax
    int32_t v6; // 0x2d70
    if (v1 == v4) {
        // 0x2d3b
        v6 = v1;
        // branch -> 0x2d70
    } else {
        int32_t v7 = v1; // 0x2d678
        int32_t v8 = v1; // 0x2d5f
        // branch -> 0x2d58
        int32_t v9; // 0x2d6e
        while (true) {
            // 0x2d58
            v9 = v7;
            int32_t v10 = 0; // 0x2d64
            if (v8 != 0) {
                // 0x2d5c
                *(char *)v8 = *(char *)v4;
                v9 = v1;
                v10 = v5;
                // branch -> 0x2d61
            }
            int32_t v11 = v4 + 1; // 0x2d61
            v4 = v11;
            int32_t v12 = v10 + 1; // 0x2d64
            v5 = v12;
            if (v11 == v9) {
                // break -> 0x2d6b
                break;
            }
            v7 = v9;
            v8 = v12;
            v4 = v11;
            // continue -> 0x2d58
        }
        // 0x2d6b
        g6 = v9;
        v6 = *(int32_t *)(g2 + 4);
        // branch -> 0x2d70
    }
    // 0x2d70
    *(int32_t *)(g2 + 4) = v6 + v3;
    int32_t v13 = v4 - g5; // 0x2d7b
    g1 = v13;
    int32_t result = v13; // 0x2d89
    if (v13 == 0) {
        // bb18
        result = function_2d91();
        // branch -> 0x2d7f
    }
    // 0x2d7f
    g6 -= result;
    return result;
}

// Address range: 0x2d91 - 0x2da8
int32_t function_2d91(void) {
    // 0x2d91
    int32_t v1;
    if (*(int32_t *)20 != v1) {
        // bb
        function_2e96();
        // branch -> 0x2da2
    }
    // 0x2da2
    return function_2e0a();
}

// Address range: 0x2da8 - 0x2e0a
int32_t function_2da8(char * a1) {
    // 0x2da8
    int32_t result;
    int32_t v1 = (int32_t)a1 - result; // 0x2dac
    int32_t v2; // ecx
    int32_t v3; // 0x2dc9
    int32_t v4; // 0x2dc9
    if (v1 == 0) {
        // 0x2da8
        v4 = 0;
        v3 = g1;
        // branch -> 0x2dc9
    } else {
        // 0x2db2
        v2 = v1;
        int32_t v5 = v1; // 0x2dc12
        // branch -> 0x2db8
        while (true) {
            int32_t v6 = v5; // 0x2dc1
            char * v7;
            if (v7 != NULL) {
                // 0x2dbc
                *v7 = (char)g3;
                v6 = v2;
                // branch -> 0x2dbe
            }
            int32_t v8 = v6 - 1; // 0x2dc1
            v2 = v8;
            if (v8 == 0) {
                // break -> 0x2dc6
                break;
            }
            v5 = v8;
            v7 = (char *)((int32_t)v7 + 1);
            // continue -> 0x2db8
        }
        // 0x2dc6
        v4 = v1;
        v3 = *(int32_t *)(g2 + 4);
        // branch -> 0x2dc9
    }
    int32_t v9 = v3 + v4; // 0x2dc9
    int32_t v10 = v9; // eax
    *(int32_t *)(g2 + 4) = v9;
    int32_t v11; // 0x2dee
    if (g6 == g5) {
        // 0x2dc9
        v11 = v10;
        // branch -> 0x2dee
    } else {
        // 0x2dd2
        v2 = g5;
        int32_t v12 = g6; // 0x2dd4
        int32_t v13 = v12; // 0x2de711
        int32_t v14 = g5; // 0x2ddc
        int32_t v15 = v10; // 0x2ddf
        // branch -> 0x2dd8
        while (true) {
            int32_t v16 = v13; // 0x2de7
            int32_t v17 = 0; // 0x2de4
            int32_t v18 = v14; // 0x2de1
            if (v15 != 0) {
                unsigned char v19 = *(char *)v14; // 0x2ddc
                g6 = v19;
                *(char *)v15 = v19;
                v16 = v12;
                v17 = v10;
                v18 = v2;
                // branch -> 0x2de1
            }
            int32_t v20 = v18 + 1; // 0x2de1
            v2 = v20;
            int32_t v21 = v17 + 1; // 0x2de4
            v10 = v21;
            if (v20 == v16) {
                // break -> 0x2deb
                break;
            }
            v13 = v16;
            v14 = v20;
            v15 = v21;
            // continue -> 0x2dd8
        }
        // 0x2deb
        v11 = *(int32_t *)(g2 + 4);
        // branch -> 0x2dee
    }
    int32_t v22 = v11 + result; // 0x2dee
    g1 = v22;
    *(int32_t *)(g2 + 4) = v22;
    int32_t v23;
    if ((*(int32_t *)20 ^ v23) != 0) {
        // bb
        function_2e96();
        // branch -> 0x2e06
    }
    // 0x2e06
    return result;
}

// Address range: 0x2e0a - 0x2e20
int32_t function_2e0a(void) {
    // 0x2e0a
    return g1;
}

// Address range: 0x2e28 - 0x2e29
int32_t function_2e28(void) {
    // 0x2e28
    return 0;
}

// Address range: 0x2e69 - 0x2e7e
int32_t function_2e69(int32_t a1, int32_t a2) {
    // 0x2e69
    return function_2c54(NULL, 0);
}

// Address range: 0x2e96 - 0x2e97
int32_t function_2e96(void) {
    // 0x2e96
    return g1;
}

// Address range: 0x2e9c - 0x2e9d
int32_t function_2e9c(void) {
    // 0x2e9c
    return 0;
}

// Address range: 0x2ede - 0x2ee5
int32_t function_2ede(void) {
    // 0x2ede
    return g1;
}

// Address range: 0x2f00 - 0x2f16
int32_t _GLOBAL__sub_I__ZN8CCrypter20SetKeyFromPassphraseERKSbIcSt11char_traitsIcE16secure_allocatorIcEERKSt6vectorIhSaIhEEjj(void) {
    // 0x2f00
    return 0;
}

// Address range: 0x2f36 - 0x2f48
int32_t function_2f36(void) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x2f36
    *v1 = *v1 - 1;
    int32_t result = *(int32_t *)20; // 0x2f3c
    if (result != 0) {
        // 0x2f48
    }
    // 0x2f44
    return result;
}

// Address range: 0x3270 - 0x3271
int32_t _ZTSN5boost16exception_detail10clone_baseE(int32_t a1) {
    // 0x3270
    return g1;
}

// Address range: 0x34c0 - 0x34c1
int32_t function_34c0(int32_t a1) {
    // 0x34c0
    return g1;
}

// Address range: 0xf631f201 - 0xf631f202
int32_t function_f631f201(void) {
    // 0xf631f201
    return g1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected language: C++
// Detected functions: 220
// Decompilation date: 2018-06-10 00:05:08
