//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct vtable_3a78_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_3a90_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_3ac8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_3b08_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

// ------------------------- Classes --------------------------

// N5boost10lock_errorE (base classes: N5boost16thread_exceptionE)
// N5boost16exception_detail10clone_baseE
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE (base classes: N5boost16exception_detail10clone_baseE, N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE)
// N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE (base classes: N5boost9exceptionE, N5boost10lock_errorE)
// N5boost16thread_exceptionE
// N5boost9exceptionE

// ------------------- Function Prototypes --------------------

void _7e_clone_impl(int32_t this, int32_t __in_chrg);
void _7e_unique_lock(int32_t this, int32_t __in_chrg);
int32_t _GLOBAL__sub_I__ZN4CKey5CheckEPKh(void);
int32_t _ZN12_GLOBAL__N_121EC_KEY_regenerate_keyEP9ec_key_stP9bignum_st_constprop_84(void);
int32_t _ZN12_GLOBAL__N_16CECKey14SetSecretBytesEPKh_part_2(void);
int32_t _ZN12_GLOBAL__N_16CECKeyC2Ev_part_0(void);
int32_t _ZN16secure_allocatorIhE10deallocateEPhj(int32_t a1, int32_t a2);
void _ZN4CKey10MakeNewKeyEb(int32_t this, bool fCompressedIn);
void _ZN4CKey10SetPrivKeyERKSt6vectorIh16secure_allocatorIhEEb(int32_t this, int32_t privkey, bool fCompressedIn);
void _ZN4CKey5CheckEPKh(char * vch);
int32_t _ZN5boost10lock_errorD0Ev(int32_t * a1);
int32_t _ZN5boost10lock_errorD1Ev(int32_t * a1);
int32_t _ZN5boost11unique_lockINS_5mutexEED2Ev_part_33(void);
int32_t _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(int32_t a1);
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEEaSERKS3_(int32_t * a1, int32_t a2);
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEEC1ERKS3_(int32_t * a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t * a1);
int32_t _ZN5boost16thread_exceptionD0Ev(int32_t * a1);
int32_t _ZN5boost16thread_exceptionD1Ev(int32_t * a1);
void _ZN7CPubKey10DecompressEv(int32_t this);
void _ZN7CPubKey14RecoverCompactERK7uint256RKSt6vectorIhSaIhEE(int32_t this, int32_t hash, int32_t vchSig);
void _ZNK4CKey10GetPrivKeyEv(int32_t this);
void _ZNK4CKey11SignCompactERK7uint256RSt6vectorIhSaIhEE(int32_t this, int32_t hash, int32_t vchSig);
void _ZNK4CKey4SignERK7uint256RSt6vectorIhSaIhEE(int32_t this, int32_t hash, int32_t vchSig);
void _ZNK4CKey9GetPubKeyEv(int32_t this);
int32_t _ZNK5boost10lock_error4whatEv(void);
void _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t this);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1);
void _ZNK7CPubKey12IsFullyValidEv(int32_t this);
void _ZNK7CPubKey13VerifyCompactERK7uint256RKSt6vectorIhSaIhEE(int32_t this, int32_t hash, int32_t vchSig);
void _ZNK7CPubKey6VerifyERK7uint256RKSt6vectorIhSaIhEE(int32_t this, int32_t hash, int32_t vchSig);
int32_t _ZNSt6vectorIh16secure_allocatorIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS2_EEjRKh(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE10_M_insert_EPKSt18_Rb_tree_node_baseSB_RKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE16_M_insert_uniqueERKS2_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t a1);
void ECDSA_SIG_recover_key_GFp(int32_t eckey, int32_t ecsig, char * msg, int32_t msglen, int32_t recid, int32_t check);
int32_t function_10b6(void);
int32_t function_10e2(void);
int32_t function_10f5(void);
int32_t function_110a(void);
int32_t function_1128(void);
int32_t function_1130(void);
int32_t function_113c(void);
int32_t function_1143(void);
int32_t function_11b9(void);
int32_t function_11c1(void);
int32_t function_1243(void);
int32_t function_126f(void);
int32_t function_1278(int32_t a1);
int32_t function_12a0(void);
int32_t function_12b2(void);
int32_t function_1351(void);
int32_t function_13ed(void);
int32_t function_13f7(void);
int32_t function_13fd(void);
int32_t function_1405(void);
int32_t function_1411(void);
int32_t function_1418(int32_t a1);
int32_t function_1450(void);
int32_t function_1460(void);
int32_t function_147e(void);
int32_t function_1488(void);
int32_t function_1497(void);
int32_t function_150e(void);
int32_t function_15e6(void);
int32_t function_1624(void);
int32_t function_1653(void);
int32_t function_1687(void);
int32_t function_16ee(void);
int32_t function_1705(int16_t a1);
int32_t function_171e(void);
int32_t function_172f(int16_t a1);
int32_t function_1747(void);
int32_t function_1751(void);
int32_t function_1754(int16_t a1);
int32_t function_176f(void);
int32_t function_1780(void);
int32_t function_1792(void);
int32_t function_1799(void);
int32_t function_17c5(void);
int32_t function_17cf(void);
int32_t function_180a(void);
int32_t function_1816(void);
int32_t function_1820(void);
int32_t function_1828(void);
int32_t function_183(int32_t a1);
int32_t function_18b6(int16_t a1);
int32_t function_18cf(void);
int32_t function_18d9(void);
int32_t function_18f2(void);
int32_t function_1920(void);
int32_t function_192f(void);
int32_t function_1937(void);
int32_t function_1958(void);
int32_t function_1964(void);
int32_t function_1982(void);
int32_t function_1990(void);
int32_t function_1998(int32_t * a1);
int32_t function_19c8(void);
int32_t function_19e0(void);
int32_t function_1a12(unsigned char a1);
int32_t function_1a33(void);
int32_t function_1a38(void);
int32_t function_1a48(void);
int32_t function_1a58(void);
int32_t function_1a68(void);
int32_t function_1a7d(void);
int32_t function_1a98(void);
int32_t function_1aa5(void);
int32_t function_1aac(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1b74(void);
int32_t function_1b75(void);
int32_t function_1b8a(void);
int32_t function_1b93(void);
int32_t function_1c42(void);
int32_t function_1c4b(void);
int32_t function_1c7(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1c7f(void);
int32_t function_1cd0(void);
int32_t function_1cd8(void);
int32_t function_1ce8(void);
int32_t function_1d10(void);
int32_t function_1d2c(int32_t a1);
int32_t function_1d84(void);
int32_t function_1e75(void);
int32_t function_1e94(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1eb0(void);
int32_t function_1eb8(void);
int32_t function_1f2a(int32_t a1);
int32_t function_1f96(void);
int32_t function_1fa6(void);
int32_t function_2123(int32_t a1);
int32_t function_2163(int32_t a1);
int32_t function_22c(void);
int32_t function_22e3(int32_t a1);
int32_t function_2311(int32_t a1);
int32_t function_2361(int32_t a1);
int32_t function_23c0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_265(int16_t a1);
int32_t function_2698(int32_t a1);
int32_t function_26a1(void);
int32_t function_26a7(void);
int32_t function_2740(int32_t a1);
int32_t function_2749(void);
int32_t function_274f(void);
int32_t function_27b1(int32_t a1);
int32_t function_27d0(int32_t a1);
int32_t function_27d9(void);
int32_t function_27df(void);
int32_t function_2878(int32_t a1);
int32_t function_2887(void);
int32_t function_2a10(void);
int32_t function_2ab(void);
int32_t function_2ab0(void);
int32_t function_2b71(void);
int32_t function_2b89(void);
int32_t function_2b9c(void);
int32_t function_2bba(void);
int32_t function_2c3(void);
int32_t function_2c30c78(void);
int32_t function_2c84(void);
int32_t function_2ccc(int32_t a1);
int32_t function_2cf8(void);
int32_t function_2d41(int32_t a1);
int32_t function_2d88(void);
int32_t function_2dec(int32_t a1, int32_t a2);
int32_t function_2df(void);
int32_t function_2e08(void);
int32_t function_2e10(int32_t a1);
int32_t function_2e2b(void);
int32_t function_2e30(void);
int32_t function_2e8d(void);
int32_t function_2e97(void);
int32_t function_2ea8(void);
int32_t function_2f23(void);
int32_t function_2f41(int32_t a1);
int32_t function_2f48(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2f60(void);
int32_t function_2f9c(void);
int32_t function_3042(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_3078(int32_t a1, int32_t a2);
int32_t function_3090(void);
int32_t function_3150(int32_t result);
int32_t function_3183(void);
int32_t function_3260(void);
int32_t function_32a6(void);
int32_t function_32b8(void);
int32_t function_32d8(void);
int32_t function_332a(void);
int32_t function_3354(int32_t a1);
int32_t function_3369(int32_t a1);
int32_t function_3388(void);
int32_t function_33f1(void);
int32_t function_3421(char * a1);
int32_t function_3488(char * a1, int32_t a2);
int32_t function_3578(void);
int32_t function_35a0(void);
int32_t function_35c8(void);
int32_t function_3609(void);
int32_t function_3612(void);
int32_t function_3617(void);
int32_t function_3624(void);
int32_t function_3691(void);
int32_t function_36a3(void);
int32_t function_36e(void);
int32_t function_36e6(void);
int32_t function_387(void);
int32_t function_42444c7(void);
int32_t function_4c70(int32_t a1);
int32_t function_4da0(int32_t a1);
int32_t function_4ff(void);
int32_t function_57a(int32_t a1);
int32_t function_58e(void);
int32_t function_59f(void);
int32_t function_5c7(int32_t a1);
int32_t function_690(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_785(unsigned char a1);
int32_t function_7b8(void);
int32_t function_7ba(int32_t result, int32_t a2, int32_t a3);
int32_t function_7c5(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_7f3(void);
int32_t function_83c(void);
int32_t function_84(void);
int32_t function_89001c53(void);
int32_t function_899(void);
int32_t function_94(void);
int32_t function_95a(void);
int32_t function_964(void);
int32_t function_96a(void);
int32_t function_971(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_990(void);
int32_t function_9a0(void);
int32_t function_9c0(void);
int32_t function_9c2(void);
int32_t function_a14(int32_t a1);
int32_t function_aeb(void);
int32_t function_b26(void);
int32_t function_b6e8f889(void);
int32_t function_b72(void);
int32_t function_b87(void);
int32_t function_b90(int32_t a1);
int32_t function_bd0(void);
int32_t function_be5(void);
int32_t function_c085ffff(int32_t a1);
int32_t function_c7000000(void);
int32_t function_cb7(void);
int32_t function_cc2(void);
int32_t function_d8(void);
int32_t function_d80(void);
int32_t function_da(void);
int32_t function_da9(void);
int32_t function_dc7(void);
int32_t function_dd1(void);
int32_t function_dd4(void);
int32_t function_de7(void);
int32_t function_df8(void);
int32_t function_e10(void);
int32_t function_e1c(int32_t a1);
int32_t function_e27(void);
int32_t function_ea4(void);
int32_t function_f000af7(void);
int32_t function_f631f201(void);
int32_t function_f884178a(void);
int32_t function_f95(void);
int32_t function_fa0(void);
void SetSecretBytes(int32_t this, char * vch);
int32_t unknown_50a0(int32_t a1);
int32_t unknown_5300(int32_t a1);
int32_t unknown_6060(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // ecx
int32_t g5 = 0; // edi
int32_t g6 = 0; // edx
int32_t g7 = 0; // esi
int32_t g8 = 0x14a1;
int32_t g9 = 0x24448900;
char * g10 = "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xba\xae\xdc\xe6\xaf\x48\xa0\x3b\xbf\xd2\x5e\x8c\xd0\x36\x41\x40\x76\x6f\x69\x64\x20\x7b\x61\x6e\x6f\x6e\x79\x6d\x6f\x75\x73\x7d\x3a\x3a\x43\x45\x43\x4b\x65\x79\x3a\x3a\x47\x65\x74\x53\x65\x63\x72\x65\x74\x42\x79\x74\x65\x73\x28\x75\x6e\x73\x69\x67\x6e\x65\x64\x20\x63\x68\x61\x72\x2a\x29\x20\x63\x6f\x6e\x73\x74";
int32_t g13 = 0;
int32_t g15 = 0x2630;
int32_t g16 = 0;
int32_t g18 = 0x26d0;
int32_t g19 = 0x2390;
int32_t g20 = 0x65ff3154;
struct vtable_3a78_type g11 = {
    .e0 = _ZN5boost16thread_exceptionD1Ev,
    .e1 = _ZN5boost16thread_exceptionD0Ev,
    .e2 = _ZN12_GLOBAL__N_121EC_KEY_regenerate_keyEP9ec_key_stP9bignum_st_constprop_84
};
struct vtable_3a90_type g12 = {
    .e0 = _ZN5boost10lock_errorD1Ev,
    .e1 = _ZN5boost10lock_errorD0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv
};
struct vtable_3ac8_type g14 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv
};
struct vtable_3b08_type g17 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv
};

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x3
// From class:    N5boost16thread_exceptionE
// Type:          virtual member function
int32_t _ZN12_GLOBAL__N_121EC_KEY_regenerate_keyEP9ec_key_stP9bignum_st_constprop_84(void) {
    // 0x0
    return 0;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x10 - 0x11
// Line range:    411 - 93
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::clone() const
void _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t this) {
    // 0x10
    return;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x20 - 0x21
// Line range:    404 - 429
void _7e_clone_impl(int32_t this, int32_t __in_chrg) {
    // 0x20
    return;
}

// From module:   /parallelcoin/src/key.cpp
// Address range: 0x34 - 0x49
// Line range:    150 - 1245
void SetSecretBytes(int32_t this, char * vch) {
    // bb
    function_94();
    // branch -> 0x42
}

// From module:   /usr/include/boost/thread/locks.hpp
// Address range: 0x68 - 0x7b
// Line range:    399 - 53
void _7e_unique_lock(int32_t this, int32_t __in_chrg) {
    char v1 = *(char *)&g1; // bp+68
    int32_t v2 = 0; // eax
    *(char *)v2 = (char)v2 + v1;
    char v3 = *(char *)&g1;
    *(char *)v2 = (char)v2 + v3;
}

// Address range: 0x84 - 0x85
int32_t function_84(void) {
    // 0x84
    return g1;
}

// Address range: 0x94 - 0xb7
int32_t function_94(void) {
    int32_t result = g5;
    g1 = result;
    int32_t v1;
    if (v1 != 0x24448900) {
        // bb
        result = function_da();
        // branch -> 0xa3
    }
    // 0xa3
    return result;
}

// Address range: 0xd8 - 0xda
int32_t function_d8(void) {
    // 0xd8
    return function_84();
}

// Address range: 0xda - 0xdb
int32_t function_da(void) {
    // 0xda
    return g1;
}

// From module:   /parallelcoin/src/key.cpp
// Address range: 0xe0 - 0x12e
// Line range:    55 - 94
void ECDSA_SIG_recover_key_GFp(int32_t eckey, int32_t ecsig, char * msg, int32_t msglen, int32_t recid, int32_t check) {
    // 0xe0
    g5 = 0;
    // bb
    function_1c7(0, ecsig, 0);
    // branch -> 0x126
}

// Address range: 0x183 - 0x184
int32_t function_183(int32_t a1) {
    // 0x183
    return g1;
}

// Address range: 0x1c7 - 0x1ee
int32_t function_1c7(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = g5;
    g1 = result;
    if (a1 != 0x24448900) {
        // bb
        result = function_2c3();
        // branch -> 0x1da
    }
    // 0x1da
    return result;
}

// Address range: 0x22c - 0x242
int32_t function_22c(void) {
    // 0x22c
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + 0x311775c0);
    *v2 = *v2 + 1;
    return function_183(0);
}

// Address range: 0x265 - 0x266
int32_t function_265(int16_t a1) {
    // 0x265
    return 0;
}

// Address range: 0x2ab - 0x2c3
int32_t function_2ab(void) {
    // 0x2ab
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + 0x311878c0);
    *v2 = *v2 + 1;
    return function_183(0);
}

// Address range: 0x2c3 - 0x2c4
int32_t function_2c3(void) {
    // 0x2c3
    return g1;
}

// Address range: 0x2df - 0x2e6
int32_t function_2df(void) {
    // 0x2df
    return 0;
}

// Address range: 0x36e - 0x387
int32_t function_36e(void) {
    int32_t * v1 = (int32_t *)-0x7ad3dbb4;
    *v1 = *v1 - 1;
    unsigned char v2 = *(char *)&g5; // bp+374
    *(char *)0 = v2 / 32 | 8 * v2;
    int32_t v3 = g1; // bp+377
    *(char *)v3 = 2 * (char)v3;
    int32_t * v4;
    return function_183((int32_t)&v4);
}

// Address range: 0x387 - 0x388
int32_t function_387(void) {
    // 0x387
    return g1;
}

// Address range: 0x4ff - 0x508
int32_t function_4ff(void) {
    int32_t * v1 = (int32_t *)-0x76efdb8c;
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x57a - 0x58e
int32_t function_57a(int32_t a1) {
    // 0x57a
    int32_t * v1;
    return function_183((int32_t)&v1);
}

// Address range: 0x58e - 0x59f
int32_t function_58e(void) {
    // 0x58e
    return function_183(0);
}

// Address range: 0x59f - 0x5b3
int32_t function_59f(void) {
    // 0x59f
    return function_183(0);
}

// Address range: 0x5c7 - 0x5dc
int32_t function_5c7(int32_t a1) {
    // 0x5c7
    if (g1 != 0) {
        // bb
        g1 = function_387();
        // branch -> 0x5d3
    }
    // 0x5d3
    int32_t * v1;
    return function_183((int32_t)&v1);
}

// From module:   /parallelcoin/src/key.h
// Address range: 0x5e0 - 0x64c
// Line range:    261 - 283
// Demangled:     CKey::Check(unsigned char const *)
void _ZN4CKey5CheckEPKh(char * vch) {
    int32_t v1 = (int32_t)vch;
    int32_t v2 = g6;
    int32_t v3 = 0;
    // branch -> 0x5f3
    while (true) {
        char v4 = *(char *)(v3 + v1);
        if (v3 == 31) {
            // 0x602
            if (v4 == 0) {
                // 0x608
                return;
            }
            int32_t v5 = 0; // bp+634
            // branch -> 0x626
            while (true) {
                unsigned char v6 = *(char *)(v5 + (int32_t)&g10); // bp+626
                unsigned char v7 = *(char *)(v5 + v1);
                if (v7 < v6 || v7 != v6) {
                    // 0x63c
                    // branch -> 0x608
                    // 0x608
                    return;
                }
              lab_0x632:
                // 0x634
                if (v5 == 31) {
                    // break -> 0x63c
                    break;
                }
                v5++;
                // continue -> 0x626
                continue;
            }
            // 0x63c
            // branch -> 0x608
            // 0x608
            return;
        }
        // 0x620
        if (v4 != 0) {
            // break -> 0x624
            break;
        }
        v2 = (int32_t)(v4 == 0) | v2 & -256;
        v3++;
        // continue -> 0x5f3
    }
}

// From module:   /parallelcoin/src/key.h
// Address range: 0x660 - 0x68b
// Line range:    285 - 291
// Demangled:     CKey::MakeNewKey(bool)
void _ZN4CKey10MakeNewKeyEb(int32_t this, bool fCompressedIn) {
    // 0x660
    return;
}

// Address range: 0x690 - 0x6b8
int32_t function_690(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x690
    _ZN4CKey5CheckEPKh((char *)0);
    int32_t v1 = 0; // esi
    *(char *)(v1 + 1) = (char)0;
    int32_t result = a1 ^ 0x24448900;
    *(char *)v1 = 1;
    if (result != 0) {
        // 0x6b8
        return result;
    }
    // 0x6b1
    return result;
}

// From module:   /parallelcoin/src/key.h
// Address range: 0x6c0 - 0x6f8
// Line range:    293 - 138
// Demangled:     CKey::SetPrivKey(std::vector<unsigned char, secure_allocator<unsigned char> > const &, bool)
void _ZN4CKey10SetPrivKeyERKSt6vectorIh16secure_allocatorIhEEb(int32_t this, int32_t privkey, bool fCompressedIn) {
    // 0x6c0
    return;
}

// Address range: 0x785 - 0x7b2
int32_t function_785(unsigned char a1) {
    // 0x785
    if (0 != g1) {
        // bb
        function_7f3();
        // branch -> 0x789
    }
    int32_t v1 = 0; // ebx
    *(char *)v1 = 1;
    *(char *)(v1 + 1) = (char)(int32_t)a1;
    return function_7ba(v1 + 2, 0, 0);
}

// Address range: 0x7b8 - 0x7ba
int32_t function_7b8(void) {
    // 0x7b8
    return 0;
}

// Address range: 0x7ba - 0x7c1
int32_t function_7ba(int32_t result, int32_t a2, int32_t a3) {
    // 0x7ba
    return result;
}

// Address range: 0x7c5 - 0x7e9
int32_t function_7c5(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x24548bd8;
    *v1 = *v1 - 1;
    int32_t v2 = 0;
    // 0x7e9
    // 0x7d5
    return (v2 + 155) % 256 | v2 & -256;
}

// Address range: 0x7f3 - 0x812
int32_t function_7f3(void) {
    // 0x7f3
    return g1;
}

// Address range: 0x83c - 0x83d
int32_t function_83c(void) {
    // 0x83c
    return 0;
}

// From module:   /parallelcoin/src/key.h
// Address range: 0x860 - 0x891
// Line range:    312 - 138
// Demangled:     CKey::GetPubKey() const
void _ZNK4CKey9GetPubKeyEv(int32_t this) {
    // 0x860
    g1 = 0;
    char * v1;
    if (*v1 == 0) {
        // bb
        function_a14(0x24448900);
        // branch -> 0x88a
    }
}

// Address range: 0x899 - 0x89a
int32_t function_899(void) {
    // 0x899
    return 0;
}

// Address range: 0x95a - 0x95b
int32_t function_95a(void) {
    // 0x95a
    return g1;
}

// Address range: 0x964 - 0x965
int32_t function_964(void) {
    // 0x964
    return g1;
}

// Address range: 0x96a - 0x96b
int32_t function_96a(void) {
    // 0x96a
    return g1;
}

// Address range: 0x971 - 0x98b
int32_t function_971(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x24548be8; // bp+971
    *v1 = *v1 - 1;
    int32_t v2 = 0; // edx
    *(char *)0 = __asm_insb((int16_t)v2);
    int32_t result; // bp+988
    if ((v2 ^ 0x24448900) != 0) {
        // bb
        result = function_9c2();
        // branch -> 0x981
    } else {
        // 0x971
        result = g1;
        // branch -> 0x981
    }
    // 0x981
    return result;
}

// Address range: 0x990 - 0x99a
int32_t function_990(void) {
    int32_t v1 = g1; // bp+990
    int32_t v2 = v1; // bp+994
    if ((char)v1 == 4) {
        int32_t v3 = function_95a(); // bp+992
        g1 = v3;
        v2 = v3;
        // branch -> 0x994
    }
    // 0x994
    if ((char)v2 != 7) {
        // bb97
        g1 = function_96a();
        // branch -> 0x998
    }
    // 0x998
    return function_95a();
}

// Address range: 0x9a0 - 0x9ac
int32_t function_9a0(void) {
    // 0x9a0
    g1 = 33;
    return function_964();
}

// Address range: 0x9c0 - 0x9c2
int32_t function_9c0(void) {
    // 0x9c0
    return function_96a();
}

// Address range: 0x9c2 - 0x9c3
int32_t function_9c2(void) {
    // 0x9c2
    return g1;
}

// Address range: 0xa14 - 0xa33
int32_t function_a14(int32_t a1) {
    // 0xa14
    return g1;
}

// From module:   /parallelcoin/src/key.h
// Address range: 0xaa0 - 0xae5
// Line range:    343 - 138
// Demangled:     CPubKey::Verify(uint256 const &, std::vector<unsigned char, std::allocator<unsigned char> > const &) const
void _ZNK7CPubKey6VerifyERK7uint256RKSt6vectorIhSaIhEE(int32_t this, int32_t hash, int32_t vchSig) {
    char v1 = *(char *)this;
    if ((v1 - 2 || 1) == 1) {
        // 0xade
        return;
    }
    // 0xad5
    if (v1 != 6) {
        // bb
        function_b90(0x24448900);
        // branch -> 0xade
    }
}

// Address range: 0xaeb - 0xaf7
int32_t function_aeb(void) {
    char * v1 = (char *)0xf242444;
    unsigned char v2 = *v1;
    *v1 = v2 / 16 | 16 * v2;
    return function_f000af7();
}

// Address range: 0xb26 - 0xb27
int32_t function_b26(void) {
    // 0xb26
    return g1;
}

// Address range: 0xb72 - 0xb7b
int32_t function_b72(void) {
    int32_t * v1 = (int32_t *)-0x6bf0fe08;
    *v1 = *v1 + 1;
    return 0;
}

// Address range: 0xb87 - 0xb89
int32_t function_b87(void) {
    // 0xb87
    return 0;
}

// Address range: 0xb90 - 0xbc9
int32_t function_b90(int32_t a1) {
    // 0xb90
    if (a1 != 0x24448900) {
        // 0xbda
    }
    // 0xbb5
    return 0;
}

// Address range: 0xbd0 - 0xbda
int32_t function_bd0(void) {
    // 0xbd0
    return function_b26();
}

// Address range: 0xbe5 - 0xbe6
int32_t function_be5(void) {
    // 0xbe5
    return 0;
}

// From module:   /parallelcoin/src/key.h
// Address range: 0xc00 - 0xc8b
// Line range:    354 - 359
// Demangled:     CPubKey::RecoverCompact(uint256 const &, std::vector<unsigned char, std::allocator<unsigned char> > const &)
void _ZN7CPubKey14RecoverCompactERK7uint256RKSt6vectorIhSaIhEE(int32_t this, int32_t hash, int32_t vchSig) {
    // 0xc00
    if (*(int32_t *)(vchSig + 4) - *(int32_t *)vchSig == 65) {
        // 0xc80
        return;
    }
}

// Address range: 0xcb7 - 0xcb8
int32_t function_cb7(void) {
    // 0xcb7
    return g1;
}

// Address range: 0xcc2 - 0xcca
int32_t function_cc2(void) {
    // 0xcc2
    int32_t v1;
    *(int32_t *)v1 = v1 - 1;
    return 0;
}

// Address range: 0xd80 - 0xd81
int32_t function_d80(void) {
    // 0xd80
    return 0;
}

// Address range: 0xda9 - 0xdaa
int32_t function_da9(void) {
    // 0xda9
    return 0;
}

// Address range: 0xdc7 - 0xdc8
int32_t function_dc7(void) {
    // 0xdc7
    return g1;
}

// Address range: 0xdd1 - 0xdd2
int32_t function_dd1(void) {
    // 0xdd1
    return g1;
}

// Address range: 0xdd4 - 0xdd5
int32_t function_dd4(void) {
    // 0xdd4
    return 0;
}

// Address range: 0xde7 - 0xdf1
int32_t function_de7(void) {
    // 0xde7
    return function_cb7();
}

// Address range: 0xdf8 - 0xe0f
int32_t function_df8(void) {
    int32_t v1 = g1;
    int32_t v2 = v1;
    if ((char)v1 == 4) {
        int32_t v3 = function_dc7();
        g1 = v3;
        v2 = v3;
        // branch -> 0xdfc
    }
    // 0xdfc
    if ((char)v2 == 7) {
        // bb97
        g1 = function_dc7();
        // branch -> 0xe02
    }
    // 0xe02
    *(char *)0 = -1;
    return function_cb7();
}

// Address range: 0xe10 - 0xe1c
int32_t function_e10(void) {
    // 0xe10
    g1 = 33;
    return function_dd1();
}

// Address range: 0xe1c - 0xe1d
int32_t function_e1c(int32_t a1) {
    // 0xe1c
    return g1;
}

// Address range: 0xe27 - 0xe28
int32_t function_e27(void) {
    // 0xe27
    return 0;
}

// Address range: 0xea4 - 0xeab
int32_t function_ea4(void) {
    // 0xea4
    return function_cb7();
}

// From module:   /parallelcoin/src/key.h
// Address range: 0xeb0 - 0xf6b
// Line range:    364 - 138
// Demangled:     CPubKey::VerifyCompact(uint256 const &, std::vector<unsigned char, std::allocator<unsigned char> > const &) const
void _ZNK7CPubKey13VerifyCompactERK7uint256RKSt6vectorIhSaIhEE(int32_t this, int32_t hash, int32_t vchSig) {
    char v1 = *(char *)this;
    if ((v1 - 2 || 1) != 1) {
        // 0xf01
        if (v1 != 6) {
            // 0xf50
            if (v1 != 4) {
                // 0xf54
                if (v1 != 7) {
                    // 0xf12
                    return;
                }
            }
            // 0xf05
            if (*(int32_t *)(vchSig + 4) - *(int32_t *)vchSig == 65) {
                // 0xf60
                return;
            }
            // 0xf12
            return;
        }
    }
    // 0xf05
    if (*(int32_t *)(vchSig + 4) - *(int32_t *)vchSig == 65) {
        // 0xf60
        return;
    }
}

// Address range: 0xf95 - 0xf96
int32_t function_f95(void) {
    // 0xf95
    return g1;
}

// Address range: 0xfa0 - 0xfab
int32_t function_fa0(void) {
    // 0xfa0
    int32_t v1;
    *(int32_t *)v1 = v1 - 1;
    return 0;
}

// Address range: 0x10b6 - 0x10b7
int32_t function_10b6(void) {
    // 0x10b6
    return g1;
}

// Address range: 0x10e2 - 0x10e3
int32_t function_10e2(void) {
    // 0x10e2
    return g1;
}

// Address range: 0x10f5 - 0x1100
int32_t function_10f5(void) {
    // 0x10f5
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x3d6bf040); // 0x10f5
    *v2 = *v2 + 1;
    return function_f95();
}

// Address range: 0x110a - 0x110b
int32_t function_110a(void) {
    // 0x110a
    return g1;
}

// Address range: 0x1128 - 0x1130
int32_t function_1128(void) {
    // 0x1128
    int32_t v1;
    *(int32_t *)v1 = v1 - 1;
    g1 = 0;
    return function_10b6();
}

// Address range: 0x1130 - 0x113c
int32_t function_1130(void) {
    // 0x1130
    return function_110a();
}

// Address range: 0x113c - 0x1143
int32_t function_113c(void) {
    // 0x113c
    g1 = 33;
    return function_10e2();
}

// Address range: 0x1143 - 0x1144
int32_t function_1143(void) {
    // 0x1143
    return g1;
}

// Address range: 0x11b9 - 0x11c0
int32_t function_11b9(void) {
    // 0x11b9
    return function_f95();
}

// Address range: 0x11c1 - 0x11c2
int32_t function_11c1(void) {
    // 0x11c1
    return 0;
}

// From module:   /parallelcoin/src/key.h
// Address range: 0x11e0 - 0x120a
// Line range:    379 - 138
// Demangled:     CPubKey::IsFullyValid() const
void _ZNK7CPubKey12IsFullyValidEv(int32_t this) {
    char v1 = *(char *)this; // 0x11f4
    if ((v1 - 2 || 1) == 1) {
        // 0x1203
        return;
    }
    // 0x11fe
    if (v1 != 6) {
        // bb
        function_1278(0x24448900);
        // branch -> 0x1203
    }
}

// Address range: 0x1243 - 0x1244
int32_t function_1243(void) {
    // 0x1243
    return g1;
}

// Address range: 0x126f - 0x1277
int32_t function_126f(void) {
    // 0x126f
    int32_t v1;
    *(int32_t *)v1 = v1 - 1;
    return 0;
}

// Address range: 0x1278 - 0x129a
int32_t function_1278(int32_t a1) {
    // 0x1278
    if (a1 != 0x24448900) {
        // 0x12a7
    }
    // 0x1295
    return 0;
}

// Address range: 0x12a0 - 0x12a7
int32_t function_12a0(void) {
    // 0x12a0
    return function_1243();
}

// Address range: 0x12b2 - 0x12b3
int32_t function_12b2(void) {
    // 0x12b2
    return 0;
}

// From module:   /parallelcoin/src/key.h
// Address range: 0x12d0 - 0x1310
// Line range:    388 - 138
// Demangled:     CPubKey::Decompress()
void _ZN7CPubKey10DecompressEv(int32_t this) {
    char v1 = *(char *)this; // 0x12ea
    if ((v1 - 2 || 1) == 1) {
        // 0x1309
        return;
    }
    // 0x1300
    if (v1 != 6) {
        // bb
        function_1418(0x24448900);
        // branch -> 0x1309
    }
}

// Address range: 0x1351 - 0x1352
int32_t function_1351(void) {
    // 0x1351
    return g1;
}

// Address range: 0x13ed - 0x13ee
int32_t function_13ed(void) {
    // 0x13ed
    return g1;
}

// Address range: 0x13f7 - 0x13f8
int32_t function_13f7(void) {
    // 0x13f7
    return g1;
}

// Address range: 0x13fd - 0x13fe
int32_t function_13fd(void) {
    // 0x13fd
    return g1;
}

// Address range: 0x1405 - 0x1406
int32_t function_1405(void) {
    // 0x1405
    return g1;
}

// Address range: 0x1411 - 0x1413
int32_t function_1411(void) {
    // 0x1411
    return 0;
}

// Address range: 0x1418 - 0x144f
int32_t function_1418(int32_t a1) {
    // 0x1418
    g1 = 0;
    int32_t result = 0; // 0x144e
    if (a1 != 0x24448900) {
        // bb
        result = function_1497();
        // branch -> 0x143b
    }
    // 0x143b
    return result;
}

// Address range: 0x1450 - 0x145a
int32_t function_1450(void) {
    // 0x1450
    return function_1351();
}

// Address range: 0x1460 - 0x1469
int32_t function_1460(void) {
    // 0x1460
    if ((char)g1 != 7) {
        // bb
        g1 = function_13fd();
        // branch -> 0x1464
    }
    // 0x1464
    return function_13ed();
}

// Address range: 0x147e - 0x1483
int32_t function_147e(void) {
    // 0x147e
    return function_1405();
}

// Address range: 0x1488 - 0x1497
int32_t function_1488(void) {
    // 0x1488
    g1 = 33;
    return function_13f7();
}

// Address range: 0x1497 - 0x1498
int32_t function_1497(void) {
    // 0x1497
    return g1;
}

// Address range: 0x150e - 0x150f
int32_t function_150e(void) {
    // 0x150e
    return 0;
}

// From module:   /parallelcoin/src/key.h
// Address range: 0x1530 - 0x159f
// Line range:    329 - 138
// Demangled:     CKey::SignCompact(uint256 const &, std::vector<unsigned char, std::allocator<unsigned char> > &) const
void _ZNK4CKey11SignCompactERK7uint256RSt6vectorIhSaIhEE(int32_t this, int32_t hash, int32_t vchSig) {
    // 0x1530
    if (*(char *)this != 0) {
        // 0x1598
        return;
    }
}

// Address range: 0x15e6 - 0x15ee
int32_t function_15e6(void) {
    // 0x15e6
    return function_c085ffff((int32_t)0);
}

// Address range: 0x1624 - 0x1625
int32_t function_1624(void) {
    // 0x1624
    return g1;
}

// Address range: 0x1653 - 0x1676
int32_t function_1653(void) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 + 0x244489c7); // 0x1653
    *v2 = *v2 + v1;
    int32_t v3 = 0; // 0x1659
    int32_t v4 = *(int32_t *)v3 + v3; // eax
    *(int32_t *)0 = 0xf000000;
    g1 = *(int32_t *)v4 + v4;
    char * v5 = (char *)(v1 - 0x3e3fce2f); // 0x166b
    *v5 = *v5 + (char)v1;
    return function_2c30c78();
}

// Address range: 0x1687 - 0x1688
int32_t function_1687(void) {
    // 0x1687
    return g1;
}

// Address range: 0x16ee - 0x16ef
int32_t function_16ee(void) {
    // 0x16ee
    return 0;
}

// Address range: 0x1705 - 0x1706
int32_t function_1705(int16_t a1) {
    // 0x1705
    return 0;
}

// Address range: 0x171e - 0x171f
int32_t function_171e(void) {
    // 0x171e
    return 0;
}

// Address range: 0x172f - 0x1730
int32_t function_172f(int16_t a1) {
    // 0x172f
    return 0;
}

// Address range: 0x1747 - 0x1748
int32_t function_1747(void) {
    // 0x1747
    return g1;
}

// Address range: 0x1751 - 0x1752
int32_t function_1751(void) {
    // 0x1751
    return g1;
}

// Address range: 0x1754 - 0x1763
int32_t function_1754(int16_t a1) {
    int32_t v1 = 0; // 0x1756
    int32_t v2 = 2 * v1 & 254 | v1 & -256; // eax
    *(char *)0 = (char)0 + *(char *)&g4;
    return v2 + 36 & 255 | v2 & -256;
}

// Address range: 0x176f - 0x177f
int32_t function_176f(void) {
    // 0x176f
    g1 = 0;
    char * v1 = (char *)-0x76e3dbb4; // 0x1772
    *v1 = (char)0 + *v1;
    return function_42444c7();
}

// Address range: 0x1780 - 0x178b
int32_t function_1780(void) {
    int32_t v1 = 0; // ecx
    char * v2 = (char *)(v1 + 0x57e8241c); // 0x1780
    *v2 = *v2 + (char)v1;
    return function_f884178a();
}

// Address range: 0x1792 - 0x1793
int32_t function_1792(void) {
    // 0x1792
    return g1;
}

// Address range: 0x1799 - 0x17b5
int32_t function_1799(void) {
    int32_t * v1 = (int32_t *)-0x47cfe3d; // 0x1799
    *v1 = *v1 + 1;
    int32_t v2 = 0; // eax
    g1 = v2 + 5 & 8 | v2 & -256;
    return function_c7000000();
}

// Address range: 0x17c5 - 0x17c8
int32_t function_17c5(void) {
    // 0x17c5
    return 0;
}

// Address range: 0x17cf - 0x17d0
int32_t function_17cf(void) {
    // 0x17cf
    return g1;
}

// Address range: 0x180a - 0x180b
int32_t function_180a(void) {
    // 0x180a
    return g1;
}

// Address range: 0x1816 - 0x181b
int32_t function_1816(void) {
    // 0x1816
    return 0;
}

// Address range: 0x1820 - 0x1828
int32_t function_1820(void) {
    // 0x1820
    *(char *)g5 = 0;
    return function_1687();
}

// Address range: 0x1828 - 0x183b
int32_t function_1828(void) {
    // 0x1828
    int32_t v1;
    *(int16_t *)v1 = 0;
    g5 = 2;
    // bb
    g1 = function_1687();
    // branch -> 0x1839
    // 0x1839
    return function_1820();
}

// Address range: 0x18b6 - 0x18b7
int32_t function_18b6(int16_t a1) {
    // 0x18b6
    return 0;
}

// Address range: 0x18cf - 0x18d0
int32_t function_18cf(void) {
    // 0x18cf
    return g1;
}

// Address range: 0x18d9 - 0x18da
int32_t function_18d9(void) {
    // 0x18d9
    return g1;
}

// Address range: 0x18f2 - 0x18f3
int32_t function_18f2(void) {
    // 0x18f2
    return g1;
}

// Address range: 0x1920 - 0x1921
int32_t function_1920(void) {
    // 0x1920
    return g1;
}

// Address range: 0x192f - 0x1937
int32_t function_192f(void) {
    int32_t v1 = 0; // 0x192f
    unsigned char v2 = *(char *)&g7; // 0x1931
    *(char *)0 = v2 / 8 | 32 * v2;
    return v1 + 125 & 255 | v1 & -256;
}

// Address range: 0x1937 - 0x193b
int32_t function_1937(void) {
    // 0x1937
    return 0;
}

// Address range: 0x1958 - 0x1964
int32_t function_1958(void) {
    char * v1 = (char *)-0x7cd7dbac; // 0x1958
    *v1 = *v1 - (char)0;
    unsigned char v2 = *(char *)&g7; // 0x195e
    *(char *)0 = v2 / 8 | 32 * v2;
    return 0;
}

// Address range: 0x1964 - 0x1968
int32_t function_1964(void) {
    // 0x1964
    return 0;
}

// Address range: 0x1982 - 0x198c
int32_t function_1982(void) {
    // 0x1982
    return function_17cf();
}

// Address range: 0x1990 - 0x1997
int32_t function_1990(void) {
    // 0x1990
    return function_180a();
}

// Address range: 0x1998 - 0x19c6
int32_t function_1998(int32_t * a1) {
    // 0x1998
    int32_t v1; // bp+68
    _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(a1, 0, 65, (int32_t)&v1);
    g1 = (int32_t)a1;
    return function_1624();
}

// Address range: 0x19c8 - 0x19df
int32_t function_19c8(void) {
    int32_t v1 = 0; // edx
    if ((char)v1 == 4) {
        // bb
        g1 = function_18cf();
        // branch -> 0x19d1
    }
    // 0x19d1
    if ((char)v1 != 7) {
        // bb97
        g1 = function_18f2();
        // branch -> 0x19da
    }
    // 0x19da
    return function_18cf();
}

// Address range: 0x19e0 - 0x19fb
int32_t function_19e0(void) {
    // 0x19e0
    if ((char)g1 == 4) {
        // bb
        g1 = function_1747();
        // branch -> 0x19e8
    }
    // 0x19e8
    return function_1747();
}

// Address range: 0x1a12 - 0x1a1f
int32_t function_1a12(unsigned char a1) {
    // 0x1a12
    g1 = a1;
    return function_18f2();
}

// Address range: 0x1a33 - 0x1a38
int32_t function_1a33(void) {
    // 0x1a33
    return 0;
}

// Address range: 0x1a38 - 0x1a47
int32_t function_1a38(void) {
    // 0x1a38
    return function_18d9();
}

// Address range: 0x1a48 - 0x1a57
int32_t function_1a48(void) {
    // 0x1a48
    g1 = 33;
    return function_1751();
}

// Address range: 0x1a58 - 0x1a66
int32_t function_1a58(void) {
    // 0x1a58
    *(char *)1 = 0;
    return 0;
}

// Address range: 0x1a68 - 0x1a78
int32_t function_1a68(void) {
    // 0x1a68
    int32_t v1;
    *(int16_t *)v1 = 0;
    return 0;
}

// Address range: 0x1a7d - 0x1a7e
int32_t function_1a7d(void) {
    // 0x1a7d
    return g1;
}

// Address range: 0x1a98 - 0x1aa5
int32_t function_1a98(void) {
    // 0x1a98
    if (g1 != 0) {
        // bb
        g1 = function_1792();
        // branch -> 0x1aa0
    }
    // 0x1aa0
    return function_1920();
}

// Address range: 0x1aa5 - 0x1aac
int32_t function_1aa5(void) {
    // 0x1aa5
    g1 = 33;
    return function_1a7d();
}

// Address range: 0x1aac - 0x1ab0
int32_t function_1aac(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1aac
    return g1;
}

// Address range: 0x1b74 - 0x1b75
int32_t function_1b74(void) {
    // 0x1b74
    return 0;
}

// Address range: 0x1b75 - 0x1b76
int32_t function_1b75(void) {
    // 0x1b75
    return g1;
}

// Address range: 0x1b8a - 0x1b8b
int32_t function_1b8a(void) {
    // 0x1b8a
    return 0;
}

// Address range: 0x1b93 - 0x1b95
int32_t function_1b93(void) {
    // 0x1b93
    return function_1b75();
}

// From module:   /parallelcoin/src/key.h
// Address range: 0x1ba0 - 0x1c07
// Line range:    321 - 138
// Demangled:     CKey::Sign(uint256 const &, std::vector<unsigned char, std::allocator<unsigned char> > &) const
void _ZNK4CKey4SignERK7uint256RSt6vectorIhSaIhEE(int32_t this, int32_t hash, int32_t vchSig) {
    // 0x1ba0
    if (*(char *)this != 0) {
        // 0x1c00
        return;
    }
}

// Address range: 0x1c42 - 0x1c49
int32_t function_1c42(void) {
    // 0x1c42
    return function_b6e8f889();
}

// Address range: 0x1c4b - 0x1c53
int32_t function_1c4b(void) {
    unsigned char v1 = *(char *)&g5; // 0x1c4b
    *(char *)0 = v1 / 16 | 16 * v1;
    return function_89001c53();
}

// Address range: 0x1c7f - 0x1c80
int32_t function_1c7f(void) {
    // 0x1c7f
    return g1;
}

// Address range: 0x1cd0 - 0x1cd1
int32_t function_1cd0(void) {
    // 0x1cd0
    return g1;
}

// Address range: 0x1cd8 - 0x1ce2
int32_t function_1cd8(void) {
    // 0x1cd8
    return 1;
}

// Address range: 0x1ce8 - 0x1d09
int32_t function_1ce8(void) {
    // 0x1ce8
    int32_t v1; // bp+75
    int32_t v2 = _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh((int32_t *)0, 0, 0, (int32_t)&v1); // 0x1cfd
    g1 = v2;
    return function_1c7f();
}

// Address range: 0x1d10 - 0x1d2c
int32_t function_1d10(void) {
    // 0x1d10
    int32_t v1; // bp+75
    int32_t v2 = _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh((int32_t *)0, 0, 0, (int32_t)&v1); // 0x1d25
    g1 = v2;
    return function_1cd0();
}

// Address range: 0x1d2c - 0x1d2d
int32_t function_1d2c(int32_t a1) {
    // 0x1d2c
    return g1;
}

// Address range: 0x1d84 - 0x1d85
int32_t function_1d84(void) {
    // 0x1d84
    return 0;
}

// From module:   /parallelcoin/src/key.h
// Address range: 0x1da0 - 0x1dcc
// Line range:    303 - 138
// Demangled:     CKey::GetPrivKey() const
void _ZNK4CKey10GetPrivKeyEv(int32_t this) {
    // 0x1da0
    g1 = 0;
    char * v1;
    if (*v1 == 0) {
        // bb
        function_1f2a(0x24448900);
        // branch -> 0x1dc5
    }
}

// Address range: 0x1e75 - 0x1e76
int32_t function_1e75(void) {
    // 0x1e75
    return g1;
}

// Address range: 0x1e94 - 0x1eae
int32_t function_1e94(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x24548bd8; // 0x1e94
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x1e9a
    // 0x1ed8
    // 0x1ea4
    return (v2 + 155) % 256 | v2 & -256;
}

// Address range: 0x1eb0 - 0x1eb8
int32_t function_1eb0(void) {
    // 0x1eb0
    int32_t v1;
    *(int32_t *)4 = v1 + g1;
    return function_1e75();
}

// Address range: 0x1eb8 - 0x1ed8
int32_t function_1eb8(void) {
    // 0x1eb8
    int32_t v1; // bp+43
    _ZNSt6vectorIh16secure_allocatorIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS2_EEjRKh((int32_t *)0, 0, 0, (int32_t)&v1);
    g1 = g3;
    return function_1e75();
}

// Address range: 0x1f2a - 0x1f49
int32_t function_1f2a(int32_t a1) {
    // 0x1f2a
    return g1;
}

// Address range: 0x1f96 - 0x1f97
int32_t function_1f96(void) {
    // 0x1f96
    return g1;
}

// Address range: 0x1fa6 - 0x1faa
int32_t function_1fa6(void) {
    // 0x1fa6
    return function_1f96();
}

// Address range: 0x1fb0 - 0x1fdf
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1) {
    // 0x1fb0
    *a1 = (int32_t)&g16;
    return 0;
}

// Address range: 0x20c0 - 0x20e5
// From class:    N5boost10lock_errorE
// Type:          virtual member function
// Demangled:     boost::lock_error::what() const
int32_t _ZNK5boost10lock_error4whatEv(void) {
    // 0x20c0
    return (int32_t)"boost::lock_error";
}

// Address range: 0x20f0 - 0x211e
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1) {
    // 0x20f0
    *a1 = (int32_t)&g16;
    return (int32_t)a1;
}

// Address range: 0x2123 - 0x2124
int32_t function_2123(int32_t a1) {
    // 0x2123
    return g1;
}

// Address range: 0x2130 - 0x215e
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_exception::~thread_exception()
int32_t _ZN5boost16thread_exceptionD1Ev(int32_t * a1) {
    // 0x2130
    *a1 = (int32_t)&g11;
    return (int32_t)a1;
}

// Address range: 0x2163 - 0x2168
int32_t function_2163(int32_t a1) {
    // 0x2163
    return g1;
}

// Address range: 0x2168 - 0x2196
int32_t _ZN12_GLOBAL__N_16CECKeyC2Ev_part_0(void) {
    // 0x2168
    return 0;
}

// Address range: 0x219c - 0x21ca
int32_t _ZN12_GLOBAL__N_16CECKey14SetSecretBytesEPKh_part_2(void) {
    // 0x219c
    return 0;
}

// Address range: 0x21d0 - 0x21fe
int32_t _ZN5boost11unique_lockINS_5mutexEED2Ev_part_33(void) {
    // 0x21d0
    return 0;
}

// Address range: 0x22b0 - 0x22de
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::lock_error::~lock_error()
int32_t _ZN5boost10lock_errorD1Ev(int32_t * a1) {
    // 0x22b0
    *a1 = (int32_t)&g11;
    return (int32_t)a1;
}

// Address range: 0x22e3 - 0x22e8
int32_t function_22e3(int32_t a1) {
    // 0x22e3
    return g1;
}

// Address range: 0x22f0 - 0x230d
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_exception::~thread_exception()
int32_t _ZN5boost16thread_exceptionD0Ev(int32_t * a1) {
    // 0x22f0
    *a1 = (int32_t)&g11;
    return 0;
}

// Address range: 0x2311 - 0x232c
int32_t function_2311(int32_t a1) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x2311
    *v1 = *v1 - 1;
    int32_t result = 0x24448900; // 0x2317
    if (result == 0) {
        // 0x231f
        // branch -> 0x232c
    }
    // 0x232c
    return result;
}

// Address range: 0x2340 - 0x235d
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::lock_error::~lock_error()
int32_t _ZN5boost10lock_errorD0Ev(int32_t * a1) {
    // 0x2340
    *a1 = (int32_t)&g11;
    return 0;
}

// Address range: 0x2361 - 0x2381
int32_t function_2361(int32_t a1) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x2361
    *v1 = *v1 - 1;
    int32_t result = 0x24448900; // 0x2367
    if (result == 0) {
        // 0x236f
        // branch -> 0x237c
    }
    // 0x237c
    return result;
}

// Address range: 0x2390 - 0x2397
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1) {
    // 0x2390
    return _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2(a1 - 28);
}

// Address range: 0x23a0 - 0x23bc
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          virtual member function
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2(int32_t a1) {
    // 0x23a0
    return 0;
}

// Address range: 0x23c0 - 0x2424
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_23c0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x4468bc3; // 0x23c0
    *v1 = *v1 - 1;
    int32_t v2 = 0; // ebx
    *(int32_t *)v2 = (int32_t)&g12;
    *(int32_t *)(v2 + 8) = (int32_t)&g13;
    *(int32_t *)(v2 + 4) = 0;
    int32_t v3 = 0; // esi
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g20); // 0x23d6
    *(int32_t *)(v2 + (int32_t)&g20) = v4;
    if (v4 != 0) {
        // 0x23e0
        // branch -> 0x23e8
    }
    int32_t v5 = *(int32_t *)(v3 + (int32_t)&g8); // 0x23e8
    *(int32_t *)(v2 + 8) = (int32_t)&g18;
    *(int32_t *)(v2 + (int32_t)&g8) = v5;
    int32_t v6 = *(int32_t *)(v3 + (int32_t)&g9); // 0x2400
    *(int32_t *)(v2 + (int32_t)&g9) = v6;
    *(int32_t *)v2 = (int32_t)&g17;
    *(int32_t *)(v2 + 28) = (int32_t)&g19;
    *(int32_t *)(v2 + 24) = *(int32_t *)(v3 + 24);
    int32_t result = v2 + 28; // 0x2419
    if (a1 != 0x24448900) {
        // 0x2424
        return result;
    }
    // 0x241e
    return result;
}

// Address range: 0x2630 - 0x263a
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t a1) {
    // 0x2630
    return function_4c70(a1 - 8);
}

// Address range: 0x2640 - 0x268f
// From class:    N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g3 = v1;
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g20); // 0x2654
    g1 = v2;
    *a1 = (int32_t)&g14;
    *(int32_t *)(g3 + 8) = (int32_t)&g13;
    if (v2 == 0) {
        // 0x2674
        *(int32_t *)g3 = (int32_t)&g11;
        return 0;
    }
    // 0x2668
    if ((char)v2 != 0) {
        // bb
        function_2698(v2);
        // branch -> 0x2674
    }
    // 0x2674
    *(int32_t *)g3 = (int32_t)&g11;
    return 0;
}

// Address range: 0x2698 - 0x26a1
int32_t function_2698(int32_t a1) {
    // 0x2698
    *(int32_t *)(g3 + (int32_t)&g20) = 0;
    return g1;
}

// Address range: 0x26a1 - 0x26a2
int32_t function_26a1(void) {
    // 0x26a1
    return g1;
}

// Address range: 0x26a7 - 0x26aa
int32_t function_26a7(void) {
    // 0x26a7
    return 0;
}

// Address range: 0x26c0 - 0x26ca
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1) {
    // 0x26c0
    return function_4da0(a1 - 28);
}

// Address range: 0x26d0 - 0x26da
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1) {
    // 0x26d0
    return function_4da0(a1 - 8);
}

// Address range: 0x26e0 - 0x2736
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g3 = v1;
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g20); // 0x26f4
    g1 = v2;
    *(int32_t *)(v1 + 28) = (int32_t)&g16;
    *(int32_t *)g3 = (int32_t)&g14;
    *(int32_t *)(g3 + 8) = (int32_t)&g13;
    if (v2 == 0) {
        // 0x271b
        *(int32_t *)g3 = (int32_t)&g11;
        return 0;
    }
    // 0x270f
    if ((char)v2 != 0) {
        // bb
        function_2740(v2);
        // branch -> 0x271b
    }
    // 0x271b
    *(int32_t *)g3 = (int32_t)&g11;
    return 0;
}

// Address range: 0x2740 - 0x2749
int32_t function_2740(int32_t a1) {
    // 0x2740
    *(int32_t *)(g3 + (int32_t)&g20) = 0;
    return g1;
}

// Address range: 0x2749 - 0x274a
int32_t function_2749(void) {
    // 0x2749
    return g1;
}

// Address range: 0x274f - 0x2752
int32_t function_274f(void) {
    // 0x274f
    return 0;
}

// Address range: 0x2760 - 0x2767
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t a1) {
    // 0x2760
    return _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev((int32_t *)(a1 - 8));
}

// Address range: 0x2770 - 0x27ad
// From class:    N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g3 = v1;
    g1 = *(int32_t *)(v1 + (int32_t)&g20);
    *a1 = (int32_t)&g14;
    *(int32_t *)(g3 + 8) = (int32_t)&g13;
    int32_t v2 = g1; // 0x2794
    if (v2 == 0) {
        // 0x27a4
        *(int32_t *)g3 = (int32_t)&g11;
        return g1;
    }
    // 0x2798
    if ((char)v2 != 0) {
        // bb
        g1 = function_27d0(v2);
        // branch -> 0x27a4
    }
    // 0x27a4
    *(int32_t *)g3 = (int32_t)&g11;
    return g1;
}

// Address range: 0x27b1 - 0x27d0
int32_t function_27b1(int32_t a1) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x27b1
    *v1 = *v1 - 1;
    int32_t v2 = 0x24448900; // 0x27b7
    g1 = v2;
    int32_t result = v2; // 0x27cc
    if (v2 != 0) {
        // bb
        result = function_27d9();
        // branch -> 0x27bf
    }
    // 0x27bf
    return result;
}

// Address range: 0x27d0 - 0x27d9
int32_t function_27d0(int32_t a1) {
    // 0x27d0
    *(int32_t *)(g3 + (int32_t)&g20) = 0;
    return g1;
}

// Address range: 0x27d9 - 0x27da
int32_t function_27d9(void) {
    // 0x27d9
    return g1;
}

// Address range: 0x27df - 0x27e2
int32_t function_27df(void) {
    // 0x27df
    return 0;
}

// Address range: 0x27f0 - 0x27f7
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1) {
    // 0x27f0
    return _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev((int32_t *)(a1 - 28));
}

// Address range: 0x2800 - 0x2807
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1) {
    // 0x2800
    return _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev((int32_t *)(a1 - 8));
}

// Address range: 0x2810 - 0x2854
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g3 = v1;
    g1 = *(int32_t *)(v1 + (int32_t)&g20);
    *(int32_t *)(v1 + 28) = (int32_t)&g16;
    *(int32_t *)g3 = (int32_t)&g14;
    *(int32_t *)(g3 + 8) = (int32_t)&g13;
    int32_t v2 = g1; // 0x283b
    if (v2 == 0) {
        // 0x284b
        *(int32_t *)g3 = (int32_t)&g11;
        return g1;
    }
    // 0x283f
    if ((char)v2 != 0) {
        // bb
        g1 = function_2878(v2);
        // branch -> 0x284b
    }
    // 0x284b
    *(int32_t *)g3 = (int32_t)&g11;
    return g1;
}

// Address range: 0x2878 - 0x2881
int32_t function_2878(int32_t a1) {
    // 0x2878
    *(int32_t *)(g3 + (int32_t)&g20) = 0;
    return g1;
}

// Address range: 0x2887 - 0x288a
int32_t function_2887(void) {
    // 0x2887
    return 0;
}

// Address range: 0x28a0 - 0x28e0
// Demangled:     boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr()
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0x28b4
    if (v1 == 0) {
        // 0x28c6
        return 0;
    }
    // 0x28ba
    if ((char)v1 != 0) {
        // 0x28d8
        *a1 = 0;
        // branch -> 0x28c6
    }
    // 0x28c6
    return 0;
}

// Address range: 0x28f0 - 0x2948
// Demangled:     boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::operator=(boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container> const &)
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEEaSERKS3_(int32_t * a1, int32_t a2) {
    int32_t v1 = *(int32_t *)a2; // 0x290f
    if (*a1 != 0) {
        // 0x2917
        // branch -> 0x291f
    }
    // 0x291f
    *a1 = v1;
    if (v1 != 0) {
        // 0x2925
        // branch -> 0x292d
    }
    // 0x292d
    return (int32_t)a1;
}

// Address range: 0x2950 - 0x29c0
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::error_info_injector(boost::exception_detail::error_info_injector<boost::lock_error> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEEC1ERKS3_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1; // ebx
    *a1 = (int32_t)&g12;
    *(int32_t *)(v1 + 8) = (int32_t)&g13;
    *(int32_t *)(v1 + 4) = *(int32_t *)(a2 + 4);
    int32_t v2 = *(int32_t *)(a2 + (int32_t)&g20); // 0x297c
    *(int32_t *)(v1 + (int32_t)&g20) = v2;
    if (v2 != 0) {
        // 0x2986
        // branch -> 0x298e
    }
    int32_t v3 = *(int32_t *)(a2 + (int32_t)&g8); // 0x298e
    *(int32_t *)(v1 + 8) = (int32_t)&g15;
    *(int32_t *)(v1 + (int32_t)&g8) = v3;
    int32_t v4 = *(int32_t *)(a2 + (int32_t)&g9); // 0x299b
    *(int32_t *)(v1 + (int32_t)&g9) = v4;
    *(int32_t *)v1 = (int32_t)&g14;
    *(int32_t *)(v1 + 24) = *(int32_t *)(a2 + 24);
    return 0;
}

// Address range: 0x29e0 - 0x29e7
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1) {
    // 0x29e0
    return _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(a1 - 28);
}

// Address range: 0x29f0 - 0x2a0c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1) {
    // 0x29f0
    return 0;
}

// Address range: 0x2a10 - 0x2a17
int32_t function_2a10(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb8c; // 0x2a10
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x2a60 - 0x2a82
// Demangled:     void boost::throw_exception<boost::lock_error>(boost::lock_error const &)
int32_t _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(int32_t a1) {
    // 0x2a60
    return 0;
}

// Address range: 0x2ab0 - 0x2ab1
int32_t function_2ab0(void) {
    // 0x2ab0
    return 0;
}

// Address range: 0x2b71 - 0x2b72
int32_t function_2b71(void) {
    // 0x2b71
    return g1;
}

// Address range: 0x2b89 - 0x2b9c
int32_t function_2b89(void) {
    int32_t v1 = 0; // ebx
    *(int32_t *)(v1 + 28) = (int32_t)&g16;
    g1 = unknown_50a0(v1);
    return function_2b71();
}

// Address range: 0x2b9c - 0x2bba
int32_t function_2b9c(void) {
    // 0x2b9c
    int32_t v1;
    unknown_5300(v1);
    return unknown_5300(0);
}

// Address range: 0x2bba - 0x2bbe
int32_t function_2bba(void) {
    // 0x2bba
    return 0;
}

// Address range: 0x2bc0 - 0x2c62
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::_M_fill_insert(__gnu_cxx::__normal_iterator<unsigned char *, std::vector<unsigned char, std::allocator<unsigned char> > >, unsigned int, unsigned char const &)
int32_t _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    g7 = a3;
    g6 = a4;
    g3 = v1;
    g5 = a2;
    if (a3 == 0) {
        // bb
        function_2ccc(0x24448900);
        v1 = g3;
        // branch -> 0x2bf7
    }
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x2bf7
    g2 = v2;
    int32_t v3 = *(int32_t *)(v1 + 8) - v2; // 0x2bfd
    g1 = v3;
    if (v3 >= a3) {
        // bb26
        function_2cf8();
        v2 = g2;
        v1 = g3;
        // branch -> 0x2c07
    }
    int32_t v4 = *(int32_t *)v1; // 0x2c07
    g1 = v4;
    int32_t v5 = v2 - v4; // 0x2c09
    uint32_t v6 = v5; // 0x2c26
    if (-1 - v5 < a3) {
        int32_t v7 = function_2e30(); // 0x2c11
        g1 = v7;
        v4 = v7;
        v6 = v5;
        // branch -> 0x2c17
    }
    int32_t v8 = v6 >= a3 ? v6 : a3; // 0x2c1b
    int32_t v9 = v8 + v6; // 0x2c26
    if (v9 < v6) {
        // bb29
        g1 = function_2e10(v8);
        // branch -> 0x2c3c
    }
    // 0x2c3c
    if (v9 != 0) {
        // bb30
        function_2e08();
        // branch -> 0x2c44
    }
    // 0x2c44
    return g5 - v4;
}

// Address range: 0x2c84 - 0x2c94
int32_t function_2c84(void) {
    int32_t * v1 = (int32_t *)-0x74dfdbac; // 0x2c84
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    g1 = v2 + 1 & 255 | v2 & -256;
    return function_f631f201();
}

// Address range: 0x2ccc - 0x2cf1
int32_t function_2ccc(int32_t a1) {
    int32_t v1 = a1 ^ 0x24448900; // 0x2cd0
    g1 = v1;
    int32_t result = v1; // 0x2cf0
    if (v1 != 0) {
        // bb
        result = function_2e2b();
        // branch -> 0x2cdd
    }
    // 0x2cdd
    return result;
}

// Address range: 0x2cf8 - 0x2d2c
int32_t function_2cf8(void) {
    // 0x2cf8
    g4 = (int32_t)*(char *)&g6;
    int32_t v1 = g2 - g5; // 0x2cfd
    g6 = v1;
    int32_t v2 = g7; // 0x2cff
    int32_t v3 = v2; // 0x2d0b
    if (v2 >= v1) {
        // bb
        function_2d88();
        v3 = g7;
        // branch -> 0x2d07
    }
    // 0x2d07
    g6 = g2 - v3;
    int32_t result = v3; // 0x2d29
    if (v3 == 0) {
        // bb10
        result = function_2d41(0);
        // branch -> 0x2d19
    }
    // 0x2d19
    return result;
}

// Address range: 0x2d41 - 0x2d87
int32_t function_2d41(int32_t a1) {
    int32_t v1 = g6 - g5; // 0x2d47
    g6 = v1;
    *(int32_t *)(g3 + 4) = g7 + a1;
    if (v1 != 0) {
        // 0x2d4e
        g4 %= 256;
        // branch -> 0x2d69
    }
    // 0x2d69
    int32_t v2;
    int32_t v3 = v2 ^ 0x24448900; // 0x2d6d
    g1 = v3;
    if (v3 != 0) {
        // bb
        g1 = function_2e2b();
        // branch -> 0x2d7a
    }
    // 0x2d7a
    return function_2dec(g4 % 256, g7);
}

// Address range: 0x2d88 - 0x2da4
int32_t function_2d88(void) {
    int32_t v1 = g7; // 0x2d88
    g7 = g4 % 256;
    g4 = v1 - g6;
    return g1;
}

// Address range: 0x2dec - 0x2e08
int32_t function_2dec(int32_t a1, int32_t a2) {
    // 0x2dec
    g3 = a1;
    return g1;
}

// Address range: 0x2e08 - 0x2e10
int32_t function_2e08(void) {
    // 0x2e08
    return g1;
}

// Address range: 0x2e10 - 0x2e2b
int32_t function_2e10(int32_t a1) {
    // 0x2e10
    return g1;
}

// Address range: 0x2e2b - 0x2e30
int32_t function_2e2b(void) {
    // 0x2e2b
    return g1;
}

// Address range: 0x2e30 - 0x2e3c
int32_t function_2e30(void) {
    // 0x2e30
    return g1;
}

// Address range: 0x2e40 - 0x2e6a
// Demangled:     secure_allocator<unsigned char>::deallocate(unsigned char *, unsigned int)
int32_t _ZN16secure_allocatorIhE10deallocateEPhj(int32_t a1, int32_t a2) {
    // 0x2e40
    g1 = 0;
    int32_t result = 0; // 0x2e67
    if (a1 == 0) {
        // bb
        result = function_2f41(0x24448900);
        // branch -> 0x2e63
    }
    // 0x2e63
    return result;
}

// Address range: 0x2e8d - 0x2e97
int32_t function_2e8d(void) {
    char v1 = *(char *)&g1; // 0x2e8d
    int32_t result = 0; // eax
    *(char *)result = (char)result + v1;
    int32_t v2 = 0; // ecx
    char * v3 = (char *)(v2 + 0x357c8deb); // 0x2e8f
    *v3 = *v3 + (char)v2;
    return result;
}

// Address range: 0x2e97 - 0x2e98
int32_t function_2e97(void) {
    // 0x2e97
    return 0;
}

// Address range: 0x2ea8 - 0x2ea9
int32_t function_2ea8(void) {
    // 0x2ea8
    return 0;
}

// Address range: 0x2f23 - 0x2f24
int32_t function_2f23(void) {
    // 0x2f23
    return 0;
}

// Address range: 0x2f41 - 0x2f44
int32_t function_2f41(int32_t a1) {
    // 0x2f41
    return g1;
}

// Address range: 0x2f48 - 0x2f5e
int32_t function_2f48(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x2f48
    *v1 = *v1 - 1;
    int32_t v2 = 0x24448900; // 0x2f4e
    g1 = v2;
    int32_t result = v2; // 0x2f5d
    if (v2 != 0) {
        // bb
        result = function_2f9c();
        // branch -> 0x2f56
    }
    // 0x2f56
    return result;
}

// Address range: 0x2f60 - 0x2f7f
int32_t function_2f60(void) {
    // 0x2f60
    return 0;
}

// Address range: 0x2f9c - 0x2f9d
int32_t function_2f9c(void) {
    // 0x2f9c
    return g1;
}

// Address range: 0x2fc0 - 0x300d
// Demangled:     std::_Rb_tree<unsigned int, std::pair<unsigned int const, int>, std::_Select1st<std::pair<unsigned int const, int> >, std::less<unsigned int>, std::allocator<std::pair<unsigned int const, int> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<unsigned int const, int> const &)
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE10_M_insert_EPKSt18_Rb_tree_node_baseSB_RKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x2fc0
    g1 = 0;
    g5 = a4;
    g2 = a5;
    int32_t result = 0; // 0x3006
    if (a3 == 0) {
        // bb
        result = function_3078(a2 + 4, 1);
        // branch -> 0x3006
    }
    // 0x3006
    return result;
}

// Address range: 0x3042 - 0x3072
int32_t function_3042(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7ce3dbbc; // 0x3042
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x3049
    int32_t result = 0; // esi
    *(int32_t *)result = (v2 + 1 + (int32_t)false) % 256 | v2 & -256;
    g1 = result;
    if (a1 != 0x24448900) {
        // bb
        result = function_3090();
        // branch -> 0x305c
    }
    // 0x305c
    return result;
}

// Address range: 0x3078 - 0x3090
int32_t function_3078(int32_t a1, int32_t a2) {
    // 0x3078
    return g1;
}

// Address range: 0x3090 - 0x3091
int32_t function_3090(void) {
    // 0x3090
    return g1;
}

// Address range: 0x30a0 - 0x3138
// Demangled:     std::_Rb_tree<unsigned int, std::pair<unsigned int const, int>, std::_Select1st<std::pair<unsigned int const, int> >, std::less<unsigned int>, std::allocator<std::pair<unsigned int const, int> > >::_M_insert_unique(std::pair<unsigned int const, int> const &)
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE16_M_insert_uniqueERKS2_(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    g5 = a2;
    g3 = v1;
    int32_t result = *(int32_t *)(a2 + 8); // 0x30bf
    g7 = result;
    int32_t v2; // 0x3127
    if (result == 0) {
        // 0x3127
        v2 = a2 + 4;
        g7 = v2;
        // branch -> 0x3130
    } else {
        uint32_t v3 = *(int32_t *)a3; // 0x30ce
        // branch -> 0x30e6
        while (true) {
            uint32_t v4 = *(int32_t *)(result + (int32_t)&g8); // 0x30e6
            int32_t v5; // 0x30d8
            if (v4 > v3) {
                // 0x30d8
                v5 = *(int32_t *)(result + 8);
                if (v5 == 0) {
                    // 0x30f6
                    // branch -> 0x3130
                    // 0x3130
                    if (result != *(int32_t *)(a2 + (int32_t)&g20)) {
                        // 0x3135
                        return result;
                    }
                    // bb122
                    // branch -> 0x3135
                    // 0x3135
                    return function_3150(v4);
                }
            } else {
                int32_t v6 = *(int32_t *)(result + (int32_t)&g20); // 0x30ed
                if (v6 == 0) {
                    // 0x3102
                    if (v4 >= v3) {
                        // 0x3108
                        *(int32_t *)v1 = result;
                        *(char *)(g3 + 4) = 0;
                        return g3;
                    }
                    int32_t v7 = function_3150(v4); // 0x3106
                    // branch -> 0x3108
                    // 0x3108
                    *(int32_t *)g3 = v7;
                    *(char *)(g3 + 4) = 0;
                    return g3;
                }
                v5 = v6;
            }
            // 0x30e4
            g7 = v5;
            result = v5;
            // branch -> 0x30e6
        }
    }
    int32_t result2 = 0; // 0x3135
    if (v2 == *(int32_t *)(a2 + (int32_t)&g20)) {
        // bb122
        int32_t v8;
        result2 = function_3150(v8);
        // branch -> 0x3135
    }
    // 0x3135
    return result2;
}

// Address range: 0x3150 - 0x3183
int32_t function_3150(int32_t result) {
    // 0x3150
    int32_t v1; // bp+44
    unknown_6060((int32_t)&v1, g5, 0, g7, result);
    *(char *)(g3 + 4) = 1;
    *(int32_t *)g3 = result;
    return result;
}

// Address range: 0x3183 - 0x3188
int32_t function_3183(void) {
    // 0x3183
    return g1;
}

// Address range: 0x3190 - 0x320c
// Demangled:     std::vector<unsigned char, secure_allocator<unsigned char> >::_M_fill_insert(__gnu_cxx::__normal_iterator<unsigned char *, std::vector<unsigned char, secure_allocator<unsigned char> > >, unsigned int, unsigned char const &)
int32_t _ZNSt6vectorIh16secure_allocatorIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS2_EEjRKh(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    g1 = 0;
    g2 = v1;
    g5 = a2;
    if (a3 == 0) {
        // bb
        function_3369(0);
        v1 = g2;
        // branch -> 0x31bf
    }
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x31bf
    g6 = v2;
    int32_t v3 = v2; // 0x31d2
    int32_t v4 = v1; // 0x31cf
    if (*(int32_t *)(v1 + 8) - v2 >= a3) {
        // bb22
        function_3388();
        v3 = g6;
        v4 = g2;
        // branch -> 0x31cf
    }
    int32_t v5 = *(int32_t *)v4; // 0x31cf
    g1 = v5;
    int32_t v6 = v3 - v5; // 0x31d2
    uint32_t v7 = v6; // 0x31f9
    if (-1 - v6 < a3) {
        int32_t v8 = function_3617(); // 0x31dc
        g1 = v8;
        v5 = v8;
        v7 = v6;
        // branch -> 0x31e2
    }
    int32_t v9 = (v7 >= a3 ? v7 : a3) + v7; // 0x31f9
    g6 = v9;
    int32_t result = v5; // 0x3209
    if (v9 >= v7) {
        // bb25
        result = function_3488((char *)(g5 - v5), -1);
        // branch -> 0x3205
    }
    // 0x3205
    g3 = -1;
    return result;
}

// Address range: 0x3260 - 0x3261
int32_t function_3260(void) {
    // 0x3260
    return 0;
}

// Address range: 0x32a6 - 0x32a7
int32_t function_32a6(void) {
    // 0x32a6
    return 0;
}

// Address range: 0x32b8 - 0x32b9
int32_t function_32b8(void) {
    // 0x32b8
    return 0;
}

// Address range: 0x32d8 - 0x32d9
int32_t function_32d8(void) {
    // 0x32d8
    return 0;
}

// Address range: 0x332a - 0x3338
int32_t function_332a(void) {
    // 0x332a
    int32_t result; // 0x3332
    if (0 >= *(int32_t *)28) {
        // bb
        result = function_3578();
        // branch -> 0x3338
    } else {
        // 0x332a
        result = g1;
        // branch -> 0x3338
    }
    // 0x3338
    return result;
}

// Address range: 0x3354 - 0x3369
int32_t function_3354(int32_t a1) {
    // 0x3354
    *(int32_t *)g2 = a1;
    int32_t v1;
    int32_t result = a1 + v1; // eax
    *(int32_t *)(g2 + 4) = 0;
    *(int32_t *)(g2 + 8) = result;
    return result;
}

// Address range: 0x3369 - 0x3382
int32_t function_3369(int32_t a1) {
    // 0x3369
    int32_t result; // 0x3381
    if (a1 != 0x24448900) {
        // bb
        result = function_3612();
        // branch -> 0x337a
    } else {
        // 0x3369
        result = g1;
        // branch -> 0x337a
    }
    // 0x337a
    return result;
}

// Address range: 0x3388 - 0x33ec
int32_t function_3388(void) {
    int32_t v1 = g6; // 0x3388
    g3 = (int32_t)*(char *)&g7;
    g1 = v1;
    int32_t v2 = v1 - g5; // 0x338f
    uint32_t v3;
    if (v3 >= v2) {
        // bb
        v1 = function_3421((char *)v2);
        // branch -> 0x339f
    }
    int32_t v4 = v1 - v3; // 0x339f
    int32_t v5 = v1; // eax
    int32_t v6; // 0x33d0
    if (v1 == v4) {
        // 0x339f
        v6 = v1;
        // branch -> 0x33d0
    } else {
        int32_t v7 = v1; // 0x33c78
        int32_t v8 = v1; // 0x33bf
        // branch -> 0x33b8
        int32_t v9; // 0x33ce
        while (true) {
            // 0x33b8
            v9 = v7;
            int32_t v10 = 0; // 0x33c4
            if (v8 != 0) {
                // 0x33bc
                *(char *)v8 = *(char *)v4;
                v9 = v1;
                v10 = v5;
                // branch -> 0x33c1
            }
            int32_t v11 = v4 + 1; // 0x33c1
            v4 = v11;
            int32_t v12 = v10 + 1; // 0x33c4
            v5 = v12;
            if (v11 == v9) {
                // break -> 0x33cb
                break;
            }
            v7 = v9;
            v8 = v12;
            v4 = v11;
            // continue -> 0x33b8
        }
        // 0x33cb
        g6 = v9;
        v6 = *(int32_t *)(g2 + 4);
        // branch -> 0x33d0
    }
    // 0x33d0
    *(int32_t *)(g2 + 4) = v6 + v3;
    int32_t v13 = v4 - g5; // 0x33db
    g1 = v13;
    int32_t result = v13; // 0x33e9
    if (v13 == 0) {
        // bb18
        result = function_33f1();
        // branch -> 0x33df
    }
    // 0x33df
    g6 -= result;
    return result;
}

// Address range: 0x33f1 - 0x341c
int32_t function_33f1(void) {
    // 0x33f1
    int32_t v1;
    int32_t v2 = v1 ^ 0x24448900; // 0x33f5
    g6 = v2;
    int32_t result; // 0x341b
    if (v2 != 0) {
        // bb
        result = function_3612();
        // branch -> 0x3402
    } else {
        // 0x33f1
        result = g1;
        // branch -> 0x3402
    }
    // 0x3402
    return result;
}

// Address range: 0x3421 - 0x3488
int32_t function_3421(char * a1) {
    // 0x3421
    int32_t v1;
    int32_t v2 = (int32_t)a1 - v1; // 0x3425
    int32_t v3; // 0x3441
    int32_t v4; // 0x3441
    if (v2 == 0) {
        // 0x3421
        v4 = 0;
        v3 = g1;
        // branch -> 0x3441
    } else {
        int32_t v5 = v2; // 0x34392
        // branch -> 0x3430
        while (true) {
            int32_t v6 = v5; // 0x3439
            char * v7;
            if (v7 != NULL) {
                // 0x3434
                *v7 = (char)g3;
                v6 = v2;
                // branch -> 0x3436
            }
            int32_t v8 = v6 - 1; // 0x3439
            v2 = v8;
            if (v8 == 0) {
                // break -> 0x343e
                break;
            }
            v5 = v8;
            v7 = (char *)((int32_t)v7 + 1);
            // continue -> 0x3430
        }
        // 0x343e
        v4 = v2;
        v3 = *(int32_t *)(g2 + 4);
        // branch -> 0x3441
    }
    int32_t v9 = v3 + v4; // 0x3441
    int32_t v10 = v9; // eax
    *(int32_t *)(g2 + 4) = v9;
    int32_t v11; // 0x3466
    if (g6 == g5) {
        // 0x3441
        v11 = v10;
        // branch -> 0x3466
    } else {
        int32_t v12 = g5; // 0x344a
        v2 = v12;
        int32_t v13 = g6; // 0x344c
        int32_t v14 = v13; // 0x345f11
        int32_t v15 = v10; // 0x3457
        // branch -> 0x3450
        while (true) {
            int32_t v16 = v14; // 0x345f
            int32_t v17 = 0; // 0x345c
            int32_t v18 = v12; // 0x3459
            if (v15 != 0) {
                // 0x3454
                *(char *)v15 = *(char *)v12;
                v16 = v13;
                v17 = v10;
                v18 = v2;
                // branch -> 0x3459
            }
            int32_t v19 = v18 + 1; // 0x3459
            v2 = v19;
            int32_t v20 = v17 + 1; // 0x345c
            v10 = v20;
            if (v19 == v16) {
                // break -> 0x3463
                break;
            }
            v14 = v16;
            v12 = v19;
            v15 = v20;
            // continue -> 0x3450
        }
        // 0x3463
        v11 = *(int32_t *)(g2 + 4);
        // branch -> 0x3466
    }
    // 0x3466
    *(int32_t *)(g2 + 4) = v11 + v1;
    int32_t v21;
    int32_t v22 = v21 ^ 0x24448900; // 0x3471
    g1 = v22;
    int32_t result = v22; // 0x3486
    if (v22 != 0) {
        // bb
        result = function_3612();
        // branch -> 0x347e
    }
    // 0x347e
    return result;
}

// Address range: 0x3488 - 0x3534
int32_t function_3488(char * a1, int32_t a2) {
    // 0x3488
    if (g6 != 0) {
        // bb
        function_3609();
        // branch -> 0x3490
    }
    int32_t v1 = (int32_t)a1; // 0x34a4
    int32_t v2 = v1; // edx
    int32_t v3 = v1; // 0x34bc5
    // branch -> 0x34b0
    while (true) {
        int32_t v4 = v3; // 0x34bc
        int32_t v5 = 0; // 0x34b9
        if (a2 != 0) {
            // 0x34b4
            *(char *)a2 = *(char *)&g7;
            v4 = v2;
            v5 = a2;
            // branch -> 0x34b9
        }
        int32_t v6 = v4 - 1; // 0x34bc
        v2 = v6;
        if (v6 == 0) {
            // break -> 0x34c1
            break;
        }
        v3 = v6;
        a2 = v5 + 1;
        // continue -> 0x34b0
    }
    // 0x34c1
    a2 = 0;
    int32_t v7 = g5; // 0x34c8
    int32_t v8 = g2; // 0x34fe
    int32_t v9 = 0; // 0x34ee
    if (g2 != v7) {
        // 0x34cc
        v2 = g2;
        int32_t v10 = g2; // 0x34d4
        int32_t v11 = 0; // 0x34d7
        // branch -> 0x34d0
        int32_t v12; // 0x34e3
        while (true) {
            // 0x34d0
            v12 = v7;
            int32_t v13 = 0; // 0x34dc
            int32_t v14 = v10; // 0x34d9
            if (v11 != 0) {
                // 0x34d4
                *(char *)v11 = *(char *)v10;
                v12 = g5;
                v13 = a2;
                v14 = v2;
                // branch -> 0x34d9
            }
            int32_t v15 = v14 + 1; // 0x34d9
            v2 = v15;
            int32_t v16 = v13 + 1; // 0x34dc
            a2 = v16;
            if (v15 == v12) {
                // break -> 0x34e3
                break;
            }
            v7 = v12;
            v10 = v15;
            v11 = v16;
            // continue -> 0x34d0
        }
        // 0x34e3
        v8 = v12;
        v9 = v12 - g2;
        // branch -> 0x34eb
    }
    int32_t v17 = *(int32_t *)(g2 + 4); // 0x34eb
    int32_t v18 = v9 + v1; // 0x34ee
    int32_t result = v18; // 0x353124
    if (v17 != v8) {
        // 0x34fa
        v2 = v18;
        a2 = v8;
        int32_t v19 = v17; // 0x350f19
        // branch -> 0x3500
        int32_t v20; // 0x3509
        while (true) {
            int32_t v21 = v19; // 0x350f
            int32_t v22 = 0; // 0x350c
            int32_t v23 = v8; // 0x3509
            if (v18 != 0) {
                // 0x3504
                *(char *)v18 = *(char *)v8;
                v21 = v17;
                v22 = v2;
                v23 = a2;
                // branch -> 0x3509
            }
            // 0x3509
            v20 = v23 + 1;
            a2 = v20;
            int32_t v24 = v22 + 1; // 0x350c
            v2 = v24;
            if (v20 == v21) {
                // break -> 0x3513
                break;
            }
            v19 = v21;
            v8 = v20;
            v18 = v24;
            // continue -> 0x3500
        }
        // 0x3513
        result = v20 - g5;
        // branch -> 0x3519
    }
    if (g2 == 0) {
        // bb34
        result = function_3354(0);
        // branch -> 0x352b
    }
    // 0x352b
    return result;
}

// Address range: 0x3578 - 0x3579
int32_t function_3578(void) {
    // 0x3578
    return g1;
}

// Address range: 0x35a0 - 0x35bf
int32_t function_35a0(void) {
    // 0x35a0
    return 0;
}

// Address range: 0x35c8 - 0x35c9
int32_t function_35c8(void) {
    // 0x35c8
    return 0;
}

// Address range: 0x3609 - 0x3612
int32_t function_3609(void) {
    // 0x3609
    return g1;
}

// Address range: 0x3612 - 0x3613
int32_t function_3612(void) {
    // 0x3612
    return g1;
}

// Address range: 0x3617 - 0x361e
int32_t function_3617(void) {
    // 0x3617
    return g1;
}

// Address range: 0x3624 - 0x3625
int32_t function_3624(void) {
    // 0x3624
    return 0;
}

// Address range: 0x3691 - 0x3692
int32_t function_3691(void) {
    // 0x3691
    return g1;
}

// Address range: 0x36a3 - 0x36a5
int32_t function_36a3(void) {
    // 0x36a3
    return function_3691();
}

// Address range: 0x36b0 - 0x36c6
int32_t _GLOBAL__sub_I__ZN4CKey5CheckEPKh(void) {
    // 0x36b0
    return 0;
}

// Address range: 0x36e6 - 0x36f8
int32_t function_36e6(void) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x36e6
    *v1 = *v1 - 1;
    int32_t result = 0x24448900; // 0x36ec
    if (result != 0) {
        // 0x36f8
    }
    // 0x36f4
    return result;
}

// Address range: 0x4c70 - 0x4c71
int32_t function_4c70(int32_t a1) {
    // 0x4c70
    return g1;
}

// Address range: 0x4da0 - 0x4da1
int32_t function_4da0(int32_t a1) {
    // 0x4da0
    return g1;
}

// Address range: 0x2c30c78 - 0x2c30c79
int32_t function_2c30c78(void) {
    // 0x2c30c78
    return g1;
}

// Address range: 0x42444c7 - 0x42444c8
int32_t function_42444c7(void) {
    // 0x42444c7
    return g1;
}

// Address range: 0xf000af7 - 0xf000af8
int32_t function_f000af7(void) {
    // 0xf000af7
    return g1;
}

// Address range: 0x89001c53 - 0x89001c54
int32_t function_89001c53(void) {
    // 0x89001c53
    return g1;
}

// Address range: 0xb6e8f889 - 0xb6e8f88a
int32_t function_b6e8f889(void) {
    // 0xb6e8f889
    return g1;
}

// Address range: 0xc085ffff - 0xc0860000
int32_t function_c085ffff(int32_t a1) {
    // 0xc085ffff
    return g1;
}

// Address range: 0xc7000000 - 0xc7000001
int32_t function_c7000000(void) {
    // 0xc7000000
    return g1;
}

// Address range: 0xf631f201 - 0xf631f202
int32_t function_f631f201(void) {
    // 0xf631f201
    return g1;
}

// Address range: 0xf884178a - 0xf884178b
int32_t function_f884178a(void) {
    // 0xf884178a
    return g1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected language: C++
// Detected functions: 281
// Decompilation date: 2018-06-10 00:06:01
