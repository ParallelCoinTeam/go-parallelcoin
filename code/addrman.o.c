//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int3_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct vector_unsignedchar_std__allocator_unsignedchar__ {
    int32_t e0;
};

struct vtable_5370_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t);
};

struct vtable_55a8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
};

struct vtable_55e8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t);
    int32_t (*e3)(int32_t);
};

// ------------------------- Classes --------------------------

// N5boost16exception_detail10bad_alloc_E
// N5boost16exception_detail10clone_baseE
// N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE (base classes: N5boost16exception_detail10bad_alloc_E, N5boost16exception_detail10clone_baseE)
// N5boost6detail15sp_counted_baseE
// N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE (base classes: N5boost6detail15sp_counted_baseE)
// N5boost6system12system_errorE
// N5boost9exceptionE

// ------------------- Function Prototypes --------------------

void _7e_clone_impl(int32_t this, int32_t __in_chrg);
void __uninitialized_move_a_3c_CAddress_2a__2c__20_CAddress_2a__2c__20_std_3a__3a_allocator_3c_CAddress_3e__20__3e_(int32_t __first, int32_t __last, int32_t __result, int32_t __alloc);
int32_t _GLOBAL__sub_I__ZNK9CAddrInfo14GetTriedBucketERKSt6vectorIhSaIhEE(void);
int32_t _Z16WriteCompactSizeI11CDataStreamEvRT_y(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZN11CDataStream5writeEPKci_part_346(void);
int32_t _ZN11CDataStreamD1Ev(int32_t * a1);
int32_t _ZN5boost10shared_ptrIKNS_16exception_detail10clone_baseEED1Ev(int32_t a1);
int32_t _ZN5boost16exception_detail10bad_alloc_D0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10bad_alloc_D1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail13get_bad_allocILi42EEENS_10shared_ptrIKNS0_10clone_baseEEEv(int32_t * a1);
int32_t _ZN5boost16exception_detail20copy_boost_exceptionEPNS_9exceptionEPKS1_(int32_t a1, int32_t a2);
int32_t _ZN5boost6detail15sp_counted_base7destroyEv(int32_t * a1);
int32_t _ZN5boost6detail15sp_counted_baseD0Ev(int32_t * a1);
int32_t _ZN5boost6detail15sp_counted_baseD1Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE11get_deleterERKSt9type_info(void);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE7disposeEv(int32_t a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED0Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED1Ev(int32_t * a1);
int32_t _ZN5boost6system12system_errorD0Ev(int32_t * a1);
int32_t _ZN5boost6system12system_errorD1Ev(int32_t * a1);
int32_t _ZN5boost6system14error_categoryD0Ev(int32_t * a1);
int32_t _ZN5boost6system14error_categoryD1Ev(int32_t * a1);
int32_t _ZN5boost9exceptionD0Ev(int32_t a1);
int32_t _ZN5boost9exceptionD1Ev(int32_t * a1);
void _ZN8CAddrMan10Connected_ERK8CServicex(int32_t this, int32_t addr, int64_t nTime);
void _ZN8CAddrMan10SwapRandomEjj(int32_t this, uint32_t nRndPos1, int32_t nRndPos2);
void _ZN8CAddrMan11SelectTriedEi(int32_t this, int32_t nKBucket);
void _ZN8CAddrMan4Add_ERK8CAddressRK8CNetAddrx(int32_t this, int32_t addr, int32_t source, int64_t nTimePenalty);
void _ZN8CAddrMan4FindERK8CNetAddrPi(int32_t this, int32_t addr, int32_t * pnId);
void _ZN8CAddrMan5Good_ERK8CServicex(int32_t this, int32_t addr, int64_t nTime);
void _ZN8CAddrMan6CreateERK8CAddressRK8CNetAddrPi(int32_t this, int32_t addr, int32_t addrSource, int32_t * pnId);
void _ZN8CAddrMan7Select_Ei(int32_t this, int32_t nUnkBias);
void _ZN8CAddrMan8Attempt_ERK8CServicex(int32_t this, int32_t addr, int64_t nTime);
void _ZN8CAddrMan8GetAddr_ERSt6vectorI8CAddressSaIS1_EE(int32_t this, int32_t vAddr);
void _ZN8CAddrMan9MakeTriedER9CAddrInfoii(int32_t this, int32_t info, int32_t nId, int32_t nOrigin);
void _ZN8CAddrMan9ShrinkNewEi(int32_t this, int32_t nUBucket);
void _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t this);
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv2(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1);
int32_t _ZNK5boost6system12system_error4whatEv(int32_t a1);
int32_t _ZNK5boost6system14error_category10equivalentEiRKNS0_15error_conditionE(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNK5boost6system14error_category10equivalentERKNS0_10error_codeEi(int32_t a1, int32_t * a2, int32_t a3);
int32_t _ZNK5boost6system14error_category23default_error_conditionEi(int32_t * a1, int32_t a2, int32_t a3);
void _ZNK9CAddrInfo10IsTerribleEx(int32_t this, int64_t nNow);
void _ZNK9CAddrInfo12GetNewBucketERKSt6vectorIhSaIhEERK8CNetAddr(int32_t this, struct vector_unsignedchar_std__allocator_unsignedchar__ nKey, int32_t src);
void _ZNK9CAddrInfo14GetTriedBucketERKSt6vectorIhSaIhEE(int32_t this, struct vector_unsignedchar_std__allocator_unsignedchar__ nKey);
void _ZNK9CAddrInfo9GetChanceEx(int32_t this, int64_t nNow);
int32_t _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(int32_t a1, int32_t * a2);
int32_t _ZNSt6vectorI8CAddressSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt6vectorIc25zero_after_free_allocatorIcEE15_M_range_insertIPKcEEvN9__gnu_cxx17__normal_iteratorIPcS2_EET_SA_St20forward_iterator_tag(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt6vectorIhSaIhEED1Ev(int32_t * a1);
int32_t _ZNSt6vectorIiSaIiEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPiS1_EERKi(int32_t a1, int32_t * a2);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE10_M_insert_EPKSt18_Rb_tree_node_baseSC_RKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE11equal_rangeERS2_(void);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS3_ESC_RS2__isra_334(void);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE16_M_insert_uniqueERKS3_(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS3_ERKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE5eraseERS2_(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE10_M_insert_EPKSt18_Rb_tree_node_baseS8_RKi(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE16_M_insert_uniqueERKi(int32_t * a1, int32_t a2);
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE5eraseERKi(int32_t a1, int32_t * a2);
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE8_M_eraseEPSt13_Rb_tree_nodeIiE(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE10_M_insert_EPKSt18_Rb_tree_node_baseSC_RKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE16_M_insert_uniqueERKS3_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS3_ERKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE5eraseERS1_(int32_t a1, int32_t * a2);
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E(int32_t a1, int32_t a2);
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D0Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D1Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1);
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1);
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1);
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1);
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1);
int32_t function_1030(int32_t a1);
int32_t function_10ef(void);
int32_t function_1102(int32_t a1, int32_t a2, int32_t a3);
int32_t function_116b(void);
int32_t function_11be(int32_t a1);
int32_t function_11e2(void);
int32_t function_132d(void);
int32_t function_13c0(int32_t a1);
int32_t function_1418(void);
int32_t function_1437(void);
int32_t function_14f0(void);
int32_t function_14f9(void);
int32_t function_14fc(void);
int32_t function_1544(void);
int32_t function_1548(void);
int32_t function_154b(void);
int32_t function_1591(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1772(char a1, int32_t result, int32_t a3);
int32_t function_18244489(void);
int32_t function_1941(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_196a(void);
int32_t function_1973(void);
int32_t function_199b(void);
int32_t function_19a4(void);
int32_t function_19ac(void);
int32_t function_1a0c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1a5e(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_1bb3(void);
int32_t function_1c58(int32_t a1);
int32_t function_1c88(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_1cf1(void);
int32_t function_1d14(void);
int32_t function_1d19(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1db6(void);
int32_t function_1dbf(void);
int32_t function_1dc2(void);
int32_t function_1e0a(void);
int32_t function_1e0e(void);
int32_t function_1e11(void);
int32_t function_1e53(int16_t a1);
int32_t function_1fef(void);
int32_t function_1ff3(int32_t result, int32_t a2, int32_t a3);
int32_t function_2023(void);
int32_t function_21cb(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_21f2(void);
int32_t function_21ff(void);
int32_t function_2207(void);
int32_t function_2222(void);
int32_t function_222b(void);
int32_t function_2234(void);
int32_t function_23b0(int32_t a1);
int32_t function_23d8(void);
int32_t function_24a8(void);
int32_t function_24e1(void);
int32_t function_2505(void);
int32_t function_2589(int32_t a1);
int32_t function_25c2(int16_t a1);
int32_t function_25d7(int32_t a1, int32_t a2, int32_t a3);
int32_t function_267b(int32_t a1, int32_t a2);
int32_t function_26a0(int32_t a1);
int32_t function_26b6(void);
int32_t function_26c7(void);
int32_t function_29b3(int32_t a1);
int32_t function_29f3(int32_t a1);
int32_t function_2a33(int32_t a1);
int32_t function_2a73(int32_t a1);
int32_t function_2ab2(void);
int32_t function_2e4d(void);
int32_t function_2e6f(void);
int32_t function_2e98(void);
int32_t function_2ec0(void);
int32_t function_2ec2(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2ed3(void);
int32_t function_2ee4(void);
int32_t function_2eea(void);
int32_t function_2ef0(void);
int32_t function_2ef3(void);
int32_t function_2fd6(int32_t a1, int32_t a2);
int32_t function_2ff0(void);
int32_t function_3015(void);
int32_t function_3017(void);
int32_t function_301c(void);
int32_t function_306e(int32_t a1, int32_t a2);
int32_t function_3088(void);
int32_t function_30ad(void);
int32_t function_30af(void);
int32_t function_30b4(void);
int32_t function_3117(void);
int32_t function_316b(int32_t a1);
int32_t function_31e2(int32_t a1);
int32_t function_3336(void);
int32_t function_3385(void);
int32_t function_3388(int32_t a1);
int32_t function_34a(void);
int32_t function_350a(void);
int32_t function_3513(void);
int32_t function_3527(void);
int32_t function_37b2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_37e8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_38af(void);
int32_t function_38b4(void);
int32_t function_38d4(void);
int32_t function_38dd(void);
int32_t function_38f1(void);
int32_t function_3902(void);
int32_t function_3908(void);
int32_t function_390a(void);
int32_t function_3912(void);
int32_t function_3968(int32_t a1);
int32_t function_3979(void);
int32_t function_39c(int32_t a1);
int32_t function_39d0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3a7d(void);
int32_t function_3a80(int32_t a1);
int32_t function_3ac1(int32_t a1);
int32_t function_3afc(void);
int32_t function_3b10(void);
int32_t function_3b28(void);
int32_t function_3b48(void);
int32_t function_3b63(int32_t a1);
int32_t function_3b6c(void);
int32_t function_3b71(void);
int32_t function_3be0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3c40(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3d0b(int32_t result);
int32_t function_3d28(void);
int32_t function_3d95(int32_t a1);
int32_t function_3dc8(void);
int32_t function_3dd5(void);
int32_t function_3e8b(int32_t result);
int32_t function_3ea8(void);
int32_t function_3f15(int32_t a1);
int32_t function_3f48(void);
int32_t function_3f55(void);
int32_t function_40(void);
int32_t function_4199(void);
int32_t function_41a9(int32_t a1);
int32_t function_41bb(int32_t a1);
int32_t function_41d7(void);
int32_t function_4207(void);
int32_t function_423(void);
int32_t function_42ff(char * a1);
int32_t function_4396(void);
int32_t function_43b0(int32_t a1);
int32_t function_43d0(char * a1, int32_t a2);
int32_t function_4470(void);
int32_t function_4488(void);
int32_t function_449a(void);
int32_t function_449f(void);
int32_t function_44a4(int32_t a1, int32_t a2);
int32_t function_44b0(void);
int32_t function_453c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4570(int32_t a1);
int32_t function_4586(void);
int32_t function_4640(int32_t result);
int32_t function_4673(void);
int32_t function_46ce(int32_t a1);
int32_t function_46fb(void);
int32_t function_4718(void);
int32_t function_471c(void);
int32_t function_472e(int32_t a1, int32_t result);
int32_t function_4760(void);
int32_t function_4765(void);
int32_t function_47fd(int32_t result);
int32_t function_4818(int32_t a1);
int32_t function_484e(int32_t a1);
int32_t function_4858(void);
int32_t function_48b9(void);
int32_t function_48e9(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4918(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4930(void);
int32_t function_4a4(void);
int32_t function_4abc(void);
int32_t function_4ae8(void);
int32_t function_4b1d(void);
int32_t function_4b38(int32_t a1);
int32_t function_4b78(void);
int32_t function_4b80(void);
int32_t function_4ba8(void);
int32_t function_4bae(void);
int32_t function_4bb7(void);
int32_t function_4c5a(int32_t a1);
int32_t function_4ce9(void);
int32_t function_4d1(void);
int32_t function_4d4(void);
int32_t function_4d88(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4db8(int32_t a1);
int32_t function_4dcf(void);
int32_t function_4ddb(void);
int32_t function_4e33(void);
int32_t function_4e37(void);
int32_t function_4e45(void);
int32_t function_4e67(void);
int32_t function_4e80(void);
int32_t function_4e88(void);
int32_t function_4eb7(int32_t a1);
int32_t function_4ebf(void);
int32_t function_4f3b(void);
int32_t function_4f50(int16_t a1);
int32_t function_4f8(void);
int32_t function_4f83(void);
int32_t function_4fd9(void);
int32_t function_4feb(void);
int32_t function_5020(int32_t a1);
int32_t function_5069(void);
int32_t function_5084(int32_t a1);
int32_t function_50a0(void);
int32_t function_50c0(void);
int32_t function_50c6(void);
int32_t function_50d0(void);
int32_t function_52a4(void);
int32_t function_52ae(void);
int32_t function_52b8(void);
int32_t function_52be(int32_t a1);
int32_t function_5c(void);
int32_t function_5cf(void);
int32_t function_5e0(int32_t a1);
int32_t function_61e(int32_t a1);
int32_t function_6200(int32_t a1);
int32_t function_6270(int32_t a1);
int32_t function_6340(int32_t a1);
int32_t function_682(float64_t a1);
int32_t function_6c8(void);
int32_t function_724(void);
int32_t function_75b(void);
int32_t function_792(void);
int32_t function_7e8(void);
int32_t function_80c(int32_t result);
int32_t function_818(void);
int32_t function_833(void);
int32_t function_860fdeb3(void);
int32_t function_870fe008(void);
int32_t function_873(void);
int32_t function_878(void);
float80_t function_88c(float64_t a1, int32_t a2);
int32_t function_89b(void);
int32_t function_8a5(void);
int32_t function_945(void);
int32_t function_955(void);
int32_t function_962(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_980(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_bcc(int32_t a1);
int32_t function_bf0(void);
int32_t function_c7e(uint32_t a1, uint32_t a2, int32_t a3);
int32_t function_d95(int32_t a1);
int32_t function_e9d(void);
int32_t function_ea4(int32_t a1);
int32_t function_eb2(void);
int32_t function_eee(int32_t a1, int32_t a2);
int32_t function_f28(void);
int32_t function_f3a(int32_t a1);
int32_t function_f4f(int32_t a1);
int32_t function_f68(int32_t a1);
int32_t function_f90(void);
int32_t unknown_63c0(int32_t a1);
int32_t unknown_67d0(int32_t a1);
int32_t unknown_6a90(int32_t a1, int32_t a2);
int32_t unknown_7320(int32_t a1, int32_t a2);
int32_t unknown_7740(int32_t a1, int32_t a2);
int32_t unknown_7770(int32_t a1, int32_t a2);
int32_t unknown_7800(int32_t a1, int32_t a2);
int32_t unknown_8370(int32_t a1, int32_t a2);
int32_t unknown_8a50(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_8df0(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_91a0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_9290(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_92f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_9370(int32_t a1, int32_t a2);
int32_t unknown_95f0(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_9ad0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_9bc0(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_9cb0(int32_t a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // ecx
int32_t g5 = 0; // edi
int32_t g6 = 0; // edx
int32_t g7 = 0; // esi
int32_t g8 = 0; // esp
int3_t g9 = 0; // fpu_stat_TOP
int32_t g10 = 0x2790;
int32_t g12; // 0x5589
int32_t g13 = 0;
int32_t g15 = 0x3130;
int32_t g16 = 0;
int32_t g18 = 0x2700;
int32_t g19 = 8;
char (*g20)[33] = "N5boost6detail15sp_counted_baseE";
int32_t g21 = -0x14f38975;
int32_t g22 = -0x49720001;
int32_t g23 = 0;
bool g24 = false; // of
bool g25 = false; // sf
bool g26 = false; // zf
struct vtable_5370_type g11 = {
    .e0 = _ZN5boost6system12system_errorD1Ev,
    .e1 = _ZN5boost6system12system_errorD0Ev,
    .e2 = _ZNK5boost6system12system_error4whatEv
};
struct vtable_55a8_type g14 = {
    .e0 = _ZN5boost16exception_detail10bad_alloc_D1Ev,
    .e1 = _ZN5boost16exception_detail10bad_alloc_D0Ev
};
struct vtable_55e8_type g17 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev,
    .e2 = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv2,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv
};

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x4
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE14_M_lower_boundEPSt13_Rb_tree_nodeIS3_ESC_RS2__isra_334(void) {
    // 0x0
    return 0;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x10 - 0x1f
// Line range:    411 - 976
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::clone() const
void _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t this) {
    char v1 = *(char *)&g1; // bp+10
    int32_t v2 = 0; // eax
    *(char *)v2 = (char)v2 + v1;
    int32_t v3 = 0; // ecx
    char * v4 = (char *)(v3 + 0x311c2444); // bp+12
    *v4 = *v4 + (char)v3;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x20 - 0x2e
// Line range:    404 - 1289
void _7e_clone_impl(int32_t this, int32_t __in_chrg) {
    // 0x20
    if (g7 == 0) {
        // bb
        function_40();
        // branch -> 0x24
    }
}

// Address range: 0x40 - 0x59
int32_t function_40(void) {
    // 0x40
    *(int32_t *)g3 = g2;
    int32_t v1;
    if (*(int32_t *)20 != v1) {
        // 0x65
        return g3;
    }
    // 0x51
    return g3;
}

// Address range: 0x5c - 0x65
int32_t function_5c(void) {
    char v1 = *(char *)&g1;
    int32_t v2 = 0; // eax
    *(char *)v2 = (char)v2 + v1;
    char v3 = *(char *)&g1;
    *(char *)v2 = (char)v2 + v3;
    g7 = *(int32_t *)12;
    int32_t * v4;
    _7e_clone_impl((int32_t)&v4, (int32_t)&v4);
    return (int32_t)&v4;
}

// From module:   /usr/include/c++/4.6/bits/stl_uninitialized.h
// Address range: 0x70 - 0x102
// Line range:    264 - 1052
void __uninitialized_move_a_3c_CAddress_2a__2c__20_CAddress_2a__2c__20_std_3a__3a_allocator_3c_CAddress_3e__20__3e_(int32_t __first, int32_t __last, int32_t __result, int32_t __alloc) {
    int32_t v1 = 0; // bp+74
    int32_t v2 = 0; // bp+79
    int32_t v3 = 0; // edx
    int32_t v4 = v3; // bp+88
    if (v4 != v1) {
        // branch -> 0x90
        while (true) {
            int32_t v5 = v4;
            int32_t v6 = 0;
            if (v2 != 0) {
                // 0x94
                *(int32_t *)v2 = *(int32_t *)v1;
                *(int32_t *)(v2 + 4) = *(int32_t *)(v1 + 4);
                *(int32_t *)(v2 + 8) = *(int32_t *)(v1 + 8);
                *(int32_t *)(v2 + 12) = *(int32_t *)(v1 + 12);
                *(int32_t *)(v2 + 16) = *(int32_t *)(v1 + 16);
                *(int32_t *)(v2 + 20) = *(int32_t *)(v1 + 20);
                *(int32_t *)(v2 + 24) = *(int32_t *)(v1 + 24);
                *(int32_t *)(v2 + 28) = *(int32_t *)(v1 + 28);
                *(int32_t *)(v2 + 32) = *(int32_t *)(v1 + 32);
                *(int32_t *)(v2 + 36) = *(int32_t *)(v1 + 36);
                v5 = v3;
                v6 = v2;
                // branch -> 0xce
            }
            int32_t v7 = v1 + 40;
            if (v7 == v5) {
                // break -> 0xd8
                break;
            }
            v4 = v5;
            v1 = v7;
            v2 = v6 + 40;
            // continue -> 0x90
        }
        // 0xd8
        // branch -> 0xed
    }
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x110 - 0x227
// Line range:    38 - 571
// Demangled:     CAddrInfo::IsTerrible(long long) const
void _ZNK9CAddrInfo10IsTerribleEx(int32_t this, int64_t nNow) {
    uint32_t v1 = (int32_t)nNow;
    uint32_t v2 = *(int32_t *)(this + 36); // bp+137
    uint32_t v3 = *(int32_t *)(this + 32);
    int32_t v4;
    uint32_t v5; // bp+168
    uint32_t v6;
    int32_t v7;
    uint32_t v8;
    int32_t v9;
    int32_t v10;
    if ((v3 || v2) == 0) {
        // 0x168
        v5 = *(int32_t *)(this + 28);
        v6 = v4 + (int32_t)(v1 > 0xfffffda7);
        if (v6 >= 0) {
            // 0x1b8
            if (v6 == 0) {
                // 0x1ba
                if (v5 > v1 + 600) {
                    // 0x18b
                    // branch -> 0x190
                    // 0x1a1
                    return;
                }
            }
            // 0x1c0
            if (v5 != 0) {
                // 0x1cd
                v9 = (int32_t)(v1 < v5) + v4;
                if (v9 >= 0 != v9 != 0) {
                    // 0x1da
                    if (v9 >= 0) {
                        // 0x1dc
                        if (v1 - v5 >= 0x4f1a01) {
                            // 0x18b
                            // branch -> 0x190
                            // 0x1a1
                            return;
                        }
                    }
                    // 0x1e3
                    v7 = *(int32_t *)(this + 60);
                    v8 = *(int32_t *)(this + 56);
                    if ((v8 || v7) == 0) {
                        // 0x1ef
                        if (*(int32_t *)(this + 64) > 2) {
                            // 0x1a1
                            return;
                        }
                    }
                    // 0x1fa
                    v10 = (int32_t)(v1 < v8) + v4 - v7;
                    if (v10 >= 0) {
                        // 0x207
                        if (v10 <= 0) {
                            // 0x218
                            if (v1 - v8 < 0x93a81) {
                                // 0x220
                                // branch -> 0x190
                                // 0x1a1
                                return;
                            }
                        }
                        // 0x209
                        // branch -> 0x190
                    }
                    // 0x1a1
                    return;
                }
                // 0x18b
                // branch -> 0x190
            }
            // 0x1a1
            return;
        }
        // 0x18b
        // branch -> 0x190
    } else {
        uint32_t v11 = (int32_t)(v1 < 60) + v4;
        if (v2 <= v11) {
            // 0x160
            if (v2 >= v11) {
                // 0x162
                if (v3 >= v1 - 60) {
                    // 0x155
                    // branch -> 0x190
                    // 0x1a1
                    return;
                }
            }
            // 0x168
            v5 = *(int32_t *)(this + 28);
            v6 = v4 + (int32_t)(v1 > 0xfffffda7);
            if (v6 < 0) {
                // 0x18b
                // branch -> 0x190
                // 0x1a1
                return;
            }
            // 0x1b8
            if (v6 == 0) {
                // 0x1ba
                if (v5 > v1 + 600) {
                    // 0x18b
                    // branch -> 0x190
                    // 0x1a1
                    return;
                }
            }
            // 0x1c0
            if (v5 != 0) {
                // 0x1cd
                v9 = (int32_t)(v1 < v5) + v4;
                if (v9 >= 0 != v9 != 0) {
                    // 0x1da
                    if (v9 >= 0) {
                        // 0x1dc
                        if (v1 - v5 >= 0x4f1a01) {
                            // 0x18b
                            // branch -> 0x190
                            // 0x1a1
                            return;
                        }
                    }
                    // 0x1e3
                    v7 = *(int32_t *)(this + 60);
                    v8 = *(int32_t *)(this + 56);
                    if ((v8 || v7) == 0) {
                        // 0x1ef
                        if (*(int32_t *)(this + 64) > 2) {
                            // 0x1a1
                            return;
                        }
                    }
                    // 0x1fa
                    v10 = (int32_t)(v1 < v8) + v4 - v7;
                    if (v10 >= 0) {
                        // 0x207
                        if (v10 <= 0) {
                            // 0x218
                            if (v1 - v8 < 0x93a81) {
                                // 0x220
                                // branch -> 0x190
                                // 0x1a1
                                return;
                            }
                        }
                        // 0x209
                        // branch -> 0x190
                    }
                    // 0x1a1
                    return;
                }
                // 0x18b
                // branch -> 0x190
            }
            // 0x1a1
            return;
        }
        // 0x155
        // branch -> 0x190
    }
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x230 - 0x2ea
// Line range:    58 - 79
// Demangled:     CAddrInfo::GetChance(long long) const
void _ZNK9CAddrInfo9GetChanceEx(int32_t this, int64_t nNow) {
    int32_t v1 = g2; // bp+230
    uint32_t v2 = (int32_t)nNow;
    int32_t v3;
    g2 = (int32_t)(v2 < *(int32_t *)(this + 28)) + v3;
    uint32_t v4 = *(int32_t *)(this + 32); // bp+260
    int32_t v5 = v3 - *(int32_t *)(this + 36) + (int32_t)(v2 < v4); // bp+265
    int3_t v6 = g9 - 1;
    g9 = v6;
    int32_t v7;
    uint32_t v8;
    if (v5 < 0) {
        // 0x2e0
        // branch -> 0x2a0
        // 0x2a0
        v8 = *(int32_t *)(this + 64);
        if (v8 >= 1) {
            // 0x2a7
            v7 = 1;
            // branch -> 0x2b0
            while (v7 != v8) {
                // 0x2b0
                v7++;
                // continue -> 0x2b0
            }
            // 0x2b9
            g9 = v6;
            // branch -> 0x2bb
        }
        // 0x2c8
        g2 = v1;
        return;
    }
    // 0x29e
    if (v5 <= 0) {
        // 0x2d2
        if (v2 - v4 < 600) {
            // 0x2e0
            // branch -> 0x2a0
        }
    }
    // 0x2a0
    v8 = *(int32_t *)(this + 64);
    if (v8 >= 1) {
        // 0x2a7
        v7 = 1;
        // branch -> 0x2b0
        while (v7 != v8) {
            // 0x2b0
            v7++;
            // continue -> 0x2b0
        }
        // 0x2b9
        g9 = v6;
        // branch -> 0x2bb
    }
    // 0x2c8
    g2 = v1;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x2f0 - 0x346
// Line range:    81 - 92
// Demangled:     CAddrMan::Find(CNetAddr const &, int *)
void _ZN8CAddrMan4FindERK8CNetAddrPi(int32_t this, int32_t addr, int32_t * pnId) {
    // 0x2f0
    g2 = 0;
    int32_t v1;
    if (this + 128 == v1) {
        // bb
        function_39c(addr);
        // branch -> 0x338
    }
}

// Address range: 0x34a - 0x39c
int32_t function_34a(void) {
    int32_t * v1 = (int32_t *)(g3 - 0x7bebdbac);
    int32_t v2 = *v1 - 1;
    *v1 = v2;
    int32_t v3; // eax
    int32_t v4; // ecx
    int32_t v5;
    int32_t v6;
    int32_t * v7;
    if (v2 == 0) {
        int32_t v8 = 0;
        // branch -> 0x37a
      lab_0x37a:
        // 0x37a
        v5 = *(int32_t *)(v8 + 8);
        int32_t v9; // bp+396
        int32_t v10;
        if (v5 != 0) {
            // 0x37a
            v6 = g6;
            // branch -> 0x381
            // branch -> 0x381
          lab_0x381:
            while (true) {
                // 0x381
                if (*(int32_t *)(v5 + 16) < v6) {
                    int32_t v11 = *(int32_t *)(v5 + 12); // bp+386
                    if (v11 == 0) {
                        // break -> 0x38d
                        break;
                    }
                    v5 = v11;
                    // continue -> 0x381
                    continue;
                } else {
                    // 0x378
                    v4 = v5;
                    v8 = v5;
                    // branch -> 0x37a
                    goto lab_0x37a;
                }
                // 0x38d
                g2 = 0;
                int32_t v12 = g3;
                v10 = v4;
                v9 = v10;
                int32_t result; // bp+396
                if (v12 != v10) {
                    // 0x393
                    result = v9 + 20;
                    v3 = result;
                    return result;
                }
                int32_t v13 = function_39c((int32_t)&v7); // bp+391
                v3 = v13;
                int32_t v14 = v4;
                v9 = v14;
                // branch -> 0x393
                // 0x393
                result = v9 + 20;
                v3 = result;
                return result;
            }
            // 0x38d
            // branch -> 0x38d
        }
        // 0x38d
        g2 = 0;
        v10 = v4;
        v9 = v10;
        if (g3 == v10) {
            // bb114
            function_39c((int32_t)&v7);
            v9 = v4;
            // branch -> 0x393
        }
        // 0x393
        return v9 + 20;
    }
    char * v15 = (char *)(g2 - 0x74f68b0a); // bp+356
    *v15 = *v15 - (char)v3;
    g6++;
    char * v16 = (char *)(g3 - 0x76e7dbb4);
    *v16 = (char)v4 & *v16;
    int32_t * v17 = (int32_t *)(g3 - 0x12ce93bd); // bp+363
    *v17 = v4 + *v17;
    int32_t v18 = v3; // 0x3819
    if (v3 == 0) {
        // bb
        v18 = function_39c((int32_t)&v7);
        // branch -> 0x36d
    }
    int32_t v19 = g3 + (int32_t)&g22;
    g3 = v19;
    int32_t v20 = *(int32_t *)(g6 + 32); // bp+370
    g6 = v20;
    v4 = v19;
    v6 = v20;
    // branch -> 0x381
    // 0x381
    v5 = v18;
    // branch -> 0x381
    goto lab_0x381;
}

// Address range: 0x39c - 0x3c0
int32_t function_39c(int32_t a1) {
    int32_t v1 = *(int32_t *)20 ^ a1;
    g6 = v1;
    if (v1 != 0) {
        // 0x3b3
    }
    // 0x3ab
    return g2;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x3c0 - 0x410
// Line range:    371 - 388
// Demangled:     CAddrMan::Attempt_(CService const &, long long)
void _ZN8CAddrMan8Attempt_ERK8CServicex(int32_t this, int32_t addr, int64_t nTime) {
    // 0x3c0
    _ZN8CAddrMan4FindERK8CNetAddrPi(this, addr, NULL);
}

// Address range: 0x423 - 0x444
int32_t function_423(void) {
    // 0x423
    int32_t v1;
    int32_t result = *(int32_t *)20 ^ v1; // bp+427
    if (result != 0) {
        // 0x444
    }
    // 0x430
    return result;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x450 - 0x4a0
// Line range:    510 - 528
// Demangled:     CAddrMan::Connected_(CService const &, long long)
void _ZN8CAddrMan10Connected_ERK8CServicex(int32_t this, int32_t addr, int64_t nTime) {
    // 0x450
    _ZN8CAddrMan4FindERK8CNetAddrPi(this, addr, NULL);
}

// Address range: 0x4a4 - 0x4ba
int32_t function_4a4(void) {
    int32_t v1 = 0; // eax
    int32_t * v2 = (int32_t *)(v1 + 0x438b2b75 + 8 * v1);
    *v2 = *v2 + 1;
    char v3 = (char)v1 - 49;
    g1 = (int32_t)(v3 + (char)false) | v1 & -256;
    int32_t v4 = 0; // ecx
    char * v5 = (char *)(v4 - 0x76e3dbac);
    unsigned char v6 = *v5;
    unsigned char v7 = (char)v4 % 32;
    if (v7 != 0) {
        // bb
        *v5 = v6 << 8 - v7 | v6 >> v7;
        // branch -> bb97
    }
    // bb97
    return function_18244489();
}

// Address range: 0x4d1 - 0x4d2
int32_t function_4d1(void) {
    // 0x4d1
    return g1;
}

// Address range: 0x4d4 - 0x4f5
int32_t function_4d4(void) {
    // 0x4d4
    int32_t v1;
    if (*(int32_t *)20 != v1) {
        // 0x501
        return g1;
    }
    // 0x4e1
    return g1;
}

// Address range: 0x4f8 - 0x501
int32_t function_4f8(void) {
    // 0x4f8
    if ((uint32_t)g1 < 1201) {
        // bb
        g1 = function_4d4();
        // branch -> 0x4ff
    }
    // 0x4ff
    return function_4d1();
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x510 - 0x5a6
// Line range:    390 - 427
// Demangled:     CAddrMan::Select_(int)
void _ZN8CAddrMan7Select_Ei(int32_t this, int32_t nUnkBias) {
    int32_t v1 = *(int32_t *)(nUnkBias + 152) - *(int32_t *)(nUnkBias + 148); // bp+543
    g1 = v1 / 4;
    if (v1 < 4) {
        // bb
        g1 = function_80c(this);
        // branch -> 0x554
    }
    float80_t v2 = (float80_t)*(int32_t *)(nUnkBias + 160); // bp+554
    int3_t v3 = -2;
    g9 = v3;
    float80_t v4 = sqrtl(v2);
    float80_t v5 = v2; // bp+570
    if (v4 != v4 || 0.0L != 0.0L) {
        // bb123
        g1 = function_89b();
        v5 = v2;
        v3 = g9;
        // branch -> 0x566
    }
    // 0x566
    g9 = v3 - 2;
    float80_t v6 = sqrtl(v5 * (100.0L - v5)); // bp+582
    if (v6 != v6 || 0.0L != 0.0L) {
        // bb124
        function_878();
        // branch -> 0x58c
    }
}

// Address range: 0x5cf - 0x5d6
int32_t function_5cf(void) {
    // 0x5cf
    return function_860fdeb3();
}

// Address range: 0x5e0 - 0x5e1
int32_t function_5e0(int32_t a1) {
    // 0x5e0
    return g1;
}

// Address range: 0x61e - 0x67e
int32_t function_61e(int32_t a1) {
    int32_t * v1 = (int32_t *)(g3 + 0xf8b6c53);
    *v1 = *v1 - 1;
    int32_t v2 = 0; // edx
    int32_t v3;
    if (v2 == 0) {
        v3 = function_7e8();
        // branch -> 0x62c
    } else {
        // 0x61e
        v3 = g1;
        // branch -> 0x62c
    }
    int32_t v4 = 4 * v3;
    g5 = v4;
    int32_t v5 = g7;
    int32_t v6 = v5; // ecx
    int32_t v7 = *(int32_t *)v4; // bp+631
    g1 = v7;
    int32_t v8 = v5;
    int32_t v9 = v2;
    // branch -> 0x641
  lab_0x641:
    while (true) {
        int32_t v10 = v9; // bp+641
        // branch -> 0x641
        int32_t v11; // bp+655
        int32_t v12;
        int32_t v13;
        while (true) {
            // 0x641
            if (*(int32_t *)(v10 + 16) < v7) {
                int32_t v14 = *(int32_t *)(v10 + 12); // bp+646
                if (v14 == 0) {
                    v12 = v8;
                    // break -> 0x64d
                    break;
                }
                v10 = v14;
                // continue -> 0x641
                continue;
            } else {
                // 0x638
                v6 = v10;
                int32_t v15 = *(int32_t *)(v10 + 8);
                if (v15 == 0) {
                    v12 = v10;
                    // break (via goto) -> 0x64d
                    goto lab_0x64d;
                }
                v8 = v10;
                v9 = v15;
                // continue (via goto) -> 0x641
                goto lab_0x641;
            }
            v11 = v12;
            if (v5 == v12) {
                // bb115
                v13 = function_7e8();
                g1 = v13;
                int32_t v16 = v6;
                v7 = v13;
                v11 = v16;
                // branch -> 0x655
            }
            int32_t v17 = *(int32_t *)(v11 + 16); // bp+655
            int32_t v18; // bp+662
            int32_t result; // bp+669
            if (v17 <= v7) {
                // 0x65e
                v2 = a1;
                v18 = g5;
                result = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(a1, (int32_t *)v18);
                return result;
            }
            // bb116
            function_7e8();
            // branch -> 0x65e
            // 0x65e
            v2 = a1;
            v18 = g5;
            result = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(a1, (int32_t *)v18);
            return result;
        }
      lab_0x64d:
        // 0x64d
        v11 = v12;
        if (v5 == v12) {
            // bb115
            v13 = function_7e8();
            g1 = v13;
            v7 = v13;
            v11 = v6;
            // branch -> 0x655
        }
        // 0x655
        if (*(int32_t *)(v11 + 16) <= v7) {
            // 0x65e
            return _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(a1, (int32_t *)g5);
        }
        // bb116
        function_7e8();
        // branch -> 0x65e
        // 0x65e
        return _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(a1, (int32_t *)g5);
    }
}

// Address range: 0x682 - 0x6c4
int32_t function_682(float64_t a1) {
    int32_t * v1 = (int32_t *)0x4489243c; // bp+682
    *v1 = *v1 - 1;
    int32_t * v2;
    _ZNK9CAddrInfo9GetChanceEx(0, (int64_t)&v2);
    g1 = (int32_t)&v2;
    return function_5e0((int32_t)(float32_t)(1.2L * (float80_t)a1));
}

// Address range: 0x6c8 - 0x6c9
int32_t function_6c8(void) {
    // 0x6c8
    return g1;
}

// Address range: 0x724 - 0x72b
int32_t function_724(void) {
    // 0x724
    return function_870fe008();
}

// Address range: 0x75b - 0x76a
int32_t function_75b(void) {
    int32_t * v1 = (int32_t *)0xb493;
    *v1 = *v1 - 1;
    char * v2 = (char *)0x2c8d4004; // bp+761
    *v2 = (char)0 + *v2;
    return 0;
}

// Address range: 0x792 - 0x7df
int32_t function_792(void) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 - 0xf8a0001); // bp+792
    *v2 = *v2 + 1;
    int32_t v3 = *(int32_t *)(v1 + (int32_t)&g23); // bp+798
    int32_t result = g1;
    if (v3 == 0) {
        // 0x7c0
        return result;
    }
    // branch -> 0x7b5
    while (true) {
        int32_t v4 = v3;
        // branch -> 0x7b5
        int32_t v5; // edx
        while (true) {
            // 0x7b5
            int32_t v6;
            if (*(int32_t *)(v4 + 16) < *(int32_t *)(result + 16)) {
                // 0x7ba
                v6 = v4 + 12;
                // branch -> 0x7ad
            } else {
                // 0x7a8
                v6 = v4 + 8;
                // branch -> 0x7ad
            }
            int32_t v7 = *(int32_t *)v6;
            v5 = v7;
            if (v7 == 0) {
                // break -> bb
                break;
            }
            v4 = v7;
            // continue -> 0x7b5
        }
        // bb
        g1 = function_6c8();
        v3 = v5;
        // branch -> 0x7b5
    }
}

// Address range: 0x7e8 - 0x807
int32_t function_7e8(void) {
    // 0x7e8
    return g1;
}

// Address range: 0x80c - 0x813
int32_t function_80c(int32_t result) {
    // 0x80c
    return result;
}

// Address range: 0x818 - 0x833
int32_t function_818(void) {
    int32_t result;
    int32_t v1;
    if (*(int32_t *)20 != v1) {
        // bb
        result = function_873();
        // branch -> 0x829
    }
    // 0x829
    return result;
}

// Address range: 0x833 - 0x873
int32_t function_833(void) {
    // 0x833
    int32_t v1;
    *(int32_t *)v1 = g5;
    int32_t v2 = 0; // edx
    *(int32_t *)(v2 + 4) = *(int32_t *)(g5 + 4);
    *(int32_t *)(v2 + 8) = *(int32_t *)(g5 + 8);
    *(int32_t *)(v2 + 12) = *(int32_t *)(g5 + 12);
    *(int32_t *)(v2 + 16) = *(int32_t *)(g5 + 16);
    *(int32_t *)(v2 + 20) = *(int32_t *)(g5 + 20);
    *(int32_t *)(v2 + 24) = *(int32_t *)(g5 + 24);
    *(int32_t *)(v2 + 28) = *(int32_t *)(g5 + 28);
    *(int32_t *)(v2 + 32) = *(int32_t *)(g5 + 32);
    *(int32_t *)(v2 + 36) = *(int32_t *)(g5 + 36);
    return function_818();
}

// Address range: 0x873 - 0x874
int32_t function_873(void) {
    // 0x873
    return g1;
}

// Address range: 0x878 - 0x887
int32_t function_878(void) {
    // 0x878
    g9 ^= -4;
    return g1;
}

// Address range: 0x88c - 0x89b
float80_t function_88c(float64_t a1, int32_t a2) {
    // 0x88c
    return (int64_t)a2;
}

// Address range: 0x89b - 0x8a0
int32_t function_89b(void) {
    // 0x89b
    g9 += 2;
    return g1;
}

// Address range: 0x8a5 - 0x8aa
int32_t function_8a5(void) {
    // 0x8a5
    return 0;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x8b0 - 0x911
// Line range:    126 - 148
// Demangled:     CAddrMan::SelectTried(int)
void _ZN8CAddrMan11SelectTriedEi(int32_t this, int32_t nKBucket) {
    // 0x8b0
    g3 = 0;
    g2 = this + (int32_t)&g22;
    int32_t v1 = *(int32_t *)(this + 164) + 12 * nKBucket;
    g7 = v1;
    g5 = -1;
    if (*(int32_t *)(v1 + 4) - *(int32_t *)v1 < 4) {
        // bb
        function_962(-1, -1, this, this + 100);
        // branch -> 0x90c
    }
}

// Address range: 0x945 - 0x946
int32_t function_945(void) {
    // 0x945
    return g1;
}

// Address range: 0x955 - 0x95c
int32_t function_955(void) {
    int32_t v1 = 0; // ecx
    char * v2 = (char *)(v1 - 0x7ce3dbb4); // bp+955
    *v2 = (char)false + *v2 - (char)v1;
    return 0;
}

// Address range: 0x962 - 0x97d
int32_t function_962(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = g5;
    if (*(int32_t *)20 != a1) {
        // 0xa44
        return result;
    }
    // 0x975
    g3 = a2;
    g7 = a3;
    g5 = a4;
    return result;
}

// Address range: 0x980 - 0xa44
int32_t function_980(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4; // bp+52
    int32_t v2 = *(int32_t *)(a2 + (int32_t)&g23); // bp+984
    if (v2 == 0) {
        // 0xa20
        return 0;
    }
    int32_t v3 = g2; // bp+993
    int32_t v4 = v3;
    // branch -> 0x9a1
  lab_0x9a1:
    while (true) {
        int32_t v5 = v2;
        // branch -> 0x9a1
        int32_t result3; // 0xa3f14
        int32_t v6;
        int32_t v7;
        int32_t v8;
        while (true) {
            // 0x9a1
            if (*(int32_t *)(v5 + 16) < a4) {
                int32_t v9 = *(int32_t *)(v5 + 12);
                if (v9 == 0) {
                    result3 = v9;
                    v6 = v4;
                    // break -> 0x9ad
                    break;
                }
                v5 = v9;
                // continue -> 0x9a1
                continue;
            } else {
                int32_t v10 = *(int32_t *)(v5 + 8);
                if (v10 == 0) {
                    result3 = 0;
                    v6 = v5;
                    // break (via goto) -> 0x9ad
                    goto lab_0x9ad;
                }
                v4 = v5;
                v2 = v10;
                // continue (via goto) -> 0x9a1
                goto lab_0x9a1;
            }
            // 0x9ad
            int32_t result;
            if (v6 == v3) {
                result = result3;
                // 0xa20
                return result;
            }
            int32_t v11 = *(int32_t *)(v6 + 16);
            if (v11 > a4) {
                result = result3;
                // 0xa20
                return result;
            }
            // 0x9b6
            v7 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(a3, &v1);
            int32_t v12 = *(int32_t *)(v7 + 60);
            v8 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(a3, &a1);
            g1 = v8;
            int32_t v13 = *(int32_t *)(v8 + 60);
            int32_t result2;
            if (v12 >= v13) {
                // 0xa07
                result2 = function_945();
                return result2;
            }
            // bb
            g1 = function_945();
            // branch -> 0xa07
            // 0xa07
            result2 = function_945();
            return result2;
        }
      lab_0x9ad:
        // 0x9ad
        if (v6 == v3 || *(int32_t *)(v6 + 16) > a4) {
            // 0xa20
            return result3;
        }
        // 0x9b6
        v7 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(a3, &v1);
        v8 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(a3, &a1);
        g1 = v8;
        if (*(int32_t *)(v7 + 60) >= *(int32_t *)(v8 + 60)) {
            // 0xa07
            return function_945();
        }
        // bb
        g1 = function_945();
        // branch -> 0xa07
        // 0xa07
        return function_945();
    }
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0xa50 - 0xbc7
// Line range:    106 - 124
// Demangled:     CAddrMan::SwapRandom(unsigned int, unsigned int)
void _ZN8CAddrMan10SwapRandomEjj(int32_t this, uint32_t nRndPos1, int32_t nRndPos2) {
    int32_t v1 = g2;
    int32_t v2 = g5;
    int32_t v3 = g7;
    int32_t v4 = g3;
    g7 = nRndPos1;
    g3 = this;
    if (nRndPos1 != nRndPos2) {
        int32_t v5 = *(int32_t *)(this + 148);
        int32_t v6 = (*(int32_t *)(this + 152) - v5) / 4;
        g1 = v6;
        int32_t v7 = v6;
        if (v6 <= nRndPos1) {
            int32_t v8 = function_bcc(nRndPos2);
            g1 = v8;
            v7 = v8;
            // branch -> 0xa95
        }
        // 0xa95
        if (v7 <= nRndPos2) {
            // bb48
            function_bcc(nRndPos2);
            // branch -> 0xa9f
        }
        int32_t v9 = *(int32_t *)(4 * g7 + v5);
        int32_t v10 = v9; // bp-40
        int32_t v11 = *(int32_t *)(v5 + 4 * nRndPos2);
        g5 = v11;
        int32_t v12 = g3;
        int32_t v13 = *(int32_t *)(v12 + (int32_t)&g23);
        int32_t v14 = v11; // bp-36
        if (v13 == 0) {
            // 0xba8
            return;
        }
        int32_t v15 = v12 + (int32_t)&g22;
        g2 = v15;
        // branch -> 0xad9
      lab_0xad9:
        while (true) {
            int32_t v16 = v13;
            // branch -> 0xad9
            while (true) {
                // 0xad9
                if (v9 > *(int32_t *)(v16 + 16)) {
                    int32_t v17 = *(int32_t *)(v16 + 12);
                    if (v17 == 0) {
                        // break -> 0xae5
                        break;
                    }
                    v16 = v17;
                    // continue -> 0xad9
                    continue;
                } else {
                    // 0xad0
                    g2 = v16;
                    int32_t v18 = *(int32_t *)(v16 + 8);
                    if (v18 == 0) {
                        // break (via goto) -> 0xae5
                        goto lab_0xae5;
                    }
                    v13 = v18;
                    // continue (via goto) -> 0xad9
                    goto lab_0xad9;
                }
              lab_0xae5:
                // 0xae5
                if (v15 == v16 || v9 < *(int32_t *)(v16 + 16)) {
                    // 0xba8
                    return;
                }
                int32_t v19 = v15;
                // branch -> 0xb09
              lab_0xb09:
                while (true) {
                    int32_t v20 = v13;
                    // branch -> 0xb09
                    int32_t v21;
                    int32_t v22;
                    int32_t v23;
                    int32_t v24;
                    int32_t v25;
                    while (true) {
                        // 0xb09
                        if (v11 > *(int32_t *)(v20 + 16)) {
                            int32_t v26 = *(int32_t *)(v20 + 12);
                            if (v26 == 0) {
                                v21 = v19;
                                // break -> 0xb15
                                break;
                            }
                            v20 = v26;
                            // continue -> 0xb09
                            continue;
                        } else {
                            int32_t v27 = *(int32_t *)(v20 + 8);
                            if (v27 == 0) {
                                v21 = v20;
                                // break (via goto) -> 0xb15
                                goto lab_0xb15;
                            }
                            v19 = v20;
                            v13 = v27;
                            // continue (via goto) -> 0xb09
                            goto lab_0xb09;
                        }
                        // 0xb15
                        int32_t v28; // eax
                        int32_t v29; // ecx
                        int32_t v30; // edx
                        int32_t v31;
                        int32_t v32;
                        int32_t v33;
                        int32_t v34;
                        int32_t v35;
                        int32_t v36;
                        int32_t v37;
                        int32_t v38;
                        int32_t v39;
                        if (v15 != v21) {
                            uint32_t v40 = *(int32_t *)(v21 + 16);
                            if (v11 >= v40) {
                                // 0xb48
                                v22 = v12 + 100;
                                g5 = v22;
                                v28 = &v10;
                                v24 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v22, &v10);
                                v29 = nRndPos2;
                                *(int32_t *)(v24 + 76) = nRndPos2;
                                v28 = &v14;
                                v31 = g5;
                                v25 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v31, &v14);
                                v28 = v25;
                                v38 = v14;
                                v30 = v38;
                                v29 = nRndPos2;
                                v32 = g7;
                                *(int32_t *)(v25 + 76) = v32;
                                v33 = g3;
                                v23 = *(int32_t *)(v33 + 148);
                                v28 = v23;
                                v34 = v30;
                                v36 = g7;
                                *(int32_t *)(4 * v36 + v23) = v34;
                                v39 = v10;
                                v30 = v39;
                                v35 = v28;
                                v37 = v29;
                                *(int32_t *)(4 * v37 + v35) = v39;
                                // branch -> 0xb8d
                                // 0xb8d
                                int32_t v41;
                                v28 = v41;
                                g1 = 0;
                                // 0xb9a
                                g3 = v4;
                                g7 = v3;
                                g5 = v2;
                                g2 = v1;
                                return;
                            }
                        }
                        // 0xb20
                        // branch -> 0xb48
                        // 0xb48
                        v22 = v12 + 100;
                        g5 = v22;
                        v28 = &v10;
                        v24 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v22, &v10);
                        v29 = nRndPos2;
                        *(int32_t *)(v24 + 76) = nRndPos2;
                        v28 = &v14;
                        v31 = g5;
                        v25 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v31, &v14);
                        v28 = v25;
                        v38 = v14;
                        v30 = v38;
                        v29 = nRndPos2;
                        v32 = g7;
                        *(int32_t *)(v25 + 76) = v32;
                        v33 = g3;
                        v23 = *(int32_t *)(v33 + 148);
                        v28 = v23;
                        v34 = v30;
                        v36 = g7;
                        *(int32_t *)(4 * v36 + v23) = v34;
                        v39 = v10;
                        v30 = v39;
                        v35 = v28;
                        v37 = v29;
                        *(int32_t *)(4 * v37 + v35) = v39;
                        // branch -> 0xb8d
                    }
                  lab_0xb15:
                    // 0xb15
                    if (v15 != v21) {
                        // 0xb1b
                        if (v11 >= *(int32_t *)(v21 + 16)) {
                            // 0xb48
                            v22 = v12 + 100;
                            g5 = v22;
                            v24 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v22, &v10);
                            *(int32_t *)(v24 + 76) = nRndPos2;
                            v25 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(g5, &v14);
                            *(int32_t *)(v25 + 76) = g7;
                            v23 = *(int32_t *)(g3 + 148);
                            *(int32_t *)(4 * g7 + v23) = v14;
                            *(int32_t *)(4 * nRndPos2 + v23) = v10;
                            // branch -> 0xb8d
                            // 0xb8d
                            g1 = 0;
                            // 0xb9a
                            g3 = v4;
                            g7 = v3;
                            g5 = v2;
                            g2 = v1;
                            return;
                        }
                    }
                    // 0xb20
                    // branch -> 0xb48
                    // 0xb48
                    v22 = v12 + 100;
                    g5 = v22;
                    v24 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v22, &v10);
                    *(int32_t *)(v24 + 76) = nRndPos2;
                    v25 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(g5, &v14);
                    *(int32_t *)(v25 + 76) = g7;
                    v23 = *(int32_t *)(g3 + 148);
                    *(int32_t *)(4 * g7 + v23) = v14;
                    *(int32_t *)(4 * nRndPos2 + v23) = v10;
                    // branch -> 0xb8d
                }
            }
        }
    }
    // 0xb8d
    g1 = 0;
    // 0xb9a
    g3 = v4;
    g7 = v3;
    g5 = v2;
    g2 = v1;
}

// Address range: 0xbcc - 0xbf0
int32_t function_bcc(int32_t a1) {
    // 0xbcc
    return g1;
}

// Address range: 0xbf0 - 0xbf1
int32_t function_bf0(void) {
    // 0xbf0
    return g1;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0xc00 - 0xc7a
// Line range:    494 - 508
// Demangled:     CAddrMan::GetAddr_(std::vector<CAddress, std::allocator<CAddress> > &)
void _ZN8CAddrMan8GetAddr_ERSt6vectorI8CAddressSaIS1_EE(int32_t this, int32_t vAddr) {
    // 0xc00
    g3 = this;
    int32_t v1 = *(int32_t *)(this + 152);
    int32_t v2 = *(int32_t *)(this + 148);
    g5 = v2;
    uint32_t v3 = (int32_t)(0x51eb851f * (23 * (int64_t)((v1 - v2) / 4) & 0xffffffff) / 0x2000000000);
    if (v3 == 0 && v3 >= 2500 != v3 != 2500) {
        // bb
        function_d95(0);
        // branch -> 0xc5a
    }
}

// Address range: 0xc7e - 0xd95
int32_t function_c7e(uint32_t a1, uint32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)-0x76fbdb94;
    *v1 = *v1 - 1;
    int32_t v2 = 0;
    uint32_t v3 = (v2 + 220 + (int32_t)false) % 256 | v2 & -256;
    char * v4;
    int32_t * v5;
    _ZN8CAddrMan10SwapRandomEjj(v3 + g2, (int32_t)v4, (int32_t)&v5);
    int32_t v6 = g3;
    int32_t v7 = *(int32_t *)(v6 + (int32_t)&g23);
    int32_t v8 = *(int32_t *)(v6 + 148);
    int32_t result;
    if (v7 == 0) {
        // 0xd7c
        g2++;
        result = _ZNSt6vectorI8CAddressSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_((int32_t *)g7, v8, 0);
        return result;
    }
    int32_t v9 = 4 * g2 + v8;
    g5 = v9;
    int32_t * v10 = (int32_t *)v9;
    int32_t v11 = *v10;
    int32_t v12 = a1;
    // branch -> 0xcb9
  lab_0xcb9:
    while (true) {
        int32_t v13 = v7;
        // branch -> 0xcb9
        int32_t result4; // eax
        int32_t v14; // edx
        int32_t v15;
        int32_t v16;
        int32_t v17;
        int32_t v18; // 0xd7c16
        uint32_t v19;
        int32_t v20;
        int32_t v21;
        int32_t result3;
        int32_t v22;
        while (true) {
            // 0xcb9
            if (v11 > *(int32_t *)(v13 + 16)) {
                int32_t v23 = *(int32_t *)(v13 + 12);
                if (v23 == 0) {
                    v18 = v23;
                    v19 = v12;
                    // break -> 0xcc5
                    break;
                }
                v13 = v23;
                // continue -> 0xcb9
                continue;
            } else {
                int32_t v24 = *(int32_t *)(v13 + 8);
                if (v24 == 0) {
                    v18 = 0;
                    v19 = v13;
                    // break (via goto) -> 0xcc5
                    goto lab_0xcc5;
                }
                v12 = v13;
                v7 = v24;
                // continue (via goto) -> 0xcb9
                goto lab_0xcb9;
            }
            // 0xcc5
            int32_t v25;
            int32_t v26;
            int32_t v27;
            int32_t v28;
            if (v19 == a1) {
                v27 = v11;
                v25 = v18;
                // 0xd7c
                v26 = g2;
                g2 = v26 + 1;
                v28 = g7;
                result = _ZNSt6vectorI8CAddressSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_((int32_t *)v28, v27, v25);
                result4 = result;
                return result;
            }
            uint32_t v29 = *(int32_t *)(v19 + 16);
            if (v11 < v29) {
                v27 = v11;
                v25 = v18;
                // 0xd7c
                v26 = g2;
                g2 = v26 + 1;
                v28 = g7;
                result = _ZNSt6vectorI8CAddressSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_((int32_t *)v28, v27, v25);
                result4 = result;
                return result;
            }
            // 0xcd8
            result4 = a3;
            v22 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(a3, v10);
            result4 = v22;
            v15 = g7;
            v20 = *(int32_t *)(v15 + 4);
            v14 = v20;
            uint32_t v30 = *(int32_t *)(v15 + 8);
            if (v20 == v30) {
                v27 = v20;
                v25 = v22;
                // 0xd7c
                v26 = g2;
                g2 = v26 + 1;
                v28 = g7;
                result = _ZNSt6vectorI8CAddressSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_((int32_t *)v28, v27, v25);
                result4 = result;
                return result;
            }
            // 0xcf4
            v17 = 40;
            if (v20 != 0) {
                int32_t v31 = *(int32_t *)v22;
                *(int32_t *)v20 = v31;
                int32_t v32 = result4;
                int32_t v33 = *(int32_t *)(v32 + 4);
                int32_t v34 = v14;
                *(int32_t *)(v34 + 4) = v33;
                int32_t v35 = result4;
                int32_t v36 = *(int32_t *)(v35 + 8);
                int32_t v37 = v14;
                *(int32_t *)(v37 + 8) = v36;
                int32_t v38 = result4;
                int32_t v39 = *(int32_t *)(v38 + 12);
                int32_t v40 = v14;
                *(int32_t *)(v40 + 12) = v39;
                int32_t v41 = result4;
                int32_t v42 = *(int32_t *)(v41 + 16);
                int32_t v43 = v14;
                *(int32_t *)(v43 + 16) = v42;
                int32_t v44 = result4;
                int32_t v45 = *(int32_t *)(v44 + 20);
                int32_t v46 = v14;
                *(int32_t *)(v46 + 20) = v45;
                int32_t v47 = result4;
                int32_t v48 = *(int32_t *)(v47 + 24);
                int32_t v49 = v14;
                *(int32_t *)(v49 + 24) = v48;
                int32_t v50 = result4;
                int32_t v51 = *(int32_t *)(v50 + 28);
                int32_t v52 = v14;
                *(int32_t *)(v52 + 28) = v51;
                int32_t v53 = result4;
                int32_t v54 = *(int32_t *)(v53 + 32);
                int32_t v55 = v14;
                *(int32_t *)(v55 + 32) = v54;
                int32_t v56 = result4;
                v21 = *(int32_t *)(v56 + 36);
                result4 = v21;
                int32_t v57 = v14;
                *(int32_t *)(v57 + 36) = v21;
                v16 = g7;
                int32_t v58 = *(int32_t *)(v16 + 4);
                int32_t v59 = v58 + 40;
                v15 = v16;
                v17 = v59;
                // branch -> 0xd37
            }
            int32_t v60 = g2;
            uint32_t v61 = v60 + 1;
            *(int32_t *)(v15 + 4) = v17;
            int32_t result2;
            if (v61 == a2) {
                // bb
                result3 = function_d95(a3);
                result4 = result3;
                result2 = result3;
                // branch -> 0xd46
                // 0xd46
                return result2;
            }
            int32_t v62 = result4;
            result2 = v62;
            // branch -> 0xd46
            // 0xd46
            return result2;
        }
      lab_0xcc5:
        // 0xcc5
        if (v19 == a1 || v11 < *(int32_t *)(v19 + 16)) {
            // 0xd7c
            g2++;
            result = _ZNSt6vectorI8CAddressSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_((int32_t *)g7, v11, v18);
            return result;
        }
        // 0xcd8
        v22 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(a3, v10);
        result4 = v22;
        v15 = g7;
        v20 = *(int32_t *)(v15 + 4);
        v14 = v20;
        if (v20 == *(int32_t *)(v15 + 8)) {
            // 0xd7c
            g2++;
            result = _ZNSt6vectorI8CAddressSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_((int32_t *)g7, v20, v22);
            return result;
        }
        // 0xcf4
        v17 = 40;
        if (v20 != 0) {
            // 0xcfa
            *(int32_t *)v20 = *(int32_t *)v22;
            *(int32_t *)(v14 + 4) = *(int32_t *)(result4 + 4);
            *(int32_t *)(v14 + 8) = *(int32_t *)(result4 + 8);
            *(int32_t *)(v14 + 12) = *(int32_t *)(result4 + 12);
            *(int32_t *)(v14 + 16) = *(int32_t *)(result4 + 16);
            *(int32_t *)(v14 + 20) = *(int32_t *)(result4 + 20);
            *(int32_t *)(v14 + 24) = *(int32_t *)(result4 + 24);
            *(int32_t *)(v14 + 28) = *(int32_t *)(result4 + 28);
            *(int32_t *)(v14 + 32) = *(int32_t *)(result4 + 32);
            v21 = *(int32_t *)(result4 + 36);
            result4 = v21;
            *(int32_t *)(v14 + 36) = v21;
            v16 = g7;
            v15 = v16;
            v17 = *(int32_t *)(v16 + 4) + 40;
            // branch -> 0xd37
        }
        // 0xd37
        *(int32_t *)(v15 + 4) = v17;
        if (g2 + 1 == a2) {
            // bb
            result3 = function_d95(a3);
            // branch -> 0xd46
            // 0xd46
            return result3;
        }
        // 0xd37
        // branch -> 0xd46
        // 0xd46
        return result4;
    }
}

// Address range: 0xd95 - 0xdaa
int32_t function_d95(int32_t a1) {
    int32_t result = *(int32_t *)20 ^ a1;
    if (result != 0) {
        // 0xdaa
    }
    // 0xda2
    return result;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0xdb0 - 0xe71
// Line range:    150 - 202
// Demangled:     CAddrMan::ShrinkNew(int)
void _ZN8CAddrMan9ShrinkNewEi(int32_t this, int32_t nUBucket) {
    int32_t v1 = *(int32_t *)20;
    g1 = 0;
    g7 = this;
    if (nUBucket < 0) {
        // bb
        function_11be(v1);
        this = g7;
        // branch -> 0xdd3
    }
    int32_t v2 = *(int32_t *)(this + 180);
    int32_t v3 = -0x55555555 * (*(int32_t *)(this + 184) - v2) / 8;
    g1 = v3;
    if (v3 <= nUBucket) {
        // bb32
        function_11be(v1);
        // branch -> 0xdf2
    }
    int32_t v4 = v2 + 24 * nUBucket;
    int32_t v5 = *(int32_t *)(v4 + 12);
    g3 = v5;
    int32_t v6 = v4 + 4;
    g2 = v6;
    if (v5 == v6) {
        // bb33
        function_ea4(v4);
        // branch -> 0xe0c
    }
    int32_t v7 = g7;
    int32_t v8 = v7 + 100;
    int32_t v9 = v7 + (int32_t)&g22;
    g5 = v9;
    int32_t v10 = *(int32_t *)(v7 + (int32_t)&g23);
    g1 = v10;
    int32_t v11 = v10; // 0xe397
    if (v10 == 0) {
        // bb34
        v11 = function_f68(v8);
        v9 = g5;
        // branch -> 0xe23
    }
    int32_t v12 = *(int32_t *)(g3 + 16);
    int32_t v13 = v9; // ecx
    int32_t v14 = v9;
    // branch -> 0xe39
  lab_0xe39:
    while (true) {
        int32_t v15 = v11;
        // branch -> 0xe39
        int32_t v16;
        int32_t v17;
        while (true) {
            // 0xe39
            if (*(int32_t *)(v15 + 16) < v12) {
                int32_t v18 = *(int32_t *)(v15 + 12);
                g1 = v18;
                if (v18 == 0) {
                    v17 = v14;
                    // break -> 0xe45
                    break;
                }
                v15 = v18;
                // continue -> 0xe39
                continue;
            } else {
                // 0xe30
                v13 = v15;
                int32_t v19 = *(int32_t *)(v15 + 8);
                g1 = v19;
                if (v19 == 0) {
                    v17 = v15;
                    // break (via goto) -> 0xe45
                    goto lab_0xe45;
                }
                v14 = v15;
                v11 = v19;
                // continue (via goto) -> 0xe39
                goto lab_0xe39;
            }
            int32_t v20 = v12;
            v16 = v17;
            if (v9 == v17) {
                // bb35
                g1 = function_f68(v8);
                int32_t v21 = v13;
                int32_t v22; // edx
                int32_t v23 = v22;
                v20 = v23;
                v16 = v21;
                // branch -> 0xe4d
            }
            int32_t v24 = *(int32_t *)(v16 + 16);
            int32_t v25;
            if (v24 <= v20) {
                // 0xe56
                v25 = g3;
                v13 = v8;
                _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v8, (int32_t *)(v25 + 16));
                return;
            }
            // bb36
            function_f68(v8);
            // branch -> 0xe56
            // 0xe56
            v25 = g3;
            v13 = v8;
            _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v8, (int32_t *)(v25 + 16));
            return;
        }
      lab_0xe45:
        // 0xe45
        v16 = v17;
        if (v9 == v17) {
            // bb35
            g1 = function_f68(v8);
            v16 = v13;
            // branch -> 0xe4d
        }
        // 0xe4d
        if (*(int32_t *)(v16 + 16) <= v12) {
            // 0xe56
            _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v8, (int32_t *)(g3 + 16));
            return;
        }
        // bb36
        function_f68(v8);
        // branch -> 0xe56
        // 0xe56
        _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v8, (int32_t *)(g3 + 16));
        return;
    }
}

// Address range: 0xe9d - 0xe9e
int32_t function_e9d(void) {
    // 0xe9d
    return 0;
}

// Address range: 0xea4 - 0xeae
int32_t function_ea4(int32_t a1) {
    // 0xea4
    return *(int32_t *)(a1 + 20);
}

// Address range: 0xeb2 - 0xebb
int32_t function_eb2(void) {
    int32_t * v1 = (int32_t *)-0x76dfdbb4;
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xeee - 0xf25
int32_t function_eee(int32_t a1, int32_t a2) {
    // 0xeee
    g6 = a1;
    int32_t v1 = *(int32_t *)(a2 + 12);
    g5 = v1;
    if (v1 == g2) {
        // bb
        g1 = function_1030(g1);
        a1 = g6;
        // branch -> 0xf0d
    }
    int32_t v2 = g7;
    g3 = 0;
    g7 = a1;
    return function_f4f(v2 + (int32_t)&g22);
}

// Address range: 0xf28 - 0xf3a
int32_t function_f28(void) {
    // 0xf28
    return g1;
}

// Address range: 0xf3a - 0xf40
int32_t function_f3a(int32_t a1) {
    // 0xf3a
    g3++;
    return g1;
}

// Address range: 0xf4f - 0xf63
int32_t function_f4f(int32_t a1) {
    // 0xf4f
    if (g3 != g7) {
        // bb
        function_f28();
        // branch -> 0xf53
    }
    // 0xf53
    if (a1 != -1) {
        // bb1
        function_f90();
        // branch -> 0xf5a
    }
    int32_t v1 = *(int32_t *)(g5 + 16);
    g1 = v1;
    return function_f3a(v1);
}

// Address range: 0xf68 - 0xf87
int32_t function_f68(int32_t a1) {
    // 0xf68
    return g1;
}

// Address range: 0xf90 - 0x1027
int32_t function_f90(void) {
    // 0xf90
    int32_t v1;
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g23);
    if (v2 == 0) {
        // 0x1003
        return 0;
    }
    int32_t * v3 = (int32_t *)(g5 + 16);
    int32_t v4 = *v3;
    int32_t v5;
    int32_t v6 = v5;
    // branch -> 0xfb1
  lab_0xfb1:
    while (true) {
        int32_t v7 = v2;
        // branch -> 0xfb1
        int32_t v8; // bp+56
        int32_t v9;
        int32_t v10;
        int32_t result2; // 0x102014
        uint32_t v11;
        int32_t result4;
        int32_t result3;
        while (true) {
            // 0xfb1
            if (v4 > *(int32_t *)(v7 + 16)) {
                int32_t v12 = *(int32_t *)(v7 + 12);
                if (v12 == 0) {
                    result2 = v12;
                    v10 = v6;
                    // break -> 0xfbd
                    break;
                }
                v7 = v12;
                // continue -> 0xfb1
                continue;
            } else {
                int32_t v13 = *(int32_t *)(v7 + 8);
                if (v13 == 0) {
                    result2 = 0;
                    v10 = v7;
                    // break (via goto) -> 0xfbd
                    goto lab_0xfbd;
                }
                v6 = v7;
                v2 = v13;
                // continue (via goto) -> 0xfb1
                goto lab_0xfb1;
            }
            // 0xfbd
            int32_t result; // 0x1003
            if (v5 == v10) {
                result = result2;
                // 0x1003
                return result;
            }
            int32_t v14 = *(int32_t *)(v10 + 16);
            if (v4 < v14) {
                result = result2;
                // 0x1003
                return result;
            }
            int32_t v15 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v9, v3);
            v11 = *(int32_t *)(v15 + 28);
            v8 = 0;
            result3 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v9, &v8);
            g1 = result3;
            uint32_t v16 = *(int32_t *)(result3 + 28);
            result = result3;
            if (v11 < v16) {
                // 0x1003
                return result;
            }
            // bb
            result4 = function_f3a(v11);
            result = result4;
            // branch -> 0x1003
            // 0x1003
            return result;
        }
      lab_0xfbd:
        // 0xfbd
        if (v5 == v10 || v4 < *(int32_t *)(v10 + 16)) {
            // 0x1003
            return result2;
        }
        // 0xfc8
        v11 = *(int32_t *)(_ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v9, v3) + 28);
        result3 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v9, &v8);
        g1 = result3;
        if (v11 < *(int32_t *)(result3 + 28)) {
            // 0x1003
            return result3;
        }
        // bb
        result4 = function_f3a(v11);
        // branch -> 0x1003
        // 0x1003
        return result4;
    }
}

// Address range: 0x1030 - 0x10d9
int32_t function_1030(int32_t a1) {
    int32_t v1 = g7; // 0x1030
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g23); // 0x1030
    if (v2 == 0) {
        // 0x10ba
        return 0;
    }
    int32_t v3 = v1 + (int32_t)&g22; // 0x103b
    int32_t v4 = v3;
    // branch -> 0x1051
  lab_0x1051:
    while (true) {
        int32_t v5 = v2; // 0x1051
        // branch -> 0x1051
        int32_t v6; // bp+56
        int32_t v7;
        int32_t v8;
        int32_t v9; // 0x1061
        int32_t v10; // 0x106a
        int32_t v11; // 0x107e
        int32_t * v12; // 0x107b
        int32_t v13; // 0x10a5
        int32_t result4; // 0x10ac
        int32_t result3; // 0x10d214
        int32_t v14; // 0x1074
        while (true) {
            // 0x1051
            if (v8 > *(int32_t *)(v5 + 16)) {
                int32_t v15 = *(int32_t *)(v5 + 12); // 0x1056
                if (v15 == 0) {
                    result3 = v15;
                    v9 = v4;
                    // break -> 0x105d
                    break;
                }
                v5 = v15;
                // continue -> 0x1051
                continue;
            } else {
                int32_t v16 = *(int32_t *)(v5 + 8); // 0x104a
                if (v16 == 0) {
                    result3 = 0;
                    v9 = v5;
                    // break (via goto) -> 0x105d
                    goto lab_0x105d;
                }
                v4 = v5;
                v2 = v16;
                // continue (via goto) -> 0x1051
                goto lab_0x1051;
            }
            // 0x105d
            int32_t result; // 0x10d2
            if (v3 == v9) {
                result = result3;
                // 0x10ba
                return result;
            }
            int32_t v17 = *(int32_t *)(v9 + 16); // 0x1061
            if (v8 < v17) {
                result = result3;
                // 0x10ba
                return result;
            }
            // 0x1066
            g3 = &v6;
            v10 = v1 + 100;
            g5 = v10;
            v14 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v10, &v6);
            g2 = v14;
            v12 = (int32_t *)(v14 + 68);
            int32_t v18 = *v12; // 0x107b
            v11 = v18 - 1;
            *v12 = v11;
            if (v11 == 0) {
                // bb
                function_116b();
                // branch -> 0x108c
            }
            // 0x108c
            _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE5eraseERKi(a1, &v6);
            g1 = 1;
            int32_t v19 = *(int32_t *)20; // 0x10a5
            v13 = v19 ^ v7;
            g6 = v13;
            int32_t result2 = 1; // 0x10b9
            if (v13 == 0) {
                // 0x10b2
                return result2;
            }
            // bb34
            result4 = function_11e2();
            result2 = result4;
            // branch -> 0x10b2
            // 0x10b2
            return result2;
        }
      lab_0x105d:
        // 0x105d
        if (v3 == v9 || v8 < *(int32_t *)(v9 + 16)) {
            // 0x10ba
            return result3;
        }
        // 0x1066
        g3 = &v6;
        v10 = v1 + 100;
        g5 = v10;
        v14 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v10, &v6);
        g2 = v14;
        v12 = (int32_t *)(v14 + 68);
        v11 = *v12 - 1;
        *v12 = v11;
        if (v11 == 0) {
            // bb
            function_116b();
            // branch -> 0x108c
        }
        // 0x108c
        _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE5eraseERKi(a1, &v6);
        g1 = 1;
        v13 = *(int32_t *)20 ^ v7;
        g6 = v13;
        if (v13 == 0) {
            // 0x10b2
            return 1;
        }
        // bb34
        result4 = function_11e2();
        // branch -> 0x10b2
        // 0x10b2
        return result4;
    }
}

// Address range: 0x10ef - 0x10f0
int32_t function_10ef(void) {
    // 0x10ef
    return g1;
}

// Address range: 0x1102 - 0x116b
int32_t function_1102(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(g3 + 0x3120244c); // 0x1102
    *v1 = *v1 - 1;
    *(char *)(g3 - 0x14feeb97) = -1;
    int32_t v2 = g7; // 0x110f
    int32_t v3 = *(int32_t *)(v2 + 152); // 0x110f
    int32_t v4 = *(int32_t *)76; // 0x1125
    _ZN8CAddrMan10SwapRandomEjj(v2, v4, (v3 - *(int32_t *)(v2 + 148)) / 4 - 1);
    int32_t * v5 = (int32_t *)(g7 + 152); // 0x1138
    *v5 = *v5 - 4;
    _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE5eraseERS2_(g7 + 124, a1);
    g1 = _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE5eraseERS1_(a3, (int32_t *)a2);
    int32_t * v6 = (int32_t *)(g7 + 176); // 0x1162
    *v6 = *v6 - 1;
    return function_10ef();
}

// Address range: 0x116b - 0x11be
int32_t function_116b(void) {
    int32_t v1 = g7; // 0x116b
    int32_t v2 = *(int32_t *)(v1 + 148); // 0x1171
    int32_t v3 = *(int32_t *)(g2 + 76); // 0x1181
    _ZN8CAddrMan10SwapRandomEjj(v1, v3, (*(int32_t *)(v1 + 152) - v2) / 4 - 1);
    int32_t v4 = g7; // 0x1190
    int32_t * v5 = (int32_t *)(v4 + 152); // 0x1193
    *v5 = *v5 - 4;
    _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE5eraseERS2_(v4 + 124, g2);
    int32_t result = _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE5eraseERS1_(g5, (int32_t *)g3); // eax
    int32_t * v6 = (int32_t *)(g7 + 176); // 0x11b2
    *v6 = *v6 - 1;
    return result;
}

// Address range: 0x11be - 0x11dd
int32_t function_11be(int32_t a1) {
    // 0x11be
    return g1;
}

// Address range: 0x11e2 - 0x11e3
int32_t function_11e2(void) {
    // 0x11e2
    return g1;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x11f0 - 0x1320
// Line range:    94 - 104
// Demangled:     CAddrMan::Create(CAddress const &, CNetAddr const &, int *)
void _ZN8CAddrMan6CreateERK8CAddressRK8CNetAddrPi(int32_t this, int32_t addr, int32_t addrSource, int32_t * pnId) {
    // 0x11f0
    g2 = this;
    g3 = addr;
    g7 = addrSource;
    int32_t * v1 = (int32_t *)(this + (int32_t)&g21); // 0x122e
    int32_t v2 = *v1; // 0x122e
    int32_t v3 = v2; // bp-136
    *v1 = v2 + 1;
    int32_t v4 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(g2 + 100, &v3); // 0x1249
    int32_t v5 = *(int32_t *)g3; // bp-132
    __asm_rep_movsd_memcpy((char *)v4, (char *)&v5, 20);
    *(int32_t *)(v4 + 32) = 0;
    *(int32_t *)(v4 + 36) = 0;
    *(int32_t *)(v4 + 56) = 0;
    *(int32_t *)(v4 + 60) = 0;
    *(int32_t *)(v4 + 64) = 0;
    *(int32_t *)(v4 + 68) = 0;
    *(int32_t *)(v4 + 76) = -1;
    *(char *)(v4 + 72) = 0;
    int32_t v6; // bp-144
    g5 = v6;
    if (g2 + 128 == v6) {
        // bb
        function_13c0(g3);
        // branch -> 0x1316
    }
}

// Address range: 0x132d - 0x13c0
int32_t function_132d(void) {
    int32_t v1 = 0; // bp+36
    int32_t v2;
    int32_t v3 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v2, &v1); // 0x1343
    int32_t v4 = g2; // 0x1348
    int32_t v5 = *(int32_t *)(v4 + 152); // 0x1348
    g6 = v5;
    *(int32_t *)(v3 + 76) = (v5 - *(int32_t *)(v4 + 148)) / 4;
    if (v5 == *(int32_t *)(v4 + 156)) {
        // bb
        function_1418();
        // branch -> 0x1368
    }
    // 0x1368
    if (v5 != 0) {
        // 0x136c
        *(int32_t *)v5 = v1;
        // branch -> 0x1372
    }
    // 0x1372
    *(int32_t *)(g2 + 152) = v5 + 4;
    int32_t v6;
    if (v6 != 0) {
        // 0x1383
        *(int32_t *)v6 = v1;
        // branch -> 0x138d
    }
    int32_t result = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v2, &v1); // 0x139c
    g1 = result;
    int32_t v7;
    if (*(int32_t *)20 != v7) {
        // bb14
        result = function_1437();
        // branch -> 0x13b5
    }
    // 0x13b5
    return result;
}

// Address range: 0x13c0 - 0x1417
int32_t function_13c0(int32_t a1) {
    int32_t v1 = g3; // bp+120
    int32_t v2; // bp+28
    _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS3_ERKS3_((int32_t)&v2, g2 + 124, g5, (int32_t)&v1);
    g5 = a1;
    return function_132d();
}

// Address range: 0x1418 - 0x1437
int32_t function_1418(void) {
    // 0x1418
    g2 += 148;
    int32_t v1 = 0; // bp+36
    return _ZNSt6vectorIiSaIiEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPiS1_EERKi(g6, &v1);
}

// Address range: 0x1437 - 0x1438
int32_t function_1437(void) {
    // 0x1437
    return g1;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x1440 - 0x14ca
// Line range:    24 - 1051
// Demangled:     CAddrInfo::GetNewBucket(std::vector<unsigned char, std::allocator<unsigned char> > const &, CNetAddr const &) const
void _ZNK9CAddrInfo12GetNewBucketERKSt6vectorIhSaIhEERK8CNetAddr(int32_t this, struct vector_unsignedchar_std__allocator_unsignedchar__ nKey, int32_t src) {
    // 0x1440
    g3 = nKey.e0;
    g7 = src;
}

// Address range: 0x14f0 - 0x14f8
int32_t function_14f0(void) {
    int32_t v1 = 0; // eax
    return (v1 + 139) % 256 | v1 & -256;
}

// Address range: 0x14f9 - 0x14fc
int32_t function_14f9(void) {
    // 0x14f9
    return 0;
}

// Address range: 0x14fc - 0x1504
int32_t function_14fc(void) {
    int32_t result = 0; // eax
    *(char *)0 = *(char *)&g4 + (char)result;
    return result;
}

// Address range: 0x1544 - 0x1547
int32_t function_1544(void) {
    // 0x1544
    return 0;
}

// Address range: 0x1548 - 0x154b
int32_t function_1548(void) {
    // 0x1548
    return 0;
}

// Address range: 0x154b - 0x1553
int32_t function_154b(void) {
    int32_t result = 0; // eax
    *(char *)0 = *(char *)&g4 + (char)result;
    return result;
}

// Address range: 0x1591 - 0x1641
int32_t function_1591(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = 0; // eax
    if ((bool)false) {
        int32_t v1 = result + a3; // 0x15cc
        return 0 == v1 ? (int32_t)&g12 : v1;
    }
    // 0x1593
    return result;
}

// Address range: 0x1772 - 0x18d2
int32_t function_1772(char a1, int32_t result, int32_t a3) {
    // 0x1772
    if (!(bool)false) {
        // 0x1774
        return 0;
    }
    int32_t v1; // eax
    *(char *)v1 = (char)v1 + *(char *)&g1;
    *(char *)v1 = (char)v1 + *(char *)&g1;
    *(char *)v1 = (char)v1 + *(char *)&g1;
    int32_t v2 = 0; // ecx
    char * v3 = (char *)(v2 - 0x7cf3dbac); // 0x17b8
    char v4 = *v3 + (char)v2; // 0x17b8
    *v3 = v4;
    int32_t v5 = v2 - 1; // 0x17be
    if (v5 == 0 || v4 == 0) {
        // 0x17c0
        return result;
    }
    char * v6 = (char *)-0x74afdbac; // 0x17e1
    *v6 = *v6 + (char)v5;
    int32_t v7; // bp+174
    return &v7;
}

// Address range: 0x1941 - 0x1964
int32_t function_1941(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)0xff25f8; // 0x1941
    *v1 = *v1 - 1;
    char v2 = *(char *)&g1; // 0x1947
    int32_t result = 0; // eax
    *(char *)result = (char)result + v2;
    if (*(int32_t *)20 != a1) {
        // 0x1964
        return result;
    }
    // 0x1959
    return result;
}

// Address range: 0x196a - 0x196b
int32_t function_196a(void) {
    // 0x196a
    return 0;
}

// Address range: 0x1973 - 0x1996
int32_t function_1973(void) {
    int32_t v1 = 0; // bp+116
    _ZNSt6vectorIhSaIhEED1Ev(&v1);
    int32_t v2 = 0; // bp+104
    _ZNSt6vectorIhSaIhEED1Ev(&v2);
    return _ZN11CDataStreamD1Ev((int32_t *)g7);
}

// Address range: 0x199b - 0x19a4
int32_t function_199b(void) {
    // 0x199b
    _ZN11CDataStream5writeEPKci_part_346();
    return function_1973();
}

// Address range: 0x19a4 - 0x19ac
int32_t function_19a4(void) {
    // 0x19a4
    return 0;
}

// Address range: 0x19ac - 0x19b4
int32_t function_19ac(void) {
    // 0x19ac
    return 0;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x19c0 - 0x1a08
// Line range:    313 - 335
// Demangled:     CAddrMan::Add_(CAddress const &, CNetAddr const &, long long)
void _ZN8CAddrMan4Add_ERK8CAddressRK8CNetAddrx(int32_t this, int32_t addr, int32_t source, int64_t nTimePenalty) {
    // 0x19c0
    return;
}

// Address range: 0x1a0c - 0x1a38
int32_t function_1a0c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // 0x1a0c
    int32_t * v2 = (int32_t *)(v1 + 0x4c8b2775 + 8 * v1); // 0x1a0c
    *v2 = *v2 + 1;
    int32_t result = 0; // ebx
    g1 = result;
    if (*(int32_t *)20 != 0) {
        // bb
        result = function_1d14();
        // branch -> 0x1a24
    }
    // 0x1a24
    return result;
}

// Address range: 0x1a5e - 0x1ba6
int32_t function_1a5e(uint32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x44c71c4e; // 0x1a5e
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x1a64
    unsigned char v3 = (char)v2 & 36; // 0x1a64
    int32_t v4 = (int32_t)v3 | v2 & -256; // 0x1a64
    char * v5 = (char *)v4; // 0x1a66
    *v5 = *v5 + v3;
    char * v6 = (char *)v4; // 0x1a68
    *v6 = *v6 + (char)v4;
    uint32_t v7 = g4; // 0x1a6a
    g1 = v4 - v7;
    int32_t v8 = (int32_t)(v4 < v7) - a3; // 0x1a72
    g24 = false;
    g25 = v8 < 0;
    int32_t v9 = v7; // 0x1a7f
    if (v8 <= 0) {
        // bb
        function_1c58(v7);
        v9 = g4;
        // branch -> 0x1a7f
    }
    // 0x1a7f
    int32_t v10; // esi
    if (v9 == 0) {
        // 0x1ae8
        v10 = 0;
        int32_t * v11 = (int32_t *)(g5 + 20); // 0x1aed
        *v11 = *v11 | *(int32_t *)(v10 + 20);
        int32_t result = *(int32_t *)(v10 + 24); // 0x1af0
        int32_t * v12 = (int32_t *)(g5 + 24); // 0x1af3
        *v12 = *v12 | result;
        return result;
    }
    int32_t v13 = g5; // 0x1a93
    int32_t * v14 = (int32_t *)(v13 + 28); // 0x1a93
    int32_t v15 = *v14; // 0x1a93
    int32_t v16;
    int32_t v17; // 0x1b3b
    int32_t v18; // 0x1b23
    int32_t result2; // 0x1b98
    int32_t v19; // 0x1b28
    int32_t * v20; // 0x1b45
    int32_t * v21; // 0x1b4b
    int32_t v22; // 0x1b9b2
    int32_t v23; // 0x1b48
    int32_t v24; // 0x1b7e
    int32_t v25; // 0x1b08
    int32_t v26; // 0x1b0c
    if (v15 == 0) {
        // 0x1a93
        // branch -> 0x1b00
        // 0x1b00
        v25 = v7 - a1;
        v26 = (int32_t)(v7 < a1) + a3 - a2;
        v18 = (v26 >> 31) - 1;
        v19 = v25 & v18;
        *v14 = v19;
        v17 = v10;
        v20 = (int32_t *)(g5 + 20);
        *v20 = *v20 | *(int32_t *)(v17 + 20);
        v23 = *(int32_t *)(v10 + 24);
        g1 = v23;
        v21 = (int32_t *)(g5 + 24);
        *v21 = *v21 | v23;
        if (*(int32_t *)(v17 + 28) == 0) {
            // bb120
            function_1d19(v19, v26 & v18, v25, v26);
            // branch -> 0x1b56
        }
        // 0x1b56
        v16 = v19;
        // branch -> 0x1b5e
    } else {
        uint32_t v27 = v7 - 0x15180; // 0x1aa2
        int32_t v28 = a3 - a2; // 0x1aaa
        uint32_t v29 = v28 + (int32_t)(v7 < 0x15180) + (int32_t)(v27 < a1); // 0x1ac2
        int32_t * v30; // 0x1add
        int32_t * v31; // 0x1ae3
        if (v29 >= 0) {
            // 0x1ace
            if (v29 == 0) {
                // 0x1ad0
                if (v15 >= v27 - a1) {
                    // 0x1ada
                    v30 = (int32_t *)(v13 + 20);
                    *v30 = *v30 | *(int32_t *)(v10 + 20);
                    v31 = (int32_t *)(g5 + 24);
                    *v31 = *v31 | *(int32_t *)(v10 + 24);
                    // branch -> 0x1b5e
                    // 0x1b5e
                    if (v15 != 0) {
                        // 0x1b66
                        // branch -> 0x1b72
                    }
                    // 0x1b72
                    v24 = *(int32_t *)(g5 + 68);
                    if (v24 < 1) {
                        // bb122
                        function_1bb3();
                        // branch -> 0x1b8e
                    }
                    // 0x1b8e
                    v22 = 1;
                    result2 = 1;
                    // branch -> 0x1b98
                    while (result2 != v24) {
                        // 0x1b98
                        v22 *= 2;
                        result2++;
                        // continue -> 0x1b98
                    }
                    // 0x1ba1
                    return result2;
                }
            }
            // 0x1b00
            v25 = v7 - a1;
            v26 = (int32_t)(v7 < a1) + v28;
            v18 = (v26 >> 31) - 1;
            v19 = v25 & v18;
            *v14 = v19;
            v17 = v10;
            v20 = (int32_t *)(g5 + 20);
            *v20 = *v20 | *(int32_t *)(v17 + 20);
            v23 = *(int32_t *)(v10 + 24);
            g1 = v23;
            v21 = (int32_t *)(g5 + 24);
            *v21 = *v21 | v23;
            if (*(int32_t *)(v17 + 28) == 0) {
                // bb120
                function_1d19(v19, v26 & v18, v25, v26);
                // branch -> 0x1b56
            }
            // 0x1b56
            // branch -> 0x1b5e
            // 0x1b5e
            if (v19 != 0) {
                // 0x1b66
                // branch -> 0x1b72
            }
            // 0x1b72
            v24 = *(int32_t *)(g5 + 68);
            if (v24 < 1) {
                // bb122
                function_1bb3();
                // branch -> 0x1b8e
            }
            // 0x1b8e
            v22 = 1;
            result2 = 1;
            // branch -> 0x1b98
            while (result2 != v24) {
                // 0x1b98
                v22 *= 2;
                result2++;
                // continue -> 0x1b98
            }
            // 0x1ba1
            return result2;
        }
        // 0x1ada
        v30 = (int32_t *)(v13 + 20);
        *v30 = *v30 | *(int32_t *)(v10 + 20);
        v31 = (int32_t *)(g5 + 24);
        *v31 = *v31 | *(int32_t *)(v10 + 24);
        v16 = v15;
        // branch -> 0x1b5e
    }
    // 0x1b5e
    if (v16 != 0) {
        // 0x1b66
        // branch -> 0x1b72
    }
    // 0x1b72
    v24 = *(int32_t *)(g5 + 68);
    if (v24 < 1) {
        // bb122
        function_1bb3();
        // branch -> 0x1b8e
    }
    // 0x1b8e
    v22 = 1;
    result2 = 1;
    // branch -> 0x1b98
    while (result2 != v24) {
        // 0x1b98
        v22 *= 2;
        result2++;
        // continue -> 0x1b98
    }
    // 0x1ba1
    return result2;
}

// Address range: 0x1bb3 - 0x1c55
int32_t function_1bb3(void) {
    struct vector_unsignedchar_std__allocator_unsignedchar__ v1; // 0x1bc7
    // 0x1bb3
    v1 = (struct vector_unsignedchar_std__allocator_unsignedchar__){
        .e0 = 0
    };
    int32_t v2;
    v1.e0 = v2 + 84;
    _ZNK9CAddrInfo12GetNewBucketERKSt6vectorIhSaIhEERK8CNetAddr(g5, v1, g2);
    int32_t * v3;
    g1 = (int32_t)&v3;
    int32_t v4 = *(int32_t *)(v2 + 180); // 0x1bd8
    g2 = v4 + 8 * ((int32_t)&v3 + 2 * (int32_t)&v3);
    int32_t v5 = *(int32_t *)(v4 + 8 * ((int32_t)&v3 + 2 * (int32_t)&v3) + 8); // 0x1be2
    int32_t v6; // bp+56
    int32_t v7; // bp+72
    int32_t * v8; // 0x1c27
    int32_t result; // 0x1c48
    if (v5 == 0) {
        // 0x1c27
        v8 = (int32_t *)(g5 + 68);
        *v8 = *v8 + 1;
        if (*(int32_t *)(g2 + 20) == 64) {
            // bb
            function_1cf1();
            // branch -> 0x1c35
        }
        // 0x1c35
        result = _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE16_M_insert_uniqueERKi(&v6, (int32_t)&v7);
        return result;
    }
    int32_t v9 = v4 + 8 * ((int32_t)&v3 + 2 * (int32_t)&v3) + 4; // 0x1be9
    g7 = v9;
    int32_t v10 = v9; // 0x1c183
    // branch -> 0x1c09
    int32_t v11; // 0x1c1e
    while (true) {
        // 0x1c09
        int32_t v12;
        int32_t v13;
        if (v13 > *(int32_t *)(v5 + 16)) {
            // 0x1c0e
            v11 = v10;
            v12 = v5 + 12;
            // branch -> 0x1c05
        } else {
            // 0x1c00
            g7 = v5;
            v11 = v5;
            v12 = v5 + 8;
            // branch -> 0x1c05
        }
        int32_t v14 = *(int32_t *)v12;
        if (v14 == 0) {
            // break -> 0x1c18
            break;
        }
        v10 = v11;
        v5 = v14;
        // continue -> 0x1c09
    }
    // 0x1c18
    if (v11 != v9) {
        // 0x1c1e
        // branch -> 0x1c27
    }
    // 0x1c27
    v8 = (int32_t *)(g5 + 68);
    *v8 = *v8 + 1;
    if (*(int32_t *)(g2 + 20) == 64) {
        // bb
        function_1cf1();
        // branch -> 0x1c35
    }
    // 0x1c35
    v6 = 0;
    result = _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE16_M_insert_uniqueERKi(&v6, (int32_t)&v7);
    return result;
}

// Address range: 0x1c58 - 0x1c83
int32_t function_1c58(int32_t a1) {
    // 0x1c58
    if (g25 == g24) {
        // 0x1c5a
        // branch -> 0x1c66
    }
    // 0x1c66
    return g1;
}

// Address range: 0x1c88 - 0x1cf1
int32_t function_1c88(uint32_t a1, int32_t a2, int32_t a3) {
    // 0x1c88
    int32_t v1; // bp+72
    int32_t * v2;
    _ZN8CAddrMan6CreateERK8CAddressRK8CNetAddrPi(a3, 0, (int32_t)&v1, &v2);
    uint32_t result = *(int32_t *)((int32_t)&v2 + 28); // 0x1cb4
    *(int32_t *)((int32_t)&v2 + 28) = result - a1 & ((int32_t)(result < a1) - a2 >> 31) - 1;
    int32_t * v3 = (int32_t *)(a3 + 176); // 0x1ce5
    *v3 = *v3 + 1;
    return result;
}

// Address range: 0x1cf1 - 0x1d14
int32_t function_1cf1(void) {
    // 0x1cf1
    int32_t v1;
    _ZN8CAddrMan9ShrinkNewEi(v1, g1);
    int32_t v2;
    g2 = *(int32_t *)(v1 + 180) + v2;
    int32_t * v3;
    return (int32_t)&v3;
}

// Address range: 0x1d14 - 0x1d15
int32_t function_1d14(void) {
    // 0x1d14
    return g1;
}

// Address range: 0x1d19 - 0x1d20
int32_t function_1d19(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1d19
    return g1;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x1d20 - 0x1d90
// Line range:    10 - 1051
// Demangled:     CAddrInfo::GetTriedBucket(std::vector<unsigned char, std::allocator<unsigned char> > const &) const
void _ZNK9CAddrInfo14GetTriedBucketERKSt6vectorIhSaIhEE(int32_t this, struct vector_unsignedchar_std__allocator_unsignedchar__ nKey) {
    // 0x1d20
    g7 = this;
    g3 = nKey.e0;
}

// Address range: 0x1db6 - 0x1dbe
int32_t function_1db6(void) {
    int32_t v1 = 0; // eax
    return (v1 + 139) % 256 | v1 & -256;
}

// Address range: 0x1dbf - 0x1dc2
int32_t function_1dbf(void) {
    // 0x1dbf
    return 0;
}

// Address range: 0x1dc2 - 0x1dca
int32_t function_1dc2(void) {
    int32_t result = 0; // eax
    *(char *)0 = *(char *)&g4 + (char)result;
    return result;
}

// Address range: 0x1e0a - 0x1e0d
int32_t function_1e0a(void) {
    // 0x1e0a
    return 0;
}

// Address range: 0x1e0e - 0x1e11
int32_t function_1e0e(void) {
    // 0x1e0e
    return 0;
}

// Address range: 0x1e11 - 0x1e19
int32_t function_1e11(void) {
    int32_t result = 0; // eax
    *(char *)0 = *(char *)&g4 + (char)result;
    return result;
}

// Address range: 0x1e53 - 0x1e56
int32_t function_1e53(int16_t a1) {
    // 0x1e53
    return 0;
}

// Address range: 0x1fef - 0x1ff3
int32_t function_1fef(void) {
    // 0x1fef
    return function_2023();
}

// Address range: 0x1ff3 - 0x2023
int32_t function_1ff3(int32_t result, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // 0x1ff3
    *(char *)v1 = (char)v1 + *(char *)&g1;
    if (a3 - a2 < 0) {
        // bb
        function_222b();
        // branch -> 0x2009
    }
    // 0x2009
    return result;
}

// Address range: 0x2023 - 0x20e9
int32_t function_2023(void) {
    // 0x2023
    int32_t * v1;
    _ZNSt6vectorIc25zero_after_free_allocatorIcEE15_M_range_insertIPKcEEvN9__gnu_cxx17__normal_iteratorIPcS2_EET_SA_St20forward_iterator_tag(&v1, (int32_t)&v1, (int32_t)&v1, (int32_t)&v1, (int32_t)&v1);
    uint32_t v2;
    uint32_t v3 = v2 % 4; // bp+128
    int32_t v4; // bp+136
    int32_t v5;
    _ZNSt6vectorIc25zero_after_free_allocatorIcEE15_M_range_insertIPKcEEvN9__gnu_cxx17__normal_iteratorIPcS2_EET_SA_St20forward_iterator_tag((int32_t *)g7, v5, (int32_t)&v3, (int32_t)&v4, 0);
    int32_t v6;
    int32_t v7;
    int32_t v8 = v7 + v6; // 0x2074
    return v5 == v8 ? (int32_t)&g12 : v8;
}

// Address range: 0x21cb - 0x21ec
int32_t function_21cb(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)0x3fe083f0; // 0x21cb
    *v1 = *v1 - 1;
    if (*(int32_t *)20 != a1) {
        // 0x21ec
        return 0;
    }
    // 0x21e1
    int32_t result; // eax
    return result;
}

// Address range: 0x21f2 - 0x21f3
int32_t function_21f2(void) {
    // 0x21f2
    return 0;
}

// Address range: 0x21ff - 0x2200
int32_t function_21ff(void) {
    // 0x21ff
    return g1;
}

// Address range: 0x2207 - 0x221e
int32_t function_2207(void) {
    int32_t v1 = 0; // bp+104
    _ZNSt6vectorIhSaIhEED1Ev(&v1);
    return _ZN11CDataStreamD1Ev((int32_t *)g2);
}

// Address range: 0x2222 - 0x222b
int32_t function_2222(void) {
    int32_t * v1 = (int32_t *)0x24748dc3; // 0x2222
    *v1 = *v1 - 1;
    return function_21ff();
}

// Address range: 0x222b - 0x2234
int32_t function_222b(void) {
    // 0x222b
    _ZN11CDataStream5writeEPKci_part_346();
    return function_2207();
}

// Address range: 0x2234 - 0x223c
int32_t function_2234(void) {
    // 0x2234
    return 0;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x2240 - 0x23a7
// Line range:    204 - 260
// Demangled:     CAddrMan::MakeTried(CAddrInfo &, int, int)
void _ZN8CAddrMan9MakeTriedER9CAddrInfoii(int32_t this, int32_t info, int32_t nId, int32_t nOrigin) {
    struct vector_unsignedchar_std__allocator_unsignedchar__ v1; // 0x2303
    // 0x2240
    g3 = this;
    g7 = info;
    int32_t v2 = *(int32_t *)(this + 180); // 0x2264
    int32_t v3 = 24 * nOrigin; // 0x226d
    int32_t v4 = v2 + v3; // 0x2272
    int32_t v5 = *(int32_t *)(v4 + 8); // 0x2278
    g1 = v5;
    int32_t v6 = v5; // 0x229910
    if (v5 == 0) {
        // bb
        v6 = function_23b0(v3);
        // branch -> 0x2287
    }
    // branch -> 0x2299
  lab_0x2299:
    while (true) {
        int32_t v7 = v6; // 0x2299
        // branch -> 0x2299
        while (true) {
            // 0x2299
            int32_t v8; // ecx
            if (*(int32_t *)(v7 + 16) < nId) {
                int32_t v9 = *(int32_t *)(v7 + 12); // 0x229e
                g1 = v9;
                if (v9 == 0) {
                    // break -> 0x22a5
                    break;
                }
                v7 = v9;
                // continue -> 0x2299
                continue;
            } else {
                // 0x2290
                v8 = v7;
                int32_t v10 = *(int32_t *)(v7 + 8); // 0x2292
                g1 = v10;
                if (v10 == 0) {
                    // break (via goto) -> 0x22a5
                    goto lab_0x22a5;
                }
                v6 = v10;
                // continue (via goto) -> 0x2299
                goto lab_0x2299;
            }
          lab_0x22a5:;
            int32_t v11 = v7; // 0x22ad
            if (v4 + 4 == v7) {
                // bb61
                g1 = function_23b0(nId);
                v11 = v8;
                // branch -> 0x22ad
            }
            // 0x22ad
            if (nId < *(int32_t *)(v11 + 16)) {
                // bb62
                g1 = function_23b0(nId);
                // branch -> 0x22b6
            }
            int32_t v12 = g3; // 0x22b6
            int32_t v13; // 0x2308
            int32_t v14; // 0x2327
            int32_t v15; // 0x232b
            int32_t v16; // 0x2339
            int32_t v17; // 0x2371
            int32_t v18; // 0x22f9
            int32_t v19; // 0x234d
            int32_t * v20; // 0x22ea
            int32_t v21; // 0x235c
            int32_t v22; // 0x2308
            int32_t v23; // 0x2311
            int32_t v24; // 0x2314
            int32_t v25; // 0x2321
            int32_t v26; // 0x2339
            int32_t v27; // 0x236a
            int32_t v28;
            int32_t * v29;
            if (v2 != *(int32_t *)(v12 + 184)) {
                // branch -> 0x22c8
                int32_t v30; // 0x22df
                while (true) {
                    int32_t v31 = _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE5eraseERKi(v2, &nId); // 0x22cf
                    g1 = v31;
                    if (v31 != 0) {
                        int32_t * v32 = (int32_t *)(g7 + 68); // 0x22d8
                        *v32 = *v32 - 1;
                        // branch -> 0x22dc
                    }
                    int32_t v33 = g5 + 24; // 0x22dc
                    v30 = g3;
                    if (v33 == *(int32_t *)(v30 + 184)) {
                        // break -> 0x22e7
                        break;
                    }
                    v2 = v33;
                    // continue -> 0x22c8
                }
                // 0x22e7
                v20 = (int32_t *)(v30 + 176);
                *v20 = *v20 - 1;
                if (*(int32_t *)(g7 + 68) != 0) {
                    // bb64
                    function_24e1();
                    // branch -> 0x22f9
                }
                // 0x22f9
                v18 = g3 + 84;
                g2 = v18;
                v1 = (struct vector_unsignedchar_std__allocator_unsignedchar__){
                    .e0 = 0
                };
                v1.e0 = v18;
                _ZNK9CAddrInfo14GetTriedBucketERKSt6vectorIhSaIhEE(g7, v1);
                g1 = (int32_t)&v29;
                v13 = g3;
                v22 = *(int32_t *)(v13 + 164);
                v23 = v22 + 4 * ((int32_t)&v29 + 2 * (int32_t)&v29);
                g5 = v23;
                v24 = *(int32_t *)(v22 + 4 * ((int32_t)&v29 + 2 * (int32_t)&v29) + 4);
                g6 = v24;
                v15 = v13;
                v14 = (int32_t)&v29;
                if (v24 - *(int32_t *)v23 < 256) {
                    // bb66
                    v25 = function_24a8();
                    v15 = g3;
                    v14 = v25;
                    // branch -> 0x2327
                }
                // 0x2327
                _ZN8CAddrMan11SelectTriedEi(v15, v14);
                v16 = g3;
                v26 = *(int32_t *)(v16 + (int32_t)&g23);
                if (v26 == 0) {
                    // 0x2388
                    return;
                }
                // 0x2340
                v19 = v16 + (int32_t)&g22;
                v21 = *(int32_t *)(*(int32_t *)g5 + 4 * (int32_t)&v29);
                v28 = v19;
                // branch -> 0x2371
                while (true) {
                    // 0x2371
                    v17 = v26;
                    // branch -> 0x2371
                  lab_0x2371:;
                    int32_t v34; // 0x2383
                    while (true) {
                        // 0x2371
                        if (*(int32_t *)(v17 + 16) < v21) {
                            int32_t v35 = *(int32_t *)(v17 + 12); // 0x2376
                            if (v35 == 0) {
                                v34 = v28;
                                // break -> 0x237d
                                break;
                            }
                            v17 = v35;
                            // continue -> 0x2371
                            continue;
                        } else {
                            // 0x2368
                            v27 = *(int32_t *)(v17 + 8);
                            if (v27 == 0) {
                                v34 = v17;
                                // break (via goto) -> 0x237d
                                goto lab_0x237d;
                            }
                            v28 = v17;
                            // continue (via goto) -> 0x2371
                            goto lab_0x2371_2;
                        }
                        // 0x237d
                        if (v19 == v34) {
                            // 0x2388
                            return;
                        }
                        uint32_t v36 = *(int32_t *)(v34 + 16); // 0x2383
                        if (v36 <= v21) {
                            // bb67
                            function_23d8();
                            // branch -> 0x2388
                        }
                        // 0x2388
                        return;
                    }
                  lab_0x237d:
                    // 0x237d
                    if (v19 == v34) {
                        // 0x2388
                        return;
                    }
                    // 0x2383
                    if (*(int32_t *)(v34 + 16) <= v21) {
                        // bb67
                        function_23d8();
                        // branch -> 0x2388
                    }
                    // 0x2388
                    return;
                }
            }
            // 0x22e7
            v20 = (int32_t *)(v12 + 176);
            *v20 = *v20 - 1;
            if (*(int32_t *)(g7 + 68) != 0) {
                // bb64
                function_24e1();
                // branch -> 0x22f9
            }
            // 0x22f9
            v18 = g3 + 84;
            g2 = v18;
            v1 = (struct vector_unsignedchar_std__allocator_unsignedchar__){
                .e0 = 0
            };
            v1.e0 = v18;
            _ZNK9CAddrInfo14GetTriedBucketERKSt6vectorIhSaIhEE(g7, v1);
            g1 = (int32_t)&v29;
            v13 = g3;
            v22 = *(int32_t *)(v13 + 164);
            v23 = v22 + 4 * ((int32_t)&v29 + 2 * (int32_t)&v29);
            g5 = v23;
            v24 = *(int32_t *)(v22 + 4 * ((int32_t)&v29 + 2 * (int32_t)&v29) + 4);
            g6 = v24;
            v15 = v13;
            v14 = (int32_t)&v29;
            if (v24 - *(int32_t *)v23 < 256) {
                // bb66
                v25 = function_24a8();
                v15 = g3;
                v14 = v25;
                // branch -> 0x2327
            }
            // 0x2327
            _ZN8CAddrMan11SelectTriedEi(v15, v14);
            v16 = g3;
            v26 = *(int32_t *)(v16 + (int32_t)&g23);
            if (v26 == 0) {
                // 0x2388
                return;
            }
            // 0x2340
            v19 = v16 + (int32_t)&g22;
            v21 = *(int32_t *)(*(int32_t *)g5 + 4 * (int32_t)&v29);
            v28 = v19;
            v27 = v26;
            // branch -> 0x2371
          lab_0x2371_2:
            while (true) {
                // 0x2371
                v17 = v27;
                // branch -> 0x2371
                goto lab_0x2371;
            }
        }
    }
}

// Address range: 0x23b0 - 0x23cf
int32_t function_23b0(int32_t a1) {
    // 0x23b0
    return g1;
}

// Address range: 0x23d8 - 0x24a7
int32_t function_23d8(void) {
    struct vector_unsignedchar_std__allocator_unsignedchar__ v1; // 0x23fd
    int32_t v2 = g3 + 100; // 0x23dc
    int32_t v3;
    int32_t v4 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v2, (int32_t *)v3); // 0x23ea
    int32_t v5 = v4 + 40; // 0x23f3
    v1 = (struct vector_unsignedchar_std__allocator_unsignedchar__){
        .e0 = 0
    };
    v1.e0 = v5;
    int32_t * v6;
    _ZNK9CAddrInfo12GetNewBucketERKSt6vectorIhSaIhEERK8CNetAddr(v4, v1, (int32_t)&v6);
    int32_t v7 = *(int32_t *)(g3 + 180); // 0x2409
    g2 = v7 + 8 * ((int32_t)&v6 + 2 * (int32_t)&v6);
    uint32_t v8;
    int32_t v9 = _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(v2, (int32_t *)(g5 + v8)); // 0x241f
    *(int32_t *)(v9 + 68) = 1;
    uint32_t v10 = *(int32_t *)(g2 + 20); // 0x242f
    *(char *)(v9 + 72) = 0;
    int32_t v11 = g5 + v5; // 0x2490
    int32_t v12 = v11; // edx
    int32_t v13; // bp+48
    if (v10 < 63 || v10 == 63) {
        // 0x2490
        _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE16_M_insert_uniqueERKi(&v13, v11);
        // branch -> 0x245c
    } else {
        // 0x243d
        uint32_t v14;
        int32_t v15 = *(int32_t *)(g3 + 180) + v14; // 0x2447
        v12 = v15;
        _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE16_M_insert_uniqueERKi(&v13, v15);
        // branch -> 0x245c
    }
    int32_t * v16 = (int32_t *)(g3 + 176); // 0x2466
    *v16 = *v16 + 1;
    *(int32_t *)(4 * v2 + g5) = v12;
    *(char *)(g7 + 72) = 1;
    int32_t v17;
    int32_t v18 = *(int32_t *)20 ^ v17; // 0x2478
    g1 = v18;
    int32_t result = v18; // 0x248c
    if (v18 != 0) {
        // bb
        result = function_2505();
        // branch -> 0x2485
    }
    // 0x2485
    return result;
}

// Address range: 0x24a8 - 0x24e1
int32_t function_24a8(void) {
    int32_t v1 = g6; // 0x24a8
    int32_t v2 = g5; // 0x24a8
    if (v1 == *(int32_t *)(v2 + 8)) {
        // 0x24cb
        g1 = _ZNSt6vectorIiSaIiEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPiS1_EERKi(v2, (int32_t *)v1);
        // branch -> 0x24be
    } else {
        // 0x24ad
        int32_t v3; // 0x24b8
        int32_t v4; // 0x24bb
        if (v1 != 0) {
            // 0x24b2
            v4 = g5;
            v3 = g6 + 4;
            // branch -> 0x24b8
        } else {
            v4 = v2;
            v3 = 4;
        }
        // 0x24b8
        *(int32_t *)(v4 + 4) = v3;
        // branch -> 0x24be
    }
    int32_t * v5 = (int32_t *)(g3 + 160); // 0x24be
    *v5 = *v5 + 1;
    *(char *)(g7 + 72) = 1;
    return g1;
}

// Address range: 0x24e1 - 0x2500
int32_t function_24e1(void) {
    // 0x24e1
    return g1;
}

// Address range: 0x2505 - 0x2506
int32_t function_2505(void) {
    // 0x2505
    return g1;
}

// From module:   /parallelcoin/src/addrman.h
// Address range: 0x2510 - 0x2564
// Line range:    262 - 311
// Demangled:     CAddrMan::Good_(CService const &, long long)
void _ZN8CAddrMan5Good_ERK8CServicex(int32_t this, int32_t addr, int64_t nTime) {
    int32_t v1 = 0; // bp-40
    _ZN8CAddrMan4FindERK8CNetAddrPi(this, addr, &v1);
}

// Address range: 0x2589 - 0x25a2
int32_t function_2589(int32_t a1) {
    int32_t v1 = *(int32_t *)20 ^ a1; // 0x258d
    g1 = v1;
    int32_t result = v1; // 0x25a1
    if (v1 != 0) {
        // bb
        result = function_26c7();
        // branch -> 0x259a
    }
    // 0x259a
    return result;
}

// Address range: 0x25c2 - 0x25d7
int32_t function_25c2(int16_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0xb48b); // 0x25c2
    *v2 = *v2 - 1;
    char * v3 = (char *)(v1 + 0xb893); // 0x25c8
    int32_t v4 = 0; // ecx
    *v3 = (char)v4 + *v3;
    char * v5 = (char *)(v4 + 0x2928244c); // 0x25ce
    *v5 = *v5 + (char)v4;
    return 0;
}

// Address range: 0x25d7 - 0x2658
int32_t function_25d7(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // eax
    int32_t v2 = 0; // edi
    *(int32_t *)v2 = v1;
    bool v3 = false; // df
    int32_t v4 = (v3 ? -4 : 4) + v2; // 0x25da
    *(char *)v4 = (char)v1;
    int32_t v5 = (v3 ? -1 : 1) + v4; // 0x25db
    *(char *)v5 = (char)v1;
    int32_t v6 = (v3 ? -1 : 1) + v5; // 0x25dc
    *(char *)v6 = (char)v1;
    int32_t v7 = 0; // edx
    int32_t v8; // 0x25ec
    if (v7 == 0) {
        // bb
        v8 = function_2589(0);
        // branch -> 0x25e6
    } else {
        // 0x25d7
        v8 = v1;
        // branch -> 0x25e6
    }
    int32_t v9 = v7 + v8; // 0x25ea
    g5 = v8;
    int32_t v10 = (int64_t)v8 % (int64_t)v7; // 0x2600
    int32_t v11 = 24 * v10 + a2; // 0x2607
    int32_t v12 = *(int32_t *)(v11 + 8); // 0x260a
    int32_t v13 = v12; // 0x26299
    if (v12 == 0) {
        // bb129
        v13 = function_26a0(v9);
        v11 = g2;
        // branch -> 0x2615
    }
    int32_t v14 = v11 + 4; // 0x2615
    int32_t v15 = v14;
    // branch -> 0x2629
  lab_0x2629:
    while (true) {
        int32_t v16 = v13; // 0x2629
        // branch -> 0x2629
        int32_t v17; // 0x2635
        int32_t v18; // 0x2639
        int32_t result3; // 0x2643
        int32_t result2; // 0x265418
        int32_t v19; // 0x265419
        while (true) {
            // 0x2629
            if (a3 > *(int32_t *)(v16 + 16)) {
                int32_t v20 = *(int32_t *)(v16 + 12); // 0x262e
                if (v20 == 0) {
                    v19 = v20;
                    v17 = v15;
                    // break -> 0x2635
                    break;
                }
                v16 = v20;
                // continue -> 0x2629
                continue;
            } else {
                int32_t v21 = *(int32_t *)(v16 + 8); // 0x2622
                if (v21 == 0) {
                    v19 = 0;
                    v17 = v16;
                    // break (via goto) -> 0x2635
                    goto lab_0x2635;
                }
                v15 = v16;
                v13 = v21;
                // continue (via goto) -> 0x2629
                goto lab_0x2629;
            }
            // 0x2635
            result2 = v19;
            v18 = v17;
            if (v17 == v14) {
                int32_t v22 = function_26a0(v9); // 0x2637
                v1 = v22;
                int32_t v23 = a3;
                int32_t v24 = g3;
                result2 = v22;
                v18 = v24;
                a3 = v23;
                // branch -> 0x2639
            }
            int32_t v25 = *(int32_t *)(v18 + 16); // 0x2639
            if (a3 < v25) {
                int32_t v26 = function_26a0(v9); // 0x263c
                v1 = v26;
                result2 = v26;
                // branch -> 0x263e
            }
            int32_t v27 = v7; // 0x263e
            int32_t result = result2; // 0x2654
            int32_t v28; // bp+56
            if (v27 != -1) {
                // 0x2649
                a3 = a1;
                v2 = &v28;
                return result;
            }
            // bb133
            result3 = function_2589(v9);
            v1 = result3;
            result = result3;
            // branch -> 0x2649
            // 0x2649
            a3 = a1;
            v2 = &v28;
            return result;
        }
      lab_0x2635:
        // 0x2635
        result2 = v19;
        v18 = v17;
        if (v17 == v14) {
            // bb131
            result2 = function_26a0(v9);
            v18 = g3;
            // branch -> 0x2639
        }
        // 0x2639
        if (a3 < *(int32_t *)(v18 + 16)) {
            // bb132
            result2 = function_26a0(v9);
            // branch -> 0x263e
        }
        // 0x263e
        if (v10 != -1) {
            // 0x2649
            return result2;
        }
        // bb133
        result3 = function_2589(v9);
        // branch -> 0x2649
        // 0x2649
        return result3;
    }
}

// Address range: 0x267b - 0x269d
int32_t function_267b(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)-0x76cbdbbc; // 0x267b
    *v1 = *v1 - 1;
    int32_t * v2;
    _ZN8CAddrMan9MakeTriedER9CAddrInfoii(a2, 0, 0, (int32_t)&v2);
    return function_2589(a2);
}

// Address range: 0x26a0 - 0x26b5
int32_t function_26a0(int32_t a1) {
    // 0x26a0
    int32_t * v1;
    return function_2589((int32_t)&v1);
}

// Address range: 0x26b6 - 0x26b7
int32_t function_26b6(void) {
    // 0x26b6
    return 0;
}

// Address range: 0x26c7 - 0x26c8
int32_t function_26c7(void) {
    // 0x26c7
    return g1;
}

// Address range: 0x26d0 - 0x26fa
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1) {
    // 0x26d0
    *a1 = (int32_t)&g16;
    // 0x26f6
    return 0;
}

// Address range: 0x2700 - 0x272a
// Demangled:     boost::detail::sp_counted_base::~sp_counted_base()
int32_t _ZN5boost6detail15sp_counted_baseD1Ev(int32_t * a1) {
    // 0x2700
    *a1 = (int32_t)&g18;
    // 0x2726
    return 0;
}

// Address range: 0x2730 - 0x2780
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_base::destroy()
int32_t _ZN5boost6detail15sp_counted_base7destroyEv(int32_t * a1) {
    // 0x2730
    if (a1 == NULL) {
        // 0x2775
        return 0;
        // 0x2779
        return 0;
    }
    // 0x2755
    return *(int32_t *)(*a1 + 4);
    // 0x2779
    return 0;
}

// Address range: 0x2790 - 0x27ba
// Demangled:     boost::system::error_category::~error_category()
int32_t _ZN5boost6system14error_categoryD1Ev(int32_t * a1) {
    // 0x2790
    *a1 = (int32_t)&g10;
    // 0x27b6
    return 0;
}

// Address range: 0x27c0 - 0x27f4
// Demangled:     boost::system::error_category::default_error_condition(int) const
int32_t _ZNK5boost6system14error_category23default_error_conditionEi(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t result = (int32_t)a1;
    *a1 = a3;
    *(int32_t *)(result + 4) = a2;
    // 0x27ee
    return result;
}

// Address range: 0x2800 - 0x2864
// Demangled:     boost::system::error_category::equivalent(int, boost::system::error_condition const &) const
int32_t _ZNK5boost6system14error_category10equivalentEiRKNS0_15error_conditionE(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t result = 0; // 0x285f
    int32_t v1;
    if (*(int32_t *)(a3 + 4) == v1) {
        // 0x2858
        int32_t v2;
        result = *(int32_t *)a3 == v2;
        // branch -> 0x2844
    }
    // 0x2844
    int32_t v3;
    if (*(int32_t *)20 != v3) {
        // 0x285f
    }
    // 0x2851
    return result;
}

// Address range: 0x2870 - 0x28b4
// Demangled:     boost::system::error_category::equivalent(boost::system::error_code const &, int) const
int32_t _ZNK5boost6system14error_category10equivalentERKNS0_10error_codeEi(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t result = 0; // 0x28af
    if (*(int32_t *)((int32_t)a2 + 4) == a1) {
        // 0x28a8
        result = *a2 == a3;
        // branch -> 0x2891
    }
    // 0x289e
    return result;
}

// Address range: 0x28c0 - 0x28ea
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::~sp_counted_impl_p()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED1Ev(int32_t * a1) {
    // 0x28c0
    *a1 = (int32_t)&g18;
    // 0x28e6
    return 0;
}

// Address range: 0x28f0 - 0x2940
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::dispose()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE7disposeEv(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 12); // 0x2903
    if (v1 == 0) {
        // 0x2935
        return 0;
        // 0x2939
        return 0;
    }
    // 0x2917
    return *(int32_t *)(*(int32_t *)v1 + 4);
    // 0x2939
    return 0;
}

// Address range: 0x2950 - 0x2970
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::get_deleter(std::type_info const &)
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE11get_deleterERKSt9type_info(void) {
    // 0x296c
    return 0;
}

// Address range: 0x2980 - 0x29ae
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::~sp_counted_impl_p()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED0Ev(int32_t * a1) {
    // 0x2980
    g1 = (int32_t)a1;
    *a1 = (int32_t)&g18;
    int32_t result;
    // 0x2980
    result = g1;
    // branch -> 0x29a7
    // 0x29a7
    return result;
}

// Address range: 0x29b3 - 0x29b8
int32_t function_29b3(int32_t a1) {
    // 0x29b3
    return g1;
}

// Address range: 0x29c0 - 0x29ee
// Demangled:     boost::detail::sp_counted_base::~sp_counted_base()
int32_t _ZN5boost6detail15sp_counted_baseD0Ev(int32_t * a1) {
    // 0x29c0
    g1 = (int32_t)a1;
    *a1 = (int32_t)&g18;
    int32_t result;
    // 0x29c0
    result = g1;
    // branch -> 0x29e7
    // 0x29e7
    return result;
}

// Address range: 0x29f3 - 0x29f4
int32_t function_29f3(int32_t a1) {
    // 0x29f3
    return g1;
}

// Address range: 0x2a00 - 0x2a2e
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1) {
    // 0x2a00
    g1 = (int32_t)a1;
    *a1 = (int32_t)&g16;
    int32_t result;
    // 0x2a00
    result = g1;
    // branch -> 0x2a27
    // 0x2a27
    return result;
}

// Address range: 0x2a33 - 0x2a38
int32_t function_2a33(int32_t a1) {
    // 0x2a33
    return g1;
}

// Address range: 0x2a40 - 0x2a6e
// Demangled:     boost::system::error_category::~error_category()
int32_t _ZN5boost6system14error_categoryD0Ev(int32_t * a1) {
    // 0x2a40
    g1 = (int32_t)a1;
    *a1 = (int32_t)&g10;
    int32_t result;
    // 0x2a40
    result = g1;
    // branch -> 0x2a67
    // 0x2a67
    return result;
}

// Address range: 0x2a73 - 0x2a78
int32_t function_2a73(int32_t a1) {
    // 0x2a73
    return g1;
}

// Address range: 0x2a80 - 0x2a87
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1) {
    // 0x2a80
    return _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(a1 - 24);
}

// Address range: 0x2a90 - 0x2aac
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1) {
    // 0x2a90
    return 0;
}

// Address range: 0x2ab2 - 0x2ab3
int32_t function_2ab2(void) {
    // 0x2ab2
    return 0;
}

// Address range: 0x2d1a - 0x2d48
int32_t _ZN11CDataStream5writeEPKci_part_346(void) {
    // 0x2d1a
    return 0;
}

// Address range: 0x2d50 - 0x2d57
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1) {
    // 0x2d50
    return _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv2(a1 - 24);
}

// Address range: 0x2d60 - 0x2de1
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          virtual member function
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv2(int32_t a1) {
    // 0x2d60
    abort();
    // UNREACHABLE
}

// Address range: 0x2df0 - 0x2e46
// From class:    N5boost6system12system_errorE
// Type:          virtual member function
// Demangled:     boost::system::system_error::what() const
int32_t _ZNK5boost6system12system_error4whatEv(int32_t a1) {
    int32_t result = *(int32_t *)(a1 + 16); // 0x2e0f
    if (*(int32_t *)(result - 12) == 0) {
        // 0x2e40
        return 0;
    }
    // 0x2e19
    g1 = result;
    // 0x2e2c
    return result;
}

// Address range: 0x2e4d - 0x2e50
int32_t function_2e4d(void) {
    // 0x2e4d
    return 0;
}

// Address range: 0x2e6f - 0x2e70
int32_t function_2e6f(void) {
    // 0x2e6f
    return g1;
}

// Address range: 0x2e98 - 0x2ea8
int32_t function_2e98(void) {
    // 0x2e98
    return 0;
}

// Address range: 0x2ec0 - 0x2ec2
int32_t function_2ec0(void) {
    // 0x2ec0
    return function_2e6f();
}

// Address range: 0x2ec2 - 0x2ec3
int32_t function_2ec2(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2ec2
    return g1;
}

// Address range: 0x2ed3 - 0x2ed4
int32_t function_2ed3(void) {
    // 0x2ed3
    return g1;
}

// Address range: 0x2ee4 - 0x2ee5
int32_t function_2ee4(void) {
    // 0x2ee4
    return 0;
}

// Address range: 0x2eea - 0x2eef
int32_t function_2eea(void) {
    // 0x2eea
    return 0;
}

// Address range: 0x2ef0 - 0x2ef2
int32_t function_2ef0(void) {
    // 0x2ef0
    return function_2ed3();
}

// Address range: 0x2ef3 - 0x2ef6
int32_t function_2ef3(void) {
    // 0x2ef3
    return 0;
}

// Address range: 0x2f10 - 0x2f95
// Demangled:     boost::shared_ptr<boost::exception_detail::clone_base const>::~shared_ptr()
int32_t _ZN5boost10shared_ptrIKNS_16exception_detail10clone_baseEED1Ev(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x2f2b
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)(v1 + 4); // 0x2f39
        int32_t v3 = *v2 - 1; // 0x2f39
        *v2 = v3;
        if (v3 == 0) {
            int32_t * v4 = (int32_t *)(v1 + 8); // 0x2f68
            int32_t v5 = *v4; // 0x2f68
            *v4 = v5 - 1;
            if (v5 == 1) {
                // 0x2f7f
                return *(int32_t *)(*(int32_t *)v1 + 12);
            }
            // 0x2f50
            return 0;
        }
    }
    // 0x2f50
    return 0;
}

// Address range: 0x2fa0 - 0x2fc7
// From class:    N5boost6system12system_errorE
// Type:          constructor
// Demangled:     boost::system::system_error::~system_error()
int32_t _ZN5boost6system12system_errorD1Ev(int32_t * a1) {
    // 0x2fa0
    *a1 = (int32_t)&g11;
    return *(int32_t *)((int32_t)a1 + 16);
}

// Address range: 0x2fd6 - 0x2ff0
int32_t function_2fd6(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x2fd6
    *v1 = *v1 - 1;
    int32_t v2 = *(int32_t *)20; // 0x2fdc
    g1 = v2;
    int32_t result = v2; // 0x2fef
    if (v2 != 0) {
        // bb
        result = function_3017();
        // branch -> 0x2fe4
    }
    // 0x2fe4
    return result;
}

// Address range: 0x2ff0 - 0x2ff1
int32_t function_2ff0(void) {
    // 0x2ff0
    return 0;
}

// Address range: 0x3015 - 0x3017
int32_t function_3015(void) {
    // 0x3015
    return 0;
}

// Address range: 0x3017 - 0x3018
int32_t function_3017(void) {
    // 0x3017
    return g1;
}

// Address range: 0x301c - 0x3027
int32_t function_301c(void) {
    int32_t result = 0; // eax
    int32_t * v1 = (int32_t *)(result - 4); // 0x301c
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x3030 - 0x3057
// From class:    N5boost6system12system_errorE
// Type:          constructor
// Demangled:     boost::system::system_error::~system_error()
int32_t _ZN5boost6system12system_errorD0Ev(int32_t * a1) {
    // 0x3030
    *a1 = (int32_t)&g11;
    return *(int32_t *)((int32_t)a1 + 16);
}

// Address range: 0x306e - 0x3088
int32_t function_306e(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x306e
    *v1 = *v1 - 1;
    int32_t v2 = *(int32_t *)20; // 0x3074
    g1 = v2;
    int32_t result = v2; // 0x3087
    if (v2 != 0) {
        // bb
        result = function_30af();
        // branch -> 0x307c
    }
    // 0x307c
    return result;
}

// Address range: 0x3088 - 0x3089
int32_t function_3088(void) {
    // 0x3088
    return 0;
}

// Address range: 0x30ad - 0x30af
int32_t function_30ad(void) {
    // 0x30ad
    return 0;
}

// Address range: 0x30af - 0x30b0
int32_t function_30af(void) {
    // 0x30af
    return g1;
}

// Address range: 0x30b4 - 0x30bf
int32_t function_30b4(void) {
    int32_t result = 0; // eax
    int32_t * v1 = (int32_t *)(result - 4); // 0x30b4
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x30c0 - 0x3111
// Demangled:     boost::exception::~exception()
int32_t _ZN5boost9exceptionD1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x30d4
    *a1 = (int32_t)&g13;
    if (v2 != 0) {
        // 0x30e1
        if ((char)v2 != 0) {
            // 0x3108
            *(int32_t *)(v1 + 4) = 0;
            // branch -> 0x30ed
        }
    }
    // 0x30fa
    return 0;
}

// Address range: 0x3117 - 0x311a
int32_t function_3117(void) {
    // 0x3117
    return 0;
}

// Address range: 0x3130 - 0x313a
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D1Ev(int32_t a1) {
    // 0x3130
    return function_6270(a1 - 20);
}

// Address range: 0x3140 - 0x3167
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::bad_alloc_::~bad_alloc_()
int32_t _ZN5boost16exception_detail10bad_alloc_D1Ev(int32_t * a1) {
    // 0x3140
    *a1 = (int32_t)&g14;
    int32_t result = (int32_t)a1 + 20; // 0x315a
    *(int32_t *)result = (int32_t)&g15;
    return result;
}

// Address range: 0x316b - 0x3186
int32_t function_316b(int32_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x651c2444); // 0x316b
    *v2 = *v2 - 1;
    int32_t result = *(int32_t *)20; // 0x3171
    g1 = result;
    if (result != 0) {
        // 0x3186
        return result;
    }
    // 0x3179
    return function_6200(v1);
}

// Address range: 0x3190 - 0x319a
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1) {
    // 0x3190
    return function_6340(a1 - 24);
}

// Address range: 0x31a0 - 0x31aa
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1) {
    // 0x31a0
    return function_6340(a1 - 20);
}

// Address range: 0x31b0 - 0x31de
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + 24) = (int32_t)&g16;
    *(int32_t *)v1 = (int32_t)&g14;
    *(int32_t *)(v1 + 20) = (int32_t)&g15;
    return v1 + 20;
}

// Address range: 0x31e2 - 0x31fd
int32_t function_31e2(int32_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x651c2444); // 0x31e2
    *v2 = *v2 - 1;
    int32_t result = *(int32_t *)20; // 0x31e8
    g1 = result;
    if (result != 0) {
        // 0x31fd
        return result;
    }
    // 0x31f0
    return function_6270(v1);
}

// Address range: 0x3210 - 0x3217
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D0Ev(int32_t a1) {
    // 0x3210
    return _ZN5boost16exception_detail10bad_alloc_D0Ev((int32_t *)(a1 - 20));
}

// Address range: 0x3220 - 0x3247
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::bad_alloc_::~bad_alloc_()
int32_t _ZN5boost16exception_detail10bad_alloc_D0Ev(int32_t * a1) {
    // 0x3220
    *a1 = (int32_t)&g14;
    int32_t result = (int32_t)a1 + 20; // 0x323a
    *(int32_t *)result = (int32_t)&g15;
    return result;
}

// Address range: 0x3280 - 0x3287
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1) {
    // 0x3280
    return _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev((int32_t *)(a1 - 24));
}

// Address range: 0x3290 - 0x3297
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1) {
    // 0x3290
    return _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev((int32_t *)(a1 - 20));
}

// Address range: 0x32a0 - 0x32ce
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + 24) = (int32_t)&g16;
    *(int32_t *)v1 = (int32_t)&g14;
    *(int32_t *)(v1 + 20) = (int32_t)&g15;
    return v1 + 20;
}

// Address range: 0x3300 - 0x3331
// Demangled:     boost::exception::~exception()
int32_t _ZN5boost9exceptionD0Ev(int32_t a1) {
    // 0x3300
    unknown_63c0(a1);
    g1 = 0;
    // 0x3329
    return 0;
}

// Address range: 0x3336 - 0x3337
int32_t function_3336(void) {
    // 0x3336
    return g1;
}

// Address range: 0x3340 - 0x3367
// Demangled:     CDataStream::~CDataStream()
int32_t _ZN11CDataStreamD1Ev(int32_t * a1) {
    // 0x3340
    g6 = 0;
    int32_t v1 = *a1; // 0x3355
    int32_t v2 = *(int32_t *)((int32_t)a1 + 8); // 0x3357
    g1 = v2;
    if (v1 == 0) {
        // bb
        v2 = function_3388(*(int32_t *)20);
        // branch -> 0x335e
    }
    // 0x335e
    return v2 - v1;
}

// Address range: 0x3385 - 0x3388
int32_t function_3385(void) {
    // 0x3385
    return 0;
}

// Address range: 0x3388 - 0x33a0
int32_t function_3388(int32_t a1) {
    int32_t v1 = *(int32_t *)20 ^ a1; // 0x338c
    g6 = v1;
    if (v1 != 0) {
        // 0x339a
        return g1;
    }
    // 0x3395
    return g1;
}

// Address range: 0x33b0 - 0x33f0
// Demangled:     boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr()
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0x33c4
    if (v1 != 0) {
        // 0x33ca
        if ((char)v1 != 0) {
            // 0x33e8
            *a1 = 0;
            // branch -> 0x33d6
        }
    }
    // 0x33e3
    return 0;
}

// Address range: 0x3400 - 0x3504
// Demangled:     boost::exception_detail::copy_boost_exception(boost::exception *, boost::exception const *)
int32_t _ZN5boost16exception_detail20copy_boost_exceptionEPNS_9exceptionEPKS1_(int32_t a1, int32_t a2) {
    // 0x3400
    if (*(int32_t *)(a2 + 4) != 0) {
        // 0x343a
        int32_t v1;
        if (v1 != 0) {
            // 0x3459
            // branch -> 0x3461
        }
        // 0x3461
        // branch -> 0x3489
    }
    int32_t v2 = 0; // edi
    *(int32_t *)(a1 + 12) = *(int32_t *)(a2 + 12);
    *(int32_t *)(a1 + 16) = *(int32_t *)(a2 + 16);
    *(int32_t *)(a1 + 8) = *(int32_t *)(a2 + 8);
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x349b
    if (v3 != 0) {
        // 0x34a2
        *(int32_t *)g8 = v3;
        // branch -> 0x34aa
    }
    // 0x34aa
    *(int32_t *)(a1 + 4) = v2;
    if (v2 != 0) {
        // 0x34b1
        *(int32_t *)g8 = v2;
        // branch -> 0x34b9
    }
    int32_t v4 = *(int32_t *)(g8 + 20); // 0x34b9
    if (v4 != 0) {
        // 0x34c1
        *(int32_t *)g8 = v4;
        // branch -> 0x34c9
    }
    int32_t result = *(int32_t *)20 ^ *(int32_t *)(g8 + 28); // 0x34cd
    if (result != 0) {
        // 0x3504
        return result;
    }
    // 0x34d6
    return result;
}

// Address range: 0x350a - 0x350b
int32_t function_350a(void) {
    // 0x350a
    return 0;
}

// Address range: 0x3513 - 0x3514
int32_t function_3513(void) {
    // 0x3513
    return g1;
}

// Address range: 0x3527 - 0x352b
int32_t function_3527(void) {
    // 0x3527
    return function_3513();
}

// Address range: 0x3690 - 0x378a
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          constructor
int32_t _ZN5boost16exception_detail13get_bad_allocILi42EEENS_10shared_ptrIKNS0_10clone_baseEEEv(int32_t * a1) {
    int32_t v1 = (int32_t)&g14; // bp-56
    int32_t v2 = (int32_t)&g17; // bp-84
    g1 = unknown_6a90((int32_t)&v2, (int32_t)&v1);
    function_37e8((int32_t)"boost::exception_ptr boost::exception_detail::get_bad_alloc() [with int Dummy = 42, boost::exception_ptr = boost::shared_ptr<const boost::exception_detail::clone_base>]", (int32_t)"/usr/include/boost/exception/detail/exception_ptr.hpp", 81);
    *a1 = 0;
    *(int32_t *)((int32_t)a1 + 4) = (int32_t)&g19;
    *(int32_t *)&g20 = (int32_t)"N5boost6detail15sp_counted_baseE" + 1;
    int32_t v3; // bp-64
    return &v3;
}

// Address range: 0x37b2 - 0x37e4
int32_t function_37b2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x6a17dbc4; // 0x37b2
    uint32_t v2 = *v1; // 0x37b2
    *v1 = v2 - 1;
    int32_t v3 = 0; // 0x37b8
    unsigned char v4 = (char)v3; // 0x37b8
    bool v5 = false; // 0x37b8
    int32_t v6;
    if (v2 % 16 > 16 || (v4 & 14) > 9) {
        char v7 = v4 - 6; // 0x37b8
        unsigned char v8 = v5 | v4 > 153 ? v7 - (char)&g21 : v7; // 0x37b8
        v6 = (int32_t)v8 | v3 & -256;
        // branch -> bb108
    } else {
        bool v9 = v5 | v4 > 153; // 0x37b8
        int32_t v10 = v9 ? v3 - (int32_t)(char)&g21 : v3; // 0x37b8
        v6 = v10 & 255 | v3 & -256;
        // branch -> bb108
    }
    char * v11 = (char *)v6; // 0x37b9
    *v11 = *v11 + (char)v6;
    int32_t result = 0; // ebx
    g1 = result;
    if (*(int32_t *)20 != a1) {
        // bb109
        result = function_38b4();
        // branch -> 0x37ce
    }
    // 0x37ce
    return result;
}

// Address range: 0x37e8 - 0x37ef
int32_t function_37e8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x37e8
    return g1;
}

// Address range: 0x38af - 0x38b4
int32_t function_38af(void) {
    // 0x38af
    return 0;
}

// Address range: 0x38b4 - 0x38b5
int32_t function_38b4(void) {
    // 0x38b4
    return g1;
}

// Address range: 0x38d4 - 0x38d5
int32_t function_38d4(void) {
    // 0x38d4
    return 0;
}

// Address range: 0x38dd - 0x38de
int32_t function_38dd(void) {
    // 0x38dd
    return g1;
}

// Address range: 0x38f1 - 0x38f2
int32_t function_38f1(void) {
    // 0x38f1
    return g1;
}

// Address range: 0x3902 - 0x3903
int32_t function_3902(void) {
    // 0x3902
    return 0;
}

// Address range: 0x3908 - 0x390a
int32_t function_3908(void) {
    // 0x3908
    return function_38dd();
}

// Address range: 0x390a - 0x3912
int32_t function_390a(void) {
    // 0x390a
    return function_38dd();
}

// Address range: 0x3912 - 0x3926
int32_t function_3912(void) {
    // 0x3912
    int32_t v1;
    g1 = unknown_67d0(v1);
    return function_38f1();
}

// Address range: 0x3930 - 0x395d
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::~vector()
int32_t _ZNSt6vectorIhSaIhEED1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0x3943
    g1 = v1;
    int32_t result = v1; // 0x395a2
    if (v1 == 0) {
        int32_t v2 = function_3968(*(int32_t *)20); // 0x3947
        g1 = v2;
        result = v2;
        // branch -> 0x3949
    }
    // 0x3956
    return result;
}

// Address range: 0x3968 - 0x3979
int32_t function_3968(int32_t a1) {
    int32_t v1 = *(int32_t *)20 ^ a1; // 0x396c
    g1 = v1;
    int32_t result = v1; // 0x3978
    if (v1 != 0) {
        // bb
        result = function_3979();
        // branch -> 0x3975
    }
    // 0x3975
    return result;
}

// Address range: 0x3979 - 0x3980
int32_t function_3979(void) {
    // 0x3979
    return g1;
}

// Address range: 0x3990 - 0x39c7
// Demangled:     std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::_M_erase(std::_Rb_tree_node<int> *)
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE8_M_eraseEPSt13_Rb_tree_nodeIiE(int32_t a1, int32_t a2) {
    // 0x3990
    if (a2 != 0) {
        // 0x39b2
        return unknown_7320(a1, *(int32_t *)(a2 + 12));
    }
    // 0x39ae
    return function_39d0(*(int32_t *)20, 0, 0, 0);
}

// Address range: 0x39d0 - 0x39e4
int32_t function_39d0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = *(int32_t *)20 ^ a1; // 0x39d4
    if (result != 0) {
        // 0x39e4
    }
    // 0x39dd
    return result;
}

// Address range: 0x39f0 - 0x3a78
// Demangled:     std::vector<int, std::allocator<int> >::_M_insert_aux(__gnu_cxx::__normal_iterator<int *, std::vector<int, std::allocator<int> > >, int const &)
int32_t _ZNSt6vectorIiSaIiEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPiS1_EERKi(int32_t a1, int32_t * a2) {
    int32_t v1 = g3; // 0x39f3
    g3 = a1;
    int32_t v2 = g7; // 0x3a07
    g7 = (int32_t)a2;
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x3a17
    g6 = v3;
    if (v3 == *(int32_t *)(a1 + 8)) {
        // bb
        function_3a80(*(int32_t *)20);
        // branch -> 0x3a23
    }
    int32_t v4 = -4;
    if (v3 != 0) {
        int32_t v5 = v3 - 4; // 0x3a27
        *(int32_t *)v3 = *(int32_t *)v5;
        v4 = v5;
        // branch -> 0x3a2c
    }
    // 0x3a2c
    *(int32_t *)(g3 + 4) = v3 + 4;
    int32_t v6 = *(int32_t *)g5; // 0x3a35
    g3 = v6;
    int32_t v7 = v4 - g7; // 0x3a37
    if (v7 >= 4) {
        // 0x3a68
        return v7 - v7 % 4;
    }
    // 0x3a40
    *(int32_t *)g7 = v6;
    g1 = 0;
    // 0x3a53
    g3 = v1;
    g7 = v2;
    return 0;
}

// Address range: 0x3a7d - 0x3a7f
int32_t function_3a7d(void) {
    // 0x3a7d
    return 0;
}

// Address range: 0x3a80 - 0x3ab4
int32_t function_3a80(int32_t a1) {
    // 0x3a80
    g1 = g3;
    int32_t v1 = g6 - g3; // 0x3a82
    int32_t v2 = v1 / 4; // 0x3a84
    g6 = v2;
    if (v1 < 4) {
        // bb
        g1 = function_3b10();
        // branch -> 0x3a8f
    }
    int32_t v3 = 2 * v2; // 0x3a8f
    g4 = v3;
    if (v1 < 4 || v2 < v3) {
        // bb6
        function_3b71();
        // branch -> 0x3a9a
    }
    // 0x3a9a
    return -4;
}

// Address range: 0x3ac1 - 0x3af7
int32_t function_3ac1(int32_t a1) {
    int32_t v1 = 4 * g6 + g2; // 0x3ac1
    if (v1 != 0) {
        // 0x3ac9
        *(int32_t *)v1 = g5;
        // branch -> 0x3acd
    }
    int32_t v2 = g7 - g1; // 0x3ad1
    g6 = v2 / 4;
    int32_t v3 = 4; // 0x3add
    if (v2 >= 4) {
        // bb
        function_3b28();
        v3 = g5 + 4;
        // branch -> 0x3ada
    }
    int32_t v4 = *(int32_t *)(g3 + 4) - g7; // 0x3ae3
    g1 = v4 / 4;
    int32_t v5 = 0; // 0x3aee
    int32_t v6 = g3; // 0x3aec
    if (v4 >= 4) {
        // bb10
        function_3b48();
        v5 = g5;
        v6 = g3;
        // branch -> 0x3aec
    }
    // 0x3aec
    g1 = v6;
    g5 = v5 + v3 + g2;
    int32_t result = v6; // 0x3af4
    if (v6 == 0) {
        // bb11
        result = function_3afc();
        // branch -> 0x3af4
    }
    // 0x3af4
    return result;
}

// Address range: 0x3afc - 0x3b0d
int32_t function_3afc(void) {
    // 0x3afc
    *(int32_t *)g3 = g2;
    int32_t v1;
    g2 += v1;
    *(int32_t *)(g3 + 4) = g5;
    *(int32_t *)(g3 + 8) = g2;
    return g1;
}

// Address range: 0x3b10 - 0x3b21
int32_t function_3b10(void) {
    int32_t result = g1; // 0x3b12
    g6 = (g7 - result) / 4;
    return result;
}

// Address range: 0x3b28 - 0x3b41
int32_t function_3b28(void) {
    // 0x3b28
    g5 = 4 * g6;
    return g1;
}

// Address range: 0x3b48 - 0x3b5e
int32_t function_3b48(void) {
    int32_t result = g1; // 0x3b48
    g5 = 4 * result;
    return result;
}

// Address range: 0x3b63 - 0x3b6c
int32_t function_3b63(int32_t a1) {
    // 0x3b63
    return 0;
}

// Address range: 0x3b6c - 0x3b6d
int32_t function_3b6c(void) {
    // 0x3b6c
    return g1;
}

// Address range: 0x3b71 - 0x3b9a
int32_t function_3b71(void) {
    int32_t v1 = g6; // 0x3b7d
    g2 = 0;
    int32_t result = g1; // 0x3b88
    g6 = (g7 - result) / 4;
    if (g4 == 0) {
        // bb
        result = function_3ac1(8 * v1);
        // branch -> 0x3b95
    }
    // 0x3b95
    return result;
}

// Address range: 0x3ba0 - 0x3bd7
// Demangled:     std::_Rb_tree<int, std::pair<int const, CAddrInfo>, std::_Select1st<std::pair<int const, CAddrInfo> >, std::less<int>, std::allocator<std::pair<int const, CAddrInfo> > >::_M_erase(std::_Rb_tree_node<std::pair<int const, CAddrInfo> > *)
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E(int32_t a1, int32_t a2) {
    // 0x3ba0
    if (a2 != 0) {
        // 0x3bc2
        return unknown_7740(a1, *(int32_t *)(a2 + 12));
    }
    // 0x3bbe
    return function_3be0(*(int32_t *)20, 0, 0, 0);
}

// Address range: 0x3be0 - 0x3bf4
int32_t function_3be0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = *(int32_t *)20 ^ a1; // 0x3be4
    if (result != 0) {
        // 0x3bf4
    }
    // 0x3bed
    return result;
}

// Address range: 0x3c00 - 0x3c37
// Demangled:     std::_Rb_tree<CNetAddr, std::pair<CNetAddr const, int>, std::_Select1st<std::pair<CNetAddr const, int> >, std::less<CNetAddr>, std::allocator<std::pair<CNetAddr const, int> > >::_M_erase(std::_Rb_tree_node<std::pair<CNetAddr const, int> > *)
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E(int32_t a1, int32_t a2) {
    // 0x3c00
    if (a2 != 0) {
        // 0x3c22
        return unknown_7800(a1, *(int32_t *)(a2 + 12));
    }
    // 0x3c1e
    return function_3c40(*(int32_t *)20, 0, 0, 0);
}

// Address range: 0x3c40 - 0x3c54
int32_t function_3c40(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = *(int32_t *)20 ^ a1; // 0x3c44
    if (result != 0) {
        // 0x3c54
    }
    // 0x3c4d
    return result;
}

// Address range: 0x3c60 - 0x3cdd
// Demangled:     std::_Rb_tree<int, std::pair<int const, CAddrInfo>, std::_Select1st<std::pair<int const, CAddrInfo> >, std::less<int>, std::allocator<std::pair<int const, CAddrInfo> > >::erase(int const &)
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE5eraseERS1_(int32_t a1, int32_t * a2) {
    // 0x3c60
    g5 = a1;
    int32_t v1 = *(int32_t *)(a1 + 8); // 0x3c7c
    int32_t v2 = a1 + 4; // 0x3c7f
    g2 = v2;
    g3 = v2;
    if (v1 != 0) {
        int32_t v3 = *a2; // 0x3c94
        g6 = v3;
        g1 = v1;
        // branch -> 0x3ca7
        while (true) {
            int32_t v4 = v1; // 0x3ca0
            // branch -> 0x3ca7
            while (true) {
                uint32_t v5 = *(int32_t *)(v4 + 16); // 0x3ca7
                if (v5 < v3) {
                    int32_t v6 = *(int32_t *)(v4 + 12); // 0x3ca0
                    g1 = v6;
                    if (v6 == 0) {
                        // break -> 0x3cb7
                        break;
                    }
                    v4 = v6;
                    // continue -> 0x3ca7
                    continue;
                } else {
                    if (v5 <= v3) {
                        // bb
                        v4 = function_3d28();
                        // branch -> 0x3cae
                    }
                    // 0x3cae
                    g3 = v4;
                    int32_t v7 = *(int32_t *)(v4 + 8); // 0x3cb0
                    g1 = v7;
                    if (v7 != 0) {
                        // 0x3cae
                        v3 = g6;
                        v1 = v7;
                        // branch -> 0x3ca7
                        break;
                    }
                }
                // 0x3cb7
                // branch -> 0x3cbb
            }
            // 0x3cb7
            // branch -> 0x3cb7
            // 0x3cb7
            // branch -> 0x3cbb
        }
    }
    int32_t v8 = *(int32_t *)(a1 + 20); // 0x3cbb
    int32_t result = v8; // 0x3cda
    int32_t v9 = v2; // 0x3cda
    if (*(int32_t *)(a1 + 12) == v2) {
        // bb28
        result = function_3d95(v8);
        v9 = g3;
        // branch -> 0x3ccb
    }
    // 0x3ccb
    if (v9 != v2) {
        // 0x3cda
        return result;
    }
    // 0x3cd1
    return function_3dc8();
}

// Address range: 0x3d0b - 0x3d28
int32_t function_3d0b(int32_t result) {
    // 0x3d0b
    g1 = result;
    int32_t v1;
    if (*(int32_t *)20 != v1) {
        // bb
        result = function_3dd5();
        // branch -> 0x3d20
    }
    // 0x3d20
    return result;
}

// Address range: 0x3d28 - 0x3d95
int32_t function_3d28(void) {
    int32_t result = g1; // 0x3d28
    int32_t v1 = *(int32_t *)(result + 12); // 0x3d28
    g7 = v1;
    int32_t v2 = *(int32_t *)(result + 8); // 0x3d2b
    if (v1 != 0) {
        // branch -> 0x3d41
      lab_0x3d41:
        while (true) {
            int32_t v3 = v1; // 0x3d41
            // branch -> 0x3d41
            while (true) {
                // 0x3d41
                if (*(int32_t *)(v3 + 16) > g6) {
                    int32_t v4 = *(int32_t *)(v3 + 8); // 0x3d3a
                    g7 = v4;
                    if (v4 == 0) {
                        // break (via goto) -> 0x3d4d
                        goto lab_0x3d4d;
                    }
                    v1 = v4;
                    // continue (via goto) -> 0x3d41
                    goto lab_0x3d41;
                } else {
                    int32_t v5 = *(int32_t *)(v3 + 12); // 0x3d46
                    g7 = v5;
                    if (v5 == 0) {
                        // break -> 0x3d4d
                        break;
                    }
                    v3 = v5;
                    // continue -> 0x3d41
                    continue;
                }
                // 0x3d4d
                // branch -> 0x3d51
            }
            // 0x3d4d
            // branch -> 0x3d4d
          lab_0x3d4d:;
            // 0x3d4d
            // branch -> 0x3d51
        }
    }
    // 0x3d51
    if (v2 == 0) {
        // 0x3d5f
        return result;
    }
    // branch -> 0x3d71
  lab_0x3d71:
    while (true) {
        int32_t v6 = v2; // 0x3d71
        // branch -> 0x3d71
        while (true) {
            // 0x3d71
            if (*(int32_t *)(v6 + 16) < g6) {
                int32_t v7 = *(int32_t *)(v6 + 12); // 0x3d76
                if (v7 == 0) {
                    // break -> 0x3d7d
                    break;
                }
                v6 = v7;
                // continue -> 0x3d71
                continue;
            } else {
                int32_t v8 = *(int32_t *)(v6 + 8); // 0x3d6a
                if (v8 == 0) {
                    // break (via goto) -> 0x3d7d
                    goto lab_0x3d7d;
                }
                v2 = v8;
                // continue (via goto) -> 0x3d71
                goto lab_0x3d71;
            }
            int32_t v9 = g5; // 0x3d81
            int32_t result2 = *(int32_t *)(v9 + 20); // 0x3d88
            return result2;
        }
      lab_0x3d7d:
        // 0x3d7d
        return *(int32_t *)(g5 + 20);
    }
}

// Address range: 0x3d95 - 0x3dc8
int32_t function_3d95(int32_t a1) {
    // 0x3d95
    int32_t v1;
    unknown_7800(g5, v1);
    *(int32_t *)(g5 + 12) = g2;
    *(int32_t *)(g5 + 8) = 0;
    *(int32_t *)(g5 + 16) = g2;
    *(int32_t *)(g5 + 20) = 0;
    return function_3d0b(v1);
}

// Address range: 0x3dc8 - 0x3dd5
int32_t function_3dc8(void) {
    // 0x3dc8
    return function_3d0b(0);
}

// Address range: 0x3dd5 - 0x3dd6
int32_t function_3dd5(void) {
    // 0x3dd5
    return g1;
}

// Address range: 0x3de0 - 0x3e5d
// Demangled:     std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::erase(int const &)
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE5eraseERKi(int32_t a1, int32_t * a2) {
    // 0x3de0
    g5 = a1;
    int32_t v1 = *(int32_t *)(a1 + 8); // 0x3dfc
    int32_t v2 = a1 + 4; // 0x3dff
    g2 = v2;
    g3 = v2;
    if (v1 != 0) {
        int32_t v3 = *a2; // 0x3e14
        g6 = v3;
        g1 = v1;
        // branch -> 0x3e27
        while (true) {
            int32_t v4 = v1; // 0x3e20
            // branch -> 0x3e27
            while (true) {
                uint32_t v5 = *(int32_t *)(v4 + 16); // 0x3e27
                if (v5 < v3) {
                    int32_t v6 = *(int32_t *)(v4 + 12); // 0x3e20
                    g1 = v6;
                    if (v6 == 0) {
                        // break -> 0x3e37
                        break;
                    }
                    v4 = v6;
                    // continue -> 0x3e27
                    continue;
                } else {
                    if (v5 <= v3) {
                        // bb
                        v4 = function_3ea8();
                        // branch -> 0x3e2e
                    }
                    // 0x3e2e
                    g3 = v4;
                    int32_t v7 = *(int32_t *)(v4 + 8); // 0x3e30
                    g1 = v7;
                    if (v7 != 0) {
                        // 0x3e2e
                        v3 = g6;
                        v1 = v7;
                        // branch -> 0x3e27
                        break;
                    }
                }
                // 0x3e37
                // branch -> 0x3e3b
            }
            // 0x3e37
            // branch -> 0x3e37
            // 0x3e37
            // branch -> 0x3e3b
        }
    }
    int32_t v8 = *(int32_t *)(a1 + 20); // 0x3e3b
    int32_t result = v8; // 0x3e5a
    int32_t v9 = v2; // 0x3e5a
    if (*(int32_t *)(a1 + 12) == v2) {
        // bb28
        result = function_3f15(v8);
        v9 = g3;
        // branch -> 0x3e4b
    }
    // 0x3e4b
    if (v9 != v2) {
        // 0x3e5a
        return result;
    }
    // 0x3e51
    return function_3f48();
}

// Address range: 0x3e8b - 0x3ea8
int32_t function_3e8b(int32_t result) {
    // 0x3e8b
    g1 = result;
    int32_t v1;
    if (*(int32_t *)20 != v1) {
        // bb
        result = function_3f55();
        // branch -> 0x3ea0
    }
    // 0x3ea0
    return result;
}

// Address range: 0x3ea8 - 0x3f15
int32_t function_3ea8(void) {
    int32_t result = g1; // 0x3ea8
    int32_t v1 = *(int32_t *)(result + 12); // 0x3ea8
    g7 = v1;
    int32_t v2 = *(int32_t *)(result + 8); // 0x3eab
    if (v1 != 0) {
        // branch -> 0x3ec1
      lab_0x3ec1:
        while (true) {
            int32_t v3 = v1; // 0x3ec1
            // branch -> 0x3ec1
            while (true) {
                // 0x3ec1
                if (*(int32_t *)(v3 + 16) > g6) {
                    int32_t v4 = *(int32_t *)(v3 + 8); // 0x3eba
                    g7 = v4;
                    if (v4 == 0) {
                        // break (via goto) -> 0x3ecd
                        goto lab_0x3ecd;
                    }
                    v1 = v4;
                    // continue (via goto) -> 0x3ec1
                    goto lab_0x3ec1;
                } else {
                    int32_t v5 = *(int32_t *)(v3 + 12); // 0x3ec6
                    g7 = v5;
                    if (v5 == 0) {
                        // break -> 0x3ecd
                        break;
                    }
                    v3 = v5;
                    // continue -> 0x3ec1
                    continue;
                }
                // 0x3ecd
                // branch -> 0x3ed1
            }
            // 0x3ecd
            // branch -> 0x3ecd
          lab_0x3ecd:;
            // 0x3ecd
            // branch -> 0x3ed1
        }
    }
    // 0x3ed1
    if (v2 == 0) {
        // 0x3edf
        return result;
    }
    // branch -> 0x3ef1
  lab_0x3ef1:
    while (true) {
        int32_t v6 = v2; // 0x3ef1
        // branch -> 0x3ef1
        while (true) {
            // 0x3ef1
            if (*(int32_t *)(v6 + 16) < g6) {
                int32_t v7 = *(int32_t *)(v6 + 12); // 0x3ef6
                if (v7 == 0) {
                    // break -> 0x3efd
                    break;
                }
                v6 = v7;
                // continue -> 0x3ef1
                continue;
            } else {
                int32_t v8 = *(int32_t *)(v6 + 8); // 0x3eea
                if (v8 == 0) {
                    // break (via goto) -> 0x3efd
                    goto lab_0x3efd;
                }
                v2 = v8;
                // continue (via goto) -> 0x3ef1
                goto lab_0x3ef1;
            }
            int32_t v9 = g5; // 0x3f01
            int32_t result2 = *(int32_t *)(v9 + 20); // 0x3f08
            return result2;
        }
      lab_0x3efd:
        // 0x3efd
        return *(int32_t *)(g5 + 20);
    }
}

// Address range: 0x3f15 - 0x3f48
int32_t function_3f15(int32_t a1) {
    // 0x3f15
    int32_t v1;
    unknown_7770(g5, v1);
    *(int32_t *)(g5 + 12) = g2;
    *(int32_t *)(g5 + 8) = 0;
    *(int32_t *)(g5 + 16) = g2;
    *(int32_t *)(g5 + 20) = 0;
    return function_3e8b(v1);
}

// Address range: 0x3f48 - 0x3f55
int32_t function_3f48(void) {
    // 0x3f48
    return function_3e8b(0);
}

// Address range: 0x3f55 - 0x3f56
int32_t function_3f55(void) {
    // 0x3f55
    return g1;
}

// Address range: 0x3f60 - 0x418d
// Demangled:     std::vector<CAddress, std::allocator<CAddress> >::_M_insert_aux(__gnu_cxx::__normal_iterator<CAddress *, std::vector<CAddress, std::allocator<CAddress> > >, CAddress const &)
int32_t _ZNSt6vectorI8CAddressSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g2; // 0x3f60
    int32_t v3 = v1; // esi
    g3 = a2;
    g2 = a3;
    int32_t v4 = *(int32_t *)(v1 + 4); // 0x3f7f
    if (v4 == *(int32_t *)(v1 + 8)) {
        int32_t v5 = *a1; // 0x40f0
        g6 = v5;
        int32_t v6 = (v4 - v5) / 8; // 0x40f4
        int32_t v7 = -0x33333333 * v6; // 0x40f7
        if (v7 == 0) {
            // bb39
            function_41bb(*(int32_t *)20);
            // branch -> 0x4105
        }
        int32_t v8 = -0x66666666 * v6; // 0x4105
        g1 = v8;
        if (v7 < v8 || 0x33333333 * v6 == 0) {
            // bb40
            function_41d7();
            // branch -> 0x4110
        }
        int32_t v9 = 8 * (g3 - g6) / 8; // 0x4140
        int32_t v10 = v9 - 16; // 0x4140
        if (v10 != 0) {
            // 0x4147
            *(int32_t *)v10 = *(int32_t *)g2;
            *(int32_t *)(v9 - 12) = *(int32_t *)(g2 + 4);
            *(int32_t *)(v9 - 8) = *(int32_t *)(g2 + 8);
            *(int32_t *)(v9 - 4) = *(int32_t *)(g2 + 12);
            *(int32_t *)v9 = *(int32_t *)(g2 + 16);
            *(int32_t *)(v9 | 4) = *(int32_t *)(g2 + 20);
            *(int32_t *)(v9 + 8) = *(int32_t *)(g2 + 24);
            *(int32_t *)(v9 + 12) = *(int32_t *)(g2 + 28);
            *(int32_t *)(v9 + 16) = *(int32_t *)(g2 + 32);
            *(int32_t *)(v9 + 20) = *(int32_t *)(g2 + 36);
            // branch -> 0x4182
        }
        // 0x4182
        return *(int32_t *)v3;
    }
    int32_t v11 = 0; // edx
    int32_t v12 = 40; // 0x3fcf
    if (v4 != 0) {
        // 0x3f91
        *(int32_t *)v4 = *(int32_t *)(v4 - 40);
        *(int32_t *)(v4 + 4) = *(int32_t *)(v4 - 36);
        *(int32_t *)(v4 + 8) = *(int32_t *)(v4 - 32);
        *(int32_t *)(v4 + 12) = *(int32_t *)(v4 - 28);
        *(int32_t *)(v4 + 16) = *(int32_t *)(v4 - 24);
        *(int32_t *)(v4 + 20) = *(int32_t *)(v4 - 20);
        *(int32_t *)(v4 + 24) = *(int32_t *)(v4 - 16);
        *(int32_t *)(v4 + 28) = *(int32_t *)(v4 - 12);
        *(int32_t *)(v4 + 32) = *(int32_t *)(v4 - 8);
        *(int32_t *)(v4 + 36) = *(int32_t *)(v4 - 4);
        int32_t v13 = v3; // 0x3fcc
        int32_t v14 = *(int32_t *)(v13 + 4); // 0x3fcc
        v11 = v14;
        v1 = v13;
        v12 = v14 + 40;
        // branch -> 0x3fcf
    }
    // 0x3fcf
    *(int32_t *)(v1 + 4) = v12;
    int32_t v15 = *(int32_t *)g2; // 0x3fd5
    int32_t v16 = v11 - 40; // 0x3fd8
    int32_t v17 = v16; // ecx
    int32_t v18 = *(int32_t *)(g2 + 4); // 0x3fe6
    int32_t v19 = -0x33333333 * (v16 - g3) / 8; // 0x3fe9
    int32_t v20 = *(int32_t *)(g2 + 8); // 0x3ff3
    int32_t v21 = *(int32_t *)(g2 + 12); // 0x3ffc
    int32_t v22 = *(int32_t *)(g2 + 16); // 0x4003
    int32_t v23 = *(int32_t *)(g2 + 20); // 0x400a
    int32_t v24 = *(int32_t *)(g2 + 24); // 0x4011
    int32_t v25 = *(int32_t *)(g2 + 28); // 0x4018
    int32_t v26 = *(int32_t *)(g2 + 32); // 0x401f
    int32_t v27 = *(int32_t *)(g2 + 36); // 0x4026
    int32_t result; // 0x40ed
    if (v19 >= 1) {
        int32_t v28 = 0; // eax
        v3 = v19;
        int32_t v29 = 0; // 0x403c
        // branch -> 0x4038
        while (true) {
            int32_t v30 = *(int32_t *)(v29 - 40 + v16); // 0x4038
            *(int32_t *)(v11 - 40 + v29) = v30;
            int32_t v31 = v28; // 0x4040
            int32_t v32 = *(int32_t *)(v17 - 36 + v31); // 0x4040
            *(int32_t *)(v31 - 36 + v11) = v32;
            int32_t v33 = v28; // 0x4048
            int32_t v34 = *(int32_t *)(v17 - 32 + v33); // 0x4048
            *(int32_t *)(v33 - 32 + v11) = v34;
            int32_t v35 = v28; // 0x4050
            int32_t v36 = *(int32_t *)(v17 - 28 + v35); // 0x4050
            *(int32_t *)(v35 - 28 + v11) = v36;
            int32_t v37 = v28; // 0x4058
            int32_t v38 = *(int32_t *)(v17 - 24 + v37); // 0x4058
            *(int32_t *)(v37 - 24 + v11) = v38;
            int32_t v39 = v28; // 0x4060
            int32_t v40 = *(int32_t *)(v17 - 20 + v39); // 0x4060
            *(int32_t *)(v39 - 20 + v11) = v40;
            int32_t v41 = v28; // 0x4068
            int32_t v42 = *(int32_t *)(v17 - 16 + v41); // 0x4068
            *(int32_t *)(v41 - 16 + v11) = v42;
            int32_t v43 = v28; // 0x4070
            int32_t v44 = *(int32_t *)(v17 - 12 + v43); // 0x4070
            *(int32_t *)(v43 - 12 + v11) = v44;
            int32_t v45 = v28; // 0x4078
            int32_t v46 = *(int32_t *)(v17 - 8 + v45); // 0x4078
            *(int32_t *)(v45 - 8 + v11) = v46;
            int32_t v47 = v28; // 0x4080
            int32_t v48 = *(int32_t *)(v17 - 4 + v47); // 0x4080
            *(int32_t *)(v47 - 4 + v11) = v48;
            int32_t v49 = v28 - 40; // 0x4088
            v28 = v49;
            int32_t v50 = v3 - 1; // 0x408b
            v3 = v50;
            if (v50 == 0) {
                // 0x4090
                // branch -> 0x4090
                // 0x4090
                *(int32_t *)g3 = v15;
                *(int32_t *)(g3 + 4) = v18;
                *(int32_t *)(g3 + 8) = v20;
                *(int32_t *)(g3 + 12) = v21;
                *(int32_t *)(g3 + 16) = v22;
                *(int32_t *)(g3 + 20) = v23;
                *(int32_t *)(g3 + 24) = v24;
                *(int32_t *)(g3 + 28) = v25;
                *(int32_t *)(g3 + 32) = v26;
                g1 = v27;
                *(int32_t *)(g3 + 36) = v27;
                // 0x4090
                // branch -> 0x40e6
                // 0x40e6
                g2 = v2;
                return g1;
            }
            // 0x4038
            v29 = v49;
            v16 = v17;
            // branch -> 0x4038
        }
    }
    // 0x4090
    *(int32_t *)g3 = v15;
    *(int32_t *)(g3 + 4) = v18;
    *(int32_t *)(g3 + 8) = v20;
    *(int32_t *)(g3 + 12) = v21;
    *(int32_t *)(g3 + 16) = v22;
    *(int32_t *)(g3 + 20) = v23;
    *(int32_t *)(g3 + 24) = v24;
    *(int32_t *)(g3 + 28) = v25;
    *(int32_t *)(g3 + 32) = v26;
    g1 = v27;
    *(int32_t *)(g3 + 36) = v27;
    // 0x4090
    result = g1;
    // branch -> 0x40e6
    // 0x40e6
    g2 = v2;
    return result;
}

// Address range: 0x4199 - 0x41a0
int32_t function_4199(void) {
    int32_t * v1 = (int32_t *)-0x762d7aea; // 0x4199
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x41a9 - 0x41bb
int32_t function_41a9(int32_t a1) {
    int32_t * v1 = (int32_t *)0x247c033e; // 0x41a9
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    unsigned char v3 = (char)false + (char)v2; // 0x41b2
    return (int32_t)v3 | v2 & -256;
}

// Address range: 0x41bb - 0x41d7
int32_t function_41bb(int32_t a1) {
    int32_t result = g3 - g6; // 0x41bd
    g6 = -0x33333333 * result / 8;
    return result;
}

// Address range: 0x41d7 - 0x4207
int32_t function_41d7(void) {
    // 0x41d7
    g6 = -0x33333333 * (g3 - g6) / 8;
    return g1;
}

// Address range: 0x4207 - 0x4208
int32_t function_4207(void) {
    // 0x4207
    return g1;
}

// Address range: 0x4210 - 0x42f0
// Demangled:     void std::vector<char, zero_after_free_allocator<char> >::_M_range_insert<char const *>(__gnu_cxx::__normal_iterator<char *, std::vector<char, zero_after_free_allocator<char> > >, char const *, char const *, std::forward_iterator_tag)
int32_t _ZNSt6vectorIc25zero_after_free_allocatorIcEE15_M_range_insertIPKcEEvN9__gnu_cxx17__normal_iteratorIPcS2_EET_SA_St20forward_iterator_tag(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g2; // 0x4210
    int32_t v3 = g5; // 0x4211
    int32_t v4 = g7; // 0x4212
    int32_t v5 = g3; // 0x4213
    g3 = a4;
    g1 = 0;
    g5 = v1;
    g7 = a2;
    if (a4 == a3) {
        // 0x42b1
        g3 = v5;
        g7 = v4;
        g5 = v3;
        g2 = v2;
        return 0;
    }
    int32_t v6 = *(int32_t *)(v1 + 4); // 0x423b
    g4 = v6;
    uint32_t v7 = a4 - a3; // 0x4243
    g2 = v7;
    if (v7 > *(int32_t *)(v1 + 8) - v6) {
        int32_t v8 = *a1; // 0x42c0
        int32_t v9 = v6 - v8; // 0x42c2
        int32_t v10 = -1 - v9; // 0x42ca
        g1 = v10;
        int32_t result = v10; // 0x42ed5
        uint32_t v11 = v9; // 0x42d6
        if (v7 > v10) {
            int32_t v12 = function_44a4(a3, v8); // 0x42ce
            g1 = v12;
            result = v12;
            v11 = v9;
            // branch -> 0x42d4
        }
        int32_t v13 = v7 < v11 ? v11 : v7; // 0x42d6
        g2 = v13;
        int32_t v14 = v13 + v11; // 0x42d9
        g4 = v14;
        if (v14 >= v11) {
            // bb41
            result = function_43b0(-1);
            // branch -> 0x42e9
        }
        // 0x42e9
        return result;
    }
    int32_t v15 = v6 - a2; // 0x424d
    if (v7 >= v15) {
        // bb
        function_43d0((char *)v15, a3);
        v6 = g4;
        // branch -> 0x425b
    }
    int32_t v16 = v6 - v7; // 0x425d
    int32_t v17; // 0x4288
    if (v7 == 0) {
        // 0x425b
        v17 = g5;
        // branch -> 0x4286
    } else {
        // branch -> 0x4270
        while (true) {
            int32_t v18 = v6; // 0x427f
            int32_t v19 = 0; // 0x427c
            if (v6 != 0) {
                // 0x4274
                *(char *)v6 = *(char *)v16;
                v18 = g4;
                v19 = v6;
                // branch -> 0x4279
            }
            int32_t v20 = v16 + 1; // 0x4279
            v16 = v20;
            if (v20 == v18) {
                // break -> 0x4283
                break;
            }
            v6 = v19 + 1;
            v16 = v20;
            // continue -> 0x4270
        }
        int32_t v21 = g5; // 0x4283
        v17 = v21;
        v6 = *(int32_t *)(v21 + 4);
        // branch -> 0x4286
    }
    // 0x4286
    *(int32_t *)(v17 + 4) = v6 + v7;
    int32_t v22 = v16 - g7; // 0x428f
    g1 = v22;
    int32_t result2 = v22; // 0x42b817
    if (v22 != 0) {
        int32_t v23 = function_4488(); // 0x4291
        g1 = v23;
        result2 = v23;
        // branch -> 0x4297
    }
    if (v7 != 0) {
        int32_t v24 = function_4470(); // 0x4299
        g1 = v24;
        result2 = v24;
        // branch -> 0x42a0
    }
    // 0x42b1
    g3 = v5;
    g7 = v4;
    g5 = v3;
    g2 = v2;
    return result2;
}

// Address range: 0x42ff - 0x4389
int32_t function_42ff(char * a1) {
    // 0x42ff
    char * v1;
    int32_t v2 = (int32_t)v1; // 0x42ff
    int32_t v3 = (int32_t)a1; // 0x4303
    int32_t v4 = v3; // ebp
    int32_t v5 = v3; // 0x4331
    int32_t v6; // eax
    int32_t v7; // edx
    if (v2 != g7) {
        // 0x4309
        v7 = v2;
        v6 = v3;
        int32_t v8 = g7; // 0x431f7
        int32_t v9 = v2; // 0x4314
        int32_t v10 = v3; // 0x4317
        // branch -> 0x4310
        int32_t v11; // 0x4323
        while (true) {
            // 0x4310
            v11 = v8;
            int32_t v12 = 0; // 0x431c
            int32_t v13 = v9; // 0x4319
            if (v10 != 0) {
                // 0x4314
                *(char *)v10 = *(char *)v9;
                v11 = g7;
                v12 = v6;
                v13 = v7;
                // branch -> 0x4319
            }
            int32_t v14 = v13 + 1; // 0x4319
            v7 = v14;
            int32_t v15 = v12 + 1; // 0x431c
            v6 = v15;
            if (v14 == v11) {
                // break -> 0x4323
                break;
            }
            v8 = v11;
            v9 = v14;
            v10 = v15;
            // continue -> 0x4310
        }
        int32_t v16 = v11 - v2 + v3; // 0x4329
        v4 = v16;
        v5 = v16;
        // branch -> 0x432d
    }
    // 0x432d
    char * v17;
    int32_t v18 = (int32_t)v17; // 0x432d
    v6 = v18;
    v7 = v5;
    int32_t v19 = v18; // 0x433c
    // branch -> 0x4338
    int32_t v20; // 0x4341
    while (true) {
        int32_t v21 = 0; // 0x4344
        int32_t v22 = v19; // 0x4341
        if (v5 != 0) {
            // 0x433c
            *(char *)v5 = *(char *)v19;
            v21 = v7;
            v22 = v6;
            // branch -> 0x4341
        }
        // 0x4341
        v20 = v22 + 1;
        v6 = v20;
        int32_t v23 = v21 + 1; // 0x4344
        v7 = v23;
        if (v20 == g3) {
            // break -> 0x434b
            break;
        }
        v19 = v20;
        v5 = v23;
        // continue -> 0x4338
    }
    int32_t v24 = v4 + v20 - v18; // 0x434f
    g2 = v24;
    int32_t v25 = g5; // 0x4351
    int32_t v26 = *(int32_t *)(v25 + 4); // 0x4351
    if (v26 != g7) {
        // 0x4358
        v7 = g7;
        int32_t v27 = v26; // 0x436f16
        int32_t v28 = g7; // 0x4364
        // branch -> 0x4360
        int32_t v29; // 0x4369
        while (true) {
            int32_t v30 = v27; // 0x436f
            int32_t v31 = 0; // 0x436c
            int32_t v32 = v28; // 0x4369
            if (v24 != 0) {
                // 0x4364
                *(char *)v24 = *(char *)v28;
                v30 = v26;
                v31 = v24;
                v32 = v7;
                // branch -> 0x4369
            }
            // 0x4369
            v29 = v32 + 1;
            v7 = v29;
            if (v29 == v30) {
                // break -> 0x4373
                break;
            }
            v27 = v30;
            v28 = v29;
            v24 = v31 + 1;
            // continue -> 0x4360
        }
        // 0x4373
        g2 += v29 - g7;
        v25 = g5;
        // branch -> 0x4377
    }
    // 0x4377
    g3 = v25;
    int32_t v33 = *(int32_t *)(v25 + 8); // 0x4380
    if (v25 == 0) {
        // bb
        v33 = function_4396();
        // branch -> 0x4380
    }
    // 0x4380
    return v33 - v25;
}

// Address range: 0x4396 - 0x43ab
int32_t function_4396(void) {
    // 0x4396
    *(int32_t *)(g5 + 4) = g2;
    int32_t v1 = 0; // eax
    *(int32_t *)g5 = v1;
    int32_t v2;
    int32_t result = v1 + v2; // 0x439f
    *(int32_t *)(g5 + 8) = result;
    return result;
}

// Address range: 0x43b0 - 0x43cd
int32_t function_43b0(int32_t a1) {
    // 0x43b0
    if (g4 != 0) {
        // bb
        function_44b0();
        // branch -> 0x43b8
    }
    // 0x43b8
    return function_42ff(NULL);
}

// Address range: 0x43d0 - 0x4468
int32_t function_43d0(char * a1, int32_t a2) {
    int32_t v1 = g4; // 0x43d4
    int32_t v2 = v1; // eax
    int32_t v3 = (int32_t)a1; // 0x43d6
    int32_t v4 = v3 + a2; // 0x43d6
    int32_t v5 = v4; // edx
    int32_t v6; // 0x4406
    int32_t v7; // 0x440a
    if (g3 == v4) {
        // 0x43d0
        v7 = g5;
        v6 = v1;
        // branch -> 0x4402
    } else {
        int32_t v8 = g3; // 0x43f76
        int32_t v9 = v1; // 0x43ef
        while (true) {
            int32_t v10 = v8; // 0x43f7
            int32_t v11 = 0; // 0x43f4
            int32_t v12 = v4; // 0x43f1
            if (v9 != 0) {
                // 0x43ec
                *(char *)v9 = *(char *)v4;
                v10 = g3;
                v11 = v2;
                v12 = v5;
                // branch -> 0x43f1
            }
            int32_t v13 = v12 + 1; // 0x43f1
            v5 = v13;
            int32_t v14 = v11 + 1; // 0x43f4
            v2 = v14;
            if (v13 == v10) {
                // break -> 0x43fb
                break;
            }
            v8 = v10;
            v4 = v13;
            v9 = v14;
            // continue -> 0x43e8
        }
        // 0x43fb
        g4 = v1;
        int32_t v15 = g5; // 0x43ff
        v7 = v15;
        v6 = *(int32_t *)(v15 + 4);
        // branch -> 0x4402
    }
    int32_t v16 = g2 - v3 + v6; // 0x4406
    int32_t v17 = v16; // ebp
    *(int32_t *)(v7 + 4) = v16;
    int32_t v18; // 0x4433
    int32_t v19; // 0x443b
    if (v1 == g7) {
        // 0x4402
        v19 = g5;
        v18 = v17;
        // branch -> 0x442f
    } else {
        // 0x440f
        v2 = g7;
        int32_t v20 = g7; // 0x441c
        int32_t v21 = v17; // 0x441f
        // branch -> 0x4418
        while (true) {
            int32_t v22 = 0; // 0x4425
            int32_t v23 = v20; // 0x4422
            if (v21 != 0) {
                // 0x441c
                *(char *)v21 = *(char *)v20;
                v22 = v17;
                v23 = v2;
                // branch -> 0x4422
            }
            int32_t v24 = v23 + 1; // 0x4422
            v2 = v24;
            int32_t v25 = v22 + 1; // 0x4425
            v17 = v25;
            if (v24 == g4) {
                // break -> 0x442c
                break;
            }
            v20 = v24;
            v21 = v25;
            // continue -> 0x4418
        }
        int32_t v26 = g5; // 0x442c
        v19 = v26;
        v18 = *(int32_t *)(v26 + 4);
        // branch -> 0x442f
    }
    // 0x442f
    g1 = v3;
    *(int32_t *)(v19 + 4) = v18 + v3;
    int32_t v27;
    int32_t result; // 0x4467
    if ((*(int32_t *)20 ^ v27) != 0) {
        // bb
        result = function_449f();
        // branch -> 0x4451
    } else {
        // 0x442f
        result = g1;
        // branch -> 0x4451
    }
    // 0x4451
    return result;
}

// Address range: 0x4470 - 0x4483
int32_t function_4470(void) {
    // 0x4470
    int32_t v1;
    int32_t result; // 0x4481
    if (*(int32_t *)20 != v1) {
        // bb
        result = function_449f();
        // branch -> 0x447d
    } else {
        // 0x4470
        result = g1;
        // branch -> 0x447d
    }
    // 0x447d
    return result;
}

// Address range: 0x4488 - 0x4495
int32_t function_4488(void) {
    // 0x4488
    return g1;
}

// Address range: 0x449a - 0x449f
int32_t function_449a(void) {
    // 0x449a
    return 0;
}

// Address range: 0x449f - 0x44a0
int32_t function_449f(void) {
    // 0x449f
    return g1;
}

// Address range: 0x44a4 - 0x44ab
int32_t function_44a4(int32_t a1, int32_t a2) {
    // 0x44a4
    return g1;
}

// Address range: 0x44b0 - 0x44b9
int32_t function_44b0(void) {
    // 0x44b0
    return g1;
}

// Address range: 0x44c0 - 0x450e
// Demangled:     std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, int const &)
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE10_M_insert_EPKSt18_Rb_tree_node_baseS8_RKi(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x44c0
    g6 = a5;
    g5 = a4;
    int32_t result = a3; // 0x4507
    if (a3 == 0) {
        // bb
        result = function_4570(*(int32_t *)20);
        // branch -> 0x44ff
    }
    // 0x44ff
    return result;
}

// Address range: 0x453c - 0x456c
int32_t function_453c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7ce3dbbc; // 0x453c
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x4543
    int32_t v3 = (v2 + 1 + (int32_t)false) % 256 | v2 & -256; // 0x4543
    int32_t result = 0; // esi
    *(int32_t *)result = v3;
    g1 = result;
    if (*(int32_t *)20 != a1) {
        // bb
        result = function_4586();
        // branch -> 0x4556
    }
    // 0x4556
    return result;
}

// Address range: 0x4570 - 0x4586
int32_t function_4570(int32_t a1) {
    int32_t v1 = *(int32_t *)(g5 + 16); // 0x4574
    int32_t v2 = g6 - v1; // 0x4577
    return v2 < 0 != ((v2 ^ g6) & (g6 ^ v1)) < 0;
}

// Address range: 0x4586 - 0x4587
int32_t function_4586(void) {
    // 0x4586
    return g1;
}

// Address range: 0x4590 - 0x4628
// Demangled:     std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::_M_insert_unique(int const &)
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE16_M_insert_uniqueERKi(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g5; // 0x4591
    int32_t v3 = g7; // 0x4592
    int32_t v4 = g3; // 0x4593
    g5 = a2;
    g3 = v1;
    int32_t result = *(int32_t *)(a2 + 8); // 0x45af
    g7 = result;
    int32_t v5; // 0x4617
    if (result == 0) {
        // 0x4617
        v5 = a2 + 4;
        g7 = v5;
        // branch -> 0x4620
    } else {
        // 0x45ba
        int32_t v6;
        int32_t v7 = *(int32_t *)v6; // 0x45be
        // branch -> 0x45d6
        while (true) {
            int32_t v8 = *(int32_t *)(result + 16); // 0x45d6
            int32_t v9; // 0x45f8
            int32_t result3; // 0x4609
            int32_t v10; // 0x45f8
            int32_t result2; // 0x4623
            int32_t v11; // 0x45c8
            int32_t v12; // 0x45f6
            if (v8 > v7) {
                // 0x45c8
                v11 = *(int32_t *)(result + 8);
                if (v11 == 0) {
                    // 0x4620
                    if (result != *(int32_t *)(a2 + 12)) {
                        // 0x4625
                        return result;
                    }
                    // bb33
                    result2 = function_4640(v8);
                    // branch -> 0x4625
                    // 0x4625
                    return result2;
                    // 0x45f2
                    v10 = v1;
                    v9 = result;
                    if (v8 < v7) {
                        // bb
                        v12 = function_4640(v8);
                        v10 = g3;
                        v9 = v12;
                        // branch -> 0x45f8
                    }
                    // 0x45f8
                    *(int32_t *)v10 = v9;
                    *(char *)(g3 + 4) = 0;
                    result3 = g3;
                    g1 = result3;
                    // 0x460d
                    g3 = v4;
                    g7 = v3;
                    g5 = v2;
                    return result3;
                }
            } else {
                int32_t v13 = *(int32_t *)(result + 12); // 0x45dd
                if (v13 == 0) {
                    // 0x45f2
                    v10 = v1;
                    v9 = result;
                    if (v8 < v7) {
                        // bb
                        v12 = function_4640(v8);
                        v10 = g3;
                        v9 = v12;
                        // branch -> 0x45f8
                    }
                    // 0x45f8
                    *(int32_t *)v10 = v9;
                    *(char *)(g3 + 4) = 0;
                    result3 = g3;
                    g1 = result3;
                    // 0x460d
                    g3 = v4;
                    g7 = v3;
                    g5 = v2;
                    return result3;
                }
                v11 = v13;
            }
            // 0x45d4
            g7 = v11;
            result = v11;
            // branch -> 0x45d6
        }
    }
    int32_t result4 = 0; // 0x4625
    if (v5 == *(int32_t *)(a2 + 12)) {
        // bb33
        int32_t v14;
        result4 = function_4640(v14);
        // branch -> 0x4625
    }
    // 0x4625
    return result4;
}

// Address range: 0x4640 - 0x4673
int32_t function_4640(int32_t result) {
    // 0x4640
    int32_t v1; // bp+44
    unknown_8a50((int32_t)&v1, g5, 0, g7, result);
    *(char *)(g3 + 4) = 1;
    *(int32_t *)g3 = result;
    return result;
}

// Address range: 0x4673 - 0x4678
int32_t function_4673(void) {
    // 0x4673
    return g1;
}

// Address range: 0x4680 - 0x46ba
// Demangled:     std::_Rb_tree<CNetAddr, std::pair<CNetAddr const, int>, std::_Select1st<std::pair<CNetAddr const, int> >, std::less<CNetAddr>, std::allocator<std::pair<CNetAddr const, int> > >::equal_range(CNetAddr const &)
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE11equal_rangeERS2_(void) {
    // 0x4680
    int32_t v1;
    g7 = v1 + 4;
    int32_t result = 0; // 0x46b6
    if (*(int32_t *)(v1 + 8) == 0) {
        // bb
        result = function_46ce(*(int32_t *)20);
        // branch -> 0x46ac
    }
    // 0x46ac
    return result;
}

// Address range: 0x46ce - 0x46f0
int32_t function_46ce(int32_t a1) {
    // 0x46ce
    *(int32_t *)g3 = g7;
    *(int32_t *)(g3 + 4) = g7;
    g1 = g3;
    int32_t result = g3; // 0x46ed
    if (*(int32_t *)20 != a1) {
        // bb
        result = function_4765();
        // branch -> 0x46e6
    }
    // 0x46e6
    return result;
}

// Address range: 0x46fb - 0x4707
int32_t function_46fb(void) {
    int32_t result = 0; // eax
    int32_t * v1 = (int32_t *)(result - 0x176f78c + 8 * result); // 0x46fb
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0x4718 - 0x4719
int32_t function_4718(void) {
    // 0x4718
    return g1;
}

// Address range: 0x471c - 0x471d
int32_t function_471c(void) {
    // 0x471c
    return g1;
}

// Address range: 0x472e - 0x4760
int32_t function_472e(int32_t a1, int32_t result) {
    int32_t * v1 = (int32_t *)-0x7bebdbac; // 0x472e
    *v1 = *v1 - 1;
    if (*(int32_t *)8 != 0) {
        // bb
        function_471c();
        // branch -> 0x4740
    }
    // 0x4740
    _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE11equal_rangeERS2_();
    *(int32_t *)(g3 + 4) = g7;
    *(int32_t *)g3 = result;
    return result;
}

// Address range: 0x4760 - 0x4765
int32_t function_4760(void) {
    // 0x4760
    return function_4718();
}

// Address range: 0x4765 - 0x4766
int32_t function_4765(void) {
    // 0x4765
    return g1;
}

// Address range: 0x4770 - 0x47cd
// Demangled:     std::_Rb_tree<CNetAddr, std::pair<CNetAddr const, int>, std::_Select1st<std::pair<CNetAddr const, int> >, std::less<CNetAddr>, std::allocator<std::pair<CNetAddr const, int> > >::erase(CNetAddr const &)
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE5eraseERS2_(int32_t a1, int32_t a2) {
    // 0x4770
    g5 = a1;
    int32_t v1; // bp-52
    unknown_8df0((int32_t)&v1, a1, a2);
    int32_t v2 = g5; // 0x479f
    g2 = v1;
    int32_t v3;
    int32_t result = v3; // 0x47ca
    int32_t v4 = v2; // 0x47b8
    if (*(int32_t *)(v2 + 12) == v3) {
        // bb
        result = function_4818(*(int32_t *)(v2 + 20));
        v1 = g2;
        v4 = g5;
        // branch -> 0x47b8
    }
    // 0x47b8
    if (v1 != result) {
        // 0x47ca
        return result;
    }
    // 0x47c3
    return function_484e(v4 + 4);
}

// Address range: 0x47fd - 0x4816
int32_t function_47fd(int32_t result) {
    // 0x47fd
    g1 = result;
    int32_t v1;
    if (*(int32_t *)20 != v1) {
        // bb
        result = function_4858();
        // branch -> 0x480e
    }
    // 0x480e
    return result;
}

// Address range: 0x4818 - 0x484e
int32_t function_4818(int32_t a1) {
    int32_t v1 = g5; // 0x4818
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x4825
    unknown_8370(v1, v2);
    int32_t v3 = v1 + 4; // edx
    *(int32_t *)(g5 + 8) = 0;
    *(int32_t *)(g5 + 20) = 0;
    *(int32_t *)(g5 + 12) = v3;
    *(int32_t *)(g5 + 16) = v3;
    return function_47fd(v2);
}

// Address range: 0x484e - 0x4858
int32_t function_484e(int32_t a1) {
    // 0x484e
    return function_47fd(0);
}

// Address range: 0x4858 - 0x4859
int32_t function_4858(void) {
    // 0x4858
    return g1;
}

// Address range: 0x4860 - 0x48b5
// Demangled:     std::_Rb_tree<int, std::pair<int const, CAddrInfo>, std::_Select1st<std::pair<int const, CAddrInfo> >, std::less<int>, std::allocator<std::pair<int const, CAddrInfo> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<int const, CAddrInfo> const &)
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE10_M_insert_EPKSt18_Rb_tree_node_baseSC_RKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4860
    g6 = a4;
    g7 = a5;
    int32_t v1 = a2 + 4; // 0x4891
    int32_t result = v1; // 0x48ae
    if (a3 == 0) {
        // bb
        result = function_4918(a1, v1, 1);
        // branch -> 0x48aa
    }
    // 0x48aa
    return result;
}

// Address range: 0x48b9 - 0x48c0
int32_t function_48b9(void) {
    int32_t * v1 = (int32_t *)-0x76efdbac; // 0x48b9
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x48e9 - 0x4917
int32_t function_48e9(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 - 0x7cebdbbc); // 0x48e9
    *v2 = *v2 - 1;
    int32_t v3 = 0; // 0x48f0
    int32_t v4 = (v3 + 1 + (int32_t)false) % 256 | v3 & -256; // 0x48f0
    g1 = v4;
    *(int32_t *)v4 = v1;
    int32_t result; // 0x4914
    if (*(int32_t *)20 != a1) {
        // bb
        result = function_4930();
        // branch -> 0x4901
    } else {
        // 0x48e9
        result = g1;
        // branch -> 0x4901
    }
    // 0x4901
    return result;
}

// Address range: 0x4918 - 0x4930
int32_t function_4918(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(g6 + 16); // 0x491c
    int32_t v2 = g7 - v1; // 0x491f
    return v2 < 0 != ((v2 ^ g7) & (g7 ^ v1)) < 0;
}

// Address range: 0x4930 - 0x4931
int32_t function_4930(void) {
    // 0x4930
    return g1;
}

// Address range: 0x4940 - 0x4a23
// Demangled:     std::_Rb_tree<int, std::pair<int const, CAddrInfo>, std::_Select1st<std::pair<int const, CAddrInfo> >, std::less<int>, std::allocator<std::pair<int const, CAddrInfo> > >::_M_insert_unique(std::pair<int const, CAddrInfo> const &)
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE16_M_insert_uniqueERKS3_(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1; // ebx
    int32_t v2 = *(int32_t *)(a2 + 8); // 0x495f
    int32_t v3; // bp-48
    int32_t result; // 0x49b9
    int32_t v4; // 0x49d5
    int32_t v5; // 0x49e3
    if (v2 == 0) {
        // 0x49c7
        v4 = a2 + 4;
        v5 = 0;
        // branch -> 0x49d0
    } else {
        uint32_t v6 = *(int32_t *)a3; // 0x496e
        // branch -> 0x4986
        while (true) {
            uint32_t v7 = *(int32_t *)(v2 + 16); // 0x4986
            int32_t v8; // 0x49fb
            int32_t v9; // 0x4978
            if (v7 > v6) {
                // 0x4978
                v9 = *(int32_t *)(v2 + 8);
                if (v9 == 0) {
                    v4 = v2;
                    v5 = v2;
                    // 0x49d0
                    if (v4 != *(int32_t *)(a2 + 12)) {
                        // 0x49d5
                        if (*(int32_t *)(v5 + 16) >= *(int32_t *)a3) {
                            // 0x49a8
                            *a1 = v5;
                            *(char *)(v1 + 4) = 0;
                            // branch -> 0x49ae
                            // 0x49ae
                            result = v1;
                            if (*(int32_t *)20 != *(int32_t *)(g8 + 60)) {
                                // 0x4a23
                                return result;
                            }
                            // 0x49bd
                            return result;
                        }
                        v8 = v4;
                    } else {
                        v8 = v4;
                    }
                    // 0x49f0
                    unknown_91a0((int32_t)&v3, a2, 0, v8, a3);
                    *(char *)(v1 + 4) = 1;
                    *(int32_t *)v1 = a3;
                    // branch -> 0x49ae
                    // 0x49ae
                    result = v1;
                    if (*(int32_t *)20 != *(int32_t *)(g8 + 60)) {
                        // 0x4a23
                        return result;
                    }
                    // 0x49bd
                    return result;
                }
            } else {
                int32_t v10 = *(int32_t *)(v2 + 12); // 0x498d
                if (v10 == 0) {
                    // 0x49a2
                    if (v7 >= v6) {
                        // 0x49a8
                        *a1 = v2;
                        *(char *)(v1 + 4) = 0;
                        // branch -> 0x49ae
                        // 0x49ae
                        result = v1;
                        if (*(int32_t *)20 != *(int32_t *)(g8 + 60)) {
                            // 0x4a23
                            return result;
                        }
                        // 0x49bd
                        return result;
                    }
                    v8 = v2;
                    // 0x49f0
                    unknown_91a0((int32_t)&v3, a2, 0, v8, a3);
                    *(char *)(v1 + 4) = 1;
                    *(int32_t *)v1 = a3;
                    // branch -> 0x49ae
                    // 0x49ae
                    result = v1;
                    if (*(int32_t *)20 != *(int32_t *)(g8 + 60)) {
                        // 0x4a23
                        return result;
                    }
                    // 0x49bd
                    return result;
                }
                v9 = v10;
            }
            // 0x4984
            v2 = v9;
            // branch -> 0x4986
        }
    }
    // 0x49d0
    if (v4 == *(int32_t *)(a2 + 12)) {
        // 0x49f0
        unknown_91a0((int32_t)&v3, a2, 0, v4, a3);
        *(char *)(v1 + 4) = 1;
        *(int32_t *)v1 = a3;
        // branch -> 0x49ae
        // 0x49ae
        result = v1;
        if (*(int32_t *)20 != *(int32_t *)(g8 + 60)) {
            // 0x4a23
            return result;
        }
        // 0x49bd
        return result;
    }
    // 0x49d5
    if (*(int32_t *)(v5 + 16) >= *(int32_t *)a3) {
        // 0x49a8
        *a1 = v5;
        *(char *)(v1 + 4) = 0;
        // branch -> 0x49ae
        // 0x49ae
        result = v1;
        if (*(int32_t *)20 != *(int32_t *)(g8 + 60)) {
            // 0x4a23
            return result;
        }
        // 0x49bd
        return result;
    }
    // 0x49f0
    unknown_91a0((int32_t)&v3, a2, 0, v4, a3);
    *(char *)(v1 + 4) = 1;
    *(int32_t *)v1 = a3;
    // branch -> 0x49ae
    // 0x49ae
    result = v1;
    if (*(int32_t *)20 != *(int32_t *)(g8 + 60)) {
        // 0x4a23
        return result;
    }
    // 0x49bd
    return result;
}

// Address range: 0x4a30 - 0x4a84
// Demangled:     std::_Rb_tree<int, std::pair<int const, CAddrInfo>, std::_Select1st<std::pair<int const, CAddrInfo> >, std::less<int>, std::allocator<std::pair<int const, CAddrInfo> > >::_M_insert_unique_(std::_Rb_tree_const_iterator<std::pair<int const, CAddrInfo> >, std::pair<int const, CAddrInfo> const &)
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS3_ERKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t * a4) {
    int32_t v1 = (int32_t)a4;
    g5 = a2;
    g3 = a3;
    g7 = a1;
    g2 = v1;
    int32_t v2 = a3; // 0x4a6d
    if (a2 + 4 == a3) {
        // bb
        function_4b38(*(int32_t *)20);
        v2 = g3;
        v1 = g2;
        // branch -> 0x4a6a
    }
    uint32_t v3 = *(int32_t *)v1; // 0x4a6a
    uint32_t v4 = *(int32_t *)(v2 + 16); // 0x4a6d
    int32_t v5 = v3 - v4; // 0x4a6d
    g24 = ((v5 ^ v3) & (v4 ^ v3)) < 0;
    g26 = v5 == 0;
    g25 = v5 < 0;
    if (v3 >= v4) {
        // bb115
        function_4ae8();
        v2 = g3;
        // branch -> 0x4a72
    }
    int32_t v6 = *(int32_t *)(g5 + 12); // 0x4a72
    g1 = v6;
    int32_t result = v6; // 0x4a80
    if (v6 == v2) {
        // bb116
        result = function_4bae();
        // branch -> 0x4a7d
    }
    // 0x4a7d
    return result;
}

// Address range: 0x4abc - 0x4ae5
int32_t function_4abc(void) {
    // 0x4abc
    g1 = g7;
    int32_t result = g7; // 0x4ae2
    int32_t v1;
    if (*(int32_t *)20 != v1) {
        // bb
        result = function_4bb7();
        // branch -> 0x4acf
    }
    // 0x4acf
    return result;
}

// Address range: 0x4ae8 - 0x4b00
int32_t function_4ae8(void) {
    // 0x4ae8
    if (g26 || g25 != g24) {
        // bb
        function_4b78();
        // branch -> 0x4aee
    }
    int32_t v1 = *(int32_t *)(g5 + 16); // 0x4aee
    g1 = v1;
    int32_t result = v1; // 0x4afc
    if (v1 == g3) {
        // bb3
        result = function_4b80();
        // branch -> 0x4af9
    }
    // 0x4af9
    return result;
}

// Address range: 0x4b1d - 0x4b36
int32_t function_4b1d(void) {
    int32_t v1 = g1; // 0x4b1d
    unknown_9290(g7, g5, v1, v1);
    return function_4abc();
}

// Address range: 0x4b38 - 0x4b72
int32_t function_4b38(int32_t a1) {
    int32_t v1 = g5; // 0x4b38
    int32_t v2; // bp+40
    if (*(int32_t *)(v1 + 20) == 0) {
        // 0x4b50
        unknown_9370((int32_t)&v2, v1);
        *(int32_t *)g7 = a1;
        return function_4abc();
    }
    int32_t v3 = *(int32_t *)(v1 + 16); // 0x4b3f
    g1 = v3;
    if (*(int32_t *)(v3 + 16) < g2) {
        // bb
        function_4b80();
        // branch -> 0x4b50
    }
    // 0x4b50
    unknown_9370((int32_t)&v2, g5);
    *(int32_t *)g7 = a1;
    return function_4abc();
}

// Address range: 0x4b78 - 0x4b7f
int32_t function_4b78(void) {
    // 0x4b78
    *(int32_t *)g7 = g3;
    return function_4abc();
}

// Address range: 0x4b80 - 0x4ba4
int32_t function_4b80(void) {
    // 0x4b80
    unknown_9290(g7, g5, 0, g1);
    return function_4abc();
}

// Address range: 0x4ba8 - 0x4bae
int32_t function_4ba8(void) {
    // 0x4ba8
    return 0;
}

// Address range: 0x4bae - 0x4bb7
int32_t function_4bae(void) {
    // 0x4bae
    return function_4b1d();
}

// Address range: 0x4bb7 - 0x4bb8
int32_t function_4bb7(void) {
    // 0x4bb7
    return g1;
}

// Address range: 0x4bc0 - 0x4c47
// Demangled:     std::map<int, CAddrInfo, std::less<int>, std::allocator<std::pair<int const, CAddrInfo> > >::operator[](int const &)
int32_t _ZNSt3mapIi9CAddrInfoSt4lessIiESaISt4pairIKiS0_EEEixERS4_(int32_t a1, int32_t * a2) {
    int32_t v1 = g2; // 0x4bc0
    int32_t v2 = g5; // 0x4bc1
    int32_t v3 = g7; // 0x4bc2
    int32_t v4 = g3; // 0x4bc3
    g2 = a1;
    g5 = (int32_t)a2;
    int32_t v5 = *(int32_t *)(a1 + 8); // 0x4be7
    int32_t v6 = a1 + 4; // 0x4bea
    int32_t v7; // bp-112
    if (v5 == 0) {
        // 0x4c38
        g3 = v6;
        // branch -> 0x4c40
    } else {
        uint32_t v8 = *a2; // 0x4bf1
        g3 = v6;
        int32_t v9 = v6;
        // branch -> 0x4c01
      lab_0x4c01:
        while (true) {
            int32_t v10 = v5; // 0x4c01
            // branch -> 0x4c01
            int32_t v11; // 0x4c24
            int32_t result2; // 0x4c24
            int32_t result3; // 0x4c4416
            while (true) {
                // 0x4c01
                if (v8 > *(int32_t *)(v10 + 16)) {
                    int32_t v12 = *(int32_t *)(v10 + 12); // 0x4c06
                    if (v12 == 0) {
                        result3 = v12;
                        v11 = v9;
                        // break -> 0x4c0d
                        break;
                    }
                    v10 = v12;
                    // continue -> 0x4c01
                    continue;
                } else {
                    // 0x4bf8
                    g3 = v10;
                    int32_t v13 = *(int32_t *)(v10 + 8); // 0x4bfa
                    if (v13 == 0) {
                        result3 = 0;
                        v11 = v10;
                        // break (via goto) -> 0x4c0d
                        goto lab_0x4c0d;
                    }
                    v9 = v10;
                    v5 = v13;
                    // continue (via goto) -> 0x4c01
                    goto lab_0x4c01;
                }
                // 0x4c0d
                int32_t result; // 0x4c44
                if (v6 == v11) {
                    result = result3;
                    // 0x4c40
                    g7 = &v7;
                    return result;
                }
                uint32_t v14 = *(int32_t *)(v11 + 16); // 0x4c11
                if (v14 > v8) {
                    result = result3;
                    // 0x4c40
                    g7 = &v7;
                    return result;
                }
                // 0x4c16
                result2 = v11 + 20;
                g1 = result2;
                // 0x4c2d
                g3 = v4;
                g7 = v3;
                g5 = v2;
                g2 = v1;
                return result2;
            }
          lab_0x4c0d:
            // 0x4c0d
            if (v6 == v11 || *(int32_t *)(v11 + 16) > v8) {
                // 0x4c40
                g7 = &v7;
                return result3;
            }
            // 0x4c16
            result2 = v11 + 20;
            g1 = result2;
            // 0x4c2d
            g3 = v4;
            g7 = v3;
            g5 = v2;
            g2 = v1;
            return result2;
        }
    }
    // 0x4c40
    g7 = &v7;
    return 0;
}

// Address range: 0x4c5a - 0x4ce9
int32_t function_4c5a(int32_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x14b907); // 0x4c5a
    *v2 = *v2 - 1;
    char v3 = *(char *)&g1; // 0x4c60
    int32_t v4 = 0; // eax
    *(char *)v4 = (char)v4 + v3;
    int32_t v5 = 0; // bp+44
    __asm_rep_movsd_memcpy((char *)&v5, (char *)0, 0);
    int32_t v6; // bp+28
    int32_t v7 = &v6; // 0x4cc5
    return unknown_95f0(v7, v1, (int32_t)&v4);
}

// Address range: 0x4ce9 - 0x4cea
int32_t function_4ce9(void) {
    // 0x4ce9
    return g1;
}

// Address range: 0x4cf0 - 0x4d84
// Demangled:     std::_Rb_tree<CNetAddr, std::pair<CNetAddr const, int>, std::_Select1st<std::pair<CNetAddr const, int> >, std::less<CNetAddr>, std::allocator<std::pair<CNetAddr const, int> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<CNetAddr const, int> const &)
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE10_M_insert_EPKSt18_Rb_tree_node_baseSC_RKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5) {
    int32_t result = a3; // eax
    int32_t v1 = (int32_t)a5; // ebx
    int32_t v2 = a2 + 4; // 0x4d22
    g4 = v2;
    g2 = a4;
    int32_t v3 = a3; // 0x4d52
    if (a3 == 0) {
        int32_t v4 = function_4db8(v2); // 0x4d31
        result = v4;
        v3 = v4;
        // branch -> 0x4d37
    }
    int32_t v5 = v3 + 16; // 0x4d4b
    if (v5 != 0) {
        // 0x4d50
        *(int32_t *)v5 = *(int32_t *)v1;
        *(int32_t *)(result + 20) = *(int32_t *)(v1 + 4);
        *(int32_t *)(result + 24) = *(int32_t *)(v1 + 8);
        *(int32_t *)(result + 28) = *(int32_t *)(v1 + 12);
        *(int32_t *)(result + 32) = *(int32_t *)(v1 + 16);
        // branch -> 0x4d6d
    } else {
        result = v3;
    }
    // 0x4d6d
    return result;
}

// Address range: 0x4d88 - 0x4db8
int32_t function_4d88(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7ce7dbbc; // 0x4d88
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x4d8f
    int32_t v3 = (v2 + 1 + (int32_t)false) % 256 | v2 & -256; // 0x4d8f
    int32_t result = 0; // edi
    *(int32_t *)result = v3;
    g1 = result;
    if (*(int32_t *)20 != a1) {
        // bb
        result = function_4ddb();
        // branch -> 0x4da2
    }
    // 0x4da2
    return result;
}

// Address range: 0x4db8 - 0x4dca
int32_t function_4db8(int32_t a1) {
    // 0x4db8
    return g2 + 16;
}

// Address range: 0x4dcf - 0x4ddb
int32_t function_4dcf(void) {
    // 0x4dcf
    return 0;
}

// Address range: 0x4ddb - 0x4ddc
int32_t function_4ddb(void) {
    // 0x4ddb
    return g1;
}

// Address range: 0x4de0 - 0x4e23
// Demangled:     std::_Rb_tree<CNetAddr, std::pair<CNetAddr const, int>, std::_Select1st<std::pair<CNetAddr const, int> >, std::less<CNetAddr>, std::allocator<std::pair<CNetAddr const, int> > >::_M_insert_unique(std::pair<CNetAddr const, int> const &)
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE16_M_insert_uniqueERKS3_(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4de0
    g2 = a2;
    g1 = 0;
    g5 = a1;
    g7 = a3;
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x4dff
    if (v1 != 0) {
        // 0x4e19
        return v1 + 16;
    }
    // 0x4e06
    return function_4eb7(*(int32_t *)20);
}

// Address range: 0x4e33 - 0x4e37
int32_t function_4e33(void) {
    // 0x4e33
    return g1;
}

// Address range: 0x4e37 - 0x4e3f
int32_t function_4e37(void) {
    // 0x4e37
    int32_t result; // 0x4e3c
    if (g3 == *(int32_t *)(g2 + 12)) {
        // bb
        result = function_4e88();
        // branch -> 0x4e3c
    } else {
        // 0x4e37
        result = g1;
        // branch -> 0x4e3c
    }
    // 0x4e3c
    return result;
}

// Address range: 0x4e45 - 0x4e48
int32_t function_4e45(void) {
    // 0x4e45
    return 0;
}

// Address range: 0x4e67 - 0x4e80
int32_t function_4e67(void) {
    int32_t result = g5; // 0x4e72
    g1 = result;
    int32_t v1;
    if (*(int32_t *)20 != v1) {
        // bb
        result = function_4ebf();
        // branch -> 0x4e76
    }
    // 0x4e76
    return result;
}

// Address range: 0x4e80 - 0x4e84
int32_t function_4e80(void) {
    // 0x4e80
    return 0;
}

// Address range: 0x4e88 - 0x4eb7
int32_t function_4e88(void) {
    // 0x4e88
    int32_t v1; // bp+44
    int32_t v2 = &v1; // 0x4e88
    unknown_9ad0(v2, 0, g3, g7);
    *(char *)(g5 + 4) = 1;
    *(int32_t *)g5 = v2;
    return function_4e67();
}

// Address range: 0x4eb7 - 0x4ebf
int32_t function_4eb7(int32_t a1) {
    // 0x4eb7
    g3 = g2 + 4;
    return function_4e37();
}

// Address range: 0x4ebf - 0x4ec4
int32_t function_4ebf(void) {
    // 0x4ebf
    return g1;
}

// Address range: 0x4ed0 - 0x4f18
// Demangled:     std::_Rb_tree<CNetAddr, std::pair<CNetAddr const, int>, std::_Select1st<std::pair<CNetAddr const, int> >, std::less<CNetAddr>, std::allocator<std::pair<CNetAddr const, int> > >::_M_insert_unique_(std::_Rb_tree_const_iterator<std::pair<CNetAddr const, int> >, std::pair<CNetAddr const, int> const &)
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS3_ERKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4ed0
    g5 = a2;
    g3 = a3;
    g7 = a1;
    int32_t v1 = a2 + 4; // 0x4ef7
    g2 = a4;
    int32_t result = v1; // 0x4f15
    if (v1 == a3) {
        // bb
        result = function_5020(*(int32_t *)20);
        // branch -> 0x4f0a
    }
    // 0x4f0a
    return result;
}

// Address range: 0x4f3b - 0x4f44
int32_t function_4f3b(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb94; // 0x4f3b
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x4f50 - 0x4f5c
int32_t function_4f50(int16_t a1) {
    int32_t * v1 = (int32_t *)-0x7bdbdbac; // 0x4f50
    *v1 = *v1 - 1;
    unsigned char v2 = *(char *)&g5; // 0x4f56
    *(char *)0 = v2 / 16 | 16 * v2;
    return 0;
}

// Address range: 0x4f83 - 0x4fac
int32_t function_4f83(void) {
    // 0x4f83
    int32_t v1;
    int32_t v2 = *(int32_t *)20 ^ v1; // 0x4f87
    g6 = v2;
    g1 = g7;
    int32_t result = g7; // 0x4fa9
    if (v2 != 0) {
        // bb
        result = function_50d0();
        // branch -> 0x4f96
    }
    // 0x4f96
    return result;
}

// Address range: 0x4fd9 - 0x4fde
int32_t function_4fd9(void) {
    // 0x4fd9
    return 0;
}

// Address range: 0x4feb - 0x501f
int32_t function_4feb(void) {
    int32_t * v1 = (int32_t *)(g3 - 0x7bdbdbac); // 0x4feb
    *v1 = *v1 - 1;
    char * v2 = (char *)(g3 - 117 + g7); // 0x4ff1
    *v2 = 8 * *v2;
    *(char *)g5 = __asm_insb((int16_t)g6);
    // bb
    function_50c0();
    // branch -> 0x5003
    // 0x5003
    unknown_9bc0(g7, g5, g6);
    return function_4f83();
}

// Address range: 0x5020 - 0x5065
int32_t function_5020(int32_t a1) {
    int32_t v1 = g5; // 0x5020
    if (*(int32_t *)(v1 + 20) != 0) {
        // 0x5058
        return *(int32_t *)(v1 + 16) + 16;
    }
    // 0x5027
    int32_t v2; // bp+40
    unknown_9cb0((int32_t)&v2, v1);
    *(int32_t *)g7 = a1;
    return function_4f83();
}

// Address range: 0x5069 - 0x507b
int32_t function_5069(void) {
    int32_t v1 = 0; // eax
    int32_t * v2 = (int32_t *)(v1 + 0x6c89b974 + 8 * v1); // 0x5069
    *v2 = *v2 + 1;
    return function_5084(*(int32_t *)(g5 + 16));
}

// Address range: 0x5084 - 0x50a0
int32_t function_5084(int32_t a1) {
    // 0x5084
    unknown_9bc0(g7, g5, 0);
    return function_4f83();
}

// Address range: 0x50a0 - 0x50c0
int32_t function_50a0(void) {
    // 0x50a0
    unknown_9bc0(g7, 0, 0);
    return function_4f83();
}

// Address range: 0x50c0 - 0x50c6
int32_t function_50c0(void) {
    // 0x50c0
    return function_5084(g3);
}

// Address range: 0x50c6 - 0x50d0
int32_t function_50c6(void) {
    // 0x50c6
    return function_5084(0);
}

// Address range: 0x50d0 - 0x50d1
int32_t function_50d0(void) {
    // 0x50d0
    return g1;
}

// Address range: 0x50e0 - 0x5223
// Demangled:     void WriteCompactSize<CDataStream>(CDataStream &, unsigned long long)
int32_t _Z16WriteCompactSizeI11CDataStreamEvRT_y(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)20; // bp-16
    int32_t v2; // bp-17
    int32_t v3; // 0x5143
    int32_t result; // 0x515b
    if (a3 != 0) {
        int32_t v4 = *(int32_t *)(a1 + 4); // 0x5106
        v2 = -1;
        unknown_92f0(a1, v4, (int32_t)&v2, (int32_t)&v1);
        // branch -> 0x5143
        // 0x5143
        v3 = *(int32_t *)(a1 + 4);
        int32_t v5; // bp-28
        unknown_92f0(a1, v3, (int32_t)&a2, (int32_t)&v5);
        result = *(int32_t *)20 ^ v1;
        if (result != 0) {
            // 0x5223
            return result;
        }
        // 0x5168
        return result;
    }
    // 0x5170
    if (a2 < 253) {
        // 0x51c0
        v2 = a2;
        // branch -> 0x5143
        // 0x5143
        v3 = *(int32_t *)(a1 + 4);
        unknown_92f0(a1, v3, (int32_t)&v2, (int32_t)&v1);
        result = *(int32_t *)20 ^ v1;
        if (result != 0) {
            // 0x5223
            return result;
        }
        // 0x5168
        return result;
    }
    // 0x5177
    int32_t * v6;
    if (a2 < 0x10000) {
        int32_t v7 = *(int32_t *)(a1 + 4); // 0x51e5
        v2 = -3;
        unknown_92f0(a1, v7, (int32_t)&v2, (int32_t)&v1);
        int32_t v8; // bp-18
        v6 = &v8;
        // branch -> 0x5143
    } else {
        int32_t v9 = *(int32_t *)(a1 + 4); // 0x5182
        v2 = -2;
        unknown_92f0(a1, v9, (int32_t)&v2, (int32_t)&v1);
        v6 = &a2;
        // branch -> 0x5143
    }
    // 0x5143
    v3 = *(int32_t *)(a1 + 4);
    unknown_92f0(a1, v3, (int32_t)&a2, (int32_t)v6);
    result = *(int32_t *)20 ^ v1;
    if (result != 0) {
        // 0x5223
        return result;
    }
    // 0x5168
    return result;
}

// Address range: 0x5230 - 0x5246
int32_t _GLOBAL__sub_I__ZNK9CAddrInfo14GetTriedBucketERKSt6vectorIhSaIhEE(void) {
    // 0x5230
    return 0;
}

// Address range: 0x52a4 - 0x52aa
int32_t function_52a4(void) {
    // 0x52a4
    return 0;
}

// Address range: 0x52ae - 0x52b4
int32_t function_52ae(void) {
    // 0x52ae
    return 0;
}

// Address range: 0x52b8 - 0x52be
int32_t function_52b8(void) {
    // 0x52b8
    return 0;
}

// Address range: 0x52be - 0x52cf
int32_t function_52be(int32_t a1) {
    int32_t result = *(int32_t *)20 ^ a1; // 0x52c2
    if (result != 0) {
        // 0x52cf
    }
    // 0x52cb
    return result;
}

// Address range: 0x6200 - 0x6201
int32_t function_6200(int32_t a1) {
    // 0x6200
    return g1;
}

// Address range: 0x6270 - 0x6271
int32_t function_6270(int32_t a1) {
    // 0x6270
    return g1;
}

// Address range: 0x6340 - 0x6341
int32_t function_6340(int32_t a1) {
    // 0x6340
    return g1;
}

// Address range: 0x18244489 - 0x1824448a
int32_t function_18244489(void) {
    // 0x18244489
    return g1;
}

// Address range: 0x860fdeb3 - 0x860fdeb4
int32_t function_860fdeb3(void) {
    // 0x860fdeb3
    return g1;
}

// Address range: 0x870fe008 - 0x870fe009
int32_t function_870fe008(void) {
    // 0x870fe008
    return g1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected language: C++
// Detected functions: 335
// Decompilation date: 2018-06-09 23:53:48
