//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef long double float80_t;

// ------------------------ Structures ------------------------

struct vtable_f5a0_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t);
};

struct vtable_f5b8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_f5d0_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_fa98_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_fad8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

struct vtable_fb58_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_fb78_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_fbb8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

struct vtable_fc38_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_fc78_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

struct vtable_fcf8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_fd18_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_fd58_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

struct vtable_fdd8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_fdf8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_fe38_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

struct vtable_feb8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_fed8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_ff18_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

struct vtable_ff98_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
};

struct vtable_ffd8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t);
    int32_t (*e3)(int32_t);
};

// ------------------------- Classes --------------------------

// N5boost10lock_errorE (base classes: N5boost16thread_exceptionE)
// N5boost16exception_detail10bad_alloc_E
// N5boost16exception_detail10clone_baseE
// N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE (base classes: N5boost16exception_detail10bad_alloc_E, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE (base classes: N5boost16exception_detail10clone_baseE, N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE)
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE (base classes: N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEE, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEEE (base classes: N5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEEE, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEEE (base classes: N5boost16exception_detail10clone_baseE, N5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEEE)
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEEE (base classes: N5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEEE, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEEE (base classes: N5boost16exception_detail19error_info_injectorISt13runtime_errorEE, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE (base classes: N5boost9exceptionE, N5boost10lock_errorE)
// N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEE (base classes: N5boost9exceptionE, N5boost21thread_resource_errorE)
// N5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEEE (base classes: N5boost9gregorian16bad_day_of_monthE, N5boost9exceptionE)
// N5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEEE (base classes: N5boost9exceptionE, N5boost9gregorian8bad_yearE)
// N5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEEE (base classes: N5boost9exceptionE, N5boost9gregorian9bad_monthE)
// N5boost16exception_detail19error_info_injectorISt13runtime_errorEE
// N5boost16thread_exceptionE
// N5boost21thread_resource_errorE (base classes: N5boost16thread_exceptionE)
// N5boost6detail15sp_counted_baseE
// N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE (base classes: N5boost6detail15sp_counted_baseE)
// N5boost6system12system_errorE
// N5boost9exceptionE
// N5boost9gregorian16bad_day_of_monthE
// N5boost9gregorian8bad_yearE
// N5boost9gregorian9bad_monthE

// ------------------- Function Prototypes --------------------

void _7e_CDBEnv(int32_t this, int32_t __in_chrg);
void _7e_clone_impl(int32_t this, int32_t __in_chrg);
void __uninitialized_move_a_3c_std_3a__3a_pair_3c_std_3a__3a_vector_3c_unsigned_20_char_3e__2c__20_std_3a__3a_vector_3c_unsigned_20_char_3e__20__3e__2a__2c__20_std_3a__3a_pair_3c_std_3a__3a_vector_3c_unsigned_20_char_3e__2c__20_std_3a__3a_vector_3c_unsigned_20_char_3e__20__3e__2a__2c__20_std_3a__3a_allocator_3c_std_3a__3a_pair_3c_std_3a__3a_vector_3c_unsigned_20_char_3e__2c__20_std_3a__3a_vector_3c_unsigned_20_char_3e__20__3e__20__3e__20__3e_(int32_t __first, int32_t __last, int32_t __result, int32_t __alloc);
int32_t _GLOBAL__sub_I_nWalletDBUpdated(void);
int32_t _Z13GetTimeMillisv(int32_t a1);
int32_t _Z15ReadCompactSizeI11CDataStreamEyRT_(int32_t a1);
int32_t _Z16WriteCompactSizeI11CDataStreamEvRT_y(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _ZN11CDataStream4readEPci(int32_t * a1, int32_t a2, int32_t a3);
void _ZN11CDataStream5writeEPKci(int32_t this, char * pch, int32_t nSize);
int32_t _ZN11CDataStream5writeEPKci_part_549(void);
int32_t _ZN11CDataStreamD1Ev(int32_t * a1);
int32_t _ZN14AnnotatedMixinIN5boost15recursive_mutexEED1Ev(void);
int32_t _ZN14AnnotatedMixinIN5boost15recursive_mutexEED2Ev_part_37(void);
void _ZN3CDB5CloseEv(int32_t this);
void _ZN3CDB5FlushEv(int32_t this);
int32_t _ZN3CDB5WriteISsiEEbRKT_RKT0_b(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t _ZN3CDB6ExistsISsEEbRKT_(int32_t * a1, int32_t a2);
void _ZN3CDB7RewriteERKSsPKc(int32_t strFile, char * pszSkip);
int32_t _ZN3CDBD1Ev(int32_t a1);
int32_t _ZN5boost10lock_errorD0Ev(int32_t * a1);
int32_t _ZN5boost10lock_errorD1Ev(int32_t * a1);
int32_t _ZN5boost10shared_ptrIKNS_16exception_detail10clone_baseEED1Ev(int32_t a1);
int32_t _ZN5boost11filesystem311path_traits8dispatchISsEEvRKSsRT_RKSt7codecvtIwc11__mbstate_tE_part_192(void);
int32_t _ZN5boost11filesystem3dvERKNS0_4pathES3_(int32_t a1, int32_t result, int32_t a3);
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(int32_t * a1);
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(int32_t * a1);
int32_t _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(int32_t a1);
int32_t _ZN5boost15throw_exceptionINS_21thread_resource_errorEEEvRKT_(int32_t a1);
int32_t _ZN5boost15throw_exceptionINS_9gregorian16bad_day_of_monthEEEvRKT_(int32_t a1);
int32_t _ZN5boost15throw_exceptionINS_9gregorian8bad_yearEEEvRKT_(int32_t a1);
int32_t _ZN5boost15throw_exceptionINS_9gregorian9bad_monthEEEvRKT_(int32_t a1);
int32_t _ZN5boost15throw_exceptionISt13runtime_errorEEvRKT_(int32_t a1);
int32_t _ZN5boost16exception_detail10bad_alloc_D0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10bad_alloc_D1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail13get_bad_allocILi42EEENS_10shared_ptrIKNS0_10clone_baseEEEv(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEEC1ERKS3_(int32_t * a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEC1ERKS3_(int32_t * a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEEC1ERKS4_(int32_t a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEEC1ERKS4_(int32_t a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEEC1ERKS4_(int32_t a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorISt13runtime_errorEC1ERKS3_(int32_t a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorISt13runtime_errorED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorISt13runtime_errorED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail20copy_boost_exceptionEPNS_9exceptionEPKS1_(int32_t a1, int32_t a2);
int32_t _ZN5boost16thread_exceptionD0Ev(int32_t * a1);
int32_t _ZN5boost16thread_exceptionD1Ev(int32_t * a1);
int32_t _ZN5boost21thread_resource_errorD0Ev(int32_t * a1);
int32_t _ZN5boost21thread_resource_errorD1Ev(int32_t * a1);
void _ZN5boost2CV23simple_exception_policyItLt1400ELt10000ENS_9gregorian8bad_yearEE8on_errorEttNS0_14violation_enumE(int16_t arg0, int16_t arg1, int32_t arg2);
int32_t _ZN5boost2CV23simple_exception_policyItLt1400ELt10000ENS_9gregorian8bad_yearEE8on_errorEttNS0_14violation_enumE_isra_533(void);
int32_t _ZN5boost2CV23simple_exception_policyItLt1ELt12ENS_9gregorian9bad_monthEE8on_errorEttNS0_14violation_enumE_isra_534(void);
void _ZN5boost2CV23simple_exception_policyItLt1ELt31ENS_9gregorian16bad_day_of_monthEE8on_errorEttNS0_14violation_enumE(int16_t arg0, int16_t arg1, int32_t arg2);
int32_t _ZN5boost2CV23simple_exception_policyItLt1ELt31ENS_9gregorian16bad_day_of_monthEE8on_errorEttNS0_14violation_enumE_isra_298(void);
int32_t _ZN5boost6detail15sp_counted_base7destroyEv(int32_t * a1);
int32_t _ZN5boost6detail15sp_counted_baseD0Ev(int32_t * a1);
int32_t _ZN5boost6detail15sp_counted_baseD1Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE11get_deleterERKSt9type_info(void);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE7disposeEv(int32_t a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED0Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED1Ev(int32_t * a1);
int32_t _ZN5boost6system12system_errorD0Ev(int32_t * a1);
int32_t _ZN5boost6system12system_errorD1Ev(int32_t * a1);
int32_t _ZN5boost6system14error_categoryD0Ev(int32_t * a1);
int32_t _ZN5boost6system14error_categoryD1Ev(int32_t * a1);
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockC2EP15pthread_mutex_t_part_22(void);
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockD1Ev(int32_t * a1);
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockD2Ev_part_23(void);
int32_t _ZN5boost9date_time14microsec_clockINS_10posix_time5ptimeEE11create_timeEPFP2tmPKlS6_E(int32_t a1, int32_t a2);
int32_t _ZN5boost9date_time19counted_time_systemINS0_16counted_time_repINS_10posix_time33millisec_posix_time_system_configEEEE14subtract_timesERKS5_S8_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZN5boost9date_time6c_time6gmtimeEPKlP2tm(int32_t result, int32_t a2);
int32_t _ZN5boost9exceptionD0Ev(int32_t a1);
int32_t _ZN5boost9exceptionD1Ev(int32_t * a1);
int32_t _ZN5boost9gregorian16bad_day_of_monthD0Ev(int32_t * a1);
int32_t _ZN5boost9gregorian16bad_day_of_monthD1Ev(int32_t * a1);
int32_t _ZN5boost9gregorian8bad_yearD0Ev(int32_t * a1);
int32_t _ZN5boost9gregorian8bad_yearD1Ev(int32_t * a1);
int32_t _ZN5boost9gregorian9bad_monthD0Ev(int32_t * a1);
int32_t _ZN5boost9gregorian9bad_monthD1Ev(int32_t * a1);
void _ZN6CDBEnv11EnvShutdownEv(int32_t this);
void _ZN6CDBEnv13CheckpointLSNESs(int32_t this, int32_t strFile);
void _ZN6CDBEnv4OpenERKN5boost11filesystem34pathE(int32_t this, int32_t pathIn);
void _ZN6CDBEnv5CloseEv(int32_t this);
void _ZN6CDBEnv5FlushEb(int32_t this, bool fShutdown);
void _ZN6CDBEnv6VerifyESsPFbRS_SsE(int32_t this, int32_t strFile, int32_t recoverFunc);
void _ZN6CDBEnv7CloseDbERKSs(int32_t this, int32_t strFile);
void _ZN6CDBEnv7SalvageESsbRSt6vectorISt4pairIS0_IhSaIhEES3_ESaIS4_EE(int32_t this, int32_t strFile, bool fAggressive, int32_t vResult);
void _ZN6CDBEnv8MakeMockEv(int32_t this);
void _ZN6CDBEnv8RemoveDbERKSs(int32_t this, int32_t strFile);
void _ZN7CAddrDB4ReadER8CAddrMan(int32_t this, int32_t addr);
void _ZN7CAddrDB5WriteERK8CAddrMan(int32_t this, int32_t addr);
int32_t _ZN8CAddrMan11UnserializeI11CDataStreamEEvRT_ii(int32_t a1);
int32_t _ZNK5boost10lock_error4whatEv(void);
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE5cloneEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE7rethrowEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE5cloneEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE7rethrowEv(int32_t a1);
void _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE5cloneEv(int32_t this);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE5cloneEv2(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE7rethrowEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE5cloneEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE7rethrowEv(int32_t a1);
int32_t _ZNK5boost21thread_resource_error4whatEv(void);
int32_t _ZNK5boost6system12system_error4whatEv(int32_t a1);
int32_t _ZNK5boost6system14error_category10equivalentEiRKNS0_15error_conditionE(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNK5boost6system14error_category10equivalentERKNS0_10error_codeEi(int32_t a1, int32_t * a2, int32_t a3);
int32_t _ZNK5boost6system14error_category23default_error_conditionEi(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNK8CAddrMan9SerializeI11CDataStreamEEvRT_ii(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZNSt11logic_errorC1ERKS_(int32_t a1, int32_t a2);
void _ZNSt12_Vector_baseIhSaIhEE13_M_deallocateEPhj(int32_t this, char * __p, int32_t __n);
int32_t _ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED0Ev(int32_t a1);
int32_t _ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev(int32_t a1);
int32_t _ZNSt3mapISsiSt4lessISsESaISt4pairIKSsiEEEixERS3_(int32_t a1, int32_t * a2);
int32_t _ZNSt3mapISsP2DbSt4lessISsESaISt4pairIKSsS1_EEEixERS5_(int32_t a1, int32_t * a2);
int32_t _ZNSt4pairISt6vectorIhSaIhEES2_ED1Ev(int32_t a1);
int32_t _ZNSt6vectorIc25zero_after_free_allocatorIcEE15_M_range_insertIPKcEEvN9__gnu_cxx17__normal_iteratorIPcS2_EET_SA_St20forward_iterator_tag(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t _ZNSt6vectorIhSaIhEEaSERKS1_(int32_t * a1, int32_t a2);
int32_t _ZNSt6vectorIiSaIiEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPiS1_EERKi(int32_t a1, int32_t * a2, int32_t a3);
int32_t _ZNSt6vectorIiSaIiEEaSERKS1_(int32_t * a1, int32_t a2);
int32_t _ZNSt6vectorIS_IiSaIiEESaIS1_EE20_M_allocate_and_copyIN9__gnu_cxx17__normal_iteratorIPKS1_S3_EEEEPS1_jT_SB_(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZNSt6vectorIS_IiSaIiEESaIS1_EEaSERKS3_(int32_t a1, int32_t a2);
int32_t _ZNSt6vectorIS_IiSaIiEESaIS1_EED1Ev(int32_t * a1);
int32_t _ZNSt6vectorISt3setIiSt4lessIiESaIiEESaIS4_EE20_M_allocate_and_copyIN9__gnu_cxx17__normal_iteratorIPKS4_S6_EEEEPS4_jT_SE_(int32_t result, int32_t a2, int32_t a3);
int32_t _ZNSt6vectorISt3setIiSt4lessIiESaIiEESaIS4_EEaSERKS6_(int32_t * a1, int32_t a2);
int32_t _ZNSt6vectorISt3setIiSt4lessIiESaIiEESaIS4_EED1Ev(int32_t * a1);
int32_t _ZNSt6vectorISt4pairIS_IhSaIhEES2_ESaIS3_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS3_S5_EERKS3_(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE10_M_insert_EPKSt18_Rb_tree_node_baseSC_RKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE16_M_insert_uniqueERKS3_(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS3_ERKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE10_M_insert_EPKSt18_Rb_tree_node_baseS8_RKi(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE16_M_insert_uniqueERKi(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE7_M_copyEPKSt13_Rb_tree_nodeIiEPS7_(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE8_M_eraseEPSt13_Rb_tree_nodeIiE(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEEaSERKS5_(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE10_M_insert_EPKSt18_Rb_tree_node_baseSC_RKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE16_M_insert_uniqueERKS3_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS3_ERKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeIiSt4pairIKiiESt10_Select1stIS2_ESt4lessIiESaIS2_EE10_M_insert_EPKSt18_Rb_tree_node_baseSB_RKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeIiSt4pairIKiiESt10_Select1stIS2_ESt4lessIiESaIS2_EE16_M_insert_uniqueERKS2_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeIiSt4pairIKiiESt10_Select1stIS2_ESt4lessIiESaIS2_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS2_ERKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t _ZNSt8_Rb_treeIiSt4pairIKiiESt10_Select1stIS2_ESt4lessIiESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE10_M_insert_EPKSt18_Rb_tree_node_baseSB_RKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE11equal_rangeERS1_(int32_t a1, int32_t a2, int32_t * a3);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE12_M_erase_auxESt23_Rb_tree_const_iteratorIS2_E(int32_t a1);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE16_M_insert_uniqueERKS2_(int32_t a1, int32_t a2, int32_t * a3);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS2_ERKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE5eraseERS1_(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsP2DbESt10_Select1stIS4_ESt4lessISsESaIS4_EE10_M_insert_EPKSt18_Rb_tree_node_baseSD_RKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsP2DbESt10_Select1stIS4_ESt4lessISsESaIS4_EE16_M_insert_uniqueERKS4_(int32_t a1, int32_t a2, int32_t * a3);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsP2DbESt10_Select1stIS4_ESt4lessISsESaIS4_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS4_ERKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsP2DbESt10_Select1stIS4_ESt4lessISsESaIS4_EE8_M_eraseEPSt13_Rb_tree_nodeIS4_E(int32_t a1, int32_t a2);
int32_t _ZSt8_DestroyIPSt3setIiSt4lessIiESaIiEEEvT_S6_(int32_t a1, int32_t a2);
int32_t _ZSt8_DestroyIPSt6vectorIiSaIiEEEvT_S4_(int32_t * a1, int32_t a2);
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D0Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D1Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1);
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1);
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1);
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1);
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED1Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED1Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED1Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED1Ev(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE7rethrowEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE7rethrowEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE7rethrowEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE7rethrowEv(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorISt13runtime_errorED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorISt13runtime_errorED1Ev(int32_t a1);
int32_t _ZZN5boost11filesystem311path_traits7convertEPKcS3_RSsRKSt7codecvtIwc11__mbstate_tEE19__PRETTY_FUNCTION__(int32_t a1);
int32_t _ZZN5boost15recursive_mutexC1EvE19__PRETTY_FUNCTION__(int32_t a1);
int32_t bitdb(void);
void CAddrDB(int32_t this);
void CDB(int32_t this, char * pszFile, char * pszMode);
void CDBEnv(int32_t this);
void dispatch_3c_std_3a__3a_basic_string_3c_char_3e__20__3e_(int32_t c, int32_t to, int32_t cvt);
int32_t function_100a(int32_t a1);
int32_t function_101c0(int32_t a1);
int32_t function_102c0(int32_t a1);
int32_t function_1033(void);
int32_t function_107a0(int32_t a1, int32_t a2);
int32_t function_10c9(void);
int32_t function_10cb(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10d2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1100(void);
int32_t function_1130(void);
int32_t function_113a(void);
int32_t function_113b(void);
int32_t function_1143(void);
int32_t function_115a(void);
int32_t function_116a(void);
int32_t function_120(void);
int32_t function_125a(int32_t a1);
int32_t function_1290(void);
int32_t function_133e(void);
int32_t function_136(void);
int32_t function_148(void);
int32_t function_14a(void);
int32_t function_14a8(void);
int32_t function_1508(void);
int32_t function_15db(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1610(int32_t a1);
int32_t function_169b(int32_t a1, int32_t a2);
int32_t function_1721(int32_t a1);
int32_t function_17a2(void);
int32_t function_17a6(int32_t a1);
int32_t function_1839(int32_t a1);
int32_t function_188d(int16_t a1);
int32_t function_189a(int16_t a1);
int32_t function_18ca(void);
int32_t function_1928(int32_t a1);
int32_t function_192d(void);
int32_t function_1932(void);
int32_t function_197a(void);
int32_t function_1980(void);
int32_t function_1988(void);
int32_t function_19d1(void);
int32_t function_19f9(void);
int32_t function_1a08(void);
int32_t function_1a28(void);
int32_t function_1a47(int32_t a1);
int32_t function_1a6f(void);
int32_t function_1a90(int32_t a1);
int32_t function_1abc(void);
int32_t function_1ac(void);
int32_t function_1ac8(void);
int32_t function_1afb(int32_t a1);
int32_t function_1b3b(void);
int32_t function_1b65(void);
int32_t function_1b6c(int32_t a1, int32_t a2);
int32_t function_1b72(void);
int32_t function_1b73(void);
int32_t function_1b83(void);
int32_t function_1b9e(void);
int32_t function_1ba6(void);
int32_t function_1bc5(void);
int32_t function_1bd4(void);
int32_t function_1bdb(void);
int32_t function_1bf8(void);
int32_t function_1bfe(void);
int32_t function_1bff(void);
int32_t function_1c0e(void);
int32_t function_1c10(void);
int32_t function_1c15(void);
int32_t function_1c2e(void);
int32_t function_1c34(void);
int32_t function_1c56(void);
int32_t function_1c5a(int32_t a1);
int32_t function_1c6d(void);
int32_t function_1c7e(int32_t a1);
int32_t function_1c91(void);
int32_t function_1dc2(void);
int32_t function_1dd6(void);
int32_t function_1e5(void);
int32_t function_2006(int32_t a1);
int32_t function_204(void);
int32_t function_206(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2064(int32_t a1);
int32_t function_208c(void);
int32_t function_20c9(void);
int32_t function_20e8(void);
int32_t function_210c(void);
int32_t function_2113(void);
int32_t function_211a(void);
int32_t function_2130(void);
int32_t function_2137(int32_t a1);
int32_t function_214e(void);
int32_t function_2158(void);
int32_t function_215a(void);
int32_t function_216a(void);
int32_t function_216c(void);
int32_t function_21ca(void);
int32_t function_21ed(void);
int32_t function_21f5(void);
int32_t function_21f7(void);
int32_t function_21fb(int32_t a1);
int32_t function_21fc(void);
int32_t function_221d(void);
int32_t function_2222(void);
int32_t function_223f(void);
int32_t function_227a(void);
int32_t function_22e1(int32_t a1, int32_t a2, int32_t a3);
int32_t function_23e9(void);
int32_t function_246c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2501(void);
int32_t function_2502(void);
int32_t function_2518(int32_t a1, int32_t a2);
int32_t function_25eb(int32_t a1);
int32_t function_2608(char * a1);
int32_t function_2652(int32_t a1);
int32_t function_26f5(void);
int32_t function_26f7(void);
int32_t function_26fc(void);
int32_t function_2709(void);
int32_t function_2719(void);
int32_t function_272c(void);
int32_t function_2733(void);
int32_t function_2736(void);
int32_t function_2743(void);
int32_t function_27da(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2877(void);
int32_t function_2898(void);
int32_t function_28cf(void);
int32_t function_2947(void);
int32_t function_294f(int32_t a1);
int32_t function_2977(void);
int32_t function_29b7(void);
int32_t function_29da(int32_t a1);
int32_t function_2ac6(void);
int32_t function_2aea(void);
int32_t function_2af2(void);
int32_t function_2b9b(void);
int32_t function_2bb1(void);
int32_t function_2bd4(void);
int32_t function_2c51(void);
int32_t function_2c64(void);
int32_t function_2c73(void);
int32_t function_2c7f(void);
int32_t function_2c84(void);
int32_t function_2c88(void);
int32_t function_2c89(void);
int32_t function_2c94(void);
int32_t function_2c99(void);
int32_t function_2c9b(void);
int32_t function_2d1c(void);
int32_t function_2d26(void);
int32_t function_2d2e(void);
int32_t function_2d3c(void);
int32_t function_2d48(void);
int32_t function_2d4d(void);
int32_t function_2e32(int32_t a1);
int32_t function_2e64(void);
int32_t function_2e76(void);
int32_t function_2f76(void);
int32_t function_2fbc(int32_t a1);
int32_t function_3020(void);
int32_t function_3158(void);
int32_t function_319d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, char * a6, int32_t result);
int32_t function_31e4(int16_t a1);
int32_t function_3288(void);
int32_t function_3391(void);
int32_t function_33b5(void);
int32_t function_3443(void);
int32_t function_3455(void);
int32_t function_3463(void);
int32_t function_348b(void);
int32_t function_34a4(void);
int32_t function_34b2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_34e8(int32_t a1);
int32_t function_34f8(void);
int32_t function_3503(int32_t a1);
int32_t function_3532(void);
int32_t function_3624(void);
int32_t function_38(int32_t a1, int32_t a2);
int32_t function_3948(void);
int32_t function_3950(void);
int32_t function_3962(void);
int32_t function_396a(void);
int32_t function_3973(void);
int32_t function_397f(void);
int32_t function_3997(void);
int32_t function_399e(void);
int32_t function_39ec(int32_t a1);
int32_t function_3a25(int16_t a1);
int32_t function_3ac9(void);
int32_t function_3ad8(int32_t a1, int32_t a2);
int32_t function_3b48(void);
int32_t function_3b52(void);
int32_t function_3bea(void);
int32_t function_3bfa(void);
int32_t function_3c22(void);
int32_t function_3c27(void);
int32_t function_3c2f(void);
int32_t function_3c38(void);
int32_t function_3c40(void);
int32_t function_3c4f(void);
int32_t function_3c6e(void);
int32_t function_3c77(void);
int32_t function_3c7a(void);
int32_t function_3c86(void);
int32_t function_3c98(void);
int32_t function_3c9c(void);
int32_t function_3ca3(void);
int32_t function_3cb3(void);
int32_t function_3cc1(void);
int32_t function_3cc3(void);
int32_t function_3cc7(int32_t a1);
int32_t function_3d12(void);
int32_t function_3d66(void);
int32_t function_3d76(void);
int32_t function_3d7a(void);
int32_t function_3d88(void);
int32_t function_3d8a(int32_t a1);
int32_t function_3d95(int32_t a1, int32_t a2);
int32_t function_3dab(void);
int32_t function_3db0(void);
int32_t function_3db4(void);
int32_t function_3dde(void);
int32_t function_3ded(void);
int32_t function_3e00(void);
int32_t function_3e02(void);
int32_t function_3e0d(void);
int32_t function_3e1c(void);
int32_t function_3e2a(void);
int32_t function_3e2c(void);
int32_t function_3edc(void);
int32_t function_4015(char * a1, int32_t a2);
int32_t function_4300(void);
int32_t function_4322(void);
int32_t function_4332(void);
int32_t function_435a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_438c(void);
int32_t function_4398(int32_t a1);
int32_t function_43a0(void);
int32_t function_43a8(void);
int32_t function_43bc(void);
int32_t function_43c8(int32_t a1);
int32_t function_4404(void);
int32_t function_440b(void);
int32_t function_44b8(void);
int32_t function_44b9(void);
int32_t function_44c3(void);
int32_t function_44d8(void);
int32_t function_44e9(void);
int32_t function_4506(void);
int32_t function_450b(void);
int32_t function_451b(void);
int32_t function_4522(void);
int32_t function_4541(void);
int32_t function_4543(void);
int32_t function_4571(void);
int32_t function_4576(void);
int32_t function_45ce(void);
int32_t function_45d4(void);
int32_t function_45d9(void);
int32_t function_4635(void);
int32_t function_463b(void);
int32_t function_4640(void);
int32_t function_4c83(int32_t a1);
int32_t function_4cc3(int32_t a1);
int32_t function_4d03(int32_t a1);
int32_t function_4d43(int32_t a1);
int32_t function_4dd2(void);
int32_t function_51a(void);
int32_t function_529(void);
int32_t function_540(void);
int32_t function_56c(void);
int32_t function_56e(int32_t a1);
int32_t function_574(void);
int32_t function_579(void);
int32_t function_581(void);
int32_t function_5903(int32_t a1);
int32_t function_594(void);
int32_t function_5943(int32_t a1);
int32_t function_5983(int32_t a1);
int32_t function_59b(void);
int32_t function_59c3(int32_t a1);
int32_t function_5a7(void);
int32_t function_5ab(void);
int32_t function_5b9(void);
int32_t function_5bb(void);
int32_t function_5bc(void);
int32_t function_5c5(void);
int32_t function_5c7(void);
int32_t function_5d5(void);
int32_t function_5e5(void);
int32_t function_5f4(void);
int32_t function_5fb(void);
int32_t function_63a3(int32_t a1);
int32_t function_63e3(int32_t a1);
int32_t function_6560(int32_t a1, int32_t a2, int32_t a3);
int32_t function_6600(int32_t a1, int32_t a2, int32_t a3);
int32_t function_66c0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_675(void);
int32_t function_67ad(void);
int32_t function_67cf(void);
int32_t function_6800(void);
int32_t function_6820(void);
int32_t function_6822(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_6833(void);
int32_t function_6844(void);
int32_t function_684a(void);
int32_t function_6850(void);
int32_t function_6853(void);
int32_t function_68ba(int32_t a1, int32_t a2);
int32_t function_691f(void);
int32_t function_6939(void);
int32_t function_698a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_69f5(void);
int32_t function_6a0f(void);
int32_t function_6a6a(int32_t a1, int32_t a2);
int32_t function_6ad5(void);
int32_t function_6aef(void);
int32_t function_6b38(void);
int32_t function_6b4a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_6bb5(void);
int32_t function_6bcf(void);
int32_t function_6cc7(void);
int32_t function_6d1b(int32_t a1);
int32_t function_6d96(void);
int32_t function_6dfc(void);
int32_t function_6e2(int32_t a1, int32_t a2, int32_t a3);
int32_t function_6e6c(int32_t a1);
int32_t function_6edc(void);
int32_t function_6f4c(int32_t a1);
int32_t function_6fbc(void);
int32_t function_704(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_70bd(void);
int32_t function_7282(int32_t a1);
int32_t function_73a(int32_t a1);
int32_t function_73a3(void);
int32_t function_7503(int32_t a1);
int32_t function_75906601(void);
int32_t function_75a(void);
int32_t function_7603(void);
int32_t function_77e3(void);
int32_t function_78c(int32_t a1);
int32_t function_78e3(int32_t a1);
int32_t function_7a16(int32_t a1);
int32_t function_7a59(void);
int32_t function_7a64(int32_t a1);
int32_t function_7ac6(int32_t a1, int32_t a2, int32_t a3);
int32_t function_7b45(void);
int32_t function_7b48(int32_t a1);
float80_t function_7b7(void);
int32_t function_7bf6(void);
int32_t function_7c(int32_t a1);
int32_t function_7c07(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_7c38(int32_t a1);
int32_t function_7c4a(int32_t a1);
int32_t function_7c53(void);
int32_t function_7c58(int32_t a1);
int32_t function_7c7c(void);
int32_t function_7cd3(void);
int32_t function_7d0b(void);
int32_t function_7d1a(int32_t a1);
int32_t function_7d31(void);
int32_t function_7d83(int32_t a1);
int32_t function_7da8(void);
int32_t function_7dba(void);
int32_t function_7f2a(void);
int32_t function_7f33(void);
int32_t function_7f47(void);
int32_t function_7f80(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8030(void);
int32_t function_8153(void);
int32_t function_8162(void);
int32_t function_818e(void);
int32_t function_81ba(int32_t a1, int32_t a2);
int32_t function_821c(void);
int32_t function_8223(void);
int32_t function_8233(void);
int32_t function_826f(int32_t a1);
int32_t function_82d0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8380(void);
int32_t function_83f(void);
int32_t function_83fb(void);
int32_t function_8488(int32_t a1);
int32_t function_8497(void);
int32_t function_84c3(void);
int32_t function_8590(void);
int32_t function_8624(void);
int32_t function_8691(void);
int32_t function_86b0(void);
int32_t function_8790(void);
int32_t function_88000000(void);
int32_t function_882a(void);
int32_t function_8891(void);
int32_t function_88b0(void);
int32_t function_89000119(void);
int32_t function_8918(void);
int32_t function_891e7401(void);
int32_t function_8955(int32_t a1);
int32_t function_89d(void);
int32_t function_8a7e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_8ad(void);
int32_t function_8ad8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8b003169(void);
int32_t function_8b9f(void);
int32_t function_8ba4(void);
int32_t function_8bc4(void);
int32_t function_8bcd(void);
int32_t function_8be1(void);
int32_t function_8bf2(void);
int32_t function_8bf8(void);
int32_t function_8bfa(void);
int32_t function_8c02(void);
int32_t function_8c1(int32_t a1);
int32_t function_8c7f(void);
int32_t function_8c8a(int32_t a1);
int32_t function_8cb8(void);
int32_t function_8cdd(void);
int32_t function_8ce8(int32_t a1, int32_t a2);
int32_t function_8d3f(void);
int32_t function_8d60(int32_t a1);
int32_t function_8d70(void);
int32_t function_8d75(void);
int32_t function_8dae(void);
int32_t function_8db7(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8dd8(void);
int32_t function_8dec(void);
int32_t function_8f8(void);
int32_t function_900(void);
int32_t function_907(int32_t a1, int32_t a2);
int32_t function_90ab(void);
int32_t function_90c1(int32_t a1);
int32_t function_90d6(int32_t a1);
int32_t function_910(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_9150(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_9228(void);
int32_t function_923c(void);
int32_t function_92dd(void);
int32_t function_92e0(int32_t a1);
int32_t function_9351(void);
int32_t function_9382(void);
int32_t function_9392(void);
int32_t function_93a8(void);
int32_t function_93bc(void);
int32_t function_93c1(void);
int32_t function_94fb(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_956b(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_960(void);
int32_t function_963(void);
int32_t function_971a(int32_t a1);
int32_t function_97d9(int32_t result);
int32_t function_97f1(int32_t a1);
int32_t function_97fa(void);
int32_t function_980e(void);
int32_t function_9813(void);
int32_t function_981a(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_9824(void);
int32_t function_9836(int32_t a1, int32_t a2, int32_t a3);
int32_t function_9841(void);
int32_t function_984a(void);
int32_t function_9856(int32_t a1);
int32_t function_985d(void);
int32_t function_9884(int32_t a1, int32_t a2);
int32_t function_989f(int32_t a1);
int32_t function_98e7(int32_t a1);
int32_t function_9953(void);
int32_t function_99b5(void);
int32_t function_99ef(void);
int32_t function_99fd(void);
int32_t function_9a06(void);
int32_t function_9a12(void);
int32_t function_9a31(void);
int32_t function_9a58(int32_t a1);
int32_t function_9a67(int32_t a1);
int32_t function_9a6f(void);
int32_t function_9a76(void);
int32_t function_9aaa(void);
int32_t function_9aaf(void);
int32_t function_9ab6(int32_t a1, int32_t result);
int32_t function_9af8(void);
int32_t function_9b04(void);
int32_t function_9b13(void);
int32_t function_9b26(void);
int32_t function_9b48(int32_t a1);
int32_t function_9c4f(char * a1);
int32_t function_9ce6(void);
int32_t function_9d00(int32_t a1);
int32_t function_9d20(char * a1, int32_t a2);
int32_t function_9d60(void);
int32_t function_9d7f(void);
int32_t function_9dc0(void);
int32_t function_9dd8(void);
int32_t function_9dea(void);
int32_t function_9def(void);
int32_t function_9df4(int32_t a1, int32_t a2);
int32_t function_9e00(void);
int32_t function_9e1(int32_t a1, int32_t a2, int32_t a3);
int32_t function_9e58(void);
int32_t function_9e68(void);
int32_t function_9e7c(void);
int32_t function_9e97(void);
int32_t function_9eb3(void);
int32_t function_9efd(void);
int32_t function_9f12(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_9fdd(void);
int32_t function_9fe8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_9ff2(void);
int32_t function_9ff7(int32_t a1);
int32_t function_9ffc(int32_t a1);
int32_t function_a04e(void);
int32_t function_a055(int32_t a1, int32_t a2, int32_t a3);
int32_t function_a0b5(int32_t a1);
int32_t function_a0c8(void);
int32_t function_a0e1(void);
int32_t function_a11a(void);
int32_t function_a11f(void);
int32_t function_a129(void);
int32_t function_a158(void);
int32_t function_a171(int32_t a1);
int32_t function_a17e(void);
int32_t function_a1a0(void);
int32_t function_a1a5(void);
int32_t function_a1ab(void);
int32_t function_a1d3(void);
int32_t function_a2bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_a2f0(int32_t a1);
int32_t function_a306(void);
int32_t function_a3c0(int32_t result);
int32_t function_a3f3(void);
int32_t function_a4c4(void);
int32_t function_a4d8(void);
int32_t function_a50c(int32_t a1);
int32_t function_a538(void);
int32_t function_a581(int32_t a1);
int32_t function_a5e1(void);
int32_t function_a5e8(int32_t a1);
int32_t function_a608(void);
int32_t function_a64a(int32_t a1);
int32_t function_a671(void);
int32_t function_a676(void);
int32_t function_a70c(void);
int32_t function_a720(void);
int32_t function_a739(int32_t a1, int32_t * a2);
int32_t function_a768(int32_t a1);
int32_t function_a780(void);
int32_t function_a78b(int32_t a1, int32_t a2);
int32_t function_a7a7(void);
int32_t function_a7b4(int16_t a1);
int32_t function_a7bc(void);
int32_t function_a7c4(void);
int32_t function_a7d8(void);
int32_t function_a7e(void);
int32_t function_a7e3(int32_t a1);
int32_t function_a80(int32_t a1);
int32_t function_a812(void);
int32_t function_a816(void);
int32_t function_a828(void);
int32_t function_a86b(int32_t a1, int32_t a2, int32_t a3);
int32_t function_a915(void);
int32_t function_a930(void);
int32_t function_a93b(void);
int32_t function_a93f(void);
int32_t function_a964(void);
int32_t function_a9a0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_aa50(void);
int32_t function_aacb(void);
int32_t function_ab3(void);
int32_t function_ab55(void);
int32_t function_ab93(void);
int32_t function_abd0(int32_t a1, int32_t a2);
int32_t function_ac3(int32_t a1);
int32_t function_ac8(void);
int32_t function_acfb(void);
int32_t function_ad85(void);
int32_t function_adc3(void);
int32_t function_adf(void);
int32_t function_ae0c(int32_t * a1, int32_t a2, int32_t a3, uint32_t a4, uint32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_b140(void);
int32_t function_b18e(void);
int32_t function_b19e(void);
int32_t function_b1a8(void);
int32_t function_b1b4(void);
int32_t function_b1c0(void);
int32_t function_b1d1(int32_t a1, int32_t a2);
int32_t function_b1d6(void);
int32_t function_b1db(int32_t a1);
int32_t function_b1e5(int32_t a1, int32_t a2);
int32_t function_b265(int32_t a1);
int32_t function_b4ba(void);
int32_t function_b4cc(int16_t a1);
int32_t function_b4fe(void);
int32_t function_b51c(void);
int32_t function_b54a(void);
int32_t function_b568(int32_t a1, int32_t a2);
int32_t function_b598(int32_t a1);
int32_t function_b59c(void);
int32_t function_b5a6(void);
int32_t function_b5a7(void);
int32_t function_b5bc(void);
int32_t function_b5c5(void);
int32_t function_b5c7(void);
int32_t function_b7f4(int16_t a1);
int32_t function_b835(void);
int32_t function_b875(void);
int32_t function_b8cf(void);
int32_t function_b8f0(void);
int32_t function_b920(int32_t a1, int32_t a2);
int32_t function_b924(void);
int32_t function_b929(void);
int32_t function_b94d(void);
int32_t function_b972(void);
int32_t function_b975(void);
int32_t function_b97d(void);
int32_t function_b98c(void);
int32_t function_ba12(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_ba48(int32_t a1, int32_t a2);
int32_t function_ba60(void);
int32_t function_bb20(int32_t result);
int32_t function_bb53(void);
int32_t function_bbec(void);
int32_t function_bc18(void);
int32_t function_bc4d(void);
int32_t function_bc68(int32_t a1);
int32_t function_bca8(void);
int32_t function_bcb0(void);
int32_t function_bcd8(void);
int32_t function_bcde(void);
int32_t function_bce7(void);
int32_t function_bdc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_bf4e(int32_t a1, int32_t a2, int32_t a3, int32_t result);
int32_t function_bf77(void);
int32_t function_c04(void);
int32_t function_c0c4(void);
int32_t function_c0cd(void);
int32_t function_c0d(int32_t a1);
int32_t function_c0de(void);
int32_t function_c105(void);
int32_t function_c110(void);
int32_t function_c12d(int32_t a1);
int32_t function_c1d(void);
int32_t function_c281(void);
int32_t function_c28a(int32_t a1);
int32_t function_c33(void);
int32_t function_c3a1(void);
int32_t function_c3a8(int32_t a1);
int32_t function_c3c1(int32_t a1);
int32_t function_c3fc(void);
int32_t function_c40(void);
int32_t function_c472(void);
int32_t function_c4e9(void);
int32_t function_c4fa(void);
int32_t function_c50e(void);
int32_t function_c513(void);
int32_t function_c517(void);
int32_t function_c579(void);
int32_t function_c5a9(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_c5d8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_c5f0(void);
int32_t function_c6840f(void);
int32_t function_c6b0(int32_t result);
int32_t function_c6e3(void);
int32_t function_c7000000(void);
int32_t function_c77c(void);
int32_t function_c7a8(void);
int32_t function_c7dd(void);
int32_t function_c7f8(int32_t a1);
int32_t function_c838(void);
int32_t function_c840(void);
int32_t function_c868(void);
int32_t function_c86e(void);
int32_t function_c877(void);
int32_t function_c918(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_c948(int32_t a1);
int32_t function_c95f(void);
int32_t function_c96b(void);
int32_t function_c9c3(void);
int32_t function_c9c7(void);
int32_t function_c9d5(void);
int32_t function_c9f7(void);
int32_t function_ca10(void);
int32_t function_ca18(void);
int32_t function_ca47(int32_t a1);
int32_t function_ca4f(void);
int32_t function_cacb(void);
int32_t function_cae0(int16_t a1);
int32_t function_cb13(void);
int32_t function_cb69(void);
int32_t function_cb7b(void);
int32_t function_cbb0(int32_t a1);
int32_t function_cbf9(void);
int32_t function_cc14(int32_t a1);
int32_t function_cc30(void);
int32_t function_cc50(void);
int32_t function_cc56(void);
int32_t function_cc60(void);
int32_t function_ccbe(void);
int32_t function_ccf(int32_t a1, int32_t a2);
int32_t function_ccf5(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_cd28(int32_t a1, int32_t a2);
int32_t function_cd44(void);
int32_t function_cd50(void);
int32_t function_cd6b(void);
int32_t function_ce1d(void);
int32_t function_ce25(int32_t a1);
int32_t function_ce3e(void);
int32_t function_ce56(void);
int32_t function_ce75(int32_t a1, int32_t a2, int32_t a3);
int32_t function_ce90(void);
int32_t function_ceb8(void);
int32_t function_cef6(void);
int32_t function_cf6b(void);
int32_t function_cfad(int16_t a1);
int32_t function_cfb3(void);
int32_t function_d009(void);
int32_t function_d01b(void);
int32_t function_d050(int32_t a1);
int32_t function_d070(void);
int32_t function_d098(void);
int32_t function_d0a0(void);
int32_t function_d0c8(void);
int32_t function_d0d0(void);
int32_t function_d0d6(void);
int32_t function_d0f6(void);
int32_t function_d100(void);
int32_t function_d19a(int32_t a1);
int32_t function_d1bf(int32_t a1);
int32_t function_d20d(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d22a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_d234(void);
int32_t function_d289(int32_t a1);
int32_t function_d28f(void);
int32_t function_d2fe(void);
int32_t function_d335(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d368(int32_t a1, int32_t a2);
int32_t function_d384(void);
int32_t function_d390(void);
int32_t function_d3ab(void);
int32_t function_d45d(void);
int32_t function_d465(int32_t result);
int32_t function_d47e(void);
int32_t function_d496(void);
int32_t function_d4b5(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_d536(void);
int32_t function_d5ab(void);
int32_t function_d5f3(void);
int32_t function_d649(void);
int32_t function_d65b(void);
int32_t function_d690(int32_t a1);
int32_t function_d6b0(void);
int32_t function_d6d8(void);
int32_t function_d6e0(void);
int32_t function_d708(void);
int32_t function_d710(void);
int32_t function_d716(void);
int32_t function_d736(void);
int32_t function_d740(void);
int32_t function_d7da(int32_t a1);
int32_t function_d7ff(int32_t a1);
int32_t function_d84d(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d86a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_d874(void);
int32_t function_d964(void);
int32_t function_d978(int32_t a1);
int32_t function_d9c(void);
int32_t function_d9c0(int32_t a1);
int32_t function_d9d0(int32_t a1);
int32_t function_d9e3(void);
int32_t function_d9f0(int32_t a1, int32_t a2);
int32_t function_da0e(void);
int32_t function_da20(int32_t a1);
int32_t function_da30(int32_t a1);
int32_t function_da44(void);
int32_t function_da50(void);
int32_t function_da5f(void);
int32_t function_da64(void);
int32_t function_dae(void);
int32_t function_daf(void);
int32_t function_db00(int32_t a1);
int32_t function_db31da01(void);
int32_t function_db46(void);
int32_t function_db4d(void);
int32_t function_db50(int32_t a1);
int32_t function_db78(int32_t a1, int32_t * a2, int32_t a3);
int32_t function_dbd0(void);
int32_t function_dbe0(int32_t a1);
int32_t function_dc0(void);
int32_t function_dc22(void);
int32_t function_dc30(int32_t a1);
int32_t function_dc37(void);
int32_t function_dc97(void);
int32_t function_dc9c(void);
int32_t function_dcab(void);
int32_t function_dcc1(void);
int32_t function_dcd0(void);
int32_t function_dce0(int32_t a1);
int32_t function_dcf8(void);
int32_t function_dcfe(void);
int32_t function_ddb0(int32_t a1);
int32_t function_ddf(void);
int32_t function_de00(void);
int32_t function_de28(void);
int32_t function_de3(int32_t a1);
int32_t function_de4f(void);
int32_t function_de5f(void);
int32_t function_de66(void);
int32_t function_dec0(int32_t a1);
int32_t function_ded0(int32_t a1);
int32_t function_df1a(void);
int32_t function_df20(int32_t a1);
int32_t function_df5c(void);
int32_t function_df92(void);
int32_t function_dfc0(int32_t a1);
int32_t function_e090(int32_t a1);
int32_t function_e0a0(void);
int32_t function_e0b0(void);
int32_t function_e0c0(int32_t a1);
int32_t function_e15f(void);
int32_t function_e17f(void);
int32_t function_e180(int32_t a1);
int32_t function_e21b(void);
int32_t function_e220(int32_t a1);
int32_t function_e288(int32_t * a1);
int32_t function_e2d8(void);
int32_t function_e2f0(int32_t a1);
int32_t function_e358(int32_t a1, int32_t a2);
int32_t function_e370(int16_t a1);
int32_t function_e39c(void);
int32_t function_e3b1(void);
int32_t function_e3c1(void);
int32_t function_e3e4(void);
int32_t function_e68e(void);
int32_t function_e6fc(void);
int32_t function_e701(void);
int32_t function_e76b(char a1);
int32_t function_e83(void);
int32_t function_e862(void);
int32_t function_e89c(int32_t a1);
int32_t function_e940(int32_t a1);
int32_t function_e9aa(int32_t a1, int32_t a2, int32_t a3);
int32_t function_eae3(void);
int32_t function_eafc(void);
int32_t function_eb40(int32_t a1);
int32_t function_ebf1(void);
int32_t function_ec0(void);
int32_t function_ec4(void);
int32_t function_ec50(void);
int32_t function_ec64(void);
int32_t function_ed6d(void);
int32_t function_ed87(void);
int32_t function_eda0(int32_t a1, int32_t a2);
int32_t function_edd0(int32_t a1);
int32_t function_ee23(int32_t a1, int32_t a2);
int32_t function_ee53(void);
int32_t function_ee54(void);
int32_t function_ee55(void);
int32_t function_ee6c(void);
int32_t function_ee86(void);
int32_t function_ee95(int32_t a1);
int32_t function_eeae(void);
int32_t function_eec7(void);
int32_t function_eed0(int32_t a1);
int32_t function_eef4(void);
int32_t function_ef19(void);
int32_t function_ef30(int32_t a1, int32_t a2);
int32_t function_f076(void);
int32_t function_f0b9(void);
int32_t function_f0d2(void);
int32_t function_f100(int32_t a1);
int32_t function_f19c(int32_t a1);
int32_t function_f1be(void);
int32_t function_f25(int32_t a1);
int32_t function_f381(void);
int32_t function_f39e(void);
int32_t function_f3b9(int32_t a1);
int32_t function_f3e8(void);
int32_t function_f400(int32_t a1);
int32_t function_f41d(void);
int32_t function_f426(void);
int32_t function_f470(void);
int32_t function_f474(void);
int32_t function_f47e(void);
int32_t function_f4b5(void);
int32_t function_f4f7(void);
int32_t function_f4fc(void);
int32_t function_ff32(void);
void path_3c_char_20__5b_9_5d__3e_(int32_t this, char source[9], char * arg2);
int32_t unknown_10eb3(void);
int32_t unknown_10f3b(void);
int32_t unknown_10fc3(void);
int32_t unknown_112f0(int32_t a1);
int32_t unknown_11480(void);
int32_t unknown_11680(void);
int32_t unknown_119a0(int32_t a1);
int32_t unknown_11c40(int32_t a1);
int32_t unknown_11da0(void);
int32_t unknown_121b0(int32_t a1);
int32_t unknown_12220(int32_t a1, int32_t a2);
int32_t unknown_122e0(int32_t a1, int32_t a2);
int32_t unknown_12340(int32_t a1, int32_t a2);
int32_t unknown_125f0(int32_t a1);
int32_t unknown_127e0(int32_t a1, int32_t a2);
int32_t unknown_128a0(int32_t a1, int32_t a2);
int32_t unknown_12960(int32_t a1, int32_t a2);
int32_t unknown_12a40(int32_t a1, int32_t a2);
int32_t unknown_12fb0(int32_t a1);
int32_t unknown_130d0(int32_t a1);
int32_t unknown_13360(int32_t a1, int32_t a2);
int32_t unknown_13d50(int32_t a1, int32_t a2);
int32_t unknown_13d60(int32_t a1);
int32_t unknown_13ff0(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_14550(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_14d50(int32_t a1);
int32_t unknown_14de0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_14e00(int32_t a1, int32_t a2);
int32_t unknown_14f30(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_15130(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_157f0(int32_t a1, int32_t a2);
int32_t unknown_15850(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_15880(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_15c40(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t unknown_15f70(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_15fc0(int32_t a1, int32_t a2);
int32_t unknown_16850(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_16f70(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_17120(int32_t a1, int32_t a2);
int32_t unknown_17180(void);
int32_t unknown_17300(int32_t a1);
int32_t unknown_17400(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_17460(int32_t a1);
int32_t unknown_174f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_17570(int32_t a1, int32_t a2);
int32_t unknown_175d0(int32_t a1);
int32_t unknown_17650(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_17850(int32_t a1, int32_t a2);
int32_t unknown_17a90(int32_t a1);
int32_t unknown_18350(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t unknown_18710(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_18b20(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_18c10(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_18cf0(int32_t a1, int32_t a2);
int32_t unknown_191f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_192e0(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_193d0(int32_t a1, int32_t a2);
int32_t unknown_199f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_19b70(int32_t a1);
int32_t unknown_19c80(int32_t a1, int32_t a2);
int32_t unknown_1a670(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_1a7f0(int32_t a1);
int32_t unknown_1a900(int32_t a1, int32_t a2);
int32_t unknown_1aaf0(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_1ae60(int32_t a1);
int32_t unknown_1b300(int32_t a1, int32_t a2);
int32_t unknown_1bd00(int32_t a1, int32_t a2);
int32_t unknown_1be30(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_1bee0(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_1c010(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_1c140(int32_t a1);
int32_t unknown_1c1f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_1c280(int32_t a1);
int32_t unknown_1c590(void);
int32_t unknown_7c8dcfd8(void);
int32_t unknown_ff66(void);

// --------------------- Global Variables ---------------------

bool g1 = false; // cf
int32_t g2 = 0; // eax
int32_t g3 = 0; // ebp
int32_t g4 = 0; // ebx
int32_t g5 = 0; // ecx
int32_t g6 = 0; // edi
int32_t g7 = 0; // edx
int32_t g8 = 0; // esi
int32_t g9 = 0; // esp
int32_t g10 = 0x6530;
int32_t g11 = 0x49d0;
int32_t g12 = 8;
int16_t * g14 = (int16_t *)0x2074c085;
int32_t g15 = 0x8585;
int32_t g16 = 1339;
int32_t g17 = 0x2444c71c;
int32_t g18 = 0x18740000;
int32_t g19 = 0x3b187400;
int32_t g20 = 0x53b1874;
int32_t g21 = 1339;
int16_t * g22 = (int16_t *)0x10740000;
int32_t g23 = 1339;
int32_t g24 = 0x8740000;
int64_t g25 = 0x14a16528ec83;
char * g29 = "\xec\x28\x65\xa1\x14";
int32_t g26 = 0x70210065;
char * g28;
int32_t g27 = 0x62642000;
int32_t g30 = 0x27bc8d00;
char * g31;
int32_t g32 = 0x652cec83;
char g33 = 21;
char g34 = 20;
int32_t g37 = 20;
int32_t g35 = 0x654cec83;
char g36 = 20;
int32_t g38 = -0x317ff8a;
int32_t g39 = 0x27bc8d00;
int32_t g40 = 0;
int32_t g41 = -0x76acaa00;
int32_t g42 = -0x3c76acaa;
int64_t g43 = 0xb68dc35b38c4;
int32_t g44 = -0x38bb137d;
int32_t g45 = 3075;
char * g47 = "\x89\x44\x24\x1c\x31\xc0\x8b\x03\x85\xc0\x74\x20\x3b\x05";
char * g46 = "\xc7\x84\x24\x84";
int16_t g49 = 0;
int32_t g48 = 0x4a60;
int32_t g53 = 0;
int32_t g55 = 0x6e10;
int32_t g56 = 0;
int32_t g58 = 0x7880;
int32_t g59 = 0x6690;
int32_t g62 = 0x6e80;
int32_t g64 = 0x7780;
int32_t g65 = 0x65d0;
int32_t g67 = 0x6d40;
int32_t g69 = 0x7060;
int32_t g70 = 0x6870;
int32_t g73 = 0x6da0;
int32_t g75 = 0x7340;
int32_t g76 = 0x6940;
int32_t g79 = 0x6ef0;
int32_t g81 = 0x75a0;
int32_t g82 = 0x6b00;
int32_t g85 = 0x6f60;
int32_t g87 = 0x74a0;
int32_t g88 = 0x6a20;
int32_t g89 = 0;
int32_t g91 = 0x6ce0;
int32_t g93 = 0x7240;
int64_t g94 = 0x653000010070ff;
bool g95 = false; // of
bool g96 = false; // sf
bool g97 = false; // zf
char * g13[3] = {
    "N5boost6detail15sp_counted_baseE",
    (char *)&g37,
    "N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE"
};
struct vtable_f5a0_type g50 = {
    .e0 = _ZN5boost6system12system_errorD1Ev,
    .e1 = _ZN5boost6system12system_errorD0Ev,
    .e2 = _ZNK5boost6system12system_error4whatEv
};
struct vtable_f5b8_type g51 = {
    .e0 = _ZN5boost16thread_exceptionD1Ev,
    .e1 = _ZN5boost16thread_exceptionD0Ev,
    .e2 = bitdb
};
struct vtable_f5d0_type g52 = {
    .e0 = _ZN5boost21thread_resource_errorD1Ev,
    .e1 = _ZN5boost21thread_resource_errorD0Ev,
    .e2 = _ZNK5boost21thread_resource_error4whatEv
};
struct vtable_fa98_type g54 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev,
    .e2 = _ZNK5boost21thread_resource_error4whatEv
};
struct vtable_fad8_type g57 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev,
    .e2 = _ZNK5boost21thread_resource_error4whatEv,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv
};
struct vtable_fb58_type g60 = {
    .e0 = _ZN5boost10lock_errorD1Ev,
    .e1 = _ZN5boost10lock_errorD0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv
};
struct vtable_fb78_type g61 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv
};
struct vtable_fbb8_type g63 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv
};
struct vtable_fc38_type g66 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorISt13runtime_errorED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorISt13runtime_errorED0Ev,
    .e2 = bitdb
};
struct vtable_fc78_type g68 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED0Ev,
    .e2 = bitdb,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE5cloneEv,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE7rethrowEv
};
struct vtable_fcf8_type g71 = {
    .e0 = _ZN5boost9gregorian16bad_day_of_monthD1Ev,
    .e1 = _ZN5boost9gregorian16bad_day_of_monthD0Ev,
    .e2 = bitdb
};
struct vtable_fd18_type g72 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED0Ev,
    .e2 = bitdb
};
struct vtable_fd58_type g74 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED0Ev,
    .e2 = bitdb,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE5cloneEv,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE7rethrowEv
};
struct vtable_fdd8_type g77 = {
    .e0 = _ZN5boost9gregorian8bad_yearD1Ev,
    .e1 = _ZN5boost9gregorian8bad_yearD0Ev,
    .e2 = bitdb
};
struct vtable_fdf8_type g78 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED0Ev,
    .e2 = bitdb
};
struct vtable_fe38_type g80 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED0Ev,
    .e2 = bitdb,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE5cloneEv,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE7rethrowEv
};
struct vtable_feb8_type g83 = {
    .e0 = _ZN5boost9gregorian9bad_monthD1Ev,
    .e1 = _ZN5boost9gregorian9bad_monthD0Ev,
    .e2 = bitdb
};
struct vtable_fed8_type g84 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED0Ev,
    .e2 = bitdb
};
struct vtable_ff18_type g86 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED0Ev,
    .e2 = bitdb,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE5cloneEv2,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE7rethrowEv
};
struct vtable_ff98_type g90 = {
    .e0 = _ZN5boost16exception_detail10bad_alloc_D1Ev,
    .e1 = _ZN5boost16exception_detail10bad_alloc_D0Ev
};
struct vtable_ffd8_type g92 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev,
    .e2 = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv
};

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x3
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEEE
// Type:          virtual member function
int32_t bitdb(void) {
    // 0x0
    return g2;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x10 - 0x14
// Line range:    411 - 978
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_month> >::clone() const
void _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE5cloneEv(int32_t this) {
    // 0x10
    return;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x20 - 0x21
// Line range:    404 - 1090
void _7e_clone_impl(int32_t this, int32_t __in_chrg) {
    // 0x20
    return;
}

// Address range: 0x38 - 0x50
int32_t function_38(int32_t a1, int32_t a2) {
    int32_t result = a1 ^ 0x2074c085;
    *(int32_t *)0 = 0;
    if (result != 0) {
        // 0x50
        return result;
    }
    // 0x4b
    return result;
}

// From module:   /usr/include/c++/4.6/bits/stl_vector.h
// Address range: 0x60 - 0x77
// Line range:    153 - 330
// Demangled:     std::_Vector_base<unsigned char, std::allocator<unsigned char> >::_M_deallocate(unsigned char *, unsigned int)
void _ZNSt12_Vector_baseIhSaIhEE13_M_deallocateEPhj(int32_t this, char * __p, int32_t __n) {
    // 0x60
    if (g2 == 0) {
        // bb
        function_7c(0x2074c085);
        // branch -> 0x74
    }
}

// Address range: 0x7c - 0x90
int32_t function_7c(int32_t a1) {
    int32_t result = a1 ^ 0x2074c085; // bp+80
    if (result != 0) {
        // 0x8d
    }
    // 0x89
    return result;
}

// From module:   /usr/include/boost/filesystem/v3/path_traits.hpp
// Address range: 0x9b - 0xa0
// Line range:    171 - 367
void dispatch_3c_std_3a__3a_basic_string_3c_char_3e__20__3e_(int32_t c, int32_t to, int32_t cvt) {
    int32_t v1 = 0; // eax
    unsigned char v2 = (char)v1;
    bool v3 = v2 > 153 | false;
    int32_t v4;
    if (false || (v2 & 14) > 9) {
        int32_t v5 = v3 ? (int32_t)(char)&g34 : 6;
        v4 = v5 + v1 & 255 | v1 & -256;
        // branch -> bb100
    } else {
        int32_t v6 = v3 ? v1 + (int32_t)(char)&g32 : v1;
        v4 = v6 & 255 | v1 & -256;
        // branch -> bb100
    }
    // bb100
    v1 = v4;
    char * v7 = (char *)v4;
    *v7 = *v7 + (char)v4;
    char * v8 = (char *)v1;
    *v8 = *v8 + (char)v1;
}

// From module:   /usr/include/boost/filesystem/v3/path.hpp
// Address range: 0xa0 - 0xa7
// Line range:    130 - 212
void path_3c_char_20__5b_9_5d__3e_(int32_t this, char source[9], char * arg2) {
    // 0xa0
    return;
}

// From module:   /parallelcoin/src/serialize.h
// Address range: 0xce - 0xd3
// Line range:    1048 - 80
// Demangled:     CDataStream::write(char const *, int)
void _ZN11CDataStream5writeEPKci(int32_t this, char * pch, int32_t nSize) {
    // 0xce
    function_89000119();
}

// From module:   /usr/include/boost/date_time/constrained_value.hpp
// Address range: 0x101 - 0x102
// Line range:    108 - 248
void _ZN5boost2CV23simple_exception_policyItLt1ELt31ENS_9gregorian16bad_day_of_monthEE8on_errorEttNS0_14violation_enumE(int16_t arg0, int16_t arg1, int32_t arg2) {
    // 0x101
    return;
}

// Address range: 0x120 - 0x121
int32_t function_120(void) {
    // 0x120
    return 0;
}

// Address range: 0x136 - 0x137
int32_t function_136(void) {
    // 0x136
    return g2;
}

// Address range: 0x148 - 0x14a
int32_t function_148(void) {
    // 0x148
    return function_136();
}

// Address range: 0x14a - 0x14c
int32_t function_14a(void) {
    // 0x14a
    return function_136();
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x150 - 0x189
// Line range:    33 - 810
// Demangled:     CDBEnv::EnvShutdown()
void _ZN6CDBEnv11EnvShutdownEv(int32_t this) {
    // 0x150
    return;
}

// From module:   /usr/include/boost/date_time/constrained_value.hpp
// Address range: 0x189 - 0x18d
// Line range:    108 - 176
void _ZN5boost2CV23simple_exception_policyItLt1400ELt10000ENS_9gregorian8bad_yearEE8on_errorEttNS0_14violation_enumE(int16_t arg0, int16_t arg1, int32_t arg2) {
    // 0x189
    return;
}

// Address range: 0x1ac - 0x1ad
int32_t function_1ac(void) {
    // 0x1ac
    return g2;
}

// Address range: 0x1e5 - 0x1e7
int32_t function_1e5(void) {
    // 0x1e5
    return 0;
}

// Address range: 0x204 - 0x206
int32_t function_204(void) {
    // 0x204
    return function_1ac();
}

// Address range: 0x206 - 0x207
int32_t function_206(int32_t a1, int32_t a2, int32_t a3) {
    // 0x206
    return g2;
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x220 - 0x24d
// Line range:    57 - 76
// Demangled:     CDBEnv::Close()
void _ZN6CDBEnv5CloseEv(int32_t this) {
    // 0x220
    _ZN6CDBEnv11EnvShutdownEv(0x2074c085);
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x260 - 0x2af
// Line range:    62 - 671
// Demangled:     CDBEnv::Open(boost::filesystem3::path const &)
void _ZN6CDBEnv4OpenERKN5boost11filesystem34pathE(int32_t this, int32_t pathIn) {
    // 0x260
    if (*(char *)this == 0) {
        // 0x2a8
        return;
    }
}

// Address range: 0x51a - 0x51b
int32_t function_51a(void) {
    // 0x51a
    return 0;
}

// Address range: 0x529 - 0x52a
int32_t function_529(void) {
    // 0x529
    return g2;
}

// Address range: 0x540 - 0x54b
int32_t function_540(void) {
    // 0x540
    int32_t v1;
    *(int32_t *)v1 = v1 - 1;
    return 0;
}

// Address range: 0x56c - 0x56e
int32_t function_56c(void) {
    // 0x56c
    return function_529();
}

// Address range: 0x56e - 0x56f
int32_t function_56e(int32_t a1) {
    // 0x56e
    return g2;
}

// Address range: 0x574 - 0x575
int32_t function_574(void) {
    // 0x574
    return 0;
}

// Address range: 0x579 - 0x57a
int32_t function_579(void) {
    // 0x579
    return g2;
}

// Address range: 0x581 - 0x582
int32_t function_581(void) {
    // 0x581
    return g2;
}

// Address range: 0x594 - 0x59b
int32_t function_594(void) {
    // 0x594
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x76bbdb84); // bp+594
    *v2 = *v2 - 1;
    return 0;
}

// Address range: 0x59b - 0x59d
int32_t function_59b(void) {
    // 0x59b
    return function_579();
}

// Address range: 0x5a7 - 0x5ab
int32_t function_5a7(void) {
    // 0x5a7
    int32_t result;
    return result;
}

// Address range: 0x5ab - 0x5ad
int32_t function_5ab(void) {
    // 0x5ab
    return 0;
}

// Address range: 0x5b9 - 0x5bb
int32_t function_5b9(void) {
    // 0x5b9
    return function_579();
}

// Address range: 0x5bb - 0x5bc
int32_t function_5bb(void) {
    // 0x5bb
    return g2;
}

// Address range: 0x5bc - 0x5bd
int32_t function_5bc(void) {
    // 0x5bc
    return 0;
}

// Address range: 0x5c5 - 0x5c7
int32_t function_5c5(void) {
    // 0x5c5
    return function_581();
}

// Address range: 0x5c7 - 0x5c9
int32_t function_5c7(void) {
    // 0x5c7
    return function_5bb();
}

// Address range: 0x5d5 - 0x5d9
int32_t function_5d5(void) {
    // 0x5d5
    return function_5bb();
}

// Address range: 0x5e5 - 0x5e6
int32_t function_5e5(void) {
    // 0x5e5
    return g2;
}

// Address range: 0x5f4 - 0x5fb
int32_t function_5f4(void) {
    int32_t * v1 = (int32_t *)-0x7677143d;
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x5fb - 0x5fd
int32_t function_5fb(void) {
    // 0x5fb
    return function_5e5();
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x600 - 0x622
// Line range:    107 - 410
// Demangled:     CDBEnv::MakeMock()
void _ZN6CDBEnv8MakeMockEv(int32_t this) {
    // 0x600
    g2 = 0;
    if (*(char *)this != 0) {
        // bb
        function_704(0x2074c085, 0, 0, 0);
        // branch -> 0x61f
    }
}

// Address range: 0x675 - 0x676
int32_t function_675(void) {
    // 0x675
    return g2;
}

// Address range: 0x6e2 - 0x704
int32_t function_6e2(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x7fc789c0;
    int32_t v2 = *v1 + 1;
    *v1 = v2;
    int32_t v3;
    if (v2 == 0 || false) {
        // bb
        v3 = function_675();
        // branch -> 0x6ea
    } else {
        // 0x6e2
        v3 = g2;
        // branch -> 0x6ea
    }
    // 0x6ea
    g2 = v3 & ((int32_t)(char)&g18 | -256) ^ 0x2074c085;
    int32_t v4 = 0; // esi
    *(char *)v4 = 1;
    *(char *)(v4 + 1) = 1;
    int32_t result; // bp+703
    // bb104
    result = function_75a();
    // branch -> 0x6fd
    // 0x6fd
    return result;
}

// Address range: 0x704 - 0x70f
int32_t function_704(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x704
    return g2;
}

// Address range: 0x73a - 0x73b
int32_t function_73a(int32_t a1) {
    // 0x73a
    return g2;
}

// Address range: 0x75a - 0x75b
int32_t function_75a(void) {
    // 0x75a
    return g2;
}

// Address range: 0x78c - 0x79c
int32_t function_78c(int32_t a1) {
    // 0x78c
    g2 = 0;
    return function_73a(0);
}

// Address range: 0x7b7 - 0x7c2
float80_t function_7b7(void) {
    int32_t * v1 = (int32_t *)-0x1413143d;
    *v1 = *v1 - 1;
    return -(float80_t)*(int16_t *)-112;
}

// From module:   /usr/include/c++/4.6/bits/stl_uninitialized.h
// Address range: 0x7d0 - 0x836
// Line range:    264 - 696
void __uninitialized_move_a_3c_std_3a__3a_pair_3c_std_3a__3a_vector_3c_unsigned_20_char_3e__2c__20_std_3a__3a_vector_3c_unsigned_20_char_3e__20__3e__2a__2c__20_std_3a__3a_pair_3c_std_3a__3a_vector_3c_unsigned_20_char_3e__2c__20_std_3a__3a_vector_3c_unsigned_20_char_3e__20__3e__2a__2c__20_std_3a__3a_allocator_3c_std_3a__3a_pair_3c_std_3a__3a_vector_3c_unsigned_20_char_3e__2c__20_std_3a__3a_vector_3c_unsigned_20_char_3e__20__3e__20__3e__20__3e_(int32_t __first, int32_t __last, int32_t __result, int32_t __alloc) {
    int32_t v1 = 0; // eax
    g4 = v1;
    g2 = 0;
    int32_t v2 = 0;
    int32_t v3 = 0; // ecx
    if (v2 == v1) {
        // bb
        g2 = function_907(v2, v3);
        // branch -> 0x7f5
    }
    int32_t v4 = v3 + (int32_t)&g47;
    g8 = v3;
    g3 = v4;
    function_8c1(v4);
}

// Address range: 0x83f - 0x894
int32_t function_83f(void) {
    // 0x83f
    *(int32_t *)(g8 + (int32_t)&g29) = g6 + g7;
    int32_t v1 = *(int32_t *)(g4 + (int32_t)&g47);
    int32_t v2 = *(int32_t *)(g4 + 16) - v1;
    int32_t v3;
    *(int32_t *)v3 = 0;
    int32_t v4 = 0; // edx
    *(int32_t *)(v4 + (int32_t)&g29) = 0;
    *(int32_t *)(v4 + (int32_t)&g37) = 0;
    g7 = 0;
    int32_t v5 = 0;
    if (v2 != 0) {
        // bb
        function_8f8();
        v5 = g7;
        // branch -> 0x86c
    }
    // 0x86c
    *(int32_t *)(g3 + (int32_t)&g37) = v5 + v2;
    g6 = 0;
    *(int32_t *)g3 = g7;
    *(int32_t *)(g3 + (int32_t)&g29) = g7;
    int32_t v6 = *(int32_t *)(g4 + (int32_t)&g47); // bp+879
    int32_t result = v6; // bp+890
    if (*(int32_t *)(g4 + 16) == v6) {
        // bb9
        result = function_89d();
        // branch -> 0x883
    }
    // 0x883
    return result;
}

// Address range: 0x89d - 0x8ad
int32_t function_89d(void) {
    // 0x89d
    int32_t v1;
    int32_t result = g8 - v1;
    int32_t v2;
    *(int32_t *)(v2 + (int32_t)&g29 + result) = g6 + g7;
    return result;
}

// Address range: 0x8ad - 0x8c1
int32_t function_8ad(void) {
    // 0x8ad
    g4 += (int32_t)&g16;
    g8 += (int32_t)&g16;
    return g2;
}

// Address range: 0x8c1 - 0x8f7
int32_t function_8c1(int32_t a1) {
    int32_t v1 = g8;
    int32_t v2 = v1;
    if (v1 == 0) {
        // bb
        g2 = function_8ad();
        v2 = g8;
        // branch -> 0x8c5
    }
    // 0x8c5
    *(int32_t *)v2 = 0;
    *(int32_t *)(g8 + (int32_t)&g29) = 0;
    *(int32_t *)(g8 + (int32_t)&g37) = 0;
    return g2;
}

// Address range: 0x8f8 - 0x8fb
int32_t function_8f8(void) {
    // 0x8f8
    return g2;
}

// Address range: 0x900 - 0x907
int32_t function_900(void) {
    // 0x900
    return 0;
}

// Address range: 0x907 - 0x910
int32_t function_907(int32_t a1, int32_t a2) {
    // 0x907
    return g2;
}

// Address range: 0x910 - 0x958
int32_t function_910(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t result = 0; // esi
    if (a2 == 0x2074c085) {
        // 0x91f
        return result;
    }
    // 0x927
    g2 = result;
    int32_t * v1;
    _ZNSt12_Vector_baseIhSaIhEE13_M_deallocateEPhj((int32_t)&v1, (char *)&v1, (int32_t)&v1);
    if (result == a1) {
        // 0x958
        return result;
    }
    int32_t result2 = _ZNSt4pairISt6vectorIhSaIhEES2_ED1Ev(a1);
    // branch -> 0x949
    while (g4 != result) {
        // 0x949
        result2 = _ZNSt4pairISt6vectorIhSaIhEES2_ED1Ev(g4);
        // continue -> 0x949
    }
    // 0x958
    return result2;
}

// Address range: 0x960 - 0x962
int32_t function_960(void) {
    // 0x960
    return 0;
}

// Address range: 0x963 - 0x964
int32_t function_963(void) {
    // 0x963
    return 0;
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x980 - 0x9c1
// Line range:    211 - 62
// Demangled:     CDBEnv::CheckpointLSN(std::string)
void _ZN6CDBEnv13CheckpointLSNESs(int32_t this, int32_t strFile) {
    // 0x980
    return;
}

// Address range: 0x9e1 - 0xa10
int32_t function_9e1(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x651c2444;
    *v1 = *v1 - 1;
    int32_t result = 0x2074c085;
    if (result != 0) {
        // 0x9ff
        return result;
    }
    // 0x9ef
    return result;
}

// From module:   /parallelcoin/src/db.h
// Address range: 0xa10 - 0xa69
// Line range:    283 - 139
// Demangled:     CDB::Flush()
void _ZN3CDB5FlushEv(int32_t this) {
    // 0xa10
    if (*(int32_t *)(this + (int32_t)&g37) != 0) {
        // 0xa2c
        return;
    }
    // 0xa48
    if (*(char *)(this + (int32_t)&g47) != 0) {
        // bb
        function_a80(0x2074c085);
        // branch -> 0xa4e
    }
    // 0xa4e
    g4 = 0;
}

// Address range: 0xa7e - 0xa80
int32_t function_a7e(void) {
    // 0xa7e
    return 0;
}

// Address range: 0xa80 - 0xa97
int32_t function_a80(int32_t a1) {
    // 0xa80
    int32_t v1; // bp+43
    return &v1;
}

// Address range: 0xab3 - 0xac3
int32_t function_ab3(void) {
    int32_t v1 = 0; // ecx
    if (v1 == 0 || v1 == -1) {
        // 0xab7
        // branch -> 0xac1
    }
    // 0xac1
    return 0;
}

// Address range: 0xac3 - 0xac4
int32_t function_ac3(int32_t a1) {
    // 0xac3
    return g2;
}

// Address range: 0xac8 - 0xac9
int32_t function_ac8(void) {
    // 0xac8
    return g2;
}

// Address range: 0xadf - 0xaea
int32_t function_adf(void) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x5c8df474 + 8 * v1);
    *v2 = *v2 + 1;
    g2 = 0;
    return function_ac8();
}

// From module:   /parallelcoin/src/db.h
// Address range: 0xaf0 - 0xb07
// Line range:    491 - 104
void CAddrDB(int32_t this) {
    // 0xaf0
    return;
}

// Address range: 0xbdc - 0xbfe
int32_t function_bdc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x653c2444;
    *v1 = *v1 - 1;
    int32_t result = 0x2074c085;
    if (result != 0) {
        // 0xbfe
        return result;
    }
    // 0xbea
    return result;
}

// Address range: 0xc04 - 0xc05
int32_t function_c04(void) {
    // 0xc04
    return 0;
}

// Address range: 0xc0d - 0xc0e
int32_t function_c0d(int32_t a1) {
    // 0xc0d
    return g2;
}

// Address range: 0xc1d - 0xc33
int32_t function_c1d(void) {
    // 0xc1d
    return function_c0d(0);
}

// Address range: 0xc33 - 0xc37
int32_t function_c33(void) {
    // 0xc33
    int32_t * v1;
    return function_c0d((int32_t)&v1);
}

// Address range: 0xc40 - 0xc53
int32_t function_c40(void) {
    int32_t * v1 = (int32_t *)-0x72111410;
    *v1 = *v1 - 1;
    g2 = unknown_7c8dcfd8() & ((int32_t)(char)&g24 | -256);
    int32_t * v2;
    return function_c0d((int32_t)&v2);
}

// From module:   /parallelcoin/src/db.h
// Address range: 0xc60 - 0xc75
// Line range:    46 - 248
void CDBEnv(int32_t this) {
    // 0xc60
    return;
}

// Address range: 0xccf - 0xd4e
int32_t function_ccf(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // ebp
    int32_t * v2 = (int32_t *)(v1 + 0xa083);
    *v2 = *v2 - 1;
    int32_t v3 = 0; // ecx
    char * v4 = (char *)(v3 + 0xa883);
    *v4 = *v4 + (char)v3;
    char * v5 = (char *)(v3 + 0xac83);
    *v5 = *v5 + (char)v3;
    char * v6 = (char *)(v1 + 0xb883);
    *v6 = (char)v3 + *v6;
    char * v7 = (char *)(v3 + 0xc083);
    *v7 = *v7 + (char)v3;
    char * v8 = (char *)(v3 + (int32_t)&g46);
    *v8 = *v8 + (char)v3;
    int32_t v9 = 0; // ebx
    char * v10 = (char *)(v9 + 0x653c2444);
    *v10 = (char)v3 + *v10;
    int32_t v11 = 0x2074c085;
    g2 = v11;
    *(int32_t *)(v9 + (int32_t)&g42) = 0;
    *(int32_t *)(v9 + (int32_t)&g44) = 0;
    *(int32_t *)(v9 + 176) = 0;
    *(int32_t *)(v9 + 184) = 0;
    *(int32_t *)(v9 + 188) = 0;
    *(int32_t *)(v9 + 200) = 0;
    *(char *)v9 = 0;
    *(char *)(v9 + 1) = 0;
    int32_t result;
    if (v11 != 0) {
        // bb
        result = function_ddf();
        // branch -> 0xd48
    } else {
        // 0xccf
        result = g2;
        // branch -> 0xd48
    }
    // 0xd48
    return result;
}

// Address range: 0xd9c - 0xd9d
int32_t function_d9c(void) {
    // 0xd9c
    return g2;
}

// Address range: 0xdae - 0xdaf
int32_t function_dae(void) {
    // 0xdae
    return g2;
}

// Address range: 0xdaf - 0xdb0
int32_t function_daf(void) {
    // 0xdaf
    return 0;
}

// Address range: 0xdc0 - 0xddf
// From class:    N5boost21thread_resource_errorE
// Type:          constructor
int32_t function_dc0(void) {
    int32_t * v1 = (int32_t *)-0x38cbdb8c;
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    unsigned char v3 = (char)v2 & 56;
    int32_t v4 = (int32_t)v3 | v2 & -256;
    v2 = v4;
    char * v5 = (char *)v4;
    *v5 = *v5 + v3;
    char * v6 = (char *)v2;
    *v6 = *v6 + (char)v2;
    g2 = _ZN5boost15throw_exceptionINS_21thread_resource_errorEEEvRKT_(0);
    return function_d9c();
}

// Address range: 0xddf - 0xde0
int32_t function_ddf(void) {
    // 0xddf
    return g2;
}

// Address range: 0xde3 - 0xdf8
int32_t function_de3(int32_t a1) {
    int32_t * v1 = (int32_t *)0x44892434;
    *v1 = *v1 - 1;
    _ZN14AnnotatedMixinIN5boost15recursive_mutexEED1Ev();
    g2 = a1;
    return function_dae();
}

// From module:   /parallelcoin/src/db.h
// Address range: 0xe00 - 0xe52
// Line range:    52 - 52
void _7e_CDBEnv(int32_t this, int32_t __in_chrg) {
    // 0xe00
    g4 = this;
    _ZN6CDBEnv11EnvShutdownEv(this);
    int32_t v1 = g4;
    int32_t v2 = *(int32_t *)(v1 + 188);
    _ZNSt8_Rb_treeISsSt4pairIKSsP2DbESt10_Select1stIS4_ESt4lessISsESaIS4_EE8_M_eraseEPSt13_Rb_tree_nodeIS4_E(v1 + 180, v2);
    int32_t v3 = g4;
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g44);
    _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E(v3 + (int32_t)&g40, v4);
}

// Address range: 0xe83 - 0xe84
int32_t function_e83(void) {
    // 0xe83
    return 0;
}

// Address range: 0xec0 - 0xec1
int32_t function_ec0(void) {
    // 0xec0
    return g2;
}

// Address range: 0xec4 - 0xec5
int32_t function_ec4(void) {
    // 0xec4
    return 0;
}

// Address range: 0xf25 - 0xf2b
int32_t function_f25(int32_t a1) {
    // 0xf25
    g2 = a1;
    return function_ec0();
}

// From module:   /parallelcoin/src/db.h
// Address range: 0xf30 - 0xff5
// Line range:    139 - 152
void _ZN6CDBEnv6VerifyESsPFbRS_SsE(int32_t this, int32_t strFile, int32_t recoverFunc) {
    int32_t v1 = 0; // bp-44
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, this + (int32_t)&g37, (int32_t)"cs_db", (int32_t)"db.cpp", 141, 0);
    if (*(int32_t *)(this + (int32_t)&g44) == 0) {
        // bb
        function_1033();
        // branch -> 0xfb7
    }
}

// Address range: 0x100a - 0x1026
int32_t function_100a(int32_t a1) {
    // 0x100a
    int32_t v1;
    if (v1 == a1) {
        // bb
        function_1033();
        // branch -> 0x1014
    }
    // 0x1014
    int32_t result;
    return result;
}

// Address range: 0x1033 - 0x104d
int32_t function_1033(void) {
    // 0x1033
    int32_t v1;
    return v1 + (int32_t)&g31;
}

// Address range: 0x10c9 - 0x10ca
int32_t function_10c9(void) {
    // 0x10c9
    return 0;
}

// Address range: 0x10cb - 0x10cc
int32_t function_10cb(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x10cb
    return g2;
}

// Address range: 0x10d2 - 0x10ff
int32_t function_10d2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)0x902494; // 0x10d2
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x10d8
    *(char *)v2 = (char)v2 + *(char *)&g2;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)0);
    if ((a1 ^ 0x2074c085) != 0) {
        // 0x1134
        return g4;
    }
    // 0x10f4
    return g4;
}

// Address range: 0x1100 - 0x112f
int32_t function_1100(void) {
    int32_t result = function_10cb((int32_t)"mapFileUseCount.count(strFile) == 0", (int32_t)"db.cpp", (int32_t)&g38, (int32_t)"CDBEnv::VerifyResult CDBEnv::Verify(std::string, bool (*)(CDBEnv&, std::string))"); // 0x112d
    return result;
}

// Address range: 0x1130 - 0x1134
int32_t function_1130(void) {
    // 0x1130
    int32_t * v1;
    int32_t result = function_10cb((int32_t)&v1, (int32_t)&v1, (int32_t)&v1, (int32_t)&v1); // 0x1132
    return result;
}

// Address range: 0x113a - 0x113b
int32_t function_113a(void) {
    // 0x113a
    return 0;
}

// Address range: 0x113b - 0x113c
int32_t function_113b(void) {
    // 0x113b
    return g2;
}

// Address range: 0x1143 - 0x1144
int32_t function_1143(void) {
    // 0x1143
    return g2;
}

// Address range: 0x115a - 0x115e
int32_t function_115a(void) {
    // 0x115a
    return function_1143();
}

// Address range: 0x116a - 0x116c
int32_t function_116a(void) {
    // 0x116a
    return function_113b();
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x1170 - 0x1245
// Line range:    156 - 142
// Demangled:     CDBEnv::Salvage(std::string, bool, std::vector<std::pair<std::vector<unsigned char, std::allocator<unsigned char> >, std::vector<unsigned char, std::allocator<unsigned char> > >, std::allocator<std::pair<std::vector<unsigned char, std::allocator<unsigned char> >, std::vector<unsigned char, std::allocator<unsigned char> > > > > &)
void _ZN6CDBEnv7SalvageESsbRSt6vectorISt4pairIS0_IhSaIhEES3_ESaIS4_EE(int32_t this, int32_t strFile, bool fAggressive, int32_t vResult) {
    int32_t v1 = 0; // bp-240
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, this + (int32_t)&g37, (int32_t)"cs_db", (int32_t)"db.cpp", (int32_t)&g41, 0);
    g2 = this;
    if (*(int32_t *)(this + (int32_t)&g44) == 0) {
        // bb
        function_1290();
        // branch -> 0x1203
    }
}

// Address range: 0x125a - 0x127e
int32_t function_125a(int32_t a1) {
    // 0x125a
    int32_t v1;
    if (v1 == a1) {
        // bb
        function_1290();
        // branch -> 0x1264
    }
    // 0x1264
    return *(int32_t *)(a1 + 16);
}

// Address range: 0x1290 - 0x12a8
int32_t function_1290(void) {
    // 0x1290
    int32_t v1; // bp+224
    g6 = &v1;
    return g2;
}

// Address range: 0x133e - 0x1344
int32_t function_133e(void) {
    // 0x133e
    return 0;
}

// Address range: 0x14a8 - 0x14a9
int32_t function_14a8(void) {
    // 0x14a8
    return g2;
}

// Address range: 0x1508 - 0x1509
int32_t function_1508(void) {
    // 0x1508
    return g2;
}

// Address range: 0x15db - 0x160c
int32_t function_15db(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)0xcc2484; // 0x15db
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    *(char *)v2 = (char)v2 + *(char *)&g2;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)v2);
    g2 = g4;
    int32_t result = g4; // 0x160b
    if (a1 != 0x2074c085) {
        // bb
        result = function_1bf8();
        // branch -> 0x1601
    }
    // 0x1601
    return result;
}

// Address range: 0x1610 - 0x165a
int32_t function_1610(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 - 12); // 0x162f
    g2 = v1;
    int32_t v2 = *(int32_t *)(124 + v1); // 0x1632
    if (v2 == 0) {
        // bb
        g2 = function_1b6c(0, (int32_t)"DATA=END");
        // branch -> 0x163e
    }
    // 0x163e
    if (*(char *)(v2 + 28) == 0) {
        // bb103
        function_1980();
        // branch -> 0x1648
    }
    // 0x1648
    return (int32_t)*(char *)(v2 + 39);
}

// Address range: 0x169b - 0x169c
int32_t function_169b(int32_t a1, int32_t a2) {
    // 0x169b
    return g2;
}

// Address range: 0x1721 - 0x1722
int32_t function_1721(int32_t a1) {
    // 0x1721
    return g2;
}

// Address range: 0x17a2 - 0x17a5
int32_t function_17a2(void) {
    // 0x17a2
    return 0;
}

// Address range: 0x17a6 - 0x17a7
int32_t function_17a6(int32_t a1) {
    // 0x17a6
    return g2;
}

// Address range: 0x1839 - 0x183a
int32_t function_1839(int32_t a1) {
    // 0x1839
    return g2;
}

// Address range: 0x188d - 0x1892
int32_t function_188d(int16_t a1) {
    int32_t result = 0; // eax
    *(char *)0 = *(char *)&g5 - (char)result;
    return result;
}

// Address range: 0x189a - 0x18ba
int32_t function_189a(int16_t a1) {
    uint32_t v1 = 0; // 0x189a
    int32_t result = 0; // eax
    unsigned char v2 = (char)result; // 0x189a
    int32_t v3 = v1 + 1; // ebx
    unsigned char v4 = (char)((char)(v1 / 256) < v2) + v2; // 0x189d
    int32_t v5 = (int32_t)v4 | result & -256; // 0x189d
    char * v6 = (char *)v5; // 0x189d
    *v6 = *v6 + v4;
    char * v7 = (char *)(v3 + 0x528b0c49); // 0x18a1
    unsigned char v8 = *v7; // 0x18a1
    int32_t v9 = 0; // ecx
    unsigned char v10 = (char)v9 + v8; // 0x18a1
    bool v11 = v10 < v8; // cf
    *v7 = v10;
    uint32_t v12 = v3; // 0x18a7
    v3 = ((int32_t)((char)(v12 >> (int32_t)&g37) + v4 + (char)v11) << (int32_t)&g37 | v12 & -0xff01) + 1;
    result = v5;
    *v6 = *v6 + v4;
    unsigned char v13 = (char)(v3 / 256); // 0x18ae
    char v14 = result; // 0x18ae
    char * v15 = (char *)result; // 0x18b1
    *v15 = *v15 + v14 + (char)(v13 + v14 < v13);
    char * v16 = (char *)result; // 0x18b3
    *v16 = *v16 + (char)result;
    unsigned char v17 = *(char *)&g5; // 0x18b5
    unsigned char v18 = (char)(v9 >> (int32_t)&g37) + v17; // 0x18b5
    *(char *)v9 = v18;
    return result;
}

// Address range: 0x18ca - 0x18cb
int32_t function_18ca(void) {
    // 0x18ca
    return g2;
}

// Address range: 0x1928 - 0x1929
int32_t function_1928(int32_t a1) {
    // 0x1928
    return g2;
}

// Address range: 0x192d - 0x1930
int32_t function_192d(void) {
    // 0x192d
    return 0;
}

// Address range: 0x1932 - 0x1933
int32_t function_1932(void) {
    // 0x1932
    return g2;
}

// Address range: 0x197a - 0x197f
int32_t function_197a(void) {
    // 0x197a
    return 0;
}

// Address range: 0x1980 - 0x1983
int32_t function_1980(void) {
    // 0x1980
    return g2;
}

// Address range: 0x1988 - 0x199d
int32_t function_1988(void) {
    // 0x1988
    return 0;
}

// Address range: 0x19d1 - 0x19f4
int32_t function_19d1(void) {
    int32_t v1 = 0; // eax
    char * v2 = (char *)(v1 + 0x74001c7b); // 0x19d4
    *v2 = *v2 + (char)v1;
    return v1 & 0x2743b60f;
}

// Address range: 0x19f9 - 0x19fe
int32_t function_19f9(void) {
    // 0x19f9
    return function_14a8();
}

// Address range: 0x1a08 - 0x1a1a
int32_t function_1a08(void) {
    // 0x1a08
    return 0;
}

// Address range: 0x1a28 - 0x1a3d
int32_t function_1a28(void) {
    int32_t v1 = 0; // 0x1a28
    g2 = v1;
    return function_169b(v1, 10);
}

// Address range: 0x1a47 - 0x1a63
int32_t function_1a47(int32_t a1) {
    int32_t * v1 = (int32_t *)0x24948bc3; // 0x1a47
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x1a4d
    char * v3 = (char *)(v2 & -0xff01); // 0x1a4f
    *v3 = *v3 + (char)v2;
    g2 = a1;
    return function_1721(a1);
}

// Address range: 0x1a6f - 0x1a8b
int32_t function_1a6f(void) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 + 0x24948bc3); // 0x1a6f
    *v2 = *v2 - 1;
    char * v3 = (char *)0xc42484; // 0x1a78
    *v3 = (char)v1 + *v3;
    char v4 = *(char *)&g2; // 0x1a7e
    int32_t v5 = 0; // eax
    *(char *)v5 = (char)v5 + v4;
    g2 = v5;
    return function_17a6(v5);
}

// Address range: 0x1a90 - 0x1aa9
int32_t function_1a90(int32_t a1) {
    // 0x1a90
    g2 = a1;
    int32_t v1; // bp+156
    return function_1928((int32_t)&v1);
}

// Address range: 0x1abc - 0x1ac3
int32_t function_1abc(void) {
    // 0x1abc
    return function_18ca();
}

// Address range: 0x1ac8 - 0x1ad7
int32_t function_1ac8(void) {
    // 0x1ac8
    return function_1839(0);
}

// Address range: 0x1afb - 0x1b27
int32_t function_1afb(int32_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 - 0x72bbdbac); // 0x1afb
    *v2 = *v2 - 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = 2 * (char)v3;
    int32_t v4 = 0; // ecx
    char * v5 = (char *)(v4 - 0x76c7dbbc); // 0x1b06
    *v5 = *v5 + (char)v4;
    _ZNSt6vectorISt4pairIS_IhSaIhEES2_ESaIS3_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS3_S5_EERKS3_(0, v1);
    g2 = a1;
    return function_1932();
}

// Address range: 0x1b3b - 0x1b42
int32_t function_1b3b(void) {
    // 0x1b3b
    return function_1508();
}

// Address range: 0x1b65 - 0x1b6c
int32_t function_1b65(void) {
    // 0x1b65
    return function_1508();
}

// Address range: 0x1b6c - 0x1b6d
int32_t function_1b6c(int32_t a1, int32_t a2) {
    // 0x1b6c
    return g2;
}

// Address range: 0x1b72 - 0x1b73
int32_t function_1b72(void) {
    // 0x1b72
    return 0;
}

// Address range: 0x1b73 - 0x1b74
int32_t function_1b73(void) {
    // 0x1b73
    return g2;
}

// Address range: 0x1b83 - 0x1b84
int32_t function_1b83(void) {
    // 0x1b83
    return g2;
}

// Address range: 0x1b9e - 0x1b9f
int32_t function_1b9e(void) {
    // 0x1b9e
    return g2;
}

// Address range: 0x1ba6 - 0x1ba7
int32_t function_1ba6(void) {
    // 0x1ba6
    return g2;
}

// Address range: 0x1bc5 - 0x1bc9
int32_t function_1bc5(void) {
    // 0x1bc5
    return function_1b83();
}

// Address range: 0x1bd4 - 0x1bdb
int32_t function_1bd4(void) {
    int32_t * v1 = (int32_t *)-0x7646143d; // 0x1bd4
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x1bdb - 0x1bf8
int32_t function_1bdb(void) {
    // 0x1bdb
    int32_t * v1;
    _ZNSt12_Vector_baseIhSaIhEE13_M_deallocateEPhj((int32_t)&v1, (char *)&v1, (int32_t)&v1);
    _ZNSt12_Vector_baseIhSaIhEE13_M_deallocateEPhj((int32_t)&v1, (char *)&v1, (int32_t)&v1);
    g2 = (int32_t)&v1;
    return function_1b73();
}

// Address range: 0x1bf8 - 0x1bf9
int32_t function_1bf8(void) {
    // 0x1bf8
    return g2;
}

// Address range: 0x1bfe - 0x1bff
int32_t function_1bfe(void) {
    // 0x1bfe
    return 0;
}

// Address range: 0x1bff - 0x1c09
int32_t function_1bff(void) {
    // 0x1bff
    int32_t v1; // bp+276
    return &v1;
}

// Address range: 0x1c0e - 0x1c10
int32_t function_1c0e(void) {
    // 0x1c0e
    return function_1ba6();
}

// Address range: 0x1c10 - 0x1c14
int32_t function_1c10(void) {
    // 0x1c10
    return function_1b9e();
}

// Address range: 0x1c15 - 0x1c16
int32_t function_1c15(void) {
    // 0x1c15
    return 0;
}

// Address range: 0x1c2e - 0x1c30
int32_t function_1c2e(void) {
    // 0x1c2e
    return function_1bff();
}

// Address range: 0x1c34 - 0x1c35
int32_t function_1c34(void) {
    // 0x1c34
    return 0;
}

// Address range: 0x1c56 - 0x1c5a
int32_t function_1c56(void) {
    // 0x1c56
    return 0;
}

// Address range: 0x1c5a - 0x1c6d
int32_t function_1c5a(int32_t a1) {
    // 0x1c5a
    _ZNSt4pairISt6vectorIhSaIhEES2_ED1Ev(a1);
    return function_1bdb();
}

// Address range: 0x1c6d - 0x1c7e
int32_t function_1c6d(void) {
    // 0x1c6d
    g2 = 0;
    int32_t * v1;
    _ZNSt12_Vector_baseIhSaIhEE13_M_deallocateEPhj(0, (char *)&v1, (int32_t)&v1);
    return (int32_t)&v1;
}

// Address range: 0x1c7e - 0x1c91
int32_t function_1c7e(int32_t a1) {
    // 0x1c7e
    g2 = a1;
    int32_t * v1;
    _ZNSt12_Vector_baseIhSaIhEE13_M_deallocateEPhj((int32_t)&v1, (char *)&v1, (int32_t)&v1);
    return function_1bdb();
}

// Address range: 0x1c91 - 0x1c98
int32_t function_1c91(void) {
    // 0x1c91
    return function_1ba6();
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x1ca0 - 0x1ce2
// Line range:    496 - 521
// Demangled:     CAddrDB::Write(CAddrMan const &)
void _ZN7CAddrDB5WriteERK8CAddrMan(int32_t this, int32_t addr) {
    // 0x1ca0
    return;
}

// Address range: 0x1dc2 - 0x1dd6
int32_t function_1dc2(void) {
    int32_t result = 0; // eax
    *(char *)result = 2 * (char)result;
    char v1 = *(char *)&g2; // 0x1dc9
    *(char *)result = (char)result + v1;
    char v2 = *(char *)&g2; // 0x1dcb
    *(char *)result = (char)result + v2;
    int32_t v3 = 0; // ecx
    char * v4 = (char *)(v3 + 0x39c129d1); // 0x1dcd
    *v4 = *v4 + (char)v3;
    return result;
}

// Address range: 0x1dd6 - 0x1dde
int32_t function_1dd6(void) {
    int32_t result = 0; // eax
    *(int32_t *)result = result + 1;
    *(char *)0 = (char)0 + *(char *)&g6;
    return result;
}

// Address range: 0x2006 - 0x201d
int32_t function_2006(int32_t a1) {
    // 0x2006
    return 0;
}

// Address range: 0x2064 - 0x2065
int32_t function_2064(int32_t a1) {
    // 0x2064
    return g2;
}

// Address range: 0x208c - 0x2097
int32_t function_208c(void) {
    // 0x208c
    return 0;
}

// Address range: 0x20c9 - 0x20e7
int32_t function_20c9(void) {
    int32_t * v1 = (int32_t *)0x24948bf0; // 0x20c9
    *v1 = *v1 - 1;
    int32_t result; // 0x20e6
    // bb
    result = function_2113();
    // branch -> 0x20dc
    // 0x20dc
    return result;
}

// Address range: 0x20e8 - 0x20fb
int32_t function_20e8(void) {
    // 0x20e8
    return function_2064((int32_t)"CAddrman::Write() : Rename-into-place failed");
}

// Address range: 0x210c - 0x2113
int32_t function_210c(void) {
    // 0x210c
    int32_t * v1;
    return function_2064((int32_t)&v1);
}

// Address range: 0x2113 - 0x2114
int32_t function_2113(void) {
    // 0x2113
    return g2;
}

// Address range: 0x211a - 0x211b
int32_t function_211a(void) {
    // 0x211a
    return g2;
}

// Address range: 0x2130 - 0x2131
int32_t function_2130(void) {
    // 0x2130
    return g2;
}

// Address range: 0x2137 - 0x2142
int32_t function_2137(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x3f17dbe4; // 0x2137
    *v1 = *v1 - 1;
    int32_t v2 = g2; // 0x213e
    *(char *)v2 = (char)v2 + *(char *)&g2;
    return function_211a();
}

// Address range: 0x214e - 0x214f
int32_t function_214e(void) {
    // 0x214e
    return g2;
}

// Address range: 0x2158 - 0x215a
int32_t function_2158(void) {
    // 0x2158
    return 0;
}

// Address range: 0x215a - 0x215e
int32_t function_215a(void) {
    // 0x215a
    return function_214e();
}

// Address range: 0x216a - 0x216c
int32_t function_216a(void) {
    // 0x216a
    return 0;
}

// Address range: 0x216c - 0x2175
int32_t function_216c(void) {
    // 0x216c
    return _ZN11CDataStream5writeEPKci_part_549();
}

// Address range: 0x21ca - 0x21db
int32_t function_21ca(void) {
    int32_t * v1 = (int32_t *)0x24448dc6; // 0x21ca
    *v1 = *v1 - 1;
    g2 = bitdb();
    return function_2130();
}

// Address range: 0x21ed - 0x21ee
int32_t function_21ed(void) {
    // 0x21ed
    return g2;
}

// Address range: 0x21f5 - 0x21f7
int32_t function_21f5(void) {
    // 0x21f5
    return 0;
}

// Address range: 0x21f7 - 0x21fb
int32_t function_21f7(void) {
    // 0x21f7
    return function_21ed();
}

// Address range: 0x21fb - 0x21fc
int32_t function_21fb(int32_t a1) {
    // 0x21fb
    return g2;
}

// Address range: 0x21fc - 0x2203
int32_t function_21fc(void) {
    // 0x21fc
    return function_75906601();
}

// Address range: 0x221d - 0x2222
int32_t function_221d(void) {
    // 0x221d
    int32_t * v1;
    return function_2064((int32_t)&v1);
}

// Address range: 0x2222 - 0x2238
int32_t function_2222(void) {
    // 0x2222
    int32_t v1;
    return function_21fb(v1);
}

// Address range: 0x223f - 0x2241
int32_t function_223f(void) {
    // 0x223f
    return 0;
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x2250 - 0x2275
// Line range:    296 - 140
// Demangled:     CDB::Close()
void _ZN3CDB5CloseEv(int32_t this) {
    // 0x2250
    g8 = this;
    int32_t v1 = this; // 0x226b
    if (*(int32_t *)this == 0) {
        // bb
        function_22e1(0x2074c085, 0, 0);
        v1 = g8;
        // branch -> 0x226b
    }
    // 0x226b
    if (*(int32_t *)(v1 + (int32_t)&g37) == 0) {
        // bb106
        function_227a();
        // branch -> 0x2272
    }
}

// Address range: 0x227a - 0x22e1
int32_t function_227a(void) {
    // 0x227a
    *(int32_t *)(g8 + (int32_t)&g37) = 0;
    int32_t v1; // bp+36
    g4 = &v1;
    *(int32_t *)g8 = 0;
    int32_t v2 = g8; // 0x228b
    g8 = v2 + (int32_t)&g29;
    _ZN3CDB5FlushEv(v2);
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, (int32_t)"ock_error", (int32_t)"bitdb.cs_db", (int32_t)"db.cpp", 308, 0);
    int32_t * v3 = (int32_t *)_ZNSt3mapISsiSt4lessISsESaISt4pairIKSsiEEEixERS3_((int32_t)"abase", (int32_t *)g8); // 0x22d6
    *v3 = *v3 - 1;
    return _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v1);
}

// Address range: 0x22e1 - 0x22f4
int32_t function_22e1(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = a1 ^ 0x2074c085; // 0x22e5
    if (result != 0) {
        // 0x22f4
        return result;
    }
    // 0x22ee
    g8 = a3;
    return result;
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x2310 - 0x23e3
// Line range:    313 - 140
// Demangled:     CDBEnv::CloseDb(std::string const &)
void _ZN6CDBEnv7CloseDbERKSs(int32_t this, int32_t strFile) {
    int32_t v1 = g6; // 0x2313
    int32_t v2 = g8; // 0x231b
    g8 = strFile;
    g6 = this + 180;
    int32_t v3 = 0; // bp-40
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v3, this + (int32_t)&g37, (int32_t)"cs_db", (int32_t)"db.cpp", 316, 0);
    int32_t v4 = _ZNSt3mapISsP2DbSt4lessISsESaISt4pairIKSsS1_EEEixERS5_(g6, (int32_t *)g8); // 0x2377
    if (*(int32_t *)v4 != 0) {
        // 0x2382
        _ZNSt3mapISsP2DbSt4lessISsESaISt4pairIKSsS1_EEEixERS5_(g6, (int32_t *)g8);
        *(int32_t *)_ZNSt3mapISsP2DbSt4lessISsESaISt4pairIKSsS1_EEEixERS5_(g6, (int32_t *)g8) = 0;
        // branch -> 0x23ba
    }
    // 0x23ba
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v3);
    g8 = v2;
    g6 = v1;
}

// Address range: 0x23e9 - 0x23ea
int32_t function_23e9(void) {
    // 0x23e9
    return 0;
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x2400 - 0x2468
// Line range:    431 - 461
// Demangled:     CDBEnv::Flush(bool)
void _ZN6CDBEnv5FlushEb(int32_t this, bool fShutdown) {
    // 0x2400
    _Z13GetTimeMillisv(this);
}

// Address range: 0x246c - 0x24f8
int32_t function_246c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t * v1 = (int32_t *)(g4 - 0x7fcfdbbc); // 0x246c
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x2472
    if (*(char *)&g2 == (char)v2) {
        int32_t v3 = a2 ^ 0x2074c085; // 0x247a
        g2 = v3;
        int32_t result = v3; // 0x248e
        if (v3 != 0) {
            // bb
            result = function_26fc();
            // branch -> 0x2487
        }
        // 0x2487
        return result;
    }
    int32_t v4 = v2 + (int32_t)&g37; // 0x2490
    int32_t v5 = 0; // bp+68
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v5, v4, (int32_t)"cs_db", (int32_t)"db.cpp", (int32_t)&g17, 0);
    int32_t v6 = *(int32_t *)(a1 + (int32_t)&g45); // 0x24c7
    g4 = v6;
    int32_t v7 = a1 + (int32_t)&g42; // 0x24cd
    if (v6 == v7) {
        // bb123
        function_2608((char *)v7);
        // branch -> 0x24de
    }
    int32_t v8 = a1 + (int32_t)&g40; // 0x24e9
    return function_2518(a1 + (int32_t)&g31, v8);
}

// Address range: 0x2501 - 0x2502
int32_t function_2501(void) {
    // 0x2501
    return 0;
}

// Address range: 0x2502 - 0x2503
int32_t function_2502(void) {
    // 0x2502
    return g2;
}

// Address range: 0x2518 - 0x2526
int32_t function_2518(int32_t a1, int32_t a2) {
    // 0x2518
    return g4 + 16;
}

// Address range: 0x25eb - 0x2605
int32_t function_25eb(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x76c7dbb4; // 0x25eb
    *v1 = *v1 - 1;
    g2 = _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE12_M_erase_auxESt23_Rb_tree_const_iteratorIS2_E(0);
    return function_2502();
}

// Address range: 0x2608 - 0x264e
int32_t function_2608(char * a1) {
    // 0x2608
    int32_t * v1;
    int32_t v2 = _Z13GetTimeMillisv((int32_t)&v1); // 0x2608
    char v3 = *a1; // 0x261f
    int32_t v4 = v3 == 0 ? (int32_t)" db not started" : (int32_t)&g27; // 0x262f
    g4 = v4;
    return v2 - g8;
}

// Address range: 0x2652 - 0x2693
int32_t function_2652(int32_t a1) {
    int32_t * v1 = (int32_t *)0x3f247c; // 0x2652
    int32_t v2 = *v1 + 1; // 0x2652
    *v1 = v2;
    int32_t v3; // bp+68
    if (v2 == 0) {
        // 0x2668
        v3 = 0;
        return _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v3);
    }
    // 0x265a
    if (*(int32_t *)(a1 + 176) == 0) {
        // 0x2679
        return a1 + (int32_t)&g31;
    }
    // 0x2668
    return _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v3);
}

// Address range: 0x26f5 - 0x26f6
int32_t function_26f5(void) {
    // 0x26f5
    return g2;
}

// Address range: 0x26f7 - 0x26fc
int32_t function_26f7(void) {
    // 0x26f7
    return 0;
}

// Address range: 0x26fc - 0x2700
int32_t function_26fc(void) {
    // 0x26fc
    return g2;
}

// Address range: 0x2709 - 0x270d
int32_t function_2709(void) {
    // 0x2709
    g2 = 0;
    return function_26f5();
}

// Address range: 0x2719 - 0x271a
int32_t function_2719(void) {
    // 0x2719
    return g2;
}

// Address range: 0x272c - 0x2733
int32_t function_272c(void) {
    int32_t * v1 = (int32_t *)-0x761f143d; // 0x272c
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x2733 - 0x2735
int32_t function_2733(void) {
    // 0x2733
    return function_2719();
}

// Address range: 0x2736 - 0x2737
int32_t function_2736(void) {
    // 0x2736
    return 0;
}

// Address range: 0x2743 - 0x2745
int32_t function_2743(void) {
    // 0x2743
    return function_2719();
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x2750 - 0x27d6
// Line range:    328 - 140
// Demangled:     CDBEnv::RemoveDb(std::string const &)
void _ZN6CDBEnv8RemoveDbERKSs(int32_t this, int32_t strFile) {
    // 0x2750
    g8 = this;
    g6 = strFile;
    int32_t v1; // bp-24
    g4 = &v1;
    _ZN6CDBEnv7CloseDbERKSs(this, strFile);
    int32_t v2 = g8; // 0x2783
    g8 = v2 + (int32_t)&g31;
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, v2 + (int32_t)&g37, (int32_t)"cs_db", (int32_t)"db.cpp", 332, 0);
}

// Address range: 0x27da - 0x2809
int32_t function_27da(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)-0x3d6bf040; // 0x27da
    *v1 = *v1 + 1;
    int32_t result = 0; // 0x27e0
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)0);
    if ((a1 ^ 0x2074c085) != 0) {
        // 0x2809
        return result;
    }
    // 0x27f9
    return result;
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x2820 - 0x286f
// Line range:    220 - 251
void CDB(int32_t this, char * pszFile, char * pszMode) {
    // 0x2820
    g2 = 0;
    *(int32_t *)this = 0;
    *(int32_t *)(this + (int32_t)&g29) = (int32_t)&g47;
    *(int32_t *)(this + (int32_t)&g37) = 0;
    if (pszFile == NULL) {
        // bb
        function_294f(0x2074c085);
        // branch -> 0x2864
    }
}

// Address range: 0x2877 - 0x2881
int32_t function_2877(void) {
    unsigned char v1 = *(char *)&g6; // 0x2877
    *(char *)0 = v1 >> (char)&g29 | 16 * v1;
    return function_88000000();
}

// Address range: 0x2898 - 0x28a8
int32_t function_2898(void) {
    int32_t v1 = 0; // eax
    unsigned char v2 = (char)false + (char)v1; // 0x2898
    int32_t v3 = (int32_t)v2 | v1 & -256; // 0x2898
    char * v4 = (char *)v3; // 0x289a
    *v4 = *v4 + v2;
    g2 = v3 & -240;
    return function_c7000000();
}

// Address range: 0x28cf - 0x28d2
int32_t function_28cf(void) {
    // 0x28cf
    return 0;
}

// Address range: 0x2947 - 0x2948
int32_t function_2947(void) {
    // 0x2947
    return g2;
}

// Address range: 0x294f - 0x2968
int32_t function_294f(int32_t a1) {
    // 0x294f
    int32_t result; // 0x2967
    if (a1 != 0x2074c085) {
        // bb
        result = function_2c51();
        // branch -> 0x2960
    } else {
        // 0x294f
        result = g2;
        // branch -> 0x2960
    }
    // 0x2960
    return result;
}

// Address range: 0x2977 - 0x2982
int32_t function_2977(void) {
    // 0x2977
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x3d6bf040); // 0x2977
    *v2 = *v2 + 1;
    return 0;
}

// Address range: 0x29b7 - 0x29d7
int32_t function_29b7(void) {
    int32_t v1 = 0; // ecx
    *(char *)0 = (char)v1 + *(char *)&g6;
    int32_t result = 0; // eax
    *(int32_t *)result = 2 * result;
    char * v2 = (char *)-0x74c3dbac; // 0x29c2
    *v2 = (char)v1 + *v2;
    int32_t v3 = v1; // 0x29c8
    char v4 = *(char *)(v3 - 0x2b7f7406); // 0x29c8
    v1 = (int32_t)((char)v3 + v4) | v3 & -256;
    char v5 = *(char *)&g2; // 0x29ce
    *(char *)result = (char)result + v5;
    char * v6 = (char *)(v1 - 0x47d3dbbc); // 0x29d0
    *v6 = *v6 + (char)v1;
    return result;
}

// Address range: 0x29da - 0x29db
int32_t function_29da(int32_t a1) {
    // 0x29da
    return g2;
}

// Address range: 0x2ac6 - 0x2ae8
int32_t function_2ac6(void) {
    char * v1 = (char *)57; // 0x2acc
    *v1 = (char)0 + *v1;
    int32_t v2 = _ZNSt3mapISsP2DbSt4lessISsESaISt4pairIKSsS1_EEEixERS5_((int32_t)"roy(&cond)", (int32_t *)0); // 0x2ada
    g2 = v2;
    *(int32_t *)v2 = g4;
    return function_2947();
}

// Address range: 0x2aea - 0x2aeb
int32_t function_2aea(void) {
    // 0x2aea
    return g2;
}

// Address range: 0x2af2 - 0x2af3
int32_t function_2af2(void) {
    // 0x2af2
    return g2;
}

// Address range: 0x2b9b - 0x2ba9
int32_t function_2b9b(void) {
    // 0x2b9b
    int32_t v1;
    *(int32_t *)v1 = v1 - 1;
    *(char *)(int32_t)&g47 = (char)0;
    return 0;
}

// Address range: 0x2bb1 - 0x2bb4
int32_t function_2bb1(void) {
    // 0x2bb1
    return 0;
}

// Address range: 0x2bd4 - 0x2bf8
int32_t function_2bd4(void) {
    int32_t * v1 = (int32_t *)-0x377af040; // 0x2bd4
    *v1 = *v1 + 1;
    char v2 = *(char *)&g2; // 0x2bda
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + v2;
    char * v4 = (char *)-0x762dcefd; // 0x2bdc
    *v4 = (char)0 + *v4;
    g2 = 0;
    return function_29da(*(int32_t *)(*(int32_t *)(v3 & -196) + 212));
}

// Address range: 0x2c51 - 0x2c52
int32_t function_2c51(void) {
    // 0x2c51
    return g2;
}

// Address range: 0x2c64 - 0x2c69
int32_t function_2c64(void) {
    // 0x2c64
    return function_2aea();
}

// Address range: 0x2c73 - 0x2c74
int32_t function_2c73(void) {
    // 0x2c73
    return g2;
}

// Address range: 0x2c7f - 0x2c84
int32_t function_2c7f(void) {
    // 0x2c7f
    return function_2aea();
}

// Address range: 0x2c84 - 0x2c88
int32_t function_2c84(void) {
    // 0x2c84
    return function_2c73();
}

// Address range: 0x2c88 - 0x2c89
int32_t function_2c88(void) {
    // 0x2c88
    return g2;
}

// Address range: 0x2c89 - 0x2c8a
int32_t function_2c89(void) {
    // 0x2c89
    return 0;
}

// Address range: 0x2c94 - 0x2c99
int32_t function_2c94(void) {
    // 0x2c94
    return function_2aea();
}

// Address range: 0x2c99 - 0x2c9b
int32_t function_2c99(void) {
    // 0x2c99
    return function_2c88();
}

// Address range: 0x2c9b - 0x2ca5
int32_t function_2c9b(void) {
    // 0x2c9b
    return function_2af2();
}

// Address range: 0x2d1c - 0x2d1d
int32_t function_2d1c(void) {
    // 0x2d1c
    return g2;
}

// Address range: 0x2d26 - 0x2d2e
int32_t function_2d26(void) {
    // 0x2d26
    return function_2aea();
}

// Address range: 0x2d2e - 0x2d32
int32_t function_2d2e(void) {
    // 0x2d2e
    return function_2d1c();
}

// Address range: 0x2d3c - 0x2d3d
int32_t function_2d3c(void) {
    // 0x2d3c
    return g2;
}

// Address range: 0x2d48 - 0x2d4d
int32_t function_2d48(void) {
    // 0x2d48
    return function_2aea();
}

// Address range: 0x2d4d - 0x2d51
int32_t function_2d4d(void) {
    // 0x2d4d
    return function_2d3c();
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x2d60 - 0x2e1d
// Line range:    337 - 401
// Demangled:     CDB::Rewrite(std::string const &, char const *)
void _ZN3CDB7RewriteERKSsPKc(int32_t strFile, char * pszSkip) {
    // 0x2d60
    g4 = (int32_t)pszSkip;
    int32_t v1 = 0; // bp-112
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, (int32_t)"ock_error", (int32_t)"bitdb.cs_db", (int32_t)"db.cpp", 342, 0);
}

// Address range: 0x2e32 - 0x2e60
int32_t function_2e32(int32_t a1) {
    // 0x2e32
    if (a1 == 0x46f0) {
        // bb
        function_2e76();
        // branch -> 0x2e40
    }
    // 0x2e40
    return *(int32_t *)(a1 + 16);
}

// Address range: 0x2e64 - 0x2e70
int32_t function_2e64(void) {
    int32_t * v1 = (int32_t *)-0x7a25d60e; // 0x2e64
    *v1 = *v1 - 1;
    unsigned char v2 = *(char *)&g6; // 0x2e6a
    *(char *)0 = v2 >> (char)&g29 | 16 * v2;
    return 0;
}

// Address range: 0x2e76 - 0x2e98
int32_t function_2e76(void) {
    // 0x2e76
    int32_t v1;
    _ZN6CDBEnv7CloseDbERKSs((int32_t)"boost::lock_error", v1);
    int32_t * v2;
    return (int32_t)&v2;
}

// Address range: 0x2f76 - 0x2f80
int32_t function_2f76(void) {
    char v1 = *(char *)&g5; // 0x2f76
    int32_t v2 = 0; // eax
    *(char *)0 = (char)v2 + v1 + (char)false;
    char v3 = *(char *)&g2; // 0x2f78
    *(char *)v2 = (char)v2 + v3;
    return v2 & ((int32_t)(char)&g47 | -256);
}

// Address range: 0x2fbc - 0x2fbd
int32_t function_2fbc(int32_t a1) {
    // 0x2fbc
    return g2;
}

// Address range: 0x3020 - 0x3021
int32_t function_3020(void) {
    // 0x3020
    return g2;
}

// Address range: 0x3158 - 0x3160
int32_t function_3158(void) {
    unsigned char v1 = *(char *)&g6; // 0x3158
    *(char *)0 = v1 >> (char)&g29 | 16 * v1;
    return function_8b003169();
}

// Address range: 0x319d - 0x31a5
int32_t function_319d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, char * a6, int32_t result) {
    // 0x319d
    *a6 = *a6 + (char)result;
    return result;
}

// Address range: 0x31e4 - 0x3208
int32_t function_31e4(int16_t a1) {
    int32_t result = 0; // eax
    *(int16_t *)result = 0;
    *(int32_t *)result = 2 * result;
    *(int32_t *)result = 2 * result;
    char v1 = *(char *)&g2; // 0x31f0
    *(char *)result = (char)result + v1;
    char v2 = *(char *)&g2; // 0x31f2
    *(char *)result = (char)result + v2;
    char * v3 = (char *)0x248489d2; // 0x31f4
    *v3 = (char)result + *v3;
    *(int32_t *)result = 2 * result;
    int32_t v4 = 0; // ecx
    *(char *)0 = (char)v4 + *(char *)&g6;
    char v5 = *(char *)&g5; // 0x3203
    *(char *)v4 = v5 + (char)result;
    return result;
}

// Address range: 0x3288 - 0x3289
int32_t function_3288(void) {
    // 0x3288
    return g2;
}

// Address range: 0x3391 - 0x3396
int32_t function_3391(void) {
    // 0x3391
    return function_3020();
}

// Address range: 0x33b5 - 0x33b6
int32_t function_33b5(void) {
    // 0x33b5
    return g2;
}

// Address range: 0x3443 - 0x3454
int32_t function_3443(void) {
    int32_t result = 0; // eax
    char * v1 = (char *)result; // 0x3445
    *v1 = *v1 + (char)result;
    int32_t v2 = 0; // ecx
    char * v3 = (char *)(v2 + 0x50ff2414); // 0x3447
    unsigned char v4 = *v3; // 0x3447
    unsigned char v5 = v4 + (char)v2; // 0x3447
    *v3 = v5;
    char * v6 = (char *)-0x76bfdbb4; // 0x344d
    *v6 = (char)v2 + *v6 + (char)(v5 < v4);
    return result;
}

// Address range: 0x3455 - 0x3461
int32_t function_3455(void) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 + 0x50ff240c); // 0x3455
    *v2 = *v2 + v1;
    int32_t v3;
    return &v3;
}

// Address range: 0x3463 - 0x3464
int32_t function_3463(void) {
    // 0x3463
    return g2;
}

// Address range: 0x348b - 0x348c
int32_t function_348b(void) {
    // 0x348b
    return g2;
}

// Address range: 0x34a4 - 0x34a5
int32_t function_34a4(void) {
    // 0x34a4
    return g2;
}

// Address range: 0x34b2 - 0x34e3
int32_t function_34b2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)0x1dc2494; // 0x34b2
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x34b8
    *(char *)v2 = (char)v2 + *(char *)&g2;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)0);
    g2 = g4;
    int32_t result = g4; // 0x34e2
    if (a1 != 0x2074c085) {
        // bb
        result = function_3db0();
        // branch -> 0x34d8
    }
    // 0x34d8
    return result;
}

// Address range: 0x34e8 - 0x34f7
int32_t function_34e8(int32_t a1) {
    // 0x34e8
    return function_3503((int32_t)&g26);
}

// Address range: 0x34f8 - 0x3503
int32_t function_34f8(void) {
    // 0x34f8
    return 0;
}

// Address range: 0x3503 - 0x351d
int32_t function_3503(int32_t a1) {
    // 0x3503
    return *(int32_t *)(g3 + 16);
}

// Address range: 0x3532 - 0x3533
int32_t function_3532(void) {
    // 0x3532
    return 0;
}

// Address range: 0x3624 - 0x3943
int32_t function_3624(void) {
    int32_t * v1 = (int32_t *)0xfc289c0; // 0x3624
    *v1 = *v1 + 1;
    int32_t v2 = 0; // 0x362a
    int32_t v3 = 0xd800; // 0x3634
    int32_t v4 = v2 | 15; // 0x371817
    if ((int16_t)v2 >= 32) {
        // bb
        v4 = function_3cc7(v3);
        // branch -> 0x364c
    }
    int32_t v5 = 0; // edx
    uint16_t v6 = *(int16_t *)(v5 + 16); // 0x364c
    int32_t v7 = v6; // 0x364c
    int32_t v8 = v7 + 1; // 0x3652
    int32_t v9 = v8; // ecx
    int32_t v10 = v8 & (int32_t)&g94; // 0x365a
    if (v10 == 0) {
        // bb147
        v4 = function_3d95((int32_t)v6, 0);
        v8 = v9;
        // branch -> 0x3669
    }
    if ((int16_t)v8 >= 13) {
        // bb149
        int32_t v11;
        v4 = function_3d95(v10, v11);
        // branch -> 0x3673
    }
    int16_t v12 = *(int16_t *)(v5 + (int32_t)&g14); // 0x3673
    int32_t v13 = v12 + 1900; // 0x367c
    g4 = v13;
    int32_t v14 = v13 & (int32_t)&g94; // 0x3681
    if (v14 <= 1399) {
        // bb150
        v4 = function_3d8a((int32_t)v12);
        v13 = g4;
        // branch -> 0x3690
    }
    if ((int16_t)v13 >= 0x2711) {
        // bb152
        v4 = function_3d8a((int32_t)v12);
        // branch -> 0x369b
    }
    int32_t v15; // bp+484
    int32_t v16; // 0x3721
    int32_t v17; // 0x381c
    int32_t v18; // 0x3840
    int32_t v19; // 0x384022
    int32_t v20; // 0x3849
    int32_t v21; // 0x3928
    int32_t v22; // 0x37ed
    int32_t v23; // 0x383a
    int32_t v24; // 0x3843
    uint32_t v25; // 0x3766
    int32_t v26; // 0x37a8
    int32_t v27; // 0x3808
    int32_t v28; // 0x380a
    int32_t v29; // 0x382c
    int32_t v30; // 0x3864
    int32_t v31; // 0x386c
    int32_t v32; // 0x3899
    int32_t v33; // 0x38a0
    int32_t v34; // 0x3721
    int32_t v35; // 0x3732
    uint32_t v36; // 0x3774
    int32_t v37; // 0x38f5
    uint64_t v38; // 0x3759
    int32_t v39; // 0x3778
    uint16_t v40; // 0x37aa
    uint16_t v41; // 0x37b7
    int32_t v42; // 0x380d
    uint64_t v43; // 0x3879
    uint64_t v44; // 0x388d
    uint64_t v45; // 0x38f8
    uint32_t v46; // 0x3759
    uint64_t v47; // 0x3764
    uint32_t v48; // 0x3879
    int32_t v49; // 0x379d
    uint32_t v50; // 0x388f
    int32_t v51; // 0x38b3
    if ((int16_t)v9 < 12) {
        uint32_t v52 = v9 % 32; // 0x36aa
        int32_t v53 = 1; // 0x36b9
        if (v52 != 0) {
            // bb154
            v53 = 1 << v52;
            // branch -> bb155
        }
        // bb155
        if ((v53 & 2640) != 0) {
            // 0x3718
            if ((int16_t)v4 > (int16_t)(int32_t)&g20) {
                // bb156
                function_3d12();
                // branch -> 0x3721
            }
        } else {
            // 0x36b9
            if ((v53 & 4) != 0) {
                int32_t v54 = (int32_t)&g20 & -256 | (int32_t)&g18; // 0x3718
                if (v14 % 4 == 0) {
                    int16_t v55 = g4; // 0x36c7
                    int32_t v56 = g4 & -0x10000; // 0x36c7
                    int32_t v57 = 100 * 0x147b * ((g4 / 4 & 0x3ff8 | v56) & (int32_t)&g94) / 0x20000; // 0x36dd
                    if (v55 == (int16_t)v57) {
                        uint16_t v58 = v55 - (int16_t)(((g4 / 16 & 4088 | v56) & (int32_t)&g94) * (int32_t)&g43 / 0x10000 * 16 * ((int32_t)&g29 + 1 + ((int32_t)&g29 + 1) * (int32_t)&g29)); // 0x3709
                        v54 = (int32_t)&g19 - 1 - (int32_t)(v58 == 0);
                        // branch -> 0x3718
                    } else {
                        v54 = &g19;
                    }
                }
                // 0x3718
                if ((int16_t)v4 > (int16_t)v54) {
                    // bb156
                    function_3d12();
                    // branch -> 0x3721
                }
            }
        }
        // 0x3721
        v16 = v5;
        v34 = *(int32_t *)(v16 + (int32_t)&g29);
        v35 = *(int32_t *)(v16 + (int32_t)&g37);
        if (v34 >= 0) {
            // 0x373d
            if (v35 >= 0) {
                // 0x374a
                if (v16 >= 0) {
                    // 0x3752
                    v38 = 3600 * (int64_t)v35;
                    v46 = (int32_t)v38;
                    v47 = 60 * (int64_t)v34;
                    v25 = v46 + (int32_t)v47;
                    v36 = v25 + v16;
                    v39 = 0xf4240 * ((int32_t)(v47 / 0x100000000) + (v16 >> 31) + (int32_t)(v38 >> (int64_t)&g21) + (int32_t)(v25 < v46) + (int32_t)(v36 < v25));
                    v17 = v39 + v36 / 0x10c7;
                    // branch -> 0x378e
                    // 0x378e
                    g6 = v17;
                    v49 = 14 - v10;
                    v26 = (int32_t)(0x2aaaaaab * (int64_t)v49 >> (int64_t)&g21) / 2;
                    v40 = (int16_t)v26 - (int16_t)(v49 >> 31);
                    v41 = 0x1a2c - v40 + v12;
                    v22 = (int32_t)(v41 / 4) & (int32_t)&g94;
                    v27 = 365 * ((int32_t)v41 & (int32_t)&g94) + v3 + v22 - 0x147b * v22 / 0x20000 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v40 | v26 & -0x10000) - 2 + v7 & (int32_t)&g94) | 2) / 0x200000000);
                    v28 = ((int32_t)(v41 / 16) & (int32_t)&g94 & 4088) * (int32_t)&g43 / 0x10000;
                    v42 = v28 - 0x7d2d + v27;
                    g2 = v42;
                    if (v42 != 0) {
                        // 0x38d0
                        if (v42 != -1) {
                            // 0x38d9
                            if (v42 != -2) {
                                // 0x38f0
                                v37 = v42 * (int32_t)&g14;
                                v45 = 0x1dd76000 * (int64_t)v42;
                                v21 = v17 + (int32_t)(v45 >> (int64_t)&g21) + v37;
                                // branch -> 0x3900
                                // 0x3900
                                if ((v21 ^ -0x80000000) == 0 || false) {
                                    // 0x392b
                                    return &v15;
                                }
                                // 0x3922
                                // branch -> 0x392b
                                // 0x392b
                                return &v15;
                            }
                        }
                    }
                    // 0x382a
                    v19 = v42;
                    if (v42 != 0) {
                        // bb159
                        v29 = function_3950();
                        g2 = v29;
                        v19 = v29;
                        // branch -> 0x3832
                    }
                    // 0x3832
                    v18 = v19;
                    if ((g8 || g6 ^ -0x80000000) == 0) {
                        // bb160
                        v23 = function_397f();
                        g2 = v23;
                        v18 = v23;
                        // branch -> 0x3840
                    }
                    // 0x3840
                    v20 = v18;
                    if (v18 == -1) {
                        // bb161
                        v24 = function_399e();
                        g2 = v24;
                        v20 = v24;
                        // branch -> 0x3849
                    }
                    // 0x3849
                    if (v20 != 0) {
                        // bb162
                        function_3962();
                        // branch -> 0x3851
                    }
                    // 0x3851
                    // branch -> 0x3900
                    // 0x392b
                    return &v15;
                    // 0x3922
                    // branch -> 0x392b
                    // 0x392b
                    return &v15;
                }
            }
        }
        // 0x3860
        v30 = v34 >> 31;
        v31 = v35 >> 31;
        v43 = -60 * (int64_t)((v30 ^ v34) - v30);
        v48 = (int32_t)v43;
        v44 = -3600 * (int64_t)((v31 ^ v35) - v31);
        v50 = (int32_t)v44 + v48;
        v32 = v16 >> 31;
        v33 = (v32 ^ v16) - v32;
        v51 = 0xf4240 * ((int32_t)(v43 >> (int64_t)&g21) + (int32_t)(v33 < 0) + (int32_t)(v44 >> (int64_t)&g21) + (int32_t)(v50 < v48) + (int32_t)(v50 < v33));
        v17 = (v50 - v33) / 0x10c7 + v51;
        // branch -> 0x378e
        // 0x378e
        g6 = v17;
        v49 = 14 - v10;
        v26 = (int32_t)(0x2aaaaaab * (int64_t)v49 >> (int64_t)&g21) / 2;
        v40 = (int16_t)v26 - (int16_t)(v49 >> 31);
        v41 = 0x1a2c - v40 + v12;
        v22 = (int32_t)(v41 / 4) & (int32_t)&g94;
        v27 = 365 * ((int32_t)v41 & (int32_t)&g94) + v3 + v22 - 0x147b * v22 / 0x20000 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v40 | v26 & -0x10000) - 2 + v7 & (int32_t)&g94) | 2) / 0x200000000);
        v28 = ((int32_t)(v41 / 16) & (int32_t)&g94 & 4088) * (int32_t)&g43 / 0x10000;
        v42 = v28 - 0x7d2d + v27;
        g2 = v42;
        if (v42 != 0) {
            // 0x38d0
            if (v42 != -1) {
                // 0x38d9
                if (v42 != -2) {
                    // 0x38f0
                    v37 = v42 * (int32_t)&g14;
                    v45 = 0x1dd76000 * (int64_t)v42;
                    v21 = v17 + (int32_t)(v45 >> (int64_t)&g21) + v37;
                    // branch -> 0x3900
                    // 0x3900
                    if ((v21 ^ -0x80000000) == 0 || false) {
                        // 0x392b
                        return &v15;
                    }
                    // 0x3922
                    // branch -> 0x392b
                    // 0x392b
                    return &v15;
                }
            }
        }
        // 0x382a
        v19 = v42;
        if (v42 != 0) {
            // bb159
            v29 = function_3950();
            g2 = v29;
            v19 = v29;
            // branch -> 0x3832
        }
        // 0x3832
        v18 = v19;
        if ((g8 || g6 ^ -0x80000000) == 0) {
            // bb160
            v23 = function_397f();
            g2 = v23;
            v18 = v23;
            // branch -> 0x3840
        }
        // 0x3840
        v20 = v18;
        if (v18 == -1) {
            // bb161
            v24 = function_399e();
            g2 = v24;
            v20 = v24;
            // branch -> 0x3849
        }
        // 0x3849
        if (v20 != 0) {
            // bb162
            function_3962();
            // branch -> 0x3851
        }
        // 0x3851
        // branch -> 0x3900
        // 0x392b
        return &v15;
        // 0x3922
        // branch -> 0x392b
        // 0x392b
        return &v15;
    }
    // 0x3721
    v16 = v5;
    v34 = *(int32_t *)(v16 + (int32_t)&g29);
    v35 = *(int32_t *)(v16 + (int32_t)&g37);
    if (v34 >= 0) {
        // 0x373d
        if (v35 >= 0) {
            // 0x374a
            if (v16 >= 0) {
                // 0x3752
                v38 = 3600 * (int64_t)v35;
                v46 = (int32_t)v38;
                v47 = 60 * (int64_t)v34;
                v25 = v46 + (int32_t)v47;
                v36 = v25 + v16;
                v39 = 0xf4240 * ((int32_t)(v47 / 0x100000000) + (v16 >> 31) + (int32_t)(v38 >> (int64_t)&g21) + (int32_t)(v25 < v46) + (int32_t)(v36 < v25));
                v17 = v39 + v36 / 0x10c7;
                // branch -> 0x378e
                // 0x378e
                g6 = v17;
                v49 = 14 - v10;
                v26 = (int32_t)(0x2aaaaaab * (int64_t)v49 >> (int64_t)&g21) / 2;
                v40 = (int16_t)v26 - (int16_t)(v49 >> 31);
                v41 = 0x1a2c - v40 + v12;
                v22 = (int32_t)(v41 / 4) & (int32_t)&g94;
                v27 = 365 * ((int32_t)v41 & (int32_t)&g94) + v3 + v22 - 0x147b * v22 / 0x20000 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v40 | v26 & -0x10000) - 2 + v7 & (int32_t)&g94) | 2) / 0x200000000);
                v28 = ((int32_t)(v41 / 16) & (int32_t)&g94 & 4088) * (int32_t)&g43 / 0x10000;
                v42 = v28 - 0x7d2d + v27;
                g2 = v42;
                if (v42 != 0) {
                    // 0x38d0
                    if (v42 != -1) {
                        // 0x38d9
                        if (v42 != -2) {
                            // 0x38f0
                            v37 = v42 * (int32_t)&g14;
                            v45 = 0x1dd76000 * (int64_t)v42;
                            v21 = v17 + (int32_t)(v45 >> (int64_t)&g21) + v37;
                            // branch -> 0x3900
                            // 0x3900
                            if ((v21 ^ -0x80000000) == 0 || false) {
                                // 0x392b
                                return &v15;
                            }
                            // 0x3922
                            // branch -> 0x392b
                            // 0x392b
                            return &v15;
                        }
                    }
                }
                // 0x382a
                v19 = v42;
                if (v42 != 0) {
                    // bb159
                    v29 = function_3950();
                    g2 = v29;
                    v19 = v29;
                    // branch -> 0x3832
                }
                // 0x3832
                v18 = v19;
                if ((g8 || g6 ^ -0x80000000) == 0) {
                    // bb160
                    v23 = function_397f();
                    g2 = v23;
                    v18 = v23;
                    // branch -> 0x3840
                }
                // 0x3840
                v20 = v18;
                if (v18 == -1) {
                    // bb161
                    v24 = function_399e();
                    g2 = v24;
                    v20 = v24;
                    // branch -> 0x3849
                }
                // 0x3849
                if (v20 != 0) {
                    // bb162
                    function_3962();
                    // branch -> 0x3851
                }
                // 0x3851
                // branch -> 0x3900
                // 0x392b
                return &v15;
                // 0x3922
                // branch -> 0x392b
                // 0x392b
                return &v15;
            }
            // 0x3860
            v30 = v34 >> 31;
            v31 = v35 >> 31;
            v43 = -60 * (int64_t)((v30 ^ v34) - v30);
            v48 = (int32_t)v43;
            v44 = -3600 * (int64_t)((v31 ^ v35) - v31);
            v50 = (int32_t)v44 + v48;
            v32 = v16 >> 31;
            v33 = (v32 ^ v16) - v32;
            v51 = 0xf4240 * ((int32_t)(v43 >> (int64_t)&g21) + (int32_t)(v33 < 0) + (int32_t)(v44 >> (int64_t)&g21) + (int32_t)(v50 < v48) + (int32_t)(v50 < v33));
            v17 = (v50 - v33) / 0x10c7 + v51;
            // branch -> 0x378e
            // 0x378e
            g6 = v17;
            v49 = 14 - v10;
            v26 = (int32_t)(0x2aaaaaab * (int64_t)v49 >> (int64_t)&g21) / 2;
            v40 = (int16_t)v26 - (int16_t)(v49 >> 31);
            v41 = 0x1a2c - v40 + v12;
            v22 = (int32_t)(v41 / 4) & (int32_t)&g94;
            v27 = 365 * ((int32_t)v41 & (int32_t)&g94) + v3 + v22 - 0x147b * v22 / 0x20000 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v40 | v26 & -0x10000) - 2 + v7 & (int32_t)&g94) | 2) / 0x200000000);
            v28 = ((int32_t)(v41 / 16) & (int32_t)&g94 & 4088) * (int32_t)&g43 / 0x10000;
            v42 = v28 - 0x7d2d + v27;
            g2 = v42;
            if (v42 != 0) {
                // 0x38d0
                if (v42 != -1) {
                    // 0x38d9
                    if (v42 != -2) {
                        // 0x38f0
                        v37 = v42 * (int32_t)&g14;
                        v45 = 0x1dd76000 * (int64_t)v42;
                        v21 = v17 + (int32_t)(v45 >> (int64_t)&g21) + v37;
                        // branch -> 0x3900
                        // 0x3900
                        if ((v21 ^ -0x80000000) == 0 || false) {
                            // 0x392b
                            return &v15;
                        }
                        // 0x3922
                        // branch -> 0x392b
                        // 0x392b
                        return &v15;
                    }
                }
            }
            // 0x382a
            v19 = v42;
            if (v42 != 0) {
                // bb159
                v29 = function_3950();
                g2 = v29;
                v19 = v29;
                // branch -> 0x3832
            }
            // 0x3832
            v18 = v19;
            if ((g8 || g6 ^ -0x80000000) == 0) {
                // bb160
                v23 = function_397f();
                g2 = v23;
                v18 = v23;
                // branch -> 0x3840
            }
            // 0x3840
            v20 = v18;
            if (v18 == -1) {
                // bb161
                v24 = function_399e();
                g2 = v24;
                v20 = v24;
                // branch -> 0x3849
            }
            // 0x3849
            if (v20 != 0) {
                // bb162
                function_3962();
                // branch -> 0x3851
            }
            // 0x3851
            // branch -> 0x3900
            // 0x392b
            return &v15;
            // 0x3922
            // branch -> 0x392b
            // 0x392b
            return &v15;
        }
        // 0x3860
        v30 = v34 >> 31;
        v31 = v35 >> 31;
        v43 = -60 * (int64_t)((v30 ^ v34) - v30);
        v48 = (int32_t)v43;
        v44 = -3600 * (int64_t)((v31 ^ v35) - v31);
        v50 = (int32_t)v44 + v48;
        v32 = v16 >> 31;
        v33 = (v32 ^ v16) - v32;
        v51 = 0xf4240 * ((int32_t)(v43 >> (int64_t)&g21) + (int32_t)(v33 < 0) + (int32_t)(v44 >> (int64_t)&g21) + (int32_t)(v50 < v48) + (int32_t)(v50 < v33));
        v17 = (v50 - v33) / 0x10c7 + v51;
        // branch -> 0x378e
        // 0x378e
        g6 = v17;
        v49 = 14 - v10;
        v26 = (int32_t)(0x2aaaaaab * (int64_t)v49 >> (int64_t)&g21) / 2;
        v40 = (int16_t)v26 - (int16_t)(v49 >> 31);
        v41 = 0x1a2c - v40 + v12;
        v22 = (int32_t)(v41 / 4) & (int32_t)&g94;
        v27 = 365 * ((int32_t)v41 & (int32_t)&g94) + v3 + v22 - 0x147b * v22 / 0x20000 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v40 | v26 & -0x10000) - 2 + v7 & (int32_t)&g94) | 2) / 0x200000000);
        v28 = ((int32_t)(v41 / 16) & (int32_t)&g94 & 4088) * (int32_t)&g43 / 0x10000;
        v42 = v28 - 0x7d2d + v27;
        g2 = v42;
        if (v42 != 0) {
            // 0x38d0
            if (v42 != -1) {
                // 0x38d9
                if (v42 != -2) {
                    // 0x38f0
                    v37 = v42 * (int32_t)&g14;
                    v45 = 0x1dd76000 * (int64_t)v42;
                    v21 = v17 + (int32_t)(v45 >> (int64_t)&g21) + v37;
                    // branch -> 0x3900
                    // 0x3900
                    if ((v21 ^ -0x80000000) == 0) {
                        // 0x392b
                        return &v15;
                    }
                    // 0x3922
                    // branch -> 0x392b
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
        }
        // 0x382a
        v19 = v42;
        if (v42 != 0) {
            // bb159
            v29 = function_3950();
            g2 = v29;
            v19 = v29;
            // branch -> 0x3832
        }
        // 0x3832
        v18 = v19;
        if ((g8 || g6 ^ -0x80000000) == 0) {
            // bb160
            v23 = function_397f();
            g2 = v23;
            v18 = v23;
            // branch -> 0x3840
        }
        // 0x3840
        v20 = v18;
        if (v18 == -1) {
            // bb161
            v24 = function_399e();
            g2 = v24;
            v20 = v24;
            // branch -> 0x3849
        }
        // 0x3849
        if (v20 != 0) {
            // bb162
            function_3962();
            // branch -> 0x3851
        }
        // 0x3851
        // branch -> 0x3900
        // Detected a possible infinite recursion (goto support failed); quitting...
        // 0x3922
        // branch -> 0x392b
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x3860
    v30 = v34 >> 31;
    v31 = v35 >> 31;
    v43 = -60 * (int64_t)((v30 ^ v34) - v30);
    v48 = (int32_t)v43;
    v44 = -3600 * (int64_t)((v31 ^ v35) - v31);
    v50 = (int32_t)v44 + v48;
    v32 = v16 >> 31;
    v33 = (v32 ^ v16) - v32;
    v51 = 0xf4240 * ((int32_t)(v43 >> (int64_t)&g21) + (int32_t)(v33 < 0) + (int32_t)(v44 >> (int64_t)&g21) + (int32_t)(v50 < v48) + (int32_t)(v50 < v33));
    v17 = (v50 - v33) / 0x10c7 + v51;
    // branch -> 0x378e
    // 0x378e
    g6 = v17;
    v49 = 14 - v10;
    v26 = (int32_t)(0x2aaaaaab * (int64_t)v49 >> (int64_t)&g21) / 2;
    v40 = (int16_t)v26 - (int16_t)(v49 >> 31);
    v41 = 0x1a2c - v40 + v12;
    v22 = (int32_t)(v41 / 4) & (int32_t)&g94;
    v27 = 365 * ((int32_t)v41 & (int32_t)&g94) + v3 + v22 - 0x147b * v22 / 0x20000 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v40 | v26 & -0x10000) - 2 + v7 & (int32_t)&g94) | 2) / 0x200000000);
    v28 = ((int32_t)(v41 / 16) & (int32_t)&g94 & 4088) * (int32_t)&g43 / 0x10000;
    v42 = v28 - 0x7d2d + v27;
    g2 = v42;
    if (v42 != 0) {
        // 0x38d0
        if (v42 != -1) {
            // 0x38d9
            if (v42 != -2) {
                // 0x38f0
                v37 = v42 * (int32_t)&g14;
                v45 = 0x1dd76000 * (int64_t)v42;
                v21 = v17 + (int32_t)(v45 >> (int64_t)&g21) + v37;
                // branch -> 0x3900
                // 0x3900
                if ((v21 ^ -0x80000000) == 0) {
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x3922
                // branch -> 0x392b
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x382a
            v19 = v42;
            if (v42 != 0) {
                // bb159
                v29 = function_3950();
                g2 = v29;
                v19 = v29;
                // branch -> 0x3832
            }
            // 0x3832
            v18 = v19;
            if ((g8 || g6 ^ -0x80000000) == 0) {
                // bb160
                v23 = function_397f();
                g2 = v23;
                v18 = v23;
                // branch -> 0x3840
            }
            // 0x3840
            v20 = v18;
            if (v18 == -1) {
                // bb161
                v24 = function_399e();
                g2 = v24;
                v20 = v24;
                // branch -> 0x3849
            }
            // 0x3849
            if (v20 != 0) {
                // bb162
                function_3962();
                // branch -> 0x3851
            }
            // 0x3851
            // branch -> 0x3900
            // Detected a possible infinite recursion (goto support failed); quitting...
            // 0x3922
            // branch -> 0x392b
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x382a
        v19 = v42;
        if (v42 != 0) {
            // bb159
            v29 = function_3950();
            g2 = v29;
            v19 = v29;
            // branch -> 0x3832
        }
        // 0x3832
        v18 = v19;
        if ((g8 || g6 ^ -0x80000000) == 0) {
            // bb160
            v23 = function_397f();
            g2 = v23;
            v18 = v23;
            // branch -> 0x3840
        }
        // 0x3840
        v20 = v18;
        if (v18 == -1) {
            // bb161
            v24 = function_399e();
            g2 = v24;
            v20 = v24;
            // branch -> 0x3849
        }
        // 0x3849
        if (v20 != 0) {
            // bb162
            function_3962();
            // branch -> 0x3851
        }
        // 0x3851
        // branch -> 0x3900
        // Detected a possible infinite recursion (goto support failed); quitting...
        // 0x3922
        // branch -> 0x392b
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x382a
    v19 = v42;
    if (v42 != 0) {
        // bb159
        v29 = function_3950();
        g2 = v29;
        v19 = v29;
        // branch -> 0x3832
    }
    // 0x3832
    v18 = v19;
    if ((g8 || g6 ^ -0x80000000) == 0) {
        // bb160
        v23 = function_397f();
        g2 = v23;
        v18 = v23;
        // branch -> 0x3840
    }
    // 0x3840
    v20 = v18;
    if (v18 == -1) {
        // bb161
        v24 = function_399e();
        g2 = v24;
        v20 = v24;
        // branch -> 0x3849
    }
    // 0x3849
    if (v20 != 0) {
        // bb162
        function_3962();
        // branch -> 0x3851
    }
    // 0x3851
    // branch -> 0x3900
    // Detected a possible infinite recursion (goto support failed); quitting...
    // 0x3922
    // branch -> 0x392b
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// Address range: 0x3948 - 0x394d
int32_t function_3948(void) {
    // 0x3948
    return 0;
}

// Address range: 0x3950 - 0x3962
int32_t function_3950(void) {
    // 0x3950
    return g2;
}

// Address range: 0x3962 - 0x396a
int32_t function_3962(void) {
    // 0x3962
    return g2;
}

// Address range: 0x396a - 0x3973
int32_t function_396a(void) {
    // 0x396a
    return g2;
}

// Address range: 0x3973 - 0x397f
int32_t function_3973(void) {
    // 0x3973
    return 0;
}

// Address range: 0x397f - 0x3997
int32_t function_397f(void) {
    // 0x397f
    g8 = -2;
    g6 = 0x7fffffff;
    return g2;
}

// Address range: 0x3997 - 0x399e
int32_t function_3997(void) {
    // 0x3997
    return function_3463();
}

// Address range: 0x399e - 0x39ad
int32_t function_399e(void) {
    // 0x399e
    g8 = -1;
    g6 = 0x7fffffff;
    return g2;
}

// Address range: 0x39ec - 0x39ed
int32_t function_39ec(int32_t a1) {
    // 0x39ec
    return g2;
}

// Address range: 0x3a25 - 0x3a2e
int32_t function_3a25(int16_t a1) {
    // 0x3a25
    return 0;
}

// Address range: 0x3ac9 - 0x3ad8
int32_t function_3ac9(void) {
    // 0x3ac9
    int32_t v1;
    if ((char)v1 != 0) {
        // bb
        g2 = function_3020();
        // branch -> 0x3ad3
    }
    // 0x3ad3
    return function_3463();
}

// Address range: 0x3ad8 - 0x3b43
int32_t function_3ad8(int32_t a1, int32_t a2) {
    int32_t v1 = a2; // bp+320
    g4 = &v1;
    int32_t v2 = 0xf9060; // bp+536
    int32_t v3; // bp+540
    _ZNSt6vectorIc25zero_after_free_allocatorIcEE15_M_range_insertIPKcEEvN9__gnu_cxx17__normal_iteratorIPcS2_EET_SA_St20forward_iterator_tag(&v1, a2, (int32_t)&v2, (int32_t)&v3, 0);
    g2 = g3 + a1;
    return function_39ec(g3);
}

// Address range: 0x3b48 - 0x3b52
int32_t function_3b48(void) {
    // 0x3b48
    return function_3288();
}

// Address range: 0x3b52 - 0x3b5c
int32_t function_3b52(void) {
    // 0x3b52
    return function_2fbc(1);
}

// Address range: 0x3bea - 0x3beb
int32_t function_3bea(void) {
    // 0x3bea
    return g2;
}

// Address range: 0x3bfa - 0x3c07
int32_t function_3bfa(void) {
    // 0x3c02
    return function_348b();
}

// Address range: 0x3c22 - 0x3c27
int32_t function_3c22(void) {
    // 0x3c22
    return function_33b5();
}

// Address range: 0x3c27 - 0x3c2e
int32_t function_3c27(void) {
    // 0x3c27
    return function_3bea();
}

// Address range: 0x3c2f - 0x3c30
int32_t function_3c2f(void) {
    // 0x3c2f
    return 0;
}

// Address range: 0x3c38 - 0x3c39
int32_t function_3c38(void) {
    // 0x3c38
    return g2;
}

// Address range: 0x3c40 - 0x3c41
int32_t function_3c40(void) {
    // 0x3c40
    return g2;
}

// Address range: 0x3c4f - 0x3c50
int32_t function_3c4f(void) {
    // 0x3c4f
    return g2;
}

// Address range: 0x3c6e - 0x3c6f
int32_t function_3c6e(void) {
    // 0x3c6e
    return 0;
}

// Address range: 0x3c77 - 0x3c79
int32_t function_3c77(void) {
    // 0x3c77
    return function_3c4f();
}

// Address range: 0x3c7a - 0x3c7b
int32_t function_3c7a(void) {
    // 0x3c7a
    return 0;
}

// Address range: 0x3c86 - 0x3c98
int32_t function_3c86(void) {
    // 0x3c86
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + 0x1cc248c); // 0x3c86
    *v2 = *v2 - 1;
    char v3 = *(char *)&g2; // 0x3c8c
    int32_t v4 = 0; // eax
    *(char *)v4 = (char)v4 + v3;
    g2 = _ZN3CDBD1Ev(0);
    return function_3c40();
}

// Address range: 0x3c98 - 0x3c9c
int32_t function_3c98(void) {
    // 0x3c98
    return 0;
}

// Address range: 0x3c9c - 0x3ca2
int32_t function_3c9c(void) {
    // 0x3c9c
    return function_3c40();
}

// Address range: 0x3ca3 - 0x3ca4
int32_t function_3ca3(void) {
    // 0x3ca3
    return 0;
}

// Address range: 0x3cb3 - 0x3cb5
int32_t function_3cb3(void) {
    // 0x3cb3
    return function_3c4f();
}

// Address range: 0x3cc1 - 0x3cc3
int32_t function_3cc1(void) {
    // 0x3cc1
    return function_3c4f();
}

// Address range: 0x3cc3 - 0x3cc7
int32_t function_3cc3(void) {
    // 0x3cc3
    return function_3c4f();
}

// Address range: 0x3cc7 - 0x3cf9
int32_t function_3cc7(int32_t a1) {
    // 0x3cc7
    _ZN5boost2CV23simple_exception_policyItLt1ELt31ENS_9gregorian16bad_day_of_monthEE8on_errorEttNS0_14violation_enumE_isra_298();
    int32_t v1; // bp+554
    return &v1;
}

// Address range: 0x3d12 - 0x3d36
int32_t function_3d12(void) {
    // 0x3d12
    int32_t v1; // bp+555
    return &v1;
}

// Address range: 0x3d66 - 0x3d67
int32_t function_3d66(void) {
    // 0x3d66
    return g2;
}

// Address range: 0x3d76 - 0x3d7a
int32_t function_3d76(void) {
    // 0x3d76
    return function_3d66();
}

// Address range: 0x3d7a - 0x3d88
int32_t function_3d7a(void) {
    // 0x3d7a
    g2 = _ZN5boost9gregorian16bad_day_of_monthD1Ev((int32_t *)0);
    return function_3d66();
}

// Address range: 0x3d88 - 0x3d8a
int32_t function_3d88(void) {
    // 0x3d88
    return function_3d76();
}

// Address range: 0x3d8a - 0x3d95
int32_t function_3d8a(int32_t a1) {
    // 0x3d8a
    return _ZN5boost2CV23simple_exception_policyItLt1400ELt10000ENS_9gregorian8bad_yearEE8on_errorEttNS0_14violation_enumE_isra_533();
}

// Address range: 0x3d95 - 0x3da6
int32_t function_3d95(int32_t a1, int32_t a2) {
    // 0x3d95
    _ZN5boost2CV23simple_exception_policyItLt1ELt12ENS_9gregorian9bad_monthEE8on_errorEttNS0_14violation_enumE_isra_534();
    int32_t v1; // bp+464
    return &v1;
}

// Address range: 0x3dab - 0x3db0
int32_t function_3dab(void) {
    // 0x3dab
    return function_3c40();
}

// Address range: 0x3db0 - 0x3db1
int32_t function_3db0(void) {
    // 0x3db0
    return g2;
}

// Address range: 0x3db4 - 0x3dce
int32_t function_3db4(void) {
    int32_t * v1 = (int32_t *)0x241c89c6; // 0x3db4
    *v1 = *v1 - 1;
    int32_t * v2;
    _ZN11CDataStreamD1Ev(&v2);
    return _ZN11CDataStreamD1Ev((int32_t *)0);
}

// Address range: 0x3dde - 0x3ddf
int32_t function_3dde(void) {
    // 0x3dde
    return g2;
}

// Address range: 0x3ded - 0x3def
int32_t function_3ded(void) {
    // 0x3ded
    return 0;
}

// Address range: 0x3e00 - 0x3e02
int32_t function_3e00(void) {
    // 0x3e00
    return function_3dde();
}

// Address range: 0x3e02 - 0x3e0b
int32_t function_3e02(void) {
    // 0x3e02
    return _ZN11CDataStream5writeEPKci_part_549();
}

// Address range: 0x3e0d - 0x3e0e
int32_t function_3e0d(void) {
    // 0x3e0d
    return g2;
}

// Address range: 0x3e1c - 0x3e1e
int32_t function_3e1c(void) {
    // 0x3e1c
    return 0;
}

// Address range: 0x3e2a - 0x3e2c
int32_t function_3e2a(void) {
    // 0x3e2a
    return function_3e0d();
}

// Address range: 0x3e2c - 0x3e33
int32_t function_3e2c(void) {
    // 0x3e2c
    return function_3c38();
}

// From module:   /parallelcoin/src/db.h
// Address range: 0x3e40 - 0x3e74
// Line range:    534 - 580
// Demangled:     CAddrDB::Read(CAddrMan &)
void _ZN7CAddrDB4ReadER8CAddrMan(int32_t this, int32_t addr) {
    // 0x3e40
    return;
}

// Address range: 0x3edc - 0x3edd
int32_t function_3edc(void) {
    // 0x3edc
    return g2;
}

// Address range: 0x4015 - 0x4129
int32_t function_4015(char * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1; // 0x4019
    int32_t v2 = v1; // 0x4061
    if (a2 - v1 != 0) {
        // bb
        function_4398(a2);
        v2 = v1;
        // branch -> 0x404b
    }
    // 0x404b
    if (v2 == a2) {
        // 0x408b
        return &g89;
    }
    int32_t v3 = v2; // edx
    int32_t v4 = 0; // ecx
    int32_t v5 = v2; // 0x406c
    int32_t v6 = 0; // 0x4071
    // branch -> 0x4068
    int32_t v7; // 0x4073
    while (true) {
        int32_t v8 = 0; // 0x4076
        int32_t v9 = v5; // 0x4073
        if (v6 != 0) {
            // 0x406c
            *(char *)v6 = *(char *)v5;
            v8 = v4;
            v9 = v3;
            // branch -> 0x4073
        }
        // 0x4073
        v7 = v9 + 1;
        v3 = v7;
        int32_t v10 = v8 + 1; // 0x4076
        v4 = v10;
        if (v7 == a2) {
            // break -> 0x407f
            break;
        }
        v5 = v7;
        v6 = v10;
        // continue -> 0x4068
    }
    // 0x407f
    // branch -> 0x408b
    // 0x408b
    return v7 - v2 == 0 ? (int32_t)&g89 : 0;
}

// Address range: 0x4300 - 0x4301
int32_t function_4300(void) {
    // 0x4300
    return g2;
}

// Address range: 0x4322 - 0x4323
int32_t function_4322(void) {
    // 0x4322
    return g2;
}

// Address range: 0x4332 - 0x4333
int32_t function_4332(void) {
    // 0x4332
    return g2;
}

// Address range: 0x435a - 0x437b
int32_t function_435a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = 0; // esi
    g2 = result;
    if (a1 != 0x2074c085) {
        // bb
        result = function_440b();
        // branch -> 0x4370
    }
    // 0x4370
    return result;
}

// Address range: 0x438c - 0x4393
int32_t function_438c(void) {
    // 0x438c
    return function_4300();
}

// Address range: 0x4398 - 0x439b
int32_t function_4398(int32_t a1) {
    // 0x4398
    return g2;
}

// Address range: 0x43a0 - 0x43a5
int32_t function_43a0(void) {
    // 0x43a0
    return 0;
}

// Address range: 0x43a8 - 0x43af
int32_t function_43a8(void) {
    // 0x43a8
    return function_3edc();
}

// Address range: 0x43bc - 0x43c3
int32_t function_43bc(void) {
    // 0x43bc
    return function_4300();
}

// Address range: 0x43c8 - 0x43f1
int32_t function_43c8(int32_t a1) {
    int32_t v1; // bp+116
    int32_t v2 = _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(&a1, 0, 0, (int32_t)&v1); // 0x43e3
    g2 = v2;
    return function_3edc();
}

// Address range: 0x4404 - 0x440b
int32_t function_4404(void) {
    // 0x4404
    return function_4332();
}

// Address range: 0x440b - 0x440c
int32_t function_440b(void) {
    // 0x440b
    return g2;
}

// Address range: 0x44b8 - 0x44b9
int32_t function_44b8(void) {
    // 0x44b8
    return g2;
}

// Address range: 0x44b9 - 0x44ba
int32_t function_44b9(void) {
    // 0x44b9
    return 0;
}

// Address range: 0x44c3 - 0x44d0
int32_t function_44c3(void) {
    int32_t * v1 = (int32_t *)-0x7c057628; // 0x44c3
    *v1 = *v1 - 1;
    return function_891e7401();
}

// Address range: 0x44d8 - 0x44d9
int32_t function_44d8(void) {
    // 0x44d8
    return g2;
}

// Address range: 0x44e9 - 0x44eb
int32_t function_44e9(void) {
    // 0x44e9
    return function_44b8();
}

// Address range: 0x4506 - 0x450b
int32_t function_4506(void) {
    // 0x4506
    return function_4322();
}

// Address range: 0x450b - 0x451b
int32_t function_450b(void) {
    int32_t v1 = 0; // bp+40
    return _ZN11CDataStreamD1Ev(&v1);
}

// Address range: 0x451b - 0x451d
int32_t function_451b(void) {
    // 0x451b
    return 0;
}

// Address range: 0x4522 - 0x4523
int32_t function_4522(void) {
    // 0x4522
    return 0;
}

// Address range: 0x4541 - 0x4543
int32_t function_4541(void) {
    // 0x4541
    return 0;
}

// Address range: 0x4543 - 0x4559
int32_t function_4543(void) {
    // 0x4548
    return 0;
}

// Address range: 0x4571 - 0x4576
int32_t function_4571(void) {
    // 0x4571
    return function_4300();
}

// Address range: 0x4576 - 0x457b
int32_t function_4576(void) {
    // 0x4576
    return 0;
}

// Address range: 0x45ce - 0x45cf
int32_t function_45ce(void) {
    // 0x45ce
    return 0;
}

// Address range: 0x45d4 - 0x45d9
int32_t function_45d4(void) {
    // 0x45d4
    return 0;
}

// Address range: 0x45d9 - 0x45de
int32_t function_45d9(void) {
    // 0x45d9
    return function_44b8();
}

// Address range: 0x4635 - 0x4636
int32_t function_4635(void) {
    // 0x4635
    return 0;
}

// Address range: 0x463b - 0x4640
int32_t function_463b(void) {
    // 0x463b
    return 0;
}

// Address range: 0x4640 - 0x4645
int32_t function_4640(void) {
    // 0x4640
    return function_44b8();
}

// Address range: 0x4940 - 0x4965
// From class:    N5boost10lock_errorE
// Type:          virtual member function
// Demangled:     boost::lock_error::what() const
int32_t _ZNK5boost10lock_error4whatEv(void) {
    // 0x4940
    return (int32_t)"boost::lock_error";
}

// Address range: 0x4970 - 0x4995
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::thread_resource_error::what() const
int32_t _ZNK5boost21thread_resource_error4whatEv(void) {
    // 0x4970
    return (int32_t)"boost::thread_resource_error";
}

// Address range: 0x49a0 - 0x49ca
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1) {
    // 0x49a0
    *a1 = (int32_t)&g56;
    return 0;
}

// Address range: 0x49d0 - 0x49fa
// Demangled:     boost::detail::sp_counted_base::~sp_counted_base()
int32_t _ZN5boost6detail15sp_counted_baseD1Ev(int32_t * a1) {
    // 0x49d0
    *a1 = (int32_t)&g11;
    return 0;
}

// Address range: 0x4a00 - 0x4a50
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_base::destroy()
int32_t _ZN5boost6detail15sp_counted_base7destroyEv(int32_t * a1) {
    // 0x4a00
    if (a1 == NULL) {
        // 0x4a38
        return 0;
    }
    // 0x4a18
    return *(int32_t *)(*a1 + (int32_t)&g29);
}

// Address range: 0x4a60 - 0x4a8a
// Demangled:     boost::system::error_category::~error_category()
int32_t _ZN5boost6system14error_categoryD1Ev(int32_t * a1) {
    // 0x4a60
    *a1 = (int32_t)&g48;
    return 0;
}

// Address range: 0x4a90 - 0x4ac4
// Demangled:     boost::system::error_category::default_error_condition(int) const
int32_t _ZNK5boost6system14error_category23default_error_conditionEi(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t result = (int32_t)a1;
    *a1 = a3;
    *(int32_t *)(result + (int32_t)&g29) = a2;
    return result;
}

// Address range: 0x4ad0 - 0x4b2f
// Demangled:     boost::system::error_category::equivalent(int, boost::system::error_condition const &) const
int32_t _ZNK5boost6system14error_category10equivalentEiRKNS0_15error_conditionE(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t result = 0; // 0x4b2d
    int32_t v1;
    if (*(int32_t *)(a3 + (int32_t)&g29) == v1) {
        // 0x4b28
        int32_t v2;
        result = *(int32_t *)a3 == v2;
        // branch -> 0x4b14
    }
    // 0x4b14
    int32_t v3;
    if (v3 != 0x2074c085) {
        // 0x4b2f
    }
    // 0x4b21
    return result;
}

// Address range: 0x4b40 - 0x4b7f
// Demangled:     boost::system::error_category::equivalent(boost::system::error_code const &, int) const
int32_t _ZNK5boost6system14error_category10equivalentERKNS0_10error_codeEi(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t result = 0; // 0x4b72
    if (*(int32_t *)((int32_t)a2 + (int32_t)&g29) == a1) {
        // 0x4b78
        result = *a2 == a3;
        // branch -> 0x4b61
    }
    // 0x4b61
    return result;
}

// Address range: 0x4b90 - 0x4bba
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::~sp_counted_impl_p()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED1Ev(int32_t * a1) {
    // 0x4b90
    *a1 = (int32_t)&g11;
    return 0;
}

// Address range: 0x4bc0 - 0x4c10
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::dispose()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE7disposeEv(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g47); // 0x4bd3
    if (v1 == 0) {
        // 0x4bf8
        return 0;
    }
    // 0x4bda
    return *(int32_t *)(*(int32_t *)v1 + (int32_t)&g29);
}

// Address range: 0x4c20 - 0x4c40
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::get_deleter(std::type_info const &)
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE11get_deleterERKSt9type_info(void) {
    // 0x4c20
    return 0;
}

// Address range: 0x4c50 - 0x4c7e
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::~sp_counted_impl_p()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED0Ev(int32_t * a1) {
    // 0x4c50
    *a1 = (int32_t)&g11;
    return (int32_t)a1;
}

// Address range: 0x4c83 - 0x4c84
int32_t function_4c83(int32_t a1) {
    // 0x4c83
    return g2;
}

// Address range: 0x4c90 - 0x4cbe
// Demangled:     boost::detail::sp_counted_base::~sp_counted_base()
int32_t _ZN5boost6detail15sp_counted_baseD0Ev(int32_t * a1) {
    // 0x4c90
    *a1 = (int32_t)&g11;
    return (int32_t)a1;
}

// Address range: 0x4cc3 - 0x4cc4
int32_t function_4cc3(int32_t a1) {
    // 0x4cc3
    return g2;
}

// Address range: 0x4cd0 - 0x4cfe
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1) {
    // 0x4cd0
    *a1 = (int32_t)&g56;
    return (int32_t)a1;
}

// Address range: 0x4d03 - 0x4d04
int32_t function_4d03(int32_t a1) {
    // 0x4d03
    return g2;
}

// Address range: 0x4d10 - 0x4d3e
// Demangled:     boost::system::error_category::~error_category()
int32_t _ZN5boost6system14error_categoryD0Ev(int32_t * a1) {
    // 0x4d10
    *a1 = (int32_t)&g48;
    return (int32_t)a1;
}

// Address range: 0x4d43 - 0x4d44
int32_t function_4d43(int32_t a1) {
    // 0x4d43
    return g2;
}

// Address range: 0x4d50 - 0x4d70
// From class:    N5boost6system12system_errorE
// Type:          constructor
// Demangled:     boost::system::system_error::~system_error()
int32_t _ZN5boost6system12system_errorD1Ev(int32_t * a1) {
    // 0x4d50
    *a1 = (int32_t)&g50;
    return (int32_t)a1 + 16;
}

// Address range: 0x4da0 - 0x4da7
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(a1 - (int32_t)&g16); // 0x4da5
    return result;
}

// Address range: 0x4db0 - 0x4dcc
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1) {
    // 0x4db0
    return 0;
}

// Address range: 0x4dd2 - 0x4dd3
int32_t function_4dd2(void) {
    // 0x4dd2
    return 0;
}

// Address range: 0x58d0 - 0x58fe
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_exception::~thread_exception()
int32_t _ZN5boost16thread_exceptionD1Ev(int32_t * a1) {
    // 0x58d0
    *a1 = (int32_t)&g51;
    return (int32_t)a1;
}

// Address range: 0x5903 - 0x5904
int32_t function_5903(int32_t a1) {
    // 0x5903
    return g2;
}

// Address range: 0x5910 - 0x593e
// From class:    N5boost9gregorian16bad_day_of_monthE
// Type:          constructor
// Demangled:     boost::gregorian::bad_day_of_month::~bad_day_of_month()
int32_t _ZN5boost9gregorian16bad_day_of_monthD1Ev(int32_t * a1) {
    // 0x5910
    *a1 = (int32_t)&g71;
    return (int32_t)a1;
}

// Address range: 0x5943 - 0x5944
int32_t function_5943(int32_t a1) {
    // 0x5943
    return g2;
}

// Address range: 0x5950 - 0x597e
// From class:    N5boost9gregorian8bad_yearE
// Type:          constructor
// Demangled:     boost::gregorian::bad_year::~bad_year()
int32_t _ZN5boost9gregorian8bad_yearD1Ev(int32_t * a1) {
    // 0x5950
    *a1 = (int32_t)&g77;
    return (int32_t)a1;
}

// Address range: 0x5983 - 0x5984
int32_t function_5983(int32_t a1) {
    // 0x5983
    return g2;
}

// Address range: 0x5990 - 0x59be
// From class:    N5boost9gregorian9bad_monthE
// Type:          constructor
// Demangled:     boost::gregorian::bad_month::~bad_month()
int32_t _ZN5boost9gregorian9bad_monthD1Ev(int32_t * a1) {
    // 0x5990
    *a1 = (int32_t)&g83;
    return (int32_t)a1;
}

// Address range: 0x59c3 - 0x59c4
int32_t function_59c3(int32_t a1) {
    // 0x59c3
    return g2;
}

// Address range: 0x5fe2 - 0x6010
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockC2EP15pthread_mutex_t_part_22(void) {
    // 0x5fe2
    return 0;
}

// Address range: 0x6016 - 0x6044
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockD2Ev_part_23(void) {
    // 0x6016
    return 0;
}

// Address range: 0x604a - 0x6078
int32_t _ZN14AnnotatedMixinIN5boost15recursive_mutexEED2Ev_part_37(void) {
    // 0x604a
    return 0;
}

// Address range: 0x607d - 0x60ab
int32_t _ZN5boost11filesystem311path_traits8dispatchISsEEvRKSsRT_RKSt7codecvtIwc11__mbstate_tE_part_192(void) {
    // 0x607d
    return 0;
}

// Address range: 0x60b0 - 0x60de
int32_t _ZN11CDataStream5writeEPKci_part_549(void) {
    // 0x60b0
    return 0;
}

// Address range: 0x60e3 - 0x610a
int32_t _ZN5boost2CV23simple_exception_policyItLt1ELt31ENS_9gregorian16bad_day_of_monthEE8on_errorEttNS0_14violation_enumE_isra_298(void) {
    // 0x60e3
    int32_t v1; // bp-17
    return &v1;
}

// Address range: 0x616b - 0x6192
int32_t _ZN5boost2CV23simple_exception_policyItLt1400ELt10000ENS_9gregorian8bad_yearEE8on_errorEttNS0_14violation_enumE_isra_533(void) {
    // 0x616b
    int32_t v1; // bp-24
    g4 = &v1;
    int32_t v2; // bp-17
    return &v2;
}

// Address range: 0x61f3 - 0x621a
int32_t _ZN5boost2CV23simple_exception_policyItLt1ELt12ENS_9gregorian9bad_monthEE8on_errorEttNS0_14violation_enumE_isra_534(void) {
    // 0x61f3
    int32_t v1; // bp-17
    return &v1;
}

// Address range: 0x6280 - 0x629d
// From class:    N5boost9gregorian9bad_monthE
// Type:          constructor
// Demangled:     boost::gregorian::bad_month::~bad_month()
int32_t _ZN5boost9gregorian9bad_monthD0Ev(int32_t * a1) {
    // 0x6280
    *a1 = (int32_t)&g83;
    return 0;
}

// Address range: 0x62d0 - 0x62ed
// From class:    N5boost9gregorian8bad_yearE
// Type:          constructor
// Demangled:     boost::gregorian::bad_year::~bad_year()
int32_t _ZN5boost9gregorian8bad_yearD0Ev(int32_t * a1) {
    // 0x62d0
    *a1 = (int32_t)&g77;
    return 0;
}

// Address range: 0x6320 - 0x633d
// From class:    N5boost9gregorian16bad_day_of_monthE
// Type:          constructor
// Demangled:     boost::gregorian::bad_day_of_month::~bad_day_of_month()
int32_t _ZN5boost9gregorian16bad_day_of_monthD0Ev(int32_t * a1) {
    // 0x6320
    *a1 = (int32_t)&g71;
    return 0;
}

// Address range: 0x6370 - 0x639e
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_resource_error::~thread_resource_error()
int32_t _ZN5boost21thread_resource_errorD1Ev(int32_t * a1) {
    // 0x6370
    *a1 = (int32_t)&g51;
    return (int32_t)a1;
}

// Address range: 0x63a3 - 0x63a4
int32_t function_63a3(int32_t a1) {
    // 0x63a3
    return g2;
}

// Address range: 0x63b0 - 0x63de
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::lock_error::~lock_error()
int32_t _ZN5boost10lock_errorD1Ev(int32_t * a1) {
    // 0x63b0
    *a1 = (int32_t)&g51;
    return (int32_t)a1;
}

// Address range: 0x63e3 - 0x63e4
int32_t function_63e3(int32_t a1) {
    // 0x63e3
    return g2;
}

// Address range: 0x63f0 - 0x640d
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_exception::~thread_exception()
int32_t _ZN5boost16thread_exceptionD0Ev(int32_t * a1) {
    // 0x63f0
    *a1 = (int32_t)&g51;
    return 0;
}

// Address range: 0x6440 - 0x645d
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_resource_error::~thread_resource_error()
int32_t _ZN5boost21thread_resource_errorD0Ev(int32_t * a1) {
    // 0x6440
    *a1 = (int32_t)&g51;
    return 0;
}

// Address range: 0x6490 - 0x64ad
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::lock_error::~lock_error()
int32_t _ZN5boost10lock_errorD0Ev(int32_t * a1) {
    // 0x6490
    *a1 = (int32_t)&g51;
    return 0;
}

// Address range: 0x64e0 - 0x6500
// From class:    N5boost6system12system_errorE
// Type:          constructor
// Demangled:     boost::system::system_error::~system_error()
int32_t _ZN5boost6system12system_errorD0Ev(int32_t * a1) {
    // 0x64e0
    *a1 = (int32_t)&g50;
    return (int32_t)a1 + 16;
}

// Address range: 0x6530 - 0x6537
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(a1 - (int32_t)&g16); // 0x6535
    return result;
}

// Address range: 0x6540 - 0x655c
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::clone() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1) {
    // 0x6540
    return 0;
}

// Address range: 0x6560 - 0x65b7
int32_t function_6560(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)-0x77ff383d; // 0x6560
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x6567
    *(char *)v2 = (char)v2 + *(char *)&g2;
    int32_t v3 = 0; // esi
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g29); // 0x6569
    int32_t v5 = 0; // ebx
    *(int32_t *)(v5 + (int32_t)&g29) = v4;
    if (v4 != 0) {
        // 0x6573
        // branch -> 0x657b
    }
    int32_t v6 = *(int32_t *)(v3 + (int32_t)&g37); // 0x657b
    *(int32_t *)v5 = (int32_t)&g92;
    *(int32_t *)(v5 + (int32_t)&g37) = v6;
    int32_t v7 = *(int32_t *)(v3 + (int32_t)&g47); // 0x6592
    *(int32_t *)(v5 + (int32_t)&g47) = v7;
    *(int32_t *)(v5 + (int32_t)&g14) = (int32_t)&g93;
    *(int32_t *)(v5 + (int32_t)&g16) = (int32_t)&g10;
    *(int32_t *)(v5 + 16) = *(int32_t *)(v3 + 16);
    int32_t result = v5 + (int32_t)&g16; // 0x65ac
    if (a1 != 0x2074c085) {
        // 0x65b7
        return result;
    }
    // 0x65b1
    return result;
}

// Address range: 0x65d0 - 0x65d7
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(a1 - (int32_t)&g18); // 0x65d5
    return result;
}

// Address range: 0x65e0 - 0x65fc
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::clone() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1) {
    // 0x65e0
    return 0;
}

// Address range: 0x6600 - 0x6664
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_6600(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x4468bc3; // 0x6600
    *v1 = *v1 - 1;
    int32_t v2 = 0; // ebx
    *(int32_t *)v2 = (int32_t)&g60;
    *(int32_t *)(v2 + (int32_t)&g37) = (int32_t)&g53;
    *(int32_t *)(v2 + (int32_t)&g29) = 0;
    int32_t v3 = 0; // esi
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g47); // 0x6616
    *(int32_t *)(v2 + (int32_t)&g47) = v4;
    if (v4 != 0) {
        // 0x6620
        // branch -> 0x6628
    }
    // 0x6628
    *(int32_t *)(v2 + (int32_t)&g37) = (int32_t)&g64;
    *(int32_t *)(v2 + 16) = *(int32_t *)(v3 + 16);
    int32_t v5 = *(int32_t *)(v3 + (int32_t)&g14); // 0x6640
    *(int32_t *)(v2 + (int32_t)&g14) = v5;
    int32_t v6 = *(int32_t *)(v3 + (int32_t)&g16); // 0x6646
    *(int32_t *)v2 = (int32_t)&g63;
    *(int32_t *)(v2 + (int32_t)&g18) = (int32_t)&g65;
    *(int32_t *)(v2 + (int32_t)&g16) = v6;
    int32_t result = v2 + (int32_t)&g18; // 0x6659
    if (a1 != 0x2074c085) {
        // 0x6664
        return result;
    }
    // 0x665e
    return result;
}

// Address range: 0x6690 - 0x6697
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv(a1 - (int32_t)&g18); // 0x6695
    return result;
}

// Address range: 0x66a0 - 0x66bc
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::thread_resource_error> >::clone() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv(int32_t a1) {
    // 0x66a0
    return 0;
}

// Address range: 0x66c0 - 0x6724
// From class:    N5boost21thread_resource_errorE
// Type:          constructor
int32_t function_66c0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x4468bc3; // 0x66c0
    *v1 = *v1 - 1;
    int32_t v2 = 0; // ebx
    *(int32_t *)v2 = (int32_t)&g52;
    *(int32_t *)(v2 + (int32_t)&g37) = (int32_t)&g53;
    *(int32_t *)(v2 + (int32_t)&g29) = 0;
    int32_t v3 = 0; // esi
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g47); // 0x66d6
    *(int32_t *)(v2 + (int32_t)&g47) = v4;
    if (v4 != 0) {
        // 0x66e0
        // branch -> 0x66e8
    }
    // 0x66e8
    *(int32_t *)(v2 + (int32_t)&g37) = (int32_t)&g58;
    *(int32_t *)(v2 + 16) = *(int32_t *)(v3 + 16);
    int32_t v5 = *(int32_t *)(v3 + (int32_t)&g14); // 0x6700
    *(int32_t *)(v2 + (int32_t)&g14) = v5;
    int32_t v6 = *(int32_t *)(v3 + (int32_t)&g16); // 0x6706
    *(int32_t *)v2 = (int32_t)&g57;
    *(int32_t *)(v2 + (int32_t)&g18) = (int32_t)&g59;
    *(int32_t *)(v2 + (int32_t)&g16) = v6;
    int32_t result = v2 + (int32_t)&g18; // 0x6719
    if (a1 != 0x2074c085) {
        // 0x6724
        return result;
    }
    // 0x671e
    return result;
}

// Address range: 0x6750 - 0x67a6
// From class:    N5boost6system12system_errorE
// Type:          virtual member function
// Demangled:     boost::system::system_error::what() const
int32_t _ZNK5boost6system12system_error4whatEv(int32_t a1) {
    int32_t result = *(int32_t *)(a1 + 16); // 0x676f
    if (*(int32_t *)(result - 12) == 0) {
        // 0x67a0
        return 0;
    }
    // 0x6779
    return result;
}

// Address range: 0x67ad - 0x67b0
int32_t function_67ad(void) {
    // 0x67ad
    return 0;
}

// Address range: 0x67cf - 0x67d0
int32_t function_67cf(void) {
    // 0x67cf
    return g2;
}

// Address range: 0x6800 - 0x6808
int32_t function_6800(void) {
    // 0x6800
    return 0;
}

// Address range: 0x6820 - 0x6822
int32_t function_6820(void) {
    // 0x6820
    return function_67cf();
}

// Address range: 0x6822 - 0x6823
int32_t function_6822(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x6822
    return g2;
}

// Address range: 0x6833 - 0x6834
int32_t function_6833(void) {
    // 0x6833
    return g2;
}

// Address range: 0x6844 - 0x6845
int32_t function_6844(void) {
    // 0x6844
    return 0;
}

// Address range: 0x684a - 0x684f
int32_t function_684a(void) {
    // 0x684a
    return 0;
}

// Address range: 0x6850 - 0x6852
int32_t function_6850(void) {
    // 0x6850
    return function_6833();
}

// Address range: 0x6853 - 0x6856
int32_t function_6853(void) {
    // 0x6853
    return 0;
}

// Address range: 0x6870 - 0x6877
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE5cloneEv(a1 - (int32_t)&g18); // 0x6875
    return result;
}

// Address range: 0x6880 - 0x689c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error> >::clone() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE5cloneEv(int32_t a1) {
    // 0x6880
    return 0;
}

// Address range: 0x68ba - 0x6910
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEEE
// Type:          constructor
int32_t function_68ba(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x43c70c46); // 0x68ba
    *v2 = *v2 - 1;
    int32_t v3 = 0; // eax
    char * v4 = (char *)(v3 - 0x7affff06); // 0x68c0
    int32_t v5 = 0; // ecx
    *v4 = (char)v5 | *v4;
    char * v6 = (char *)(v5 + 0x52ff2404); // 0x68cd
    *v6 = *v6 + (char)v5;
    int32_t v7 = 1; // esi
    char * v8 = (char *)(v1 + 0x651c2454); // 0x68d6
    *v8 = (char)v5 + *v8;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g69;
    *(int32_t *)(v1 + 16) = v3 | 139;
    int32_t v9 = *(int32_t *)(v7 + 20); // 0x68ec
    *(int32_t *)(v1 + (int32_t)&g14) = v9;
    int32_t v10 = *(int32_t *)(v7 + 24); // 0x68f2
    *(int32_t *)v1 = (int32_t)&g68;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g70;
    *(int32_t *)(v1 + (int32_t)&g16) = v10;
    int32_t result = v1 + (int32_t)&g18; // 0x6905
    // 0x6910
    return result;
    // 0x690a
    return result;
}

// Address range: 0x691f - 0x6920
int32_t function_691f(void) {
    // 0x691f
    return g2;
}

// Address range: 0x6939 - 0x693b
int32_t function_6939(void) {
    // 0x6939
    return function_691f();
}

// Address range: 0x6940 - 0x6947
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE5cloneEv(a1 - (int32_t)&g18); // 0x6945
    return result;
}

// Address range: 0x6950 - 0x696c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_day_of_month> >::clone() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE5cloneEv(int32_t a1) {
    // 0x6950
    return 0;
}

// Address range: 0x698a - 0x69e6
int32_t function_698a(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x3c70c46); // 0x698a
    *v2 = *v2 - 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + *(char *)&g2;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g53;
    *(int32_t *)(v1 + (int32_t)&g47) = v3;
    if (v3 != 0) {
        // 0x69a2
        // branch -> 0x69aa
    }
    int32_t v4 = 0; // esi
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g75;
    *(int32_t *)(v1 + 16) = *(int32_t *)(v4 + 16);
    int32_t v5 = *(int32_t *)(v4 + (int32_t)&g14); // 0x69c2
    *(int32_t *)(v1 + (int32_t)&g14) = v5;
    int32_t v6 = *(int32_t *)(v4 + (int32_t)&g16); // 0x69c8
    *(int32_t *)v1 = (int32_t)&g74;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g76;
    *(int32_t *)(v1 + (int32_t)&g16) = v6;
    int32_t result = v1 + (int32_t)&g18; // 0x69db
    if (a1 != 0x2074c085) {
        // 0x69e6
        return result;
    }
    // 0x69e0
    return result;
}

// Address range: 0x69f5 - 0x69f6
int32_t function_69f5(void) {
    // 0x69f5
    return g2;
}

// Address range: 0x6a0f - 0x6a11
int32_t function_6a0f(void) {
    // 0x6a0f
    return function_69f5();
}

// Address range: 0x6a20 - 0x6a27
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE5cloneEv2(a1 - (int32_t)&g18); // 0x6a25
    return result;
}

// Address range: 0x6a30 - 0x6a4c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEEE
// Type:          virtual member function
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE5cloneEv2(int32_t a1) {
    // 0x6a30
    return 0;
}

// Address range: 0x6a6a - 0x6ac6
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEEE
// Type:          constructor
int32_t function_6a6a(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x3c70c46); // 0x6a6a
    *v2 = *v2 - 1;
    v1++;
    char v3 = *(char *)0x4c0001f8; // 0x6a76
    int32_t v4 = 0; // ecx
    *(char *)0x4c0001f8 = (char)v4 | v3;
    char * v5 = (char *)(v4 + 0x52ff2404); // 0x6a83
    *v5 = *v5 + (char)v4;
    int32_t v6 = 1; // esi
    char * v7 = (char *)(v1 + 0x651c2454); // 0x6a8c
    *v7 = (char)v4 + *v7;
    *(int32_t *)(v1 + 8) = (int32_t)&g87;
    *(int32_t *)(v1 + 16) = -0x38ffff01;
    *(int32_t *)(v1 + 20) = *(int32_t *)(v6 + 20);
    *(int32_t *)v1 = (int32_t)&g86;
    *(int32_t *)(v1 + 28) = (int32_t)&g88;
    *(int32_t *)(v1 + 24) = *(int32_t *)(v6 + 24);
    int32_t result = v1 + 28; // 0x6abb
    // 0x6ac6
    return result;
    // 0x6ac0
    return result;
}

// Address range: 0x6ad5 - 0x6ad6
int32_t function_6ad5(void) {
    // 0x6ad5
    return g2;
}

// Address range: 0x6aef - 0x6af1
int32_t function_6aef(void) {
    // 0x6aef
    return function_6ad5();
}

// Address range: 0x6b00 - 0x6b07
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE5cloneEv(a1 - (int32_t)&g18); // 0x6b05
    return result;
}

// Address range: 0x6b10 - 0x6b2c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_year> >::clone() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE5cloneEv(int32_t a1) {
    // 0x6b10
    return 0;
}

// Address range: 0x6b38 - 0x6b39
int32_t function_6b38(void) {
    // 0x6b38
    return 0;
}

// Address range: 0x6b4a - 0x6ba6
int32_t function_6b4a(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x3c70c46); // 0x6b4a
    *v2 = *v2 - 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + *(char *)&g2;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g53;
    *(int32_t *)(v1 + (int32_t)&g47) = v3;
    if (v3 != 0) {
        // 0x6b62
        // branch -> 0x6b6a
    }
    int32_t v4 = 0; // esi
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g81;
    *(int32_t *)(v1 + 16) = *(int32_t *)(v4 + 16);
    int32_t v5 = *(int32_t *)(v4 + (int32_t)&g14); // 0x6b82
    *(int32_t *)(v1 + (int32_t)&g14) = v5;
    int32_t v6 = *(int32_t *)(v4 + (int32_t)&g16); // 0x6b88
    *(int32_t *)v1 = (int32_t)&g80;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g82;
    *(int32_t *)(v1 + (int32_t)&g16) = v6;
    int32_t result = v1 + (int32_t)&g18; // 0x6b9b
    if (a1 != 0x2074c085) {
        // 0x6ba6
        return result;
    }
    // 0x6ba0
    return result;
}

// Address range: 0x6bb5 - 0x6bb6
int32_t function_6bb5(void) {
    // 0x6bb5
    return g2;
}

// Address range: 0x6bcf - 0x6bd1
int32_t function_6bcf(void) {
    // 0x6bcf
    return function_6bb5();
}

// Address range: 0x6be0 - 0x6c65
// Demangled:     boost::shared_ptr<boost::exception_detail::clone_base const>::~shared_ptr()
int32_t _ZN5boost10shared_ptrIKNS_16exception_detail10clone_baseEED1Ev(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g29); // 0x6bfb
    if (v1 == 0) {
        // 0x6c13
        return 0;
    }
    int32_t * v2 = (int32_t *)(v1 + (int32_t)&g29); // 0x6c09
    int32_t v3 = *v2 - 1; // 0x6c09
    *v2 = v3;
    if (v3 != 0) {
        // 0x6c13
        return 0;
    }
    int32_t * v4 = (int32_t *)(v1 + (int32_t)&g37); // 0x6c38
    int32_t v5 = *v4; // 0x6c38
    *v4 = v5 - 1;
    if (v5 == 1) {
        // 0x6c42
        return *(int32_t *)(*(int32_t *)v1 + (int32_t)&g47);
    }
    // 0x6c13
    return 0;
}

// Address range: 0x6c70 - 0x6cc1
// Demangled:     boost::exception::~exception()
int32_t _ZN5boost9exceptionD1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g29); // 0x6c84
    *a1 = (int32_t)&g53;
    if (v2 == 0) {
        // 0x6c9d
        return 0;
    }
    // 0x6c91
    if ((char)v2 != 0) {
        // 0x6cb8
        *(int32_t *)(v1 + (int32_t)&g29) = 0;
        // branch -> 0x6c9d
    }
    // 0x6c9d
    return 0;
}

// Address range: 0x6cc7 - 0x6cca
int32_t function_6cc7(void) {
    // 0x6cc7
    return 0;
}

// Address range: 0x6ce0 - 0x6cea
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D1Ev(int32_t a1) {
    // 0x6ce0
    return function_d9d0(a1 - (int32_t)&g14);
}

// Address range: 0x6cf0 - 0x6d17
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::bad_alloc_::~bad_alloc_()
int32_t _ZN5boost16exception_detail10bad_alloc_D1Ev(int32_t * a1) {
    // 0x6cf0
    *a1 = (int32_t)&g90;
    int32_t result = (int32_t)a1 + (int32_t)&g14; // 0x6d0a
    *(int32_t *)result = (int32_t)&g91;
    return result;
}

// Address range: 0x6d1b - 0x6d36
int32_t function_6d1b(int32_t a1) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x6d1b
    *v1 = *v1 - 1;
    int32_t result = 0x2074c085; // 0x6d21
    if (result != 0) {
        // 0x6d36
        return result;
    }
    // 0x6d29
    return result;
}

// Address range: 0x6d40 - 0x6d4a
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorISt13runtime_errorED1Ev(int32_t a1) {
    // 0x6d40
    return 0;
}

// Address range: 0x6d50 - 0x6d91
// From class:    N5boost16exception_detail19error_info_injectorISt13runtime_errorEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<std::runtime_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorISt13runtime_errorED1Ev(int32_t * a1) {
    // 0x6d50
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g66;
    int32_t v1 = g4 + (int32_t)&g37; // 0x6d6a
    g2 = v1;
    *(int32_t *)v1 = (int32_t)&g67;
    function_d9c0(g2);
    return 0;
}

// Address range: 0x6d96 - 0x6d97
int32_t function_6d96(void) {
    // 0x6d96
    return g2;
}

// Address range: 0x6da0 - 0x6daa
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED1Ev(int32_t a1) {
    // 0x6da0
    return function_db50(a1 - (int32_t)&g37);
}

// Address range: 0x6db0 - 0x6df7
// From class:    N5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::gregorian::bad_day_of_month>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g72;
    int32_t v2 = v1 + (int32_t)&g37; // 0x6dca
    g2 = v2;
    *(int32_t *)v2 = (int32_t)&g73;
    function_da20(g2);
    *(int32_t *)v1 = (int32_t)&g71;
    return 0;
}

// Address range: 0x6dfc - 0x6dfd
int32_t function_6dfc(void) {
    // 0x6dfc
    return g2;
}

// Address range: 0x6e10 - 0x6e1a
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED1Ev(int32_t a1) {
    // 0x6e10
    return function_dc30(a1 - (int32_t)&g37);
}

// Address range: 0x6e20 - 0x6e67
// From class:    N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::thread_resource_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g54;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g55;
    *(int32_t *)v1 = (int32_t)&g51;
    return 0;
}

// Address range: 0x6e6c - 0x6e6d
int32_t function_6e6c(int32_t a1) {
    // 0x6e6c
    return g2;
}

// Address range: 0x6e80 - 0x6e8a
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t a1) {
    // 0x6e80
    return _Z15ReadCompactSizeI11CDataStreamEyRT_(a1 - (int32_t)&g37);
}

// Address range: 0x6e90 - 0x6ed7
// From class:    N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t * a1) {
    // 0x6e90
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g61;
    int32_t v1 = g4 + (int32_t)&g37; // 0x6eaa
    *(int32_t *)v1 = (int32_t)&g62;
    function_db00(v1);
    *(int32_t *)g4 = (int32_t)&g51;
    return 0;
}

// Address range: 0x6edc - 0x6edd
int32_t function_6edc(void) {
    // 0x6edc
    return g2;
}

// Address range: 0x6ef0 - 0x6efa
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED1Ev(int32_t a1) {
    // 0x6ef0
    return 0;
}

// Address range: 0x6f00 - 0x6f47
// From class:    N5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::gregorian::bad_year>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g78;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g79;
    *(int32_t *)v1 = (int32_t)&g77;
    return 0;
}

// Address range: 0x6f4c - 0x6f4d
int32_t function_6f4c(int32_t a1) {
    // 0x6f4c
    return g2;
}

// Address range: 0x6f60 - 0x6f6a
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED1Ev(int32_t a1) {
    // 0x6f60
    return function_ded0(a1 - (int32_t)&g37);
}

// Address range: 0x6f70 - 0x6fb7
// From class:    N5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::gregorian::bad_month>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED1Ev(int32_t * a1) {
    // 0x6f70
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g84;
    int32_t v1 = g4 + (int32_t)&g37; // 0x6f8a
    g2 = v1;
    *(int32_t *)v1 = (int32_t)&g85;
    function_dbe0(g2);
    *(int32_t *)g4 = (int32_t)&g83;
    return 0;
}

// Address range: 0x6fbc - 0x6fbd
int32_t function_6fbc(void) {
    // 0x6fbc
    return g2;
}

// Address range: 0x6fd0 - 0x6fd7
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev((int32_t *)(a1 - (int32_t)&g16)); // 0x6fd5
    return result;
}

// Address range: 0x6fe0 - 0x6fe7
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev((int32_t *)(a1 - (int32_t)&g14)); // 0x6fe5
    return result;
}

// Address range: 0x6ff0 - 0x701e
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g16) = (int32_t)&g56;
    *(int32_t *)v1 = (int32_t)&g90;
    *(int32_t *)(v1 + (int32_t)&g14) = (int32_t)&g91;
    return v1 + (int32_t)&g14;
}

// Address range: 0x7050 - 0x705a
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED1Ev(int32_t a1) {
    // 0x7050
    return function_e0c0(a1 - (int32_t)&g18);
}

// Address range: 0x7060 - 0x706a
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED1Ev(int32_t a1) {
    // 0x7060
    return function_e0c0(a1 - (int32_t)&g37);
}

// Address range: 0x7070 - 0x70b8
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    g2 = v1 + (int32_t)&g37;
    *(int32_t *)v1 = (int32_t)&g66;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g67;
    function_dce0(g2);
    return 0;
}

// Address range: 0x70bd - 0x70be
int32_t function_70bd(void) {
    // 0x70bd
    return g2;
}

// Address range: 0x70d0 - 0x70d7
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorISt13runtime_errorED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail19error_info_injectorISt13runtime_errorED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x70d5
    return result;
}

// Address range: 0x70e0 - 0x710f
// From class:    N5boost16exception_detail19error_info_injectorISt13runtime_errorEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<std::runtime_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorISt13runtime_errorED0Ev(int32_t * a1) {
    // 0x70e0
    *a1 = (int32_t)&g66;
    int32_t result = (int32_t)a1 + (int32_t)&g37; // 0x70fa
    *(int32_t *)result = (int32_t)&g67;
    return result;
}

// Address range: 0x7140 - 0x7147
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED0Ev((int32_t *)(a1 - (int32_t)&g18)); // 0x7145
    return result;
}

// Address range: 0x7150 - 0x7157
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x7155
    return result;
}

// Address range: 0x7160 - 0x7196
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    g2 = v1 + (int32_t)&g37;
    *(int32_t *)v1 = (int32_t)&g66;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g67;
    return function_ddb0(g2);
}

// Address range: 0x71c0 - 0x71c7
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10bad_alloc_D0Ev((int32_t *)(a1 - (int32_t)&g14)); // 0x71c5
    return result;
}

// Address range: 0x71d0 - 0x71f7
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::bad_alloc_::~bad_alloc_()
int32_t _ZN5boost16exception_detail10bad_alloc_D0Ev(int32_t * a1) {
    // 0x71d0
    *a1 = (int32_t)&g90;
    int32_t result = (int32_t)a1 + (int32_t)&g14; // 0x71ea
    *(int32_t *)result = (int32_t)&g91;
    return result;
}

// Address range: 0x7230 - 0x723a
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1) {
    // 0x7230
    return 0;
}

// Address range: 0x7240 - 0x724a
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1) {
    // 0x7240
    return 0;
}

// Address range: 0x7250 - 0x727e
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g16) = (int32_t)&g56;
    *(int32_t *)v1 = (int32_t)&g90;
    *(int32_t *)(v1 + (int32_t)&g14) = (int32_t)&g91;
    return v1 + (int32_t)&g14;
}

// Address range: 0x7282 - 0x729d
int32_t function_7282(int32_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x651c2444); // 0x7282
    *v2 = *v2 - 1;
    int32_t result = 0x2074c085; // 0x7288
    g2 = result;
    if (result != 0) {
        // 0x729d
        return result;
    }
    // 0x7290
    g4 = a1;
    return function_dec0(v1);
}

// Address range: 0x72b0 - 0x72b7
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED0Ev((int32_t *)(a1 - (int32_t)&g18)); // 0x72b5
    return result;
}

// Address range: 0x72c0 - 0x72c7
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x72c5
    return result;
}

// Address range: 0x72d0 - 0x730c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_day_of_month> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g4 = v1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    g2 = g4 + (int32_t)&g37;
    *(int32_t *)g4 = (int32_t)&g72;
    *(int32_t *)(g4 + (int32_t)&g37) = (int32_t)&g73;
    int32_t result = function_df20(g2); // eax
    *(int32_t *)g4 = (int32_t)&g71;
    return result;
}

// Address range: 0x7330 - 0x733a
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED1Ev(int32_t a1) {
    // 0x7330
    return 0;
}

// Address range: 0x7340 - 0x734a
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED1Ev(int32_t a1) {
    // 0x7340
    return 0;
}

// Address range: 0x7350 - 0x739e
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_day_of_month> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g4 = v1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    g2 = g4 + (int32_t)&g37;
    *(int32_t *)g4 = (int32_t)&g72;
    *(int32_t *)(g4 + (int32_t)&g37) = (int32_t)&g73;
    function_dfc0(g2);
    *(int32_t *)g4 = (int32_t)&g71;
    return 0;
}

// Address range: 0x73a3 - 0x73a4
int32_t function_73a3(void) {
    // 0x73a3
    return g2;
}

// Address range: 0x73b0 - 0x73b7
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x73b5
    return result;
}

// Address range: 0x73c0 - 0x73f5
// From class:    N5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::gregorian::bad_day_of_month>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g72;
    int32_t result = v1 + (int32_t)&g37; // 0x73da
    *(int32_t *)result = (int32_t)&g73;
    *(int32_t *)v1 = (int32_t)&g71;
    return result;
}

// Address range: 0x7420 - 0x7427
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x7425
    return result;
}

// Address range: 0x7430 - 0x7465
// From class:    N5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::gregorian::bad_month>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g84;
    int32_t v2 = v1 + (int32_t)&g37; // 0x744a
    g2 = v2;
    *(int32_t *)v2 = (int32_t)&g85;
    int32_t result = function_e090(g2); // eax
    *(int32_t *)v1 = (int32_t)&g83;
    return result;
}

// Address range: 0x7490 - 0x749a
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED1Ev(int32_t a1) {
    // 0x7490
    return function_e940(a1 - (int32_t)&g18);
}

// Address range: 0x74a0 - 0x74aa
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED1Ev(int32_t a1) {
    // 0x74a0
    return function_e940(a1 - (int32_t)&g37);
}

// Address range: 0x74b0 - 0x74fe
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_month> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    *(int32_t *)v1 = (int32_t)&g84;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g85;
    *(int32_t *)v1 = (int32_t)&g83;
    return 0;
}

// Address range: 0x7503 - 0x7504
int32_t function_7503(int32_t a1) {
    // 0x7503
    return g2;
}

// Address range: 0x7510 - 0x7517
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED0Ev((int32_t *)(a1 - (int32_t)&g18)); // 0x7515
    return result;
}

// Address range: 0x7520 - 0x7527
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x7525
    return result;
}

// Address range: 0x7530 - 0x756c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_month> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    g2 = v1 + (int32_t)&g37;
    *(int32_t *)v1 = (int32_t)&g84;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g85;
    int32_t result = function_e180(g2); // eax
    *(int32_t *)v1 = (int32_t)&g83;
    return result;
}

// Address range: 0x7590 - 0x759a
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED1Ev(int32_t a1) {
    // 0x7590
    return function_eb40(a1 - (int32_t)&g18);
}

// Address range: 0x75a0 - 0x75aa
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED1Ev(int32_t a1) {
    // 0x75a0
    return function_eb40(a1 - (int32_t)&g37);
}

// Address range: 0x75b0 - 0x75fe
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_year> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    g2 = v1 + (int32_t)&g37;
    *(int32_t *)v1 = (int32_t)&g78;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g79;
    function_e220(g2);
    *(int32_t *)g4 = (int32_t)&g77;
    return 0;
}

// Address range: 0x7603 - 0x7604
int32_t function_7603(void) {
    // 0x7603
    return g2;
}

// Address range: 0x7610 - 0x7617
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x7615
    return result;
}

// Address range: 0x7620 - 0x7655
// From class:    N5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::gregorian::bad_year>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g78;
    int32_t result = v1 + (int32_t)&g37; // 0x763a
    *(int32_t *)result = (int32_t)&g79;
    *(int32_t *)v1 = (int32_t)&g77;
    return result;
}

// Address range: 0x7680 - 0x7687
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED0Ev((int32_t *)(a1 - (int32_t)&g18)); // 0x7685
    return result;
}

// Address range: 0x7690 - 0x7697
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x7695
    return result;
}

// Address range: 0x76a0 - 0x76dc
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_year> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g4 = v1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    int32_t v2 = g4; // 0x76bb
    g2 = v2 + (int32_t)&g37;
    *(int32_t *)v2 = (int32_t)&g78;
    *(int32_t *)(g4 + (int32_t)&g37) = (int32_t)&g79;
    int32_t result = function_e2f0(g2); // eax
    *(int32_t *)g4 = (int32_t)&g77;
    return result;
}

// Address range: 0x7700 - 0x7707
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x7705
    return result;
}

// Address range: 0x7710 - 0x7745
// From class:    N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t * a1) {
    // 0x7710
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g61;
    int32_t v1 = g4 + (int32_t)&g37; // 0x772a
    g2 = v1;
    *(int32_t *)v1 = (int32_t)&g62;
    int32_t result = function_e370((int16_t)g2); // eax
    *(int32_t *)g4 = (int32_t)&g51;
    return result;
}

// Address range: 0x7770 - 0x777a
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1) {
    // 0x7770
    return 0;
}

// Address range: 0x7780 - 0x778a
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1) {
    // 0x7780
    return 0;
}

// Address range: 0x7790 - 0x77de
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    *(int32_t *)v1 = (int32_t)&g61;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g62;
    _ZN8CAddrMan11UnserializeI11CDataStreamEEvRT_ii(v1 + (int32_t)&g37);
    *(int32_t *)g4 = (int32_t)&g51;
    return 0;
}

// Address range: 0x77e3 - 0x77e4
int32_t function_77e3(void) {
    // 0x77e3
    return g2;
}

// Address range: 0x77f0 - 0x77f7
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev((int32_t *)(a1 - (int32_t)&g18)); // 0x77f5
    return result;
}

// Address range: 0x7800 - 0x7807
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x7805
    return result;
}

// Address range: 0x7810 - 0x784c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    *(int32_t *)v1 = (int32_t)&g61;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g62;
    *(int32_t *)v1 = (int32_t)&g51;
    return v1 + (int32_t)&g37;
}

// Address range: 0x7870 - 0x787a
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t a1) {
    // 0x7870
    return function_f100(a1 - (int32_t)&g18);
}

// Address range: 0x7880 - 0x788a
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t a1) {
    // 0x7880
    return function_f100(a1 - (int32_t)&g37);
}

// Address range: 0x7890 - 0x78de
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::thread_resource_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    *(int32_t *)v1 = (int32_t)&g54;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g55;
    *(int32_t *)v1 = (int32_t)&g51;
    return 0;
}

// Address range: 0x78e3 - 0x78e4
int32_t function_78e3(int32_t a1) {
    // 0x78e3
    return g2;
}

// Address range: 0x78f0 - 0x78f7
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x78f5
    return result;
}

// Address range: 0x7900 - 0x7935
// From class:    N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::thread_resource_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g54;
    int32_t result = v1 + (int32_t)&g37; // 0x791a
    *(int32_t *)result = (int32_t)&g55;
    *(int32_t *)v1 = (int32_t)&g51;
    return result;
}

// Address range: 0x7960 - 0x7967
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev((int32_t *)(a1 - (int32_t)&g18)); // 0x7965
    return result;
}

// Address range: 0x7970 - 0x7977
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev((int32_t *)(a1 - (int32_t)&g37)); // 0x7975
    return result;
}

// Address range: 0x7980 - 0x79bc
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::thread_resource_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g18) = (int32_t)&g56;
    *(int32_t *)v1 = (int32_t)&g54;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g55;
    *(int32_t *)v1 = (int32_t)&g51;
    return v1 + (int32_t)&g37;
}

// Address range: 0x79e0 - 0x7a11
// Demangled:     boost::exception::~exception()
int32_t _ZN5boost9exceptionD0Ev(int32_t a1) {
    // 0x79e0
    return 0;
}

// Address range: 0x7a16 - 0x7a17
int32_t function_7a16(int32_t a1) {
    // 0x7a16
    return g2;
}

// Address range: 0x7a20 - 0x7a55
// Demangled:     boost::pthread::pthread_mutex_scoped_lock::~pthread_mutex_scoped_lock()
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockD1Ev(int32_t * a1) {
    // 0x7a20
    if (*(char *)((int32_t)a1 + (int32_t)&g29) != 0) {
        // 0x7a50
        return *a1;
    }
    // 0x7a3a
    return 0;
}

// Address range: 0x7a59 - 0x7a64
int32_t function_7a59(void) {
    // 0x7a59
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x39f48a40); // 0x7a59
    *v2 = *v2 + 1;
    return 0;
}

// Address range: 0x7a64 - 0x7a65
int32_t function_7a64(int32_t a1) {
    // 0x7a64
    return g2;
}

// Address range: 0x7a70 - 0x7aa2
// Demangled:     boost::filesystem3::operator/(boost::filesystem3::path const &, boost::filesystem3::path const &)
int32_t _ZN5boost11filesystem3dvERKNS0_4pathES3_(int32_t a1, int32_t result, int32_t a3) {
    // 0x7a70
    return result;
}

// Address range: 0x7ac6 - 0x7ae8
int32_t function_7ac6(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x24548bf0; // 0x7ac6
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x7acc
    int32_t result = (v2 - (int32_t)(char)&g33 + (int32_t)false) % 256 | v2 & -256; // 0x7acc
    // 0x7ae8
    return result;
    // 0x7ad6
    return result;
}

// Address range: 0x7b00 - 0x7b27
// Demangled:     CDataStream::~CDataStream()
int32_t _ZN11CDataStreamD1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0x7b15
    int32_t v2 = *(int32_t *)((int32_t)a1 + (int32_t)&g37); // 0x7b17
    g2 = v2;
    if (v1 == 0) {
        // bb
        v2 = function_7b48(0x2074c085);
        // branch -> 0x7b1e
    }
    // 0x7b1e
    return v2 - v1;
}

// Address range: 0x7b45 - 0x7b48
int32_t function_7b45(void) {
    // 0x7b45
    return 0;
}

// Address range: 0x7b48 - 0x7b60
int32_t function_7b48(int32_t a1) {
    // 0x7b48
    if (a1 != 0x2074c085) {
        // 0x7b5a
        return g2;
    }
    // 0x7b55
    return g2;
}

// Address range: 0x7b70 - 0x7be5
// Demangled:     CDataStream::read(char *, int)
int32_t _ZN11CDataStream4readEPci(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    g2 = 0;
    if (a3 < 0) {
        // bb
        function_7c58(0x2074c085);
        // branch -> 0x7ba3
    }
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g47); // 0x7ba3
    g5 = v2;
    g2 = a3;
    uint32_t v3 = v2 + a3; // 0x7bab
    int32_t v4 = *(int32_t *)v1; // 0x7bb2
    g6 = v4;
    uint32_t v5 = *(int32_t *)(v1 + (int32_t)&g29) - v4; // 0x7bb4
    bool v6 = v3 == v5; // 0x7bbc
    bool v7 = false; // 0x7bbc
    if (v3 < v5) {
        // bb116
        g2 = function_7c38(v3);
        v6 = g97;
        v7 = g1;
        // branch -> 0x7bbc
    }
    // 0x7bbc
    if (v6 || v7) {
        // bb117
        g2 = function_7bf6();
        // branch -> 0x7bbe
    }
    int16_t * v8 = (int16_t *)(v1 + 16); // 0x7bbe
    int32_t v9 = (int32_t)*v8 | 4; // 0x7bc6
    *v8 = (int16_t)v9;
    int32_t result; // 0x7be2
    if (((int32_t)*(int16_t *)(v1 + 18) & v9) != 0) {
        // bb118
        result = function_7c7c();
        // branch -> 0x7bd6
    } else {
        // 0x7bbe
        result = g2;
        // branch -> 0x7bd6
    }
    // 0x7bd6
    return result;
}

// Address range: 0x7bf6 - 0x7c03
int32_t function_7bf6(void) {
    // 0x7bf6
    return g2;
}

// Address range: 0x7c07 - 0x7c37
int32_t function_7c07(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = 0; // ebx
    int32_t * v1 = (int32_t *)(result + 0xc43c703); // 0x7c07
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    *(char *)v2 = (char)v2 + *(char *)&g2;
    *(char *)v2 = (char)v2 + *(char *)&g2;
    *(int32_t *)(result + (int32_t)&g29) = v2;
    g2 = result;
    if (a1 != 0x2074c085) {
        // bb
        result = function_7c53();
        // branch -> 0x7c23
    }
    // 0x7c23
    return result;
}

// Address range: 0x7c38 - 0x7c45
int32_t function_7c38(int32_t a1) {
    uint32_t v1 = g5; // 0x7c38
    int32_t v2 = g6 + v1; // 0x7c38
    g1 = v2 < v1;
    g97 = v2 == 0;
    g5 = v2;
    return g2;
}

// Address range: 0x7c4a - 0x7c53
int32_t function_7c4a(int32_t a1) {
    // 0x7c4a
    *(int32_t *)(int32_t)&g47 = a1;
    return 0;
}

// Address range: 0x7c53 - 0x7c54
int32_t function_7c53(void) {
    // 0x7c53
    return g2;
}

// Address range: 0x7c58 - 0x7c77
int32_t function_7c58(int32_t a1) {
    // 0x7c58
    return g2;
}

// Address range: 0x7c7c - 0x7c87
int32_t function_7c7c(void) {
    // 0x7c7c
    return g2;
}

// Address range: 0x7cd3 - 0x7cd4
int32_t function_7cd3(void) {
    // 0x7cd3
    return 0;
}

// Address range: 0x7cf0 - 0x7d07
// Demangled:     AnnotatedMixin<boost::recursive_mutex>::~AnnotatedMixin()
int32_t _ZN14AnnotatedMixinIN5boost15recursive_mutexEED1Ev(void) {
    // 0x7cf0
    return 0;
}

// Address range: 0x7d0b - 0x7d12
int32_t function_7d0b(void) {
    // 0x7d0b
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x7cde8a40); // 0x7d0b
    *v2 = *v2 + 1;
    return 0;
}

// Address range: 0x7d1a - 0x7d31
int32_t function_7d1a(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x74e38a40; // 0x7d1a
    *v1 = *v1 + 1;
    return 0x2074c085;
}

// Address range: 0x7d31 - 0x7d36
int32_t function_7d31(void) {
    // 0x7d31
    return 0;
}

// Address range: 0x7d60 - 0x7d7e
// Demangled:     std::pair<std::vector<unsigned char, std::allocator<unsigned char> >, std::vector<unsigned char, std::allocator<unsigned char> > >::~pair()
int32_t _ZNSt4pairISt6vectorIhSaIhEES2_ED1Ev(int32_t a1) {
    // 0x7d60
    g4 = a1;
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g47); // 0x7d74
    int32_t result = v1; // 0x7d7b
    if (v1 == 0) {
        // bb
        result = function_7d83(0x2074c085);
        // branch -> 0x7d7b
    }
    // 0x7d7b
    return result;
}

// Address range: 0x7d83 - 0x7d9e
int32_t function_7d83(int32_t a1) {
    // 0x7d83
    g2 = g4;
    int32_t result = g4; // 0x7d9d2
    if (g4 == 0) {
        int32_t v1 = function_7da8(); // 0x7d87
        g2 = v1;
        result = v1;
        // branch -> 0x7d89
    }
    if (a1 != 0x2074c085) {
        // bb6
        result = function_7dba();
        // branch -> 0x7d96
    }
    // 0x7d96
    return result;
}

// Address range: 0x7da8 - 0x7dba
int32_t function_7da8(void) {
    // 0x7da8
    int32_t v1;
    int32_t v2 = v1 ^ 0x2074c085; // 0x7dac
    g2 = v2;
    int32_t result = v2; // 0x7db9
    if (v2 != 0) {
        // bb
        result = function_7dba();
        // branch -> 0x7db5
    }
    // 0x7db5
    return result;
}

// Address range: 0x7dba - 0x7dc0
int32_t function_7dba(void) {
    // 0x7dba
    return g2;
}

// Address range: 0x7dd0 - 0x7e10
// Demangled:     boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr()
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0x7de4
    if (v1 == 0) {
        // 0x7df6
        return 0;
    }
    // 0x7dea
    if ((char)v1 != 0) {
        // 0x7e08
        *a1 = 0;
        // branch -> 0x7df6
    }
    // 0x7df6
    return 0;
}

// Address range: 0x7e20 - 0x7f24
// Demangled:     boost::exception_detail::copy_boost_exception(boost::exception *, boost::exception const *)
int32_t _ZN5boost16exception_detail20copy_boost_exceptionEPNS_9exceptionEPKS1_(int32_t a1, int32_t a2) {
    // 0x7e20
    if (*(int32_t *)(a2 + (int32_t)&g29) != 0) {
        // 0x7e5a
        int32_t v1;
        if (v1 != 0) {
            // 0x7e79
            // branch -> 0x7e81
        }
        // 0x7e81
        // branch -> 0x7ea9
    }
    int32_t v2 = 0; // edi
    int32_t v3 = *(int32_t *)(a2 + (int32_t)&g47); // 0x7ea9
    *(int32_t *)(a1 + (int32_t)&g47) = v3;
    *(int32_t *)(a1 + 16) = *(int32_t *)(a2 + 16);
    int32_t v4 = *(int32_t *)(a2 + (int32_t)&g37); // 0x7eb5
    *(int32_t *)(a1 + (int32_t)&g37) = v4;
    int32_t v5 = *(int32_t *)(a1 + (int32_t)&g29); // 0x7ebb
    if (v5 != 0) {
        // 0x7ec2
        *(int32_t *)g9 = v5;
        // branch -> 0x7eca
    }
    // 0x7eca
    *(int32_t *)(a1 + (int32_t)&g29) = v2;
    if (v2 != 0) {
        // 0x7ed1
        *(int32_t *)g9 = v2;
        // branch -> 0x7ed9
    }
    int32_t v6 = *(int32_t *)(g9 + (int32_t)&g14); // 0x7ed9
    if (v6 != 0) {
        // 0x7ee1
        *(int32_t *)g9 = v6;
        // branch -> 0x7ee9
    }
    int32_t result = *(int32_t *)(g9 + (int32_t)&g18) ^ 0x2074c085; // 0x7eed
    if (result != 0) {
        // 0x7f24
        return result;
    }
    // 0x7ef6
    return result;
}

// Address range: 0x7f2a - 0x7f2b
int32_t function_7f2a(void) {
    // 0x7f2a
    return 0;
}

// Address range: 0x7f33 - 0x7f34
int32_t function_7f33(void) {
    // 0x7f33
    return g2;
}

// Address range: 0x7f47 - 0x7f4b
int32_t function_7f47(void) {
    // 0x7f47
    return function_7f33();
}

// Address range: 0x7f50 - 0x7f6c
// Demangled:     boost::exception_detail::error_info_injector<std::runtime_error>::error_info_injector(boost::exception_detail::error_info_injector<std::runtime_error> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorISt13runtime_errorEC1ERKS3_(int32_t a1, int32_t a2) {
    // 0x7f50
    return a2 + (int32_t)&g29;
}

// Address range: 0x7f80 - 0x7fcc
int32_t function_7f80(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x43c70c46); // 0x7f80
    *v2 = *v2 - 1;
    int32_t v3 = 0; // eax
    char * v4 = (char *)(v3 - 0x7affff06); // 0x7f86
    int32_t v5 = 0; // ecx
    *v4 = (char)v5 | *v4;
    char * v6 = (char *)(v5 + 0x52ff2404); // 0x7f93
    *v6 = *v6 + (char)v5;
    int32_t v7 = v3 | 139; // 0x7f99
    uint32_t v8 = v1; // 0x7f9c
    unsigned char v9 = (char)(v8 >> (int32_t)&g37); // 0x7f9c
    unsigned char v10 = v9 + (char)v7; // 0x7f9c
    char * v11 = (char *)g9; // 0x7f9f
    *v11 = (char)v5 | *v11;
    char * v12 = (char *)(v5 + 0x468b1043); // 0x7fa3
    unsigned char v13 = *v12; // 0x7fa3
    unsigned char v14 = v13 + (char)v5; // 0x7fa3
    *v12 = v14;
    unsigned char v15 = (char)v7; // 0x7fa9
    bool v16 = v14 < v13; // 0x7fa9
    unsigned char v17 = v15 - 119 + (char)v16; // 0x7fa9
    bool v18 = v16 ? v17 <= v15 : v15 > 118; // 0x7fa9
    int32_t v19 = ((int32_t)v10 << (int32_t)&g37 | v8 & -0xff01) + 1; // 0x7fab
    uint32_t v20 = v19 + 1; // 0x7fab
    unsigned char v21 = v17 - 117 + (char)v18; // 0x7fac
    bool v22 = v18 ? v21 <= v17 : v17 > 116; // 0x7fac
    int32_t v23 = (int32_t)v21 | v7 & -256; // 0x7fac
    v1 = 256 * (int32_t)((char)(v20 >> (int32_t)&g37) - v21 + (char)v22) | v20 & -0xff01;
    char * v24 = (char *)v23; // 0x7fb4
    *v24 = *v24 + v21;
    *(int32_t *)(v1 + (int32_t)&g16) = v23;
    int32_t result = a1 ^ 0x2074c085; // 0x7fbd
    if (result != 0) {
        // 0x7fcc
        return result;
    }
    // 0x7fc6
    return result;
}

// Address range: 0x8000 - 0x8007
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE7rethrowEv(a1 - (int32_t)&g18); // 0x8005
    return result;
}

// Address range: 0x8010 - 0x802c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::runtime_error> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEE7rethrowEv(int32_t a1) {
    // 0x8010
    return 0;
}

// Address range: 0x8030 - 0x8037
int32_t function_8030(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb8c; // 0x8030
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x8080 - 0x809c
// Demangled:     void boost::throw_exception<std::runtime_error>(std::runtime_error const &)
int32_t _ZN5boost15throw_exceptionISt13runtime_errorEEvRKT_(int32_t a1) {
    // 0x8080
    return 0;
}

// Address range: 0x8153 - 0x8154
int32_t function_8153(void) {
    // 0x8153
    return g2;
}

// Address range: 0x8162 - 0x818e
int32_t function_8162(void) {
    // 0x8162
    g4 = 1;
    int32_t v1 = 0; // eax
    unsigned char v2 = (char)v1 + 64 + (char)false; // 0x8165
    int32_t v3 = (int32_t)v2 | v1 & -256; // 0x8165
    g2 = v3;
    char * v4 = (char *)v3; // 0x8168
    *v4 = *v4 + v2;
    int32_t v5 = g2; // 0x816a
    function_edd0(g4);
    g2 = v5;
    function_edd0(0);
    g2 = v5;
    return function_8153();
}

// Address range: 0x818e - 0x8190
int32_t function_818e(void) {
    // 0x818e
    return 0;
}

// Address range: 0x8190 - 0x81b6
// Demangled:     boost::date_time::c_time::gmtime(long const *, tm *)
int32_t _ZN5boost9date_time6c_time6gmtimeEPKlP2tm(int32_t result, int32_t a2) {
    // 0x8190
    return result;
}

// Address range: 0x81ba - 0x81d8
int32_t function_81ba(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)-0x74e18b40; // 0x81ba
    *v1 = *v1 + 1;
    // 0x81d8
    // 0x81cc
    return 0;
}

// Address range: 0x821c - 0x8223
int32_t function_821c(void) {
    int32_t * v1 = (int32_t *)-0x76e3dbbc; // 0x821c
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x8223 - 0x8224
int32_t function_8223(void) {
    // 0x8223
    return g2;
}

// Address range: 0x8233 - 0x8237
int32_t function_8233(void) {
    // 0x8233
    return function_8223();
}

// Address range: 0x8240 - 0x825b
// Demangled:     std::logic_error::logic_error(std::logic_error const &)
int32_t _ZNSt11logic_errorC1ERKS_(int32_t a1, int32_t a2) {
    // 0x8240
    return a2 + (int32_t)&g29;
}

// Address range: 0x826f - 0x8282
int32_t function_826f(int32_t a1) {
    int32_t * v1 = (int32_t *)0x652c2444; // 0x826f
    *v1 = *v1 - 1;
    int32_t result = 0x2074c085; // 0x8275
    if (result != 0) {
        // 0x8282
        return result;
    }
    // 0x827d
    return result;
}

// Address range: 0x82a0 - 0x82bc
// Demangled:     boost::exception_detail::error_info_injector<boost::gregorian::bad_day_of_month>::error_info_injector(boost::exception_detail::error_info_injector<boost::gregorian::bad_day_of_month> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian16bad_day_of_monthEEC1ERKS4_(int32_t a1, int32_t a2) {
    // 0x82a0
    return a2 + (int32_t)&g29;
}

// Address range: 0x82d0 - 0x8322
int32_t function_82d0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x3c70c46); // 0x82d0
    *v2 = *v2 - 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + *(char *)&g2;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g53;
    *(int32_t *)(v1 + (int32_t)&g47) = v3;
    if (v3 != 0) {
        // 0x82e8
        // branch -> 0x82f0
    }
    int32_t v4 = 0; // esi
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g73;
    *(int32_t *)(v1 + 16) = *(int32_t *)(v4 + 16);
    int32_t v5 = *(int32_t *)(v4 + (int32_t)&g14); // 0x82fd
    *(int32_t *)(v1 + (int32_t)&g14) = v5;
    int32_t v6 = *(int32_t *)(v4 + (int32_t)&g16); // 0x8303
    *(int32_t *)v1 = (int32_t)&g72;
    *(int32_t *)(v1 + (int32_t)&g16) = v6;
    int32_t result = a1 ^ 0x2074c085; // 0x8313
    if (result != 0) {
        // 0x8322
        return result;
    }
    // 0x831c
    return result;
}

// Address range: 0x8350 - 0x8357
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE7rethrowEv(a1 - (int32_t)&g18); // 0x8355
    return result;
}

// Address range: 0x8360 - 0x837c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_day_of_month> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian16bad_day_of_monthEEEE7rethrowEv(int32_t a1) {
    // 0x8360
    return 0;
}

// Address range: 0x8380 - 0x8387
int32_t function_8380(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb8c; // 0x8380
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x83d0 - 0x83ec
// Demangled:     void boost::throw_exception<boost::gregorian::bad_day_of_month>(boost::gregorian::bad_day_of_month const &)
int32_t _ZN5boost15throw_exceptionINS_9gregorian16bad_day_of_monthEEEvRKT_(int32_t a1) {
    // 0x83d0
    return 0;
}

// Address range: 0x83fb - 0x83fe
int32_t function_83fb(void) {
    // 0x83fb
    return 0;
}

// Address range: 0x8488 - 0x8489
int32_t function_8488(int32_t a1) {
    // 0x8488
    return g2;
}

// Address range: 0x8497 - 0x84c3
int32_t function_8497(void) {
    int32_t v1 = 0; // eax
    unsigned char v2 = (char)v1 + 64 + (char)false; // 0x849a
    int32_t v3 = (int32_t)v2 | v1 & -256; // 0x849a
    g2 = v3;
    char * v4 = (char *)v3; // 0x849d
    *v4 = *v4 + v2;
    return function_8488(0);
}

// Address range: 0x84c3 - 0x84c5
int32_t function_84c3(void) {
    // 0x84c3
    return 0;
}

// Address range: 0x84d0 - 0x8540
// From class:    N5boost21thread_resource_errorE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::thread_resource_error>::error_info_injector(boost::exception_detail::error_info_injector<boost::thread_resource_error> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEC1ERKS3_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1; // ebx
    int32_t v2 = *(int32_t *)(a2 + (int32_t)&g29); // 0x84e9
    *a1 = (int32_t)&g52;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g53;
    *(int32_t *)(v1 + (int32_t)&g29) = v2;
    int32_t v3 = *(int32_t *)(a2 + (int32_t)&g47); // 0x84fc
    *(int32_t *)(v1 + (int32_t)&g47) = v3;
    if (v3 != 0) {
        // 0x8506
        // branch -> 0x850e
    }
    // 0x850e
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g55;
    *(int32_t *)(v1 + 16) = *(int32_t *)(a2 + 16);
    int32_t v4 = *(int32_t *)(a2 + (int32_t)&g14); // 0x851b
    *(int32_t *)(v1 + (int32_t)&g14) = v4;
    int32_t v5 = *(int32_t *)(a2 + (int32_t)&g16); // 0x8521
    *(int32_t *)v1 = (int32_t)&g54;
    *(int32_t *)(v1 + (int32_t)&g16) = v5;
    return 0;
}

// Address range: 0x8560 - 0x8567
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv(a1 - (int32_t)&g18); // 0x8565
    return result;
}

// Address range: 0x8570 - 0x858c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::thread_resource_error> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv(int32_t a1) {
    // 0x8570
    return 0;
}

// Address range: 0x8590 - 0x8597
int32_t function_8590(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb8c; // 0x8590
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x85e0 - 0x85fc
// Demangled:     void boost::throw_exception<boost::thread_resource_error>(boost::thread_resource_error const &)
int32_t _ZN5boost15throw_exceptionINS_21thread_resource_errorEEEvRKT_(int32_t a1) {
    // 0x85e0
    return 0;
}

// Address range: 0x8624 - 0x862b
int32_t function_8624(void) {
    int32_t result = 0; // eax
    char * v1 = (char *)(result - 0x76ffff06); // 0x8624
    *v1 = (char)0 & *v1;
    return result;
}

// Address range: 0x8691 - 0x8692
int32_t function_8691(void) {
    // 0x8691
    return g2;
}

// Address range: 0x86b0 - 0x86ca
int32_t function_86b0(void) {
    int32_t v1 = 0; // eax
    unsigned char v2 = (char)v1 + 64 + (char)false; // 0x86b3
    int32_t v3 = (int32_t)v2 | v1 & -256; // 0x86b3
    g2 = v3;
    char * v4 = (char *)v3; // 0x86b6
    *v4 = *v4 + v2;
    function_f400(1);
    return function_8691();
}

// Address range: 0x86d0 - 0x8740
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::error_info_injector(boost::exception_detail::error_info_injector<boost::lock_error> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEEC1ERKS3_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1; // ebx
    int32_t v2 = *(int32_t *)(a2 + (int32_t)&g29); // 0x86e9
    *a1 = (int32_t)&g60;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g53;
    *(int32_t *)(v1 + (int32_t)&g29) = v2;
    int32_t v3 = *(int32_t *)(a2 + (int32_t)&g47); // 0x86fc
    *(int32_t *)(v1 + (int32_t)&g47) = v3;
    if (v3 != 0) {
        // 0x8706
        // branch -> 0x870e
    }
    // 0x870e
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g62;
    *(int32_t *)(v1 + 16) = *(int32_t *)(a2 + 16);
    int32_t v4 = *(int32_t *)(a2 + (int32_t)&g14); // 0x871b
    *(int32_t *)(v1 + (int32_t)&g14) = v4;
    int32_t v5 = *(int32_t *)(a2 + (int32_t)&g16); // 0x8721
    *(int32_t *)v1 = (int32_t)&g61;
    *(int32_t *)(v1 + (int32_t)&g16) = v5;
    return 0;
}

// Address range: 0x8760 - 0x8767
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(a1 - (int32_t)&g18); // 0x8765
    return result;
}

// Address range: 0x8770 - 0x878c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1) {
    // 0x8770
    return 0;
}

// Address range: 0x8790 - 0x8797
int32_t function_8790(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb8c; // 0x8790
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x87e0 - 0x87fc
// Demangled:     void boost::throw_exception<boost::lock_error>(boost::lock_error const &)
int32_t _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(int32_t a1) {
    // 0x87e0
    return 0;
}

// Address range: 0x882a - 0x882b
int32_t function_882a(void) {
    // 0x882a
    return 0;
}

// Address range: 0x8891 - 0x8892
int32_t function_8891(void) {
    // 0x8891
    return g2;
}

// Address range: 0x88b0 - 0x88ca
int32_t function_88b0(void) {
    int32_t v1 = 0; // eax
    unsigned char v2 = (char)v1 + 64 + (char)false; // 0x88b3
    int32_t v3 = (int32_t)v2 | v1 & -256; // 0x88b3
    g2 = v3;
    char * v4 = (char *)v3; // 0x88b6
    *v4 = *v4 + v2;
    _ZZN5boost11filesystem311path_traits7convertEPKcS3_RSsRKSt7codecvtIwc11__mbstate_tEE19__PRETTY_FUNCTION__(1);
    return function_8891();
}

// Address range: 0x88d0 - 0x88e4
// Demangled:     std::basic_stringbuf<char, std::char_traits<char>, std::allocator<char> >::~basic_stringbuf()
int32_t _ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev(int32_t a1) {
    // 0x88d0
    return 0;
}

// Address range: 0x8918 - 0x8919
int32_t function_8918(void) {
    // 0x8918
    return 0;
}

// Address range: 0x8920 - 0x8934
// Demangled:     std::basic_stringbuf<char, std::char_traits<char>, std::allocator<char> >::~basic_stringbuf()
int32_t _ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED0Ev(int32_t a1) {
    // 0x8920
    return 0;
}

// Address range: 0x8955 - 0x8970
int32_t function_8955(int32_t a1) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x8955
    *v1 = *v1 - 1;
    int32_t result = 0x2074c085; // 0x895b
    if (result == 0) {
        // 0x8963
        // branch -> 0x8970
    }
    // 0x8970
    return result;
}

// Address range: 0x8980 - 0x8a7a
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          constructor
int32_t _ZN5boost16exception_detail13get_bad_allocILi42EEENS_10shared_ptrIKNS0_10clone_baseEEEv(int32_t * a1) {
    int32_t v1 = (int32_t)a1; // ebx
    g2 = 0;
    int32_t v2 = (int32_t)&g90; // bp-56
    int32_t v3 = (int32_t)&g92; // bp-84
    g2 = function_107a0((int32_t)&v3, (int32_t)&v2);
    function_8ad8((int32_t)"boost::exception_ptr boost::exception_detail::get_bad_alloc() [with int Dummy = 42, boost::exception_ptr = boost::shared_ptr<const boost::exception_detail::clone_base>]", (int32_t)"/usr/include/boost/exception/detail/exception_ptr.hpp", 81);
    *(int32_t *)v1 = 0;
    *(int32_t *)(v1 + (int32_t)&g29) = (int32_t)&g12;
    *(int32_t *)&g13 = (int32_t)"N5boost6detail15sp_counted_baseE" + 1;
    int32_t v4; // bp-64
    return &v4;
}

// Address range: 0x8a7e - 0x8ad4
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
int32_t function_8a7e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)0x69e82434; // 0x8a7e
    *v1 = *v1 - 1;
    int32_t v2; // bp+72
    g2 = &v2;
    v2 = &g91;
    _ZZN5boost15recursive_mutexC1EvE19__PRETTY_FUNCTION__(0);
    int32_t result = 0; // ebx
    g2 = result;
    if (a1 != 0x2074c085) {
        // bb
        result = function_8ba4();
        // branch -> 0x8abe
    }
    // 0x8abe
    return result;
}

// Address range: 0x8ad8 - 0x8adf
int32_t function_8ad8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8ad8
    return g2;
}

// Address range: 0x8b9f - 0x8ba4
int32_t function_8b9f(void) {
    // 0x8b9f
    return 0;
}

// Address range: 0x8ba4 - 0x8ba5
int32_t function_8ba4(void) {
    // 0x8ba4
    return g2;
}

// Address range: 0x8bc4 - 0x8bc5
int32_t function_8bc4(void) {
    // 0x8bc4
    return 0;
}

// Address range: 0x8bcd - 0x8bce
int32_t function_8bcd(void) {
    // 0x8bcd
    return g2;
}

// Address range: 0x8be1 - 0x8be2
int32_t function_8be1(void) {
    // 0x8be1
    return g2;
}

// Address range: 0x8bf2 - 0x8bf3
int32_t function_8bf2(void) {
    // 0x8bf2
    return 0;
}

// Address range: 0x8bf8 - 0x8bfa
int32_t function_8bf8(void) {
    // 0x8bf8
    return function_8bcd();
}

// Address range: 0x8bfa - 0x8c02
int32_t function_8bfa(void) {
    // 0x8bfa
    return function_8bcd();
}

// Address range: 0x8c02 - 0x8c16
int32_t function_8c02(void) {
    // 0x8c02
    int32_t v1;
    g2 = _ZZN5boost11filesystem311path_traits7convertEPKcS3_RSsRKSt7codecvtIwc11__mbstate_tEE19__PRETTY_FUNCTION__(v1);
    return function_8be1();
}

// Address range: 0x8c20 - 0x8c7a
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::operator=(std::vector<unsigned char, std::allocator<unsigned char> > const &)
int32_t _ZNSt6vectorIhSaIhEEaSERKS1_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    g4 = v1;
    int32_t v2 = v1; // 0x8c50
    int32_t v3 = a2; // 0x8c4b
    if (v1 == a2) {
        // bb
        function_8c8a(0x2074c085);
        v2 = g4;
        v3 = g6;
        // branch -> 0x8c4b
    }
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g29); // 0x8c4b
    g7 = v4;
    int32_t v5 = *(int32_t *)v3; // 0x8c4e
    g3 = v5;
    int32_t v6 = *(int32_t *)v2; // 0x8c50
    g2 = v6;
    int32_t v7 = v4 - v5; // 0x8c57
    g8 = v7;
    int32_t v8 = v6; // 0x8c69
    if (v7 <= *(int32_t *)(v2 + (int32_t)&g37) - v6) {
        int32_t v9 = function_8cb8(); // 0x8c5d
        g2 = v9;
        v8 = v9;
        // branch -> 0x8c5f
    }
    // 0x8c5f
    g6 = v8;
    if (v7 != 0) {
        // bb112
        function_8d60(v7);
        // branch -> 0x8c71
    }
    int32_t v10 = *(int32_t *)g4; // 0x8c71
    int32_t result = v10; // 0x8c77
    if (v10 == 0) {
        // bb113
        result = function_8c7f();
        // branch -> 0x8c77
    }
    // 0x8c77
    return result;
}

// Address range: 0x8c7f - 0x8c8a
int32_t function_8c7f(void) {
    int32_t v1 = g6; // 0x8c7f
    int32_t result = g8 + v1; // eax
    *(int32_t *)g4 = v1;
    *(int32_t *)(g4 + (int32_t)&g37) = result;
    *(int32_t *)(g4 + (int32_t)&g29) = result;
    return result;
}

// Address range: 0x8c8a - 0x8cb1
int32_t function_8c8a(int32_t a1) {
    // 0x8c8a
    g2 = g4;
    int32_t result = g4; // 0x8cb0
    if (a1 != 0x2074c085) {
        // bb
        result = function_8d75();
        // branch -> 0x8c9d
    }
    // 0x8c9d
    return result;
}

// Address range: 0x8cb8 - 0x8cd8
int32_t function_8cb8(void) {
    int32_t v1 = *(int32_t *)(g4 + (int32_t)&g29); // 0x8cb8
    int32_t result = g2; // 0x8cbf
    uint32_t v2 = v1 - result; // 0x8cbf
    if (g8 > v2) {
        // bb
        result = function_8ce8(v1, v2);
        // branch -> 0x8cc9
    }
    // 0x8cc9
    return result;
}

// Address range: 0x8cdd - 0x8ce3
int32_t function_8cdd(void) {
    // 0x8cdd
    int32_t result;
    return result;
}

// Address range: 0x8ce8 - 0x8d3b
int32_t function_8ce8(int32_t a1, int32_t a2) {
    // 0x8ce8
    if (a2 != 0) {
        // 0x8d30
        return g2;
    }
    // 0x8cfa
    if (g7 != g3 + a2) {
        // 0x8d08
        return g8 + g4;
    }
    // 0x8d00
    return g8 + g2;
}

// Address range: 0x8d3f - 0x8d5c
int32_t function_8d3f(void) {
    int32_t result = 0; // ebx
    int32_t * v1 = (int32_t *)(result + 0xf8b0443); // 0x8d3f
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x8d60 - 0x8d6b
int32_t function_8d60(int32_t a1) {
    // 0x8d60
    return g2;
}

// Address range: 0x8d70 - 0x8d75
int32_t function_8d70(void) {
    // 0x8d70
    return 0;
}

// Address range: 0x8d75 - 0x8d76
int32_t function_8d75(void) {
    // 0x8d75
    return g2;
}

// Address range: 0x8d80 - 0x8da9
// Demangled:     std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >::~vector()
int32_t _ZNSt6vectorIS_IiSaIiEESaIS1_EED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g6 = v1;
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g29); // 0x8d96
    g8 = v2;
    int32_t v3 = *a1; // 0x8d99
    g4 = v3;
    int32_t v4 = v3; // 0x8da0
    if (v2 == v3) {
        // bb
        function_8db7(0x2074c085, 0, 0, 0);
        v4 = g4;
        // branch -> 0x8d9f
    }
    int32_t v5 = *(int32_t *)v4; // 0x8da0
    g2 = v5;
    int32_t result = v5; // 0x8da6
    if (v5 == 0) {
        // bb106
        result = function_8dae();
        // branch -> 0x8da6
    }
    // 0x8da6
    return result;
}

// Address range: 0x8dae - 0x8db7
int32_t function_8dae(void) {
    // 0x8dae
    return g2;
}

// Address range: 0x8db7 - 0x8dd2
int32_t function_8db7(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x8db7
    if (g4 == 0) {
        // bb
        function_8dd8();
        // branch -> 0x8dbb
    }
    int32_t v1 = a1 ^ 0x2074c085; // 0x8dbf
    g2 = v1;
    int32_t result = v1; // 0x8dd1
    if (v1 != 0) {
        // bb7
        result = function_8dec();
        // branch -> 0x8dc8
    }
    // 0x8dc8
    g4 = a2;
    g8 = a3;
    g6 = a4;
    return result;
}

// Address range: 0x8dd8 - 0x8dec
int32_t function_8dd8(void) {
    // 0x8dd8
    int32_t v1;
    int32_t v2 = v1 ^ 0x2074c085; // 0x8ddc
    g2 = v2;
    int32_t result = v2; // 0x8deb
    if (v2 != 0) {
        // bb
        result = function_8dec();
        // branch -> 0x8de5
    }
    // 0x8de5
    return result;
}

// Address range: 0x8dec - 0x8ded
int32_t function_8dec(void) {
    // 0x8dec
    return g2;
}

// Address range: 0x8e00 - 0x905a
// Demangled:     boost::date_time::counted_time_system<boost::date_time::counted_time_rep<boost::posix_time::millisec_posix_time_system_config> >::subtract_times(boost::date_time::counted_time_rep<boost::posix_time::millisec_posix_time_system_config> const &, boost::date_time::counted_time_rep<boost::posix_time::millisec_posix_time_system_config> const &)
int32_t _ZN5boost9date_time19counted_time_systemINS0_16counted_time_repINS_10posix_time33millisec_posix_time_system_configEEEE14subtract_timesERKS5_S8_(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t result = (int32_t)a1; // eax
    int32_t v1 = *(int32_t *)(a2 + (int32_t)&g29); // 0x8e28
    uint32_t v2 = *(int32_t *)a2; // 0x8e2b
    int32_t v3; // 0x8f40
    int32_t v4; // 0x8fdf
    int32_t v5; // 0x8fe1
    int32_t v6; // 0x9040
    int32_t v7; // 0x8ee1
    uint32_t v8; // 0x8fbc
    int32_t v9; // 0x8fbc
    int32_t v10; // 0x8fbe
    if ((v2 || v1 ^ -0x80000000) != 0) {
        int32_t v11 = v1 ^ 0x7fffffff; // 0x8e4f
        if ((v11 || -1 - v2) != 0) {
            int32_t v12 = *(int32_t *)(a3 + (int32_t)&g29); // 0x8e5f
            int32_t v13 = v2 ^ -2; // 0x8e62
            int32_t v14 = *(int32_t *)a3; // 0x8e67
            int32_t v15 = v14; // 0x8fa7
            int32_t v16 = v12; // 0x8f93
            int32_t v17; // 0x8f97
            if ((v13 || v11) != 0) {
                // 0x8e6f
                if ((v14 || v12 ^ -0x80000000) == 0) {
                    // 0x9008
                    v15 = 0;
                    v16 = -0x80000000;
                    // branch -> 0x8f70
                } else {
                    int32_t v18 = v12 ^ 0x7fffffff; // 0x8e81
                    if ((v18 || -1 - v14) != 0) {
                        // 0x8e91
                        if ((v14 ^ -2 || v18) == 0) {
                            // 0x8f60
                            v15 = -2;
                            v16 = 0x7fffffff;
                            // branch -> 0x8f70
                            // 0x8f70
                            if ((v13 || v11) != 0) {
                                // 0x8f85
                                v3 = v15;
                                v6 = v16;
                                if ((v16 ^ -0x80000000 || v15) != 0) {
                                    // 0x8f93
                                    v17 = v16 ^ 0x7fffffff;
                                    if ((v17 || -1 - v15) != 0) {
                                        // 0x8fa7
                                        if ((v17 || v15 ^ -2) != 0) {
                                            v8 = v15;
                                            // 0x8fb4
                                            v9 = v2 - v8;
                                            v10 = (int32_t)(v2 < v8) + v1 - v16;
                                            if ((v10 ^ 0x7fffffff || v9 ^ -2) == 0) {
                                                // 0x8f48
                                                *a1 = -2;
                                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                                // branch -> 0x8eaf
                                                // 0x8eaf
                                                return result;
                                            }
                                            v5 = v9;
                                            v4 = v10;
                                            // 0x8fd5
                                            if ((v4 ^ -0x80000000 || v5) == 0) {
                                                // 0x9018
                                                *a1 = 0;
                                                *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                                // branch -> 0x8eaf
                                                // 0x8eaf
                                                return result;
                                            }
                                            // 0x8fdf
                                            if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                                // 0x8f48
                                                *a1 = -2;
                                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                                // branch -> 0x8eaf
                                            } else {
                                                // 0x8ff1
                                                *a1 = -1;
                                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                                // branch -> 0x8eaf
                                            }
                                            // 0x8eaf
                                            return result;
                                        }
                                        v3 = v15;
                                        v6 = v16;
                                    } else {
                                        v3 = v15;
                                        v6 = v16;
                                    }
                                }
                                // 0x8edd
                                v7 = v6 ^ 0x7fffffff;
                                if ((v7 || v3 ^ -2) != 0) {
                                    // 0x8eee
                                    if ((v1 ^ 0x7fffffff || -1 - v2) == 0) {
                                        // 0x8f40
                                        if ((v7 || -1 - v3) != 0) {
                                            // 0x8f30
                                            v5 = -1;
                                            v4 = 0x7fffffff;
                                            // branch -> 0x8fd5
                                            // 0x8fd5
                                            if ((v4 ^ -0x80000000 || v5) == 0) {
                                                // 0x9018
                                                *a1 = 0;
                                                *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                                // branch -> 0x8eaf
                                                // 0x8eaf
                                                return result;
                                            }
                                            // 0x8fdf
                                            if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                                // 0x8f48
                                                *a1 = -2;
                                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                                // branch -> 0x8eaf
                                            } else {
                                                // 0x8ff1
                                                *a1 = -1;
                                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                                // branch -> 0x8eaf
                                            }
                                            // 0x8eaf
                                            return result;
                                        }
                                        // 0x8f48
                                        *a1 = -2;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                        // 0x8eaf
                                        return result;
                                    }
                                    // 0x8f02
                                    if ((v2 || v1 ^ -0x80000000) == 0) {
                                        // 0x9040
                                        if ((v6 ^ -0x80000000 || v3) == 0) {
                                            // 0x8f48
                                            *a1 = -2;
                                            *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                            // branch -> 0x8eaf
                                            // 0x8eaf
                                            return result;
                                        }
                                    } else {
                                        // 0x8f16
                                        if ((v7 || -1 - v3) != 0) {
                                            // 0x8f22
                                            if ((v6 ^ -0x80000000 || v3) != 0) {
                                                v8 = v3;
                                                // 0x8fb4
                                                v9 = v2 - v8;
                                                v10 = (int32_t)(v2 < v8) + v1 - v6;
                                                if ((v10 ^ 0x7fffffff || v9 ^ -2) == 0) {
                                                    // 0x8f48
                                                    *a1 = -2;
                                                    *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                                    // branch -> 0x8eaf
                                                    // 0x8eaf
                                                    return result;
                                                }
                                                v5 = v9;
                                                v4 = v10;
                                            } else {
                                                // 0x8f30
                                                v5 = -1;
                                                v4 = 0x7fffffff;
                                                // branch -> 0x8fd5
                                            }
                                            // 0x8fd5
                                            if ((v4 ^ -0x80000000 || v5) == 0) {
                                                // 0x9018
                                                *a1 = 0;
                                                *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                                // branch -> 0x8eaf
                                                // 0x8eaf
                                                return result;
                                            }
                                            // 0x8fdf
                                            if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                                // 0x8f48
                                                *a1 = -2;
                                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                                // branch -> 0x8eaf
                                            } else {
                                                // 0x8ff1
                                                *a1 = -1;
                                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                                // branch -> 0x8eaf
                                            }
                                            // 0x8eaf
                                            return result;
                                        }
                                    }
                                    // 0x904e
                                    v5 = 0;
                                    v4 = -0x80000000;
                                    // branch -> 0x8fd5
                                    // 0x8fd5
                                    if ((v4 ^ -0x80000000 || v5) == 0) {
                                        // 0x9018
                                        *a1 = 0;
                                        *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                        // branch -> 0x8eaf
                                        // 0x8eaf
                                        return result;
                                    }
                                    // 0x8fdf
                                    if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                        // 0x8f48
                                        *a1 = -2;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    } else {
                                        // 0x8ff1
                                        *a1 = -1;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    }
                                    // 0x8eaf
                                    return result;
                                }
                            }
                            // 0x8f48
                            *a1 = -2;
                            *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                            // branch -> 0x8eaf
                        } else {
                            int32_t v19 = (int32_t)(v2 < v14) + v1 - v12; // 0x8ea8
                            *a1 = v2 - v14;
                            *(int32_t *)(result + (int32_t)&g29) = v19;
                            // branch -> 0x8eaf
                        }
                        // 0x8eaf
                        return result;
                    }
                    // 0x9030
                    v15 = -1;
                    v16 = 0x7fffffff;
                    // branch -> 0x8f70
                    // 0x8f70
                    if ((v13 || v11) != 0) {
                        // 0x8f85
                        v3 = v15;
                        v6 = v16;
                        if ((v16 ^ -0x80000000 || v15) != 0) {
                            // 0x8f93
                            v17 = v16 ^ 0x7fffffff;
                            if ((v17 || -1 - v15) != 0) {
                                // 0x8fa7
                                if ((v17 || v15 ^ -2) != 0) {
                                    v8 = v15;
                                    // 0x8fb4
                                    v9 = v2 - v8;
                                    v10 = (int32_t)(v2 < v8) + v1 - v16;
                                    if ((v10 ^ 0x7fffffff || v9 ^ -2) == 0) {
                                        // 0x8f48
                                        *a1 = -2;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                        // 0x8eaf
                                        return result;
                                    }
                                    v5 = v9;
                                    v4 = v10;
                                    // 0x8fd5
                                    if ((v4 ^ -0x80000000 || v5) == 0) {
                                        // 0x9018
                                        *a1 = 0;
                                        *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                        // branch -> 0x8eaf
                                        // 0x8eaf
                                        return result;
                                    }
                                    // 0x8fdf
                                    if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                        // 0x8f48
                                        *a1 = -2;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    } else {
                                        // 0x8ff1
                                        *a1 = -1;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    }
                                    // 0x8eaf
                                    return result;
                                }
                                v3 = v15;
                                v6 = v16;
                            } else {
                                v3 = v15;
                                v6 = v16;
                            }
                        }
                        // 0x8edd
                        v7 = v6 ^ 0x7fffffff;
                        if ((v7 || v3 ^ -2) != 0) {
                            // 0x8eee
                            if ((v1 ^ 0x7fffffff || -1 - v2) == 0) {
                                // 0x8f40
                                if ((v7 || -1 - v3) != 0) {
                                    // 0x8f30
                                    v5 = -1;
                                    v4 = 0x7fffffff;
                                    // branch -> 0x8fd5
                                    // 0x8fd5
                                    if ((v4 ^ -0x80000000 || v5) == 0) {
                                        // 0x9018
                                        *a1 = 0;
                                        *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                        // branch -> 0x8eaf
                                        // 0x8eaf
                                        return result;
                                    }
                                    // 0x8fdf
                                    if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                        // 0x8f48
                                        *a1 = -2;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    } else {
                                        // 0x8ff1
                                        *a1 = -1;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    }
                                    // 0x8eaf
                                    return result;
                                }
                                // 0x8f48
                                *a1 = -2;
                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                // branch -> 0x8eaf
                                // 0x8eaf
                                return result;
                            }
                            // 0x8f02
                            if ((v2 || v1 ^ -0x80000000) == 0) {
                                // 0x9040
                                if ((v6 ^ -0x80000000 || v3) == 0) {
                                    // 0x8f48
                                    *a1 = -2;
                                    *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                    // branch -> 0x8eaf
                                    // 0x8eaf
                                    return result;
                                }
                            } else {
                                // 0x8f16
                                if ((v7 || -1 - v3) != 0) {
                                    // 0x8f22
                                    if ((v6 ^ -0x80000000 || v3) != 0) {
                                        v8 = v3;
                                        // 0x8fb4
                                        v9 = v2 - v8;
                                        v10 = (int32_t)(v2 < v8) + v1 - v6;
                                        if ((v10 ^ 0x7fffffff || v9 ^ -2) == 0) {
                                            // 0x8f48
                                            *a1 = -2;
                                            *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                            // branch -> 0x8eaf
                                            // 0x8eaf
                                            return result;
                                        }
                                        v5 = v9;
                                        v4 = v10;
                                    } else {
                                        // 0x8f30
                                        v5 = -1;
                                        v4 = 0x7fffffff;
                                        // branch -> 0x8fd5
                                    }
                                    // 0x8fd5
                                    if ((v4 ^ -0x80000000 || v5) == 0) {
                                        // 0x9018
                                        *a1 = 0;
                                        *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                        // branch -> 0x8eaf
                                        // 0x8eaf
                                        return result;
                                    }
                                    // 0x8fdf
                                    if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                        // 0x8f48
                                        *a1 = -2;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    } else {
                                        // 0x8ff1
                                        *a1 = -1;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    }
                                    // 0x8eaf
                                    return result;
                                }
                            }
                            // 0x904e
                            v5 = 0;
                            v4 = -0x80000000;
                            // branch -> 0x8fd5
                            // 0x8fd5
                            if ((v4 ^ -0x80000000 || v5) == 0) {
                                // 0x9018
                                *a1 = 0;
                                *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                // branch -> 0x8eaf
                                // 0x8eaf
                                return result;
                            }
                            // 0x8fdf
                            if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                // 0x8f48
                                *a1 = -2;
                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                // branch -> 0x8eaf
                            } else {
                                // 0x8ff1
                                *a1 = -1;
                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                // branch -> 0x8eaf
                            }
                            // 0x8eaf
                            return result;
                        }
                    }
                    // 0x8f48
                    *a1 = -2;
                    *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                    // branch -> 0x8eaf
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x8f70
                if ((v13 || v11) != 0) {
                    // 0x8f85
                    v3 = v15;
                    v6 = v16;
                    if ((v16 ^ -0x80000000 || v15) != 0) {
                        // 0x8f93
                        v17 = v16 ^ 0x7fffffff;
                        if ((v17 || -1 - v15) != 0) {
                            // 0x8fa7
                            if ((v17 || v15 ^ -2) != 0) {
                                v8 = v15;
                                // 0x8fb4
                                v9 = v2 - v8;
                                v10 = (int32_t)(v2 < v8) + v1 - v16;
                                if ((v10 ^ 0x7fffffff || v9 ^ -2) == 0) {
                                    // 0x8f48
                                    *a1 = -2;
                                    *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                    // branch -> 0x8eaf
                                } else {
                                    v5 = v9;
                                    v4 = v10;
                                    // 0x8fd5
                                    if ((v4 ^ -0x80000000 || v5) == 0) {
                                        // 0x9018
                                        *a1 = 0;
                                        *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                        // branch -> 0x8eaf
                                    } else {
                                        // 0x8fdf
                                        if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                            // 0x8f48
                                            *a1 = -2;
                                            *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                            // branch -> 0x8eaf
                                        } else {
                                            // 0x8ff1
                                            *a1 = -1;
                                            *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                            // branch -> 0x8eaf
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                v3 = v15;
                                v6 = v16;
                            }
                        } else {
                            v3 = v15;
                            v6 = v16;
                        }
                    }
                    // 0x8edd
                    v7 = v6 ^ 0x7fffffff;
                    if ((v7 || v3 ^ -2) != 0) {
                        // 0x8eee
                        if ((v1 ^ 0x7fffffff || -1 - v2) == 0) {
                            // 0x8f40
                            if ((v7 || -1 - v3) != 0) {
                                // 0x8f30
                                v5 = -1;
                                v4 = 0x7fffffff;
                                // branch -> 0x8fd5
                                // 0x8fd5
                                if ((v4 ^ -0x80000000 || v5) == 0) {
                                    // 0x9018
                                    *a1 = 0;
                                    *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                    // branch -> 0x8eaf
                                } else {
                                    // 0x8fdf
                                    if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                        // 0x8f48
                                        *a1 = -2;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    } else {
                                        // 0x8ff1
                                        *a1 = -1;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        } else {
                            // 0x8f02
                            if ((v2 || v1 ^ -0x80000000) == 0) {
                                // 0x9040
                                if ((v6 ^ -0x80000000 || v3) == 0) {
                                    // 0x8f48
                                    *a1 = -2;
                                    *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                    // branch -> 0x8eaf
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            } else {
                                // 0x8f16
                                if ((v7 || -1 - v3) != 0) {
                                    // 0x8f22
                                    if ((v6 ^ -0x80000000 || v3) != 0) {
                                        v8 = v3;
                                        // 0x8fb4
                                        v9 = v2 - v8;
                                        v10 = (int32_t)(v2 < v8) + v1 - v6;
                                        if ((v10 ^ 0x7fffffff || v9 ^ -2) == 0) {
                                            // 0x8f48
                                            *a1 = -2;
                                            *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                            // branch -> 0x8eaf
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            v5 = v9;
                                            v4 = v10;
                                        }
                                    } else {
                                        // 0x8f30
                                        v5 = -1;
                                        v4 = 0x7fffffff;
                                        // branch -> 0x8fd5
                                    }
                                    // 0x8fd5
                                    if ((v4 ^ -0x80000000 || v5) == 0) {
                                        // 0x9018
                                        *a1 = 0;
                                        *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                        // branch -> 0x8eaf
                                    } else {
                                        // 0x8fdf
                                        if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                            // 0x8f48
                                            *a1 = -2;
                                            *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                            // branch -> 0x8eaf
                                        } else {
                                            // 0x8ff1
                                            *a1 = -1;
                                            *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                            // branch -> 0x8eaf
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x904e
                            v5 = 0;
                            v4 = -0x80000000;
                            // branch -> 0x8fd5
                            // 0x8fd5
                            if ((v4 ^ -0x80000000 || v5) == 0) {
                                // 0x9018
                                *a1 = 0;
                                *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                // branch -> 0x8eaf
                            } else {
                                // 0x8fdf
                                if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                    // 0x8f48
                                    *a1 = -2;
                                    *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                    // branch -> 0x8eaf
                                } else {
                                    // 0x8ff1
                                    *a1 = -1;
                                    *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                    // branch -> 0x8eaf
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x8f70
            if ((v13 || v11) != 0) {
                // 0x8f85
                v3 = v15;
                v6 = v16;
                if ((v16 ^ -0x80000000 || v15) != 0) {
                    // 0x8f93
                    v17 = v16 ^ 0x7fffffff;
                    if ((v17 || -1 - v15) != 0) {
                        // 0x8fa7
                        if ((v17 || v15 ^ -2) != 0) {
                            v8 = v15;
                            // 0x8fb4
                            v9 = v2 - v8;
                            v10 = (int32_t)(v2 < v8) + v1 - v16;
                            if ((v10 ^ 0x7fffffff || v9 ^ -2) == 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                v5 = v9;
                                v4 = v10;
                                // 0x8fd5
                                if ((v4 ^ -0x80000000 || v5) == 0) {
                                    // 0x9018
                                    *a1 = 0;
                                    *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                    // branch -> 0x8eaf
                                } else {
                                    // 0x8fdf
                                    if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x8ff1
                                        *a1 = -1;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            v3 = v15;
                            v6 = v16;
                        }
                    } else {
                        v3 = v15;
                        v6 = v16;
                    }
                }
                // 0x8edd
                v7 = v6 ^ 0x7fffffff;
                if ((v7 || v3 ^ -2) != 0) {
                    // 0x8eee
                    if ((v1 ^ 0x7fffffff || -1 - v2) == 0) {
                        // 0x8f40
                        if ((v7 || -1 - v3) != 0) {
                            // 0x8f30
                            v5 = -1;
                            v4 = 0x7fffffff;
                            // branch -> 0x8fd5
                            // 0x8fd5
                            if ((v4 ^ -0x80000000 || v5) == 0) {
                                // 0x9018
                                *a1 = 0;
                                *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                // branch -> 0x8eaf
                            } else {
                                // 0x8fdf
                                if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x8ff1
                                    *a1 = -1;
                                    *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                    // branch -> 0x8eaf
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    } else {
                        // 0x8f02
                        if ((v2 || v1 ^ -0x80000000) == 0) {
                            // 0x9040
                            if ((v6 ^ -0x80000000 || v3) == 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        } else {
                            // 0x8f16
                            if ((v7 || -1 - v3) != 0) {
                                // 0x8f22
                                if ((v6 ^ -0x80000000 || v3) != 0) {
                                    v8 = v3;
                                    // 0x8fb4
                                    v9 = v2 - v8;
                                    v10 = (int32_t)(v2 < v8) + v1 - v6;
                                    if ((v10 ^ 0x7fffffff || v9 ^ -2) == 0) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        v5 = v9;
                                        v4 = v10;
                                    }
                                } else {
                                    // 0x8f30
                                    v5 = -1;
                                    v4 = 0x7fffffff;
                                    // branch -> 0x8fd5
                                }
                                // 0x8fd5
                                if ((v4 ^ -0x80000000 || v5) == 0) {
                                    // 0x9018
                                    *a1 = 0;
                                    *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                                    // branch -> 0x8eaf
                                } else {
                                    // 0x8fdf
                                    if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x8ff1
                                        *a1 = -1;
                                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                        // branch -> 0x8eaf
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x904e
                        v5 = 0;
                        v4 = -0x80000000;
                        // branch -> 0x8fd5
                        // 0x8fd5
                        if ((v4 ^ -0x80000000 || v5) == 0) {
                            // 0x9018
                            *a1 = 0;
                            *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                            // branch -> 0x8eaf
                        } else {
                            // 0x8fdf
                            if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x8ff1
                                *a1 = -1;
                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                // branch -> 0x8eaf
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x8ed8
        v3 = *(int32_t *)a3;
        v6 = *(int32_t *)(a3 + (int32_t)&g29);
        // branch -> 0x8edd
        // 0x8edd
        v7 = v6 ^ 0x7fffffff;
        if ((v7 || v3 ^ -2) != 0) {
            // 0x8eee
            if ((v1 ^ 0x7fffffff || -1 - v2) == 0) {
                // 0x8f40
                if ((v7 || -1 - v3) != 0) {
                    // 0x8f30
                    v5 = -1;
                    v4 = 0x7fffffff;
                    // branch -> 0x8fd5
                    // 0x8fd5
                    if ((v4 ^ -0x80000000 || v5) == 0) {
                        // 0x9018
                        *a1 = 0;
                        *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                        // branch -> 0x8eaf
                    } else {
                        // 0x8fdf
                        if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x8ff1
                            *a1 = -1;
                            *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                            // branch -> 0x8eaf
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            } else {
                // 0x8f02
                if ((v2 || v1 ^ -0x80000000) == 0) {
                    // 0x9040
                    if ((v6 ^ -0x80000000 || v3) == 0) {
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                } else {
                    // 0x8f16
                    if ((v7 || -1 - v3) != 0) {
                        // 0x8f22
                        if ((v6 ^ -0x80000000 || v3) != 0) {
                            v8 = v3;
                            // 0x8fb4
                            v9 = v2 - v8;
                            v10 = (int32_t)(v2 < v8) + v1 - v6;
                            if ((v10 ^ 0x7fffffff || v9 ^ -2) == 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                v5 = v9;
                                v4 = v10;
                            }
                        } else {
                            // 0x8f30
                            v5 = -1;
                            v4 = 0x7fffffff;
                            // branch -> 0x8fd5
                        }
                        // 0x8fd5
                        if ((v4 ^ -0x80000000 || v5) == 0) {
                            // 0x9018
                            *a1 = 0;
                            *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                            // branch -> 0x8eaf
                        } else {
                            // 0x8fdf
                            if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x8ff1
                                *a1 = -1;
                                *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                                // branch -> 0x8eaf
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // 0x904e
                v5 = 0;
                v4 = -0x80000000;
                // branch -> 0x8fd5
                // 0x8fd5
                if ((v4 ^ -0x80000000 || v5) == 0) {
                    // 0x9018
                    *a1 = 0;
                    *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                    // branch -> 0x8eaf
                } else {
                    // 0x8fdf
                    if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x8ff1
                        *a1 = -1;
                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                        // branch -> 0x8eaf
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x8ed8
    v3 = *(int32_t *)a3;
    v6 = *(int32_t *)(a3 + (int32_t)&g29);
    // branch -> 0x8edd
    // 0x8edd
    v7 = v6 ^ 0x7fffffff;
    if ((v7 || v3 ^ -2) != 0) {
        // 0x8eee
        if ((v1 ^ 0x7fffffff || -1 - v2) == 0) {
            // 0x8f40
            if ((v7 || -1 - v3) != 0) {
                // 0x8f30
                v5 = -1;
                v4 = 0x7fffffff;
                // branch -> 0x8fd5
                // 0x8fd5
                if ((v4 ^ -0x80000000 || v5) == 0) {
                    // 0x9018
                    *a1 = 0;
                    *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                    // branch -> 0x8eaf
                } else {
                    // 0x8fdf
                    if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x8ff1
                        *a1 = -1;
                        *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                        // branch -> 0x8eaf
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        } else {
            // 0x8f02
            if ((v2 || v1 ^ -0x80000000) == 0) {
                // 0x9040
                if ((v6 ^ -0x80000000 || v3) == 0) {
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            } else {
                // 0x8f16
                if ((v7 || -1 - v3) != 0) {
                    // 0x8f22
                    if ((v6 ^ -0x80000000 || v3) != 0) {
                        v8 = v3;
                        // 0x8fb4
                        v9 = v2 - v8;
                        v10 = (int32_t)(v2 < v8) + v1 - v6;
                        if ((v10 ^ 0x7fffffff || v9 ^ -2) == 0) {
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            v5 = v9;
                            v4 = v10;
                        }
                    } else {
                        // 0x8f30
                        v5 = -1;
                        v4 = 0x7fffffff;
                        // branch -> 0x8fd5
                    }
                    // 0x8fd5
                    if ((v4 ^ -0x80000000 || v5) == 0) {
                        // 0x9018
                        *a1 = 0;
                        *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                        // branch -> 0x8eaf
                    } else {
                        // 0x8fdf
                        if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x8ff1
                            *a1 = -1;
                            *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                            // branch -> 0x8eaf
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // 0x904e
            v5 = 0;
            v4 = -0x80000000;
            // branch -> 0x8fd5
            // 0x8fd5
            if ((v4 ^ -0x80000000 || v5) == 0) {
                // 0x9018
                *a1 = 0;
                *(int32_t *)(result + (int32_t)&g29) = -0x80000000;
                // branch -> 0x8eaf
            } else {
                // 0x8fdf
                if ((v4 ^ 0x7fffffff || -1 - v5) != 0) {
                    // Detected a possible infinite recursion (goto support failed); quitting...
                } else {
                    // 0x8ff1
                    *a1 = -1;
                    *(int32_t *)(result + (int32_t)&g29) = 0x7fffffff;
                    // branch -> 0x8eaf
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// Address range: 0x9060 - 0x9095
// Demangled:     boost::unique_lock<AnnotatedMixin<boost::recursive_mutex> >::~unique_lock()
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(int32_t * a1) {
    int32_t result = (int32_t)a1;
    if (*(char *)(result + (int32_t)&g29) == 0) {
        // 0x907b
        return 0;
    }
    // 0x9090
    g4 = *a1;
    return result;
}

// Address range: 0x90ab - 0x90ac
int32_t function_90ab(void) {
    // 0x90ab
    return g2;
}

// Address range: 0x90c1 - 0x90d6
int32_t function_90c1(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x174a8b40; // 0x90c1
    *v1 = *v1 + 1;
    *(int32_t *)0 = g2;
    int32_t v2 = g2; // 0x90c9
    *(char *)v2 = (char)v2 + *(char *)&g2;
    *(char *)(int32_t)&g28 = 0;
    return function_90ab();
}

// Address range: 0x90d6 - 0x90d7
int32_t function_90d6(int32_t a1) {
    // 0x90d6
    return g2;
}

// Address range: 0x9110 - 0x9147
// Demangled:     std::_Rb_tree<int, std::pair<int const, int>, std::_Select1st<std::pair<int const, int> >, std::less<int>, std::allocator<std::pair<int const, int> > >::_M_erase(std::_Rb_tree_node<std::pair<int const, int> > *)
int32_t _ZNSt8_Rb_treeIiSt4pairIKiiESt10_Select1stIS2_ESt4lessIiESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E(int32_t a1, int32_t a2) {
    // 0x9110
    if (a2 != 0) {
        // 0x9132
        return unknown_12220(a1, *(int32_t *)(a2 + (int32_t)&g47));
    }
    // 0x912e
    return function_9150(0x2074c085, 0, 0, 0);
}

// Address range: 0x9150 - 0x9169
int32_t function_9150(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1 ^ 0x2074c085; // 0x9154
    if (result != 0) {
        // 0x9164
    }
    // 0x915d
    return result;
}

// Address range: 0x9170 - 0x91c4
// Demangled:     std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::_M_erase(std::_Rb_tree_node<int> *)
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE8_M_eraseEPSt13_Rb_tree_nodeIiE(int32_t a1, int32_t a2) {
    // 0x9170
    if (a2 != 0) {
        unknown_122e0(a1, *(int32_t *)(a2 + (int32_t)&g47));
        int32_t v1 = *(int32_t *)(a2 + (int32_t)&g37); // 0x91a1
        while (v1 != 0) {
            // 0x9192
            // 0x9190
            unknown_122e0(a1, *(int32_t *)(v1 + (int32_t)&g47));
            v1 += (int32_t)&g37;
            // branch -> 0x9192
        }
        // 0x91b0
        return 0;
    }
    // 0x91b0
    return 0;
}

// Address range: 0x91d0 - 0x9223
// Demangled:     std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > >::~vector()
int32_t _ZNSt6vectorISt3setIiSt4lessIiESaIiEESaIS4_EED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g29); // 0x91e6
    int32_t v3 = *a1; // 0x91e9
    int32_t v4 = v3; // 0x9208
    if (v2 != v3) {
        unknown_12340(v3, *(int32_t *)(v3 + (int32_t)&g37));
        while (v2 != v3 + (int32_t)&g16) {
            // 0x91f0
            v3 += (int32_t)&g16;
            unknown_12340(v3, *(int32_t *)(v3 + (int32_t)&g37));
            // continue -> 0x91f0
        }
        // 0x9206
        v4 = *(int32_t *)v1;
        // branch -> 0x9208
    }
    // 0x9208
    if (v4 == 0) {
        // bb
        function_9228();
        // branch -> 0x920c
    }
    // 0x920c
    return 0;
}

// Address range: 0x9228 - 0x923c
int32_t function_9228(void) {
    // 0x9228
    int32_t v1;
    int32_t v2 = v1 ^ 0x2074c085; // 0x922c
    g2 = v2;
    int32_t result = v2; // 0x923b
    if (v2 != 0) {
        // bb
        result = function_923c();
        // branch -> 0x9235
    }
    // 0x9235
    return result;
}

// Address range: 0x923c - 0x923d
int32_t function_923c(void) {
    // 0x923c
    return g2;
}

// Address range: 0x9250 - 0x92d8
// Demangled:     std::vector<int, std::allocator<int> >::_M_insert_aux(__gnu_cxx::__normal_iterator<int *, std::vector<int, std::allocator<int> > >, int const &)
int32_t _ZNSt6vectorIiSaIiEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPiS1_EERKi(int32_t a1, int32_t * a2, int32_t a3) {
    // 0x9250
    g4 = a1;
    g8 = (int32_t)a2;
    g6 = a3;
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g29); // 0x9277
    g7 = v1;
    if (v1 == *(int32_t *)(a1 + (int32_t)&g37)) {
        // bb
        function_92e0(0x2074c085);
        // branch -> 0x9283
    }
    int32_t v2 = -4;
    if (v1 != 0) {
        int32_t v3 = v1 - 4; // 0x9287
        *(int32_t *)v1 = *(int32_t *)v3;
        v2 = v3;
        // branch -> 0x928c
    }
    // 0x928c
    *(int32_t *)(g4 + (int32_t)&g29) = v1 + (int32_t)&g29;
    int32_t v4 = g8; // 0x9297
    int32_t v5 = v2 - v4; // 0x9297
    if (v5 >= 4) {
        // 0x92c8
        return v5 - v5 % 4;
    }
    // 0x92a0
    *(int32_t *)v4 = *(int32_t *)g6;
    return 0;
}

// Address range: 0x92dd - 0x92df
int32_t function_92dd(void) {
    // 0x92dd
    return 0;
}

// Address range: 0x92e0 - 0x934c
int32_t function_92e0(int32_t a1) {
    // 0x92e0
    g2 = g4;
    int32_t v1 = g7 - g4; // 0x92e2
    int32_t v2 = v1 / 4; // 0x92e4
    int32_t v3 = g4; // 0x92fc3
    if (v1 < 4) {
        int32_t v4 = function_93a8(); // 0x92e9
        g2 = v4;
        v3 = v4;
        // branch -> 0x92ef
    }
    int32_t v5 = 2 * v2; // 0x92ef
    g5 = v5;
    if (v1 < 4 || v2 < v5) {
        // bb15
        v3 = function_93c1();
        // branch -> 0x92fa
    }
    // 0x92fa
    g3 = -4;
    int32_t v6 = (g8 - v3) / 4 * (int32_t)&g29 - 4; // 0x9321
    int32_t result = g4; // 0x9331
    if (v6 != 0) {
        // 0x9329
        *(int32_t *)v6 = g6;
        result = g4;
        // branch -> 0x932d
    }
    // 0x932d
    g6 = 0;
    int32_t v7 = g8 - result; // 0x9331
    if (v7 < 4) {
        // bb16
        result = function_9351();
        // branch -> 0x933a
    }
    // 0x933a
    g6 = v7 / 4 * (int32_t)&g29;
    return result;
}

// Address range: 0x9351 - 0x9379
int32_t function_9351(void) {
    // 0x9351
    g7 = g3 + (int32_t)&g29 + g6;
    g6 = 0;
    int32_t v1 = *(int32_t *)(g4 + (int32_t)&g29) - g8; // 0x935a
    int32_t result = v1 / 4; // 0x9363
    if (v1 < 4) {
        // bb
        result = function_9382();
        // branch -> 0x9363
    }
    // 0x9363
    return result;
}

// Address range: 0x9382 - 0x938d
int32_t function_9382(void) {
    // 0x9382
    g2 = g4;
    g6 += g7;
    int32_t result = g4; // 0x938a
    if (g4 == 0) {
        // bb
        result = function_9392();
        // branch -> 0x938a
    }
    // 0x938a
    return result;
}

// Address range: 0x9392 - 0x93a3
int32_t function_9392(void) {
    // 0x9392
    *(int32_t *)g4 = g3;
    *(int32_t *)(g4 + (int32_t)&g29) = g6;
    int32_t v1;
    *(int32_t *)(g4 + (int32_t)&g37) = g3 + v1;
    return g2;
}

// Address range: 0x93a8 - 0x93bc
int32_t function_93a8(void) {
    // 0x93a8
    return g2;
}

// Address range: 0x93bc - 0x93bd
int32_t function_93bc(void) {
    // 0x93bc
    return g2;
}

// Address range: 0x93c1 - 0x93ea
int32_t function_93c1(void) {
    // 0x93c1
    return g2;
}

// Address range: 0x93f0 - 0x9444
// Demangled:     std::_Rb_tree<int, std::pair<int const, CAddrInfo>, std::_Select1st<std::pair<int const, CAddrInfo> >, std::less<int>, std::allocator<std::pair<int const, CAddrInfo> > >::_M_erase(std::_Rb_tree_node<std::pair<int const, CAddrInfo> > *)
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E(int32_t a1, int32_t a2) {
    // 0x93f0
    if (a2 != 0) {
        unknown_127e0(a1, *(int32_t *)(a2 + (int32_t)&g47));
        int32_t v1 = *(int32_t *)(a2 + (int32_t)&g37); // 0x9421
        while (v1 != 0) {
            // 0x9412
            // 0x9410
            unknown_127e0(a1, *(int32_t *)(v1 + (int32_t)&g47));
            v1 += (int32_t)&g37;
            // branch -> 0x9412
        }
        // 0x9430
        return 0;
    }
    // 0x9430
    return 0;
}

// Address range: 0x9450 - 0x94a4
// Demangled:     std::_Rb_tree<CNetAddr, std::pair<CNetAddr const, int>, std::_Select1st<std::pair<CNetAddr const, int> >, std::less<CNetAddr>, std::allocator<std::pair<CNetAddr const, int> > >::_M_erase(std::_Rb_tree_node<std::pair<CNetAddr const, int> > *)
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E(int32_t a1, int32_t a2) {
    // 0x9450
    if (a2 != 0) {
        unknown_128a0(a1, *(int32_t *)(a2 + (int32_t)&g47));
        int32_t v1 = *(int32_t *)(a2 + (int32_t)&g37); // 0x9481
        while (v1 != 0) {
            // 0x9472
            // 0x9470
            unknown_128a0(a1, *(int32_t *)(v1 + (int32_t)&g47));
            v1 += (int32_t)&g37;
            // branch -> 0x9472
        }
        // 0x9490
        return 0;
    }
    // 0x9490
    return 0;
}

// Address range: 0x94b0 - 0x94ea
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, int>, std::_Select1st<std::pair<std::string const, int> >, std::less<std::string>, std::allocator<std::pair<std::string const, int> > >::_M_erase(std::_Rb_tree_node<std::pair<std::string const, int> > *)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE8_M_eraseEPSt13_Rb_tree_nodeIS2_E(int32_t a1, int32_t a2) {
    int32_t v1 = g4; // 0x94b2
    g4 = a2;
    if (a2 == 0) {
        // 0x94ce
        return function_94fb(0x2074c085, v1, g8, g6);
    }
    // 0x94d2
    unknown_12960(a1, *(int32_t *)(a2 + (int32_t)&g47));
    return a2 + 16;
}

// Address range: 0x94fb - 0x950f
int32_t function_94fb(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1 ^ 0x2074c085; // 0x94ff
    if (result != 0) {
        // 0x950f
        return result;
    }
    // 0x9508
    g4 = a2;
    return result;
}

// Address range: 0x9520 - 0x955a
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, Db *>, std::_Select1st<std::pair<std::string const, Db *> >, std::less<std::string>, std::allocator<std::pair<std::string const, Db *> > >::_M_erase(std::_Rb_tree_node<std::pair<std::string const, Db *> > *)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsP2DbESt10_Select1stIS4_ESt4lessISsESaIS4_EE8_M_eraseEPSt13_Rb_tree_nodeIS4_E(int32_t a1, int32_t a2) {
    int32_t v1 = g6; // 0x9520
    int32_t v2 = g8; // 0x9521
    int32_t v3 = g4; // 0x9522
    g4 = a2;
    g6 = a1;
    if (a2 == 0) {
        // 0x953e
        return function_956b(0x2074c085, v3, v2, v1);
    }
    // 0x9542
    unknown_12a40(a1, *(int32_t *)(a2 + (int32_t)&g47));
    g8 = *(int32_t *)(a2 + (int32_t)&g37);
    return a2 + 16;
}

// Address range: 0x956b - 0x9584
int32_t function_956b(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1 ^ 0x2074c085; // 0x956f
    if (result != 0) {
        // 0x957f
        return result;
    }
    // 0x9578
    g4 = a2;
    g8 = a3;
    g6 = a4;
    return result;
}

// Address range: 0x9590 - 0x9711
// Demangled:     std::vector<std::pair<std::vector<unsigned char, std::allocator<unsigned char> >, std::vector<unsigned char, std::allocator<unsigned char> > >, std::allocator<std::pair<std::vector<unsigned char, std::allocator<unsigned char> >, std::vector<unsigned char, std::allocator<unsigned char> > > > >::_M_insert_aux(__gnu_cxx::__normal_iterator<std::pair<std::vector<unsigned char, std::allocator<unsigned char> >, std::vector<unsigned char, std::allocator<unsigned char> > > *, std::vector<std::pair<std::vector<unsigned char, std::allocator<unsigned char> >, std::vector<unsigned char, std::allocator<unsigned char> > >, std::allocator<std::pair<std::vector<unsigned char, std::allocator<unsigned char> >, std::vector<unsigned char, std::allocator<unsigned char> > > > > >, std::pair<std::vector<unsigned char, std::allocator<unsigned char> >, std::vector<unsigned char, std::allocator<unsigned char> > > const &)
int32_t _ZNSt6vectorISt4pairIS_IhSaIhEES2_ESaIS3_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS3_S5_EERKS3_(int32_t a1, int32_t a2) {
    // 0x9590
    g8 = a1;
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g29); // 0x95b0
    g4 = v1;
    if (v1 == *(int32_t *)(a1 + (int32_t)&g37)) {
        // bb
        function_989f(a2);
        // branch -> 0x95c0
    }
    // 0x95c0
    if (v1 == 0) {
        // bb33
        function_9813();
        // branch -> 0x95c8
    }
    // 0x95c8
    g3 = 0;
    int32_t * v2 = (int32_t *)v1; // 0x95d0
    *v2 = 0;
    int32_t * v3 = (int32_t *)(v1 + (int32_t)&g29); // 0x95d6
    *v3 = 0;
    int32_t * v4 = (int32_t *)(v1 + (int32_t)&g37); // 0x95dd
    *v4 = 0;
    int32_t v5 = *(int32_t *)(v1 - 20) - *(int32_t *)(v1 - 24); // 0x95e4
    g2 = v5;
    if (v5 != 0) {
        // bb34
        g2 = function_9884(v5, 0);
        // branch -> 0x95fa
    }
    // 0x95fa
    *v2 = g3;
    *v3 = g3;
    *v4 = g3 + v5;
    if (g2 != 0) {
        // bb35
        function_97fa();
        // branch -> 0x9610
    }
    int32_t * v6 = (int32_t *)(v1 + (int32_t)&g47); // 0x961a
    *v6 = 0;
    *v3 = g3;
    int32_t v7 = 0; // edx
    int32_t v8 = *(int32_t *)(v1 - 8) - *(int32_t *)(v1 - 12); // 0x9628
    g2 = v8;
    int32_t * v9 = (int32_t *)(v1 + 16); // 0x962e
    *v9 = 0;
    int32_t * v10 = (int32_t *)(v1 + (int32_t)&g14); // 0x9635
    *v10 = 0;
    int32_t v11; // 0x964c
    if (v8 != 0) {
        // bb36
        v11 = function_9856(0);
        // branch -> 0x964a
    } else {
        // 0x9610
        v11 = g2;
        // branch -> 0x964a
    }
    // 0x964a
    *v6 = v7;
    *v9 = v7;
    *v10 = v7 + v8;
    if (v11 != 0) {
        // bb37
        function_97d9(0);
        // branch -> 0x965d
    }
    int32_t v12 = *(int32_t *)(g8 + (int32_t)&g29); // 0x9661
    *v9 = v7;
    int32_t v13 = v12 + (int32_t)&g16; // 0x9667
    *(int32_t *)(g8 + (int32_t)&g29) = v13;
    int32_t v14 = *(int32_t *)(g6 + (int32_t)&g29); // 0x9671
    int32_t v15 = v14 - *(int32_t *)g6; // 0x968e
    g2 = v15;
    int32_t v16 = v15; // 0x969c
    if (v15 != 0) {
        // bb38
        v16 = function_9836(0, 0, 0);
        // branch -> 0x969a
    }
    // 0x969a
    if (v16 != 0) {
        // 0x96ac
        // branch -> 0x96bc
    }
    int32_t v17 = g6; // 0x96bc
    int32_t v18 = *(int32_t *)(v17 + (int32_t)&g47); // 0x96bc
    g7 = 0;
    g3 = 0;
    int32_t v19 = *(int32_t *)(v17 + 16) - v18; // 0x96dc
    g2 = v19;
    int32_t v20 = v19; // 0x96f2
    int32_t v21 = 0; // 0x96f0
    if (v19 != 0) {
        // bb39
        v20 = function_981a(0, 0, 0, 0);
        v21 = g3;
        // branch -> 0x96f0
    }
    int32_t result = v20; // 0x970e
    if (v20 == 0) {
        // bb40
        result = function_971a(v19 + v21);
        // branch -> 0x9702
    }
    // 0x9702
    return result;
}

// Address range: 0x971a - 0x97d9
int32_t function_971a(int32_t a1) {
    int32_t v1 = *(int32_t *)(g8 + (int32_t)&g29) - 48; // 0x9723
    int32_t v2 = v1; // ebx
    int32_t v3 = -0x55555555 * (v1 - a1 >> (int32_t)&g25); // 0x972f
    if (v3 >= 0 == (v3 != 0)) {
        while (true) {
            // 0x9742
            unknown_121b0(v1);
            int32_t v4 = v2 - 12; // 0x9758
            v2 = v4;
            unknown_121b0(v4);
            int32_t v5 = v3 - 1; // 0x976e
            if (v5 != 0) {
                int32_t v6 = v1 - 24; // 0x9740
                v2 = v6;
                v1 = v6;
                v3 = v5;
                // branch -> 0x9742
                continue;
            }
        }
    }
    // 0x9775
    unknown_121b0(a1);
    unknown_121b0(a1 + (int32_t)&g47);
    int32_t result = 0; // bp+52
    g2 = result;
    int32_t v7;
    if (v7 != 0x2074c085) {
        // bb
        result = function_9aaa();
        // branch -> 0x97d1
    }
    // 0x97d1
    return result;
}

// Address range: 0x97d9 - 0x97ec
int32_t function_97d9(int32_t result) {
    // 0x97d9
    return result;
}

// Address range: 0x97f1 - 0x97fa
int32_t function_97f1(int32_t a1) {
    // 0x97f1
    return 0;
}

// Address range: 0x97fa - 0x9809
int32_t function_97fa(void) {
    // 0x97fa
    return g2;
}

// Address range: 0x980e - 0x9813
int32_t function_980e(void) {
    // 0x980e
    return 0;
}

// Address range: 0x9813 - 0x981a
int32_t function_9813(void) {
    // 0x9813
    return 0;
}

// Address range: 0x981a - 0x9820
int32_t function_981a(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x981a
    return g2;
}

// Address range: 0x9824 - 0x9836
int32_t function_9824(void) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 + 0xc4f8bc5); // 0x9824
    *v2 = *v2 - 1;
    return *(int32_t *)16 - v1;
}

// Address range: 0x9836 - 0x983d
int32_t function_9836(int32_t a1, int32_t a2, int32_t a3) {
    // 0x9836
    return g2;
}

// Address range: 0x9841 - 0x984a
int32_t function_9841(void) {
    int32_t * v1 = (int32_t *)0x24548b0f; // 0x9841
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    return v2 + 119 + (int32_t)false & 255 | v2 & -256;
}

// Address range: 0x984a - 0x9856
int32_t function_984a(void) {
    // 0x984a
    int32_t v1;
    return *(int32_t *)(v1 + (int32_t)&g29);
}

// Address range: 0x9856 - 0x9859
int32_t function_9856(int32_t a1) {
    // 0x9856
    return g2;
}

// Address range: 0x985d - 0x9884
int32_t function_985d(void) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 - 0xbb4743e); // 0x985d
    *v2 = *v2 - 1;
    int32_t v3 = 0; // ebx
    int32_t v4 = 0; // edx
    *(int32_t *)(v3 + (int32_t)&g47) = v4;
    *(int32_t *)(v3 + 16) = v4;
    *(int32_t *)(v3 + (int32_t)&g14) = v4;
    return function_97d9(*(int32_t *)(v3 - 8) - v1);
}

// Address range: 0x9884 - 0x989f
int32_t function_9884(int32_t a1, int32_t a2) {
    // 0x9884
    g3 = g2;
    return *(int32_t *)(g4 - 20) - *(int32_t *)(g4 - 24);
}

// Address range: 0x989f - 0x98de
int32_t function_989f(int32_t a1) {
    int32_t v1 = g8; // 0x989f
    g2 = v1;
    int32_t v2 = g4 - v1 >> (int32_t)&g25; // 0x98a3
    uint32_t v3 = -0x55555555 * v2; // 0x98a6
    if (v3 == 0) {
        int32_t v4 = function_9a31(); // 0x98ae
        g2 = v4;
        v1 = v4;
        // branch -> 0x98b4
    }
    int32_t v5 = 0x55555556 * v2; // 0x98b4
    g7 = v5;
    if (v3 < v5 || 0x55555555 * v2 == 0) {
        // bb6
        v1 = function_9a76();
        // branch -> 0x98bf
    }
    // 0x98bf
    g4 = -0x55555555 * (a1 - v1 >> (int32_t)&g25);
    return -16;
}

// Address range: 0x98e7 - 0x994a
int32_t function_98e7(int32_t a1) {
    int32_t v1 = g4 * 3 * (int32_t)&g37 + a1; // 0x98ee
    g4 = v1;
    if (v1 == 0) {
        // bb
        function_99b5();
        // branch -> 0x98f9
    }
    int32_t v2 = g6; // 0x98f9
    g3 = 0;
    int32_t * v3 = (int32_t *)v1; // 0x9900
    *v3 = 0;
    int32_t * v4 = (int32_t *)(v1 + (int32_t)&g29); // 0x9906
    *v4 = 0;
    int32_t * v5 = (int32_t *)(v1 + (int32_t)&g37); // 0x990d
    *v5 = 0;
    int32_t v6 = *(int32_t *)(v2 + (int32_t)&g29) - v2; // 0x9914
    g2 = v6;
    if (v6 != 0) {
        // bb9
        function_9a58(v6);
        // branch -> 0x9922
    }
    // 0x9922
    g7 = 0;
    *v3 = g3;
    *v4 = g3;
    *v5 = g3 + v6;
    int32_t v7 = g6; // 0x9932
    int32_t result = v7; // 0x9946
    if (*(int32_t *)(v7 + (int32_t)&g29) == v7) {
        // bb10
        result = function_9953();
        // branch -> 0x993b
    }
    // 0x993b
    return result;
}

// Address range: 0x9953 - 0x99b5
int32_t function_9953(void) {
    int32_t v1 = 0; // ebp
    *(int32_t *)(g4 + (int32_t)&g29) = g3 + g7;
    int32_t v2 = g6; // 0x995a
    int32_t v3 = *(int32_t *)(v2 + 16); // 0x995a
    *(int32_t *)(g4 + (int32_t)&g47) = 0;
    *(int32_t *)(g4 + 16) = 0;
    *(int32_t *)(g4 + (int32_t)&g14) = 0;
    int32_t v4 = v3 - *(int32_t *)(v2 + (int32_t)&g47); // 0x9975
    g2 = v4;
    if (v4 != 0) {
        // bb
        function_9a67(v4);
        // branch -> 0x9983
    }
    // 0x9983
    *(int32_t *)(g4 + (int32_t)&g47) = v1;
    *(int32_t *)(g4 + 16) = v1;
    *(int32_t *)(g4 + (int32_t)&g14) = v1 + v4;
    int32_t v5 = g6; // 0x9992
    int32_t result = *(int32_t *)(v5 + (int32_t)&g47); // 0x9992
    int32_t v6 = *(int32_t *)(v5 + 16) - result; // 0x999a
    if (v6 != 0) {
        // 0x999e
        // branch -> 0x99b0
    } else {
        v6 = 0;
    }
    int32_t v7 = v1 + v6; // 0x99b0
    g6 = v7;
    *(int32_t *)(g4 + 16) = v7;
    return result;
}

// Address range: 0x99b5 - 0x99ea
int32_t function_99b5(void) {
    // 0x99b5
    g2 = g8;
    function_9d60();
    int32_t v1 = function_9d60(); // 0x99d0
    g2 = v1;
    int32_t v2 = g8; // 0x99d5
    int32_t v3 = *(int32_t *)(v2 + (int32_t)&g29); // 0x99d5
    g6 = v3;
    g3 = v1;
    g4 = v2;
    int32_t v4 = v2; // 0x99e0
    if (v3 == v2) {
        // bb
        function_9a06();
        v4 = g4;
        // branch -> 0x99e0
    }
    int32_t v5 = *(int32_t *)(v4 + (int32_t)&g47); // 0x99e0
    int32_t result = v5; // 0x99e7
    if (v5 == 0) {
        // bb5
        result = function_99ef();
        // branch -> 0x99e7
    }
    // 0x99e7
    return result;
}

// Address range: 0x99ef - 0x99f8
int32_t function_99ef(void) {
    int32_t v1 = g4; // 0x99ef
    g2 = v1;
    int32_t result = v1; // 0x99f5
    if (v1 == 0) {
        // bb
        result = function_99fd();
        // branch -> 0x99f5
    }
    // 0x99f5
    return result;
}

// Address range: 0x99fd - 0x9a06
int32_t function_99fd(void) {
    // 0x99fd
    g4 = g8;
    return g2;
}

// Address range: 0x9a06 - 0x9a0d
int32_t function_9a06(void) {
    // 0x9a06
    int32_t result; // 0x9a0a
    if (g4 == 0) {
        // bb
        result = function_9a12();
        // branch -> 0x9a0a
    } else {
        // 0x9a06
        result = g2;
        // branch -> 0x9a0a
    }
    // 0x9a0a
    return result;
}

// Address range: 0x9a12 - 0x9a31
int32_t function_9a12(void) {
    // 0x9a12
    *(int32_t *)(g8 + (int32_t)&g29) = g3;
    *(int32_t *)g8 = 0;
    int32_t result;
    *(int32_t *)(g8 + (int32_t)&g37) = result;
    return result;
}

// Address range: 0x9a31 - 0x9a54
int32_t function_9a31(void) {
    // 0x9a31
    return 3 << (uint32_t)(int32_t)&g25;
}

// Address range: 0x9a58 - 0x9a67
int32_t function_9a58(int32_t a1) {
    int32_t result = g2; // 0x9a60
    g3 = result;
    return result;
}

// Address range: 0x9a67 - 0x9a6a
int32_t function_9a67(int32_t a1) {
    // 0x9a67
    return g2;
}

// Address range: 0x9a6f - 0x9a76
int32_t function_9a6f(void) {
    // 0x9a6f
    return 0;
}

// Address range: 0x9a76 - 0x9aaa
int32_t function_9a76(void) {
    // 0x9a76
    int32_t v1;
    g4 = -0x55555555 * (v1 - g2 >> (int32_t)&g25);
    return function_98e7(0);
}

// Address range: 0x9aaa - 0x9aab
int32_t function_9aaa(void) {
    // 0x9aaa
    return g2;
}

// Address range: 0x9aaf - 0x9ab0
int32_t function_9aaf(void) {
    // 0x9aaf
    return g2;
}

// Address range: 0x9ab6 - 0x9af3
int32_t function_9ab6(int32_t a1, int32_t result) {
    int32_t * v1 = (int32_t *)-0x74de8b01; // 0x9ab6
    *v1 = *v1 + 1;
    g2 = 0;
    int32_t v2 = 0; // edi
    int32_t v3 = 0; // 0x9abf
    if (v2 == v3) {
        // 0x9ae4
        if (result == 0) {
            // bb
            function_9af8();
            // branch -> 0x9aec
        }
        // 0x9aec
        return result;
    }
    int32_t v4 = v3 + (int32_t)&g16; // 0x9ac6
    g2 = unknown_112f0(v3);
    while (v2 != v4) {
        // 0x9ac3
        v3 = v4;
        v4 = v3 + (int32_t)&g16;
        g2 = unknown_112f0(v3);
        // continue -> 0x9ac3
    }
    // 0x9ae4
    if (result == 0) {
        // bb
        function_9af8();
        // branch -> 0x9aec
    }
    // 0x9aec
    return result;
}

// Address range: 0x9af8 - 0x9b03
int32_t function_9af8(void) {
    // 0x9af8
    return function_9aaf();
}

// Address range: 0x9b04 - 0x9b05
int32_t function_9b04(void) {
    // 0x9b04
    return 0;
}

// Address range: 0x9b13 - 0x9b14
int32_t function_9b13(void) {
    // 0x9b13
    return 0;
}

// Address range: 0x9b26 - 0x9b27
int32_t function_9b26(void) {
    // 0x9b26
    return 0;
}

// Address range: 0x9b48 - 0x9b5c
int32_t function_9b48(int32_t a1) {
    // 0x9b48
    return function_9aaf();
}

// Address range: 0x9b60 - 0x9c40
// Demangled:     void std::vector<char, zero_after_free_allocator<char> >::_M_range_insert<char const *>(__gnu_cxx::__normal_iterator<char *, std::vector<char, zero_after_free_allocator<char> > >, char const *, char const *, std::forward_iterator_tag)
int32_t _ZNSt6vectorIc25zero_after_free_allocatorIcEE15_M_range_insertIPKcEEvN9__gnu_cxx17__normal_iteratorIPcS2_EET_SA_St20forward_iterator_tag(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g3; // 0x9b60
    g4 = a4;
    g6 = v1;
    g8 = a2;
    if (a4 == a3) {
        // 0x9bf0
        g3 = v2;
        return 0;
    }
    int32_t v3 = *(int32_t *)(v1 + (int32_t)&g29); // 0x9b8b
    g5 = v3;
    uint32_t v4 = a4 - a3; // 0x9b93
    g3 = v4;
    if (v4 > *(int32_t *)(v1 + (int32_t)&g37) - v3) {
        int32_t v5 = *a1; // 0x9c10
        int32_t v6 = v3 - v5; // 0x9c12
        int32_t v7 = -1 - v6; // 0x9c1a
        g2 = v7;
        int32_t result = v7; // 0x9c3d5
        uint32_t v8 = v6; // 0x9c26
        if (v4 > v7) {
            int32_t v9 = function_9df4(a3, v5); // 0x9c1e
            g2 = v9;
            result = v9;
            v8 = v6;
            // branch -> 0x9c24
        }
        int32_t v10 = v4 < v8 ? v8 : v4; // 0x9c26
        g3 = v10;
        int32_t v11 = v10 + v8; // 0x9c29
        g5 = v11;
        if (v11 >= v8) {
            // bb40
            result = function_9d00(-1);
            // branch -> 0x9c39
        }
        // 0x9c39
        return result;
    }
    int32_t v12 = v3 - a2; // 0x9b9d
    if (v4 >= v12) {
        // bb
        function_9d20((char *)v12, a3);
        v3 = g5;
        // branch -> 0x9bab
    }
    int32_t v13 = v3 - v4; // 0x9bad
    int32_t v14; // 0x9bd8
    if (v4 == 0) {
        // 0x9bab
        v14 = g6;
        // branch -> 0x9bd6
    } else {
        // branch -> 0x9bc0
        while (true) {
            int32_t v15 = v3; // 0x9bcf
            int32_t v16 = 0; // 0x9bcc
            if (v3 != 0) {
                // 0x9bc4
                *(char *)v3 = *(char *)v13;
                v15 = g5;
                v16 = v3;
                // branch -> 0x9bc9
            }
            int32_t v17 = v13 + 1; // 0x9bc9
            v13 = v17;
            if (v17 == v15) {
                // break -> 0x9bd3
                break;
            }
            v3 = v16 + 1;
            v13 = v17;
            // continue -> 0x9bc0
        }
        int32_t v18 = g6; // 0x9bd3
        v14 = v18;
        v3 = *(int32_t *)(v18 + (int32_t)&g29);
        // branch -> 0x9bd6
    }
    // 0x9bd6
    *(int32_t *)(v14 + (int32_t)&g29) = v3 + v4;
    int32_t v19 = v13 - g8; // 0x9bdf
    g2 = v19;
    int32_t result2 = v19; // 0x9c0816
    if (v19 != 0) {
        int32_t v20 = function_9dd8(); // 0x9be1
        g2 = v20;
        result2 = v20;
        // branch -> 0x9be7
    }
    if (v4 != 0) {
        // bb37
        result2 = function_9dc0();
        // branch -> 0x9bf0
    }
    // 0x9bf0
    g3 = v2;
    return result2;
}

// Address range: 0x9c4f - 0x9cd9
int32_t function_9c4f(char * a1) {
    // 0x9c4f
    char * v1;
    int32_t v2 = (int32_t)v1; // 0x9c4f
    int32_t v3 = g8; // 0x9c4f
    int32_t v4 = (int32_t)a1; // 0x9c53
    int32_t v5 = v4; // ebp
    int32_t v6 = v4; // 0x9c81
    int32_t v7; // eax
    int32_t v8; // edx
    if (v2 != v3) {
        // 0x9c59
        v8 = v2;
        v7 = v4;
        int32_t v9 = v2; // 0x9c64
        int32_t v10 = v4; // 0x9c67
        // branch -> 0x9c60
        int32_t v11; // 0x9c73
        while (true) {
            // 0x9c60
            v11 = v3;
            int32_t v12 = 0; // 0x9c6c
            int32_t v13 = v9; // 0x9c69
            if (v10 != 0) {
                // 0x9c64
                *(char *)v10 = *(char *)v9;
                v11 = g8;
                v12 = v7;
                v13 = v8;
                // branch -> 0x9c69
            }
            int32_t v14 = v13 + 1; // 0x9c69
            v8 = v14;
            int32_t v15 = v12 + 1; // 0x9c6c
            v7 = v15;
            if (v14 == v11) {
                // break -> 0x9c73
                break;
            }
            v3 = v11;
            v9 = v14;
            v10 = v15;
            // continue -> 0x9c60
        }
        int32_t v16 = v11 - v2 + v4; // 0x9c79
        v5 = v16;
        v6 = v16;
        // branch -> 0x9c7d
    }
    // 0x9c7d
    char * v17;
    int32_t v18 = (int32_t)v17; // 0x9c7d
    v7 = v18;
    v8 = v6;
    int32_t v19 = v18; // 0x9c8c
    // branch -> 0x9c88
    int32_t v20; // 0x9c91
    while (true) {
        int32_t v21 = 0; // 0x9c94
        int32_t v22 = v19; // 0x9c91
        if (v6 != 0) {
            // 0x9c8c
            *(char *)v6 = *(char *)v19;
            v21 = v8;
            v22 = v7;
            // branch -> 0x9c91
        }
        // 0x9c91
        v20 = v22 + 1;
        v7 = v20;
        int32_t v23 = v21 + 1; // 0x9c94
        v8 = v23;
        if (v20 == g4) {
            // break -> 0x9c9b
            break;
        }
        v19 = v20;
        v6 = v23;
        // continue -> 0x9c88
    }
    int32_t v24 = v5 + v20 - v18; // 0x9c9f
    g3 = v24;
    int32_t v25 = g6; // 0x9ca1
    int32_t v26 = *(int32_t *)(v25 + (int32_t)&g29); // 0x9ca1
    int32_t v27 = g8; // 0x9ca4
    if (v26 != v27) {
        // 0x9ca8
        v8 = v27;
        int32_t v28 = v26; // 0x9cbf15
        // branch -> 0x9cb0
        int32_t v29; // 0x9cb9
        while (true) {
            int32_t v30 = v28; // 0x9cbf
            int32_t v31 = 0; // 0x9cbc
            int32_t v32 = v27; // 0x9cb9
            if (v24 != 0) {
                // 0x9cb4
                *(char *)v24 = *(char *)v27;
                v30 = v26;
                v31 = v24;
                v32 = v8;
                // branch -> 0x9cb9
            }
            // 0x9cb9
            v29 = v32 + 1;
            v8 = v29;
            if (v29 == v30) {
                // break -> 0x9cc3
                break;
            }
            v28 = v30;
            v27 = v29;
            v24 = v31 + 1;
            // continue -> 0x9cb0
        }
        // 0x9cc3
        g3 += v29 - g8;
        v25 = g6;
        // branch -> 0x9cc7
    }
    int32_t v33 = *(int32_t *)(v25 + (int32_t)&g37); // 0x9cd0
    if (v25 == 0) {
        // bb
        v33 = function_9ce6();
        // branch -> 0x9cd0
    }
    // 0x9cd0
    return v33 - v25;
}

// Address range: 0x9ce6 - 0x9cfb
int32_t function_9ce6(void) {
    // 0x9ce6
    *(int32_t *)(g6 + (int32_t)&g29) = g3;
    int32_t v1 = 0; // eax
    *(int32_t *)g6 = v1;
    int32_t v2;
    int32_t result = v1 + v2; // 0x9cef
    *(int32_t *)(g6 + (int32_t)&g37) = result;
    return result;
}

// Address range: 0x9d00 - 0x9d1d
int32_t function_9d00(int32_t a1) {
    // 0x9d00
    if (g5 != 0) {
        // bb
        function_9e00();
        // branch -> 0x9d08
    }
    // 0x9d08
    return function_9c4f(NULL);
}

// Address range: 0x9d20 - 0x9d5f
int32_t function_9d20(char * a1, int32_t a2) {
    int32_t v1 = g5; // 0x9d24
    int32_t v2 = v1; // eax
    int32_t v3 = (int32_t)a1; // 0x9d26
    int32_t v4 = v3 + a2; // 0x9d26
    int32_t v5 = v4; // edx
    int32_t v6; // 0x9d56
    int32_t v7; // 0x9d5a
    if (g4 == v4) {
        // 0x9d20
        v7 = g6;
        v6 = v1;
        // branch -> 0x9d52
    } else {
        int32_t v8 = g4; // 0x9d475
        int32_t v9 = v1; // 0x9d3f
        while (true) {
            int32_t v10 = v8; // 0x9d47
            int32_t v11 = 0; // 0x9d44
            int32_t v12 = v4; // 0x9d41
            if (v9 != 0) {
                // 0x9d3c
                *(char *)v9 = *(char *)v4;
                v10 = g4;
                v11 = v2;
                v12 = v5;
                // branch -> 0x9d41
            }
            int32_t v13 = v12 + 1; // 0x9d41
            v5 = v13;
            int32_t v14 = v11 + 1; // 0x9d44
            v2 = v14;
            if (v13 == v10) {
                // break -> 0x9d4b
                break;
            }
            v8 = v10;
            v4 = v13;
            v9 = v14;
            // continue -> 0x9d38
        }
        // 0x9d4b
        g5 = v1;
        int32_t v15 = g6; // 0x9d4f
        int32_t v16 = *(int32_t *)(v15 + (int32_t)&g29); // 0x9d4f
        v2 = v16;
        v7 = v15;
        v6 = v16;
        // branch -> 0x9d52
    }
    int32_t v17 = g3 - v3 + v6; // 0x9d56
    g3 = v17;
    *(int32_t *)(v7 + (int32_t)&g29) = v17;
    int32_t result; // 0x9d5d
    if (v1 == g8) {
        // bb
        result = function_9d7f();
        // branch -> 0x9d5f
    } else {
        // 0x9d52
        result = v2;
        // branch -> 0x9d5f
    }
    // 0x9d5f
    return result;
}

// Address range: 0x9d60 - 0x9d61
int32_t function_9d60(void) {
    // 0x9d60
    return g2;
}

// Address range: 0x9d7f - 0x9dc0
int32_t function_9d7f(void) {
    // 0x9d7f
    int32_t v1;
    int32_t v2;
    g2 = v2 - v1;
    int32_t v3;
    *(int32_t *)(g6 + (int32_t)&g29) = g3 + v3;
    int32_t v4;
    int32_t result; // 0x9dbd
    if (v4 != 0x2074c085) {
        // bb
        result = function_9def();
        // branch -> 0x9da1
    } else {
        // 0x9d7f
        result = g2;
        // branch -> 0x9da1
    }
    // 0x9da1
    return result;
}

// Address range: 0x9dc0 - 0x9dd3
int32_t function_9dc0(void) {
    // 0x9dc0
    int32_t v1;
    int32_t result; // 0x9dd1
    if (v1 != 0x2074c085) {
        // bb
        result = function_9def();
        // branch -> 0x9dcd
    } else {
        // 0x9dc0
        result = g2;
        // branch -> 0x9dcd
    }
    // 0x9dcd
    return result;
}

// Address range: 0x9dd8 - 0x9de5
int32_t function_9dd8(void) {
    // 0x9dd8
    return g2;
}

// Address range: 0x9dea - 0x9def
int32_t function_9dea(void) {
    // 0x9dea
    return 0;
}

// Address range: 0x9def - 0x9df4
int32_t function_9def(void) {
    // 0x9def
    return g2;
}

// Address range: 0x9df4 - 0x9dfb
int32_t function_9df4(int32_t a1, int32_t a2) {
    // 0x9df4
    return g2;
}

// Address range: 0x9e00 - 0x9e09
int32_t function_9e00(void) {
    // 0x9e00
    return g2;
}

// Address range: 0x9e10 - 0x9e3e
// Demangled:     boost::unique_lock<AnnotatedMixin<boost::recursive_mutex> >::lock()
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(int32_t * a1) {
    int32_t result = 0; // 0x9e3b
    if (*(char *)((int32_t)a1 + (int32_t)&g29) != 0) {
        // bb
        result = function_9f12(0x2074c085, 0, 0, 0);
        // branch -> 0x9e30
    }
    // 0x9e30
    return result;
}

// Address range: 0x9e58 - 0x9e67
int32_t function_9e58(void) {
    // 0x9e58
    g7 = 1;
    if (g2 == *(int32_t *)(g4 + 76)) {
        // bb
        g2 = function_9eb3();
        // branch -> 0x9e62
    }
    // 0x9e62
    return function_9e7c();
}

// Address range: 0x9e68 - 0x9e6f
int32_t function_9e68(void) {
    // 0x9e68
    return g2;
}

// Address range: 0x9e7c - 0x9e88
int32_t function_9e7c(void) {
    // 0x9e7c
    if ((char)g7 != 0) {
        // bb
        g2 = function_9e68();
        // branch -> 0x9e80
    }
    int32_t * v1 = (int32_t *)(g4 + 80); // 0x9e80
    *v1 = *v1 + 1;
    *(char *)(g4 + (int32_t)&g28) = 1;
    return g2;
}

// Address range: 0x9e97 - 0x9eb3
int32_t function_9e97(void) {
    // 0x9e97
    *(char *)(g6 + (int32_t)&g29) = 1;
    int32_t v1;
    return v1 ^ 0x2074c085;
}

// Address range: 0x9eb3 - 0x9ec7
int32_t function_9eb3(void) {
    int32_t * v1 = (int32_t *)(g4 + 80); // 0x9eb3
    *v1 = *v1 + 1;
    char v2;
    if (v2 == 0) {
        // bb
        function_9e97();
        // branch -> 0x9ebe
    }
    // 0x9ebe
    int32_t result;
    return result;
}

// Address range: 0x9efd - 0x9efe
int32_t function_9efd(void) {
    // 0x9efd
    return 0;
}

// Address range: 0x9f12 - 0x9f40
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_9f12(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x9f12
    int32_t v1; // bp+28
    int32_t v2 = &v1; // 0x9f12
    v1 = (int32_t)&g60;
    g2 = unknown_125f0(v2);
    return function_101c0(v2);
}

// Address range: 0x9f50 - 0x9fd5
// Demangled:     CMutexLock<AnnotatedMixin<boost::recursive_mutex> >::CMutexLock(AnnotatedMixin<boost::recursive_mutex> &, char const *, char const *, int, bool)
int32_t _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g4; // 0x9f53
    g4 = (int32_t)a1;
    int32_t v2 = g8; // 0x9f5b
    g8 = a2;
    g2 = 0;
    int32_t v3 = g6; // 0x9f74
    *a1 = a2;
    *(char *)(g4 + (int32_t)&g29) = 0;
    int32_t v4; // 0x9f7e
    if ((char)a3 == 0) {
        // bb
        v4 = function_9fe8(0x2074c085, v1, v2, v3);
        g2 = v4;
        // branch -> 0x9f80
    } else {
        // 0x9f50
        v4 = g2;
        // branch -> 0x9f80
    }
    int32_t v5 = g8; // 0x9f80
    int32_t result = v4; // 0x9fd4
    int32_t v6 = v5; // 0x9f97
    if (v4 != 0) {
        int32_t v7 = function_9ff7(v5); // 0x9f8a
        g2 = v7;
        result = v7;
        v6 = g8;
        // branch -> 0x9f8c
    }
    // 0x9f8c
    if (*(char *)(v6 + (int32_t)&g28) != 0) {
        // 0x9fd8
        return result;
    }
    int32_t * v8 = (int32_t *)(v6 + 80); // 0x9f97
    *v8 = *v8 + 1;
    *(char *)(g8 + (int32_t)&g28) = 1;
    *(int32_t *)(g8 + 76) = g2;
    int32_t v9 = g8; // 0x9fa7
    if (g2 != 0) {
        // bb16
        function_9ffc(v9);
        // branch -> 0x9fb3
    }
    // 0x9fb3
    *(char *)(g4 + (int32_t)&g29) = (char)1;
    g8 = v2;
    g6 = v3;
    return 0;
}

// Address range: 0x9fdd - 0x9fe6
int32_t function_9fdd(void) {
    // 0x9fdd
    return 0;
}

// Address range: 0x9fe8 - 0x9ff2
int32_t function_9fe8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x9fe8
    return unknown_13d60(g4);
}

// Address range: 0x9ff2 - 0x9ff7
int32_t function_9ff2(void) {
    // 0x9ff2
    return g2;
}

// Address range: 0x9ff7 - 0x9ffc
int32_t function_9ff7(int32_t a1) {
    // 0x9ff7
    return function_ff32();
}

// Address range: 0x9ffc - 0xa017
int32_t function_9ffc(int32_t a1) {
    // 0x9ffc
    unknown_ff66();
    return unknown_12fb0(g4);
}

// Address range: 0xa020 - 0xa049
// Demangled:     void std::_Destroy<std::vector<int, std::allocator<int> > *>(std::vector<int, std::allocator<int> > *, std::vector<int, std::allocator<int> > *)
int32_t _ZSt8_DestroyIPSt6vectorIiSaIiEEEvT_S4_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    g4 = v1;
    g8 = a2;
    int32_t v2 = v1; // 0xa040
    if (v1 == a2) {
        // bb
        function_a055(0x2074c085, 0, 0);
        v2 = g4;
        // branch -> 0xa03d
    }
    int32_t v3 = *(int32_t *)v2; // 0xa040
    g2 = v3;
    int32_t result = v3; // 0xa046
    if (v3 == 0) {
        // bb106
        result = function_a04e();
        // branch -> 0xa046
    }
    // 0xa046
    return result;
}

// Address range: 0xa04e - 0xa055
int32_t function_a04e(void) {
    // 0xa04e
    return g2;
}

// Address range: 0xa055 - 0xa068
int32_t function_a055(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = a1 ^ 0x2074c085; // 0xa059
    if (result != 0) {
        // 0xa068
        return result;
    }
    // 0xa062
    g4 = a2;
    g8 = a3;
    return result;
}

// Address range: 0xa070 - 0xa0ac
// Demangled:     std::vector<int, std::allocator<int> > * std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >::_M_allocate_and_copy<__gnu_cxx::__normal_iterator<std::vector<int, std::allocator<int> > const *, std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > > >(unsigned int, __gnu_cxx::__normal_iterator<std::vector<int, std::allocator<int> > const *, std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > >, __gnu_cxx::__normal_iterator<std::vector<int, std::allocator<int> > const *, std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > >)
int32_t _ZNSt6vectorIS_IiSaIiEESaIS1_EE20_M_allocate_and_copyIN9__gnu_cxx17__normal_iteratorIPKS1_S3_EEEEPS1_jT_SB_(int32_t a1, int32_t a2, int32_t a3) {
    // 0xa070
    g2 = a1;
    g8 = a2;
    g3 = a3;
    int32_t v1 = a1; // 0xa098
    if (a1 == 0) {
        int32_t v2 = function_a171(0x2074c085); // 0xa092
        g2 = v2;
        v1 = v2;
        // branch -> 0xa098
    }
    // 0xa098
    int32_t v3; // 0xa0a3
    if (v1 >= 0x15555556) {
        // bb111
        v3 = function_a1a5();
        // branch -> 0xa0a3
    } else {
        v3 = v1;
    }
    // 0xa0a3
    return 12 * v3;
}

// Address range: 0xa0b5 - 0xa0c3
int32_t function_a0b5(int32_t a1) {
    // 0xa0b5
    if (g3 == g8) {
        // bb
        g2 = function_a158();
        // branch -> 0xa0bd
    }
    // 0xa0bd
    g4 = a1;
    return function_a129();
}

// Address range: 0xa0c8 - 0xa0e1
int32_t function_a0c8(void) {
    // 0xa0c8
    int32_t result; // 0xa0df
    if ((uint32_t)g6 < 0x40000000) {
        // 0xa0c8
        result = g2;
        // branch -> 0xa0d4
    } else {
        // bb
        result = function_a17e();
        // branch -> 0xa0d4
    }
    // 0xa0d4
    return result;
}

// Address range: 0xa0e1 - 0xa111
int32_t function_a0e1(void) {
    // 0xa0e1
    *(int32_t *)(g4 + (int32_t)&g37) = g7 + g6;
    g6 = 0;
    *(int32_t *)g4 = g7;
    *(int32_t *)(g4 + (int32_t)&g29) = g7;
    int32_t v1 = g8; // 0xa0ed
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g29) - v1; // 0xa0f2
    int32_t result = v2 / 4; // 0xa0f4
    g2 = result;
    if (v2 < 4) {
        // bb
        result = function_a11a();
        // branch -> 0xa0fb
    }
    // 0xa0fb
    return result;
}

// Address range: 0xa11a - 0xa11f
int32_t function_a11a(void) {
    // 0xa11a
    *(int32_t *)(g4 + (int32_t)&g29) = g6 + g7;
    return g2;
}

// Address range: 0xa11f - 0xa129
int32_t function_a11f(void) {
    // 0xa11f
    g8 += (int32_t)&g47;
    g4 += (int32_t)&g47;
    return g2;
}

// Address range: 0xa129 - 0xa157
int32_t function_a129(void) {
    int32_t v1 = g4; // 0xa129
    int32_t v2 = v1; // 0xa132
    if (v1 == 0) {
        // bb
        g2 = function_a11f();
        v2 = g4;
        // branch -> 0xa12d
    }
    int32_t v3 = g8; // 0xa12d
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g29); // 0xa12d
    int32_t v5 = v4 - v3; // edi
    *(int32_t *)v2 = 0;
    *(int32_t *)(g4 + (int32_t)&g29) = 0;
    g6 = v5 / 4;
    *(int32_t *)(g4 + (int32_t)&g37) = 0;
    if (v5 >= 4) {
        // bb2
        function_a0c8();
        // branch -> 0xa151
    }
    // 0xa151
    g6 = 0;
    g7 = 0;
    return function_a0e1();
}

// Address range: 0xa158 - 0xa171
int32_t function_a158(void) {
    int32_t result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_a1a0();
        // branch -> 0xa169
    }
    // 0xa169
    return result;
}

// Address range: 0xa171 - 0xa17e
int32_t function_a171(int32_t a1) {
    // 0xa171
    return function_a0b5(0);
}

// Address range: 0xa17e - 0xa17f
int32_t function_a17e(void) {
    // 0xa17e
    return g2;
}

// Address range: 0xa1a0 - 0xa1a1
int32_t function_a1a0(void) {
    // 0xa1a0
    return g2;
}

// Address range: 0xa1a5 - 0xa1a6
int32_t function_a1a5(void) {
    // 0xa1a5
    return g2;
}

// Address range: 0xa1ab - 0xa1ac
int32_t function_a1ab(void) {
    // 0xa1ab
    return 0;
}

// Address range: 0xa1d3 - 0xa1d4
int32_t function_a1d3(void) {
    // 0xa1d3
    return 0;
}

// Address range: 0xa1f0 - 0xa239
// Demangled:     void std::_Destroy<std::set<int, std::less<int>, std::allocator<int> > *>(std::set<int, std::less<int>, std::allocator<int> > *, std::set<int, std::less<int>, std::allocator<int> > *)
int32_t _ZSt8_DestroyIPSt3setIiSt4lessIiESaIiEEEvT_S6_(int32_t a1, int32_t a2) {
    // 0xa1f0
    if (a1 == a2) {
        // 0xa226
        return 0;
    }
    unknown_13360(a1, *(int32_t *)(a1 + (int32_t)&g37));
    while (a2 != a1 + (int32_t)&g16) {
        // 0xa210
        a1 += (int32_t)&g16;
        unknown_13360(a1, *(int32_t *)(a1 + (int32_t)&g37));
        // continue -> 0xa210
    }
    // 0xa226
    // branch -> 0xa226
    // 0xa226
    return 0;
}

// Address range: 0xa240 - 0xa2b8
// Demangled:     std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, int const &)
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE10_M_insert_EPKSt18_Rb_tree_node_baseS8_RKi(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5) {
    int32_t result = (int32_t)a3;
    g7 = a5;
    g6 = a4;
    if (a3 == NULL) {
        // bb
        result = function_a2f0(0x2074c085);
        a5 = g7;
        // branch -> 0xa27f
    }
    int32_t v1 = result + 16; // 0xa29b
    if (v1 != 0) {
        // 0xa2a0
        *(int32_t *)v1 = *(int32_t *)a5;
        // branch -> 0xa2a5
    }
    // 0xa2a5
    return result;
}

// Address range: 0xa2bc - 0xa2ec
int32_t function_a2bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7ce3dbbc; // 0xa2bc
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0xa2c3
    int32_t result = 0; // esi
    *(int32_t *)result = (v2 + 1 + (int32_t)false) % 256 | v2 & -256;
    g2 = result;
    if (a1 != 0x2074c085) {
        // bb
        result = function_a306();
        // branch -> 0xa2d6
    }
    // 0xa2d6
    return result;
}

// Address range: 0xa2f0 - 0xa306
int32_t function_a2f0(int32_t a1) {
    int32_t v1 = *(int32_t *)(g6 + 16); // 0xa2f4
    int32_t v2 = g7; // 0xa2f7
    int32_t v3 = v2 - v1; // 0xa2f7
    return v3 < 0 != ((v3 ^ v2) & (v2 ^ v1)) < 0;
}

// Address range: 0xa306 - 0xa30b
int32_t function_a306(void) {
    // 0xa306
    return g2;
}

// Address range: 0xa310 - 0xa3a8
// Demangled:     std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::_M_insert_unique(int const &)
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE16_M_insert_uniqueERKi(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    g6 = a2;
    g4 = v1;
    int32_t result = *(int32_t *)(a2 + (int32_t)&g37); // 0xa32f
    g8 = result;
    int32_t v2; // 0xa397
    if (result == 0) {
        // 0xa397
        v2 = a2 + (int32_t)&g29;
        g8 = v2;
        // branch -> 0xa3a0
    } else {
        int32_t v3 = *(int32_t *)a3; // 0xa33e
        // branch -> 0xa356
        while (true) {
            int32_t v4 = *(int32_t *)(result + 16); // 0xa356
            int32_t result2; // 0xa3a3
            int32_t v5; // 0xa348
            int32_t v6; // 0xa376
            if (v4 > v3) {
                // 0xa348
                v5 = *(int32_t *)(result + (int32_t)&g37);
                if (v5 == 0) {
                    // 0xa3a0
                    if (result != *(int32_t *)(a2 + (int32_t)&g47)) {
                        // 0xa3a5
                        return result;
                    }
                    // bb129
                    result2 = function_a3c0(v4);
                    // branch -> 0xa3a5
                    // 0xa3a5
                    return result2;
                    // 0xa372
                    if (v4 >= v3) {
                        // 0xa378
                        *(int32_t *)v1 = result;
                        *(char *)(g4 + (int32_t)&g29) = 0;
                        return g4;
                    }
                    // bb
                    v6 = function_a3c0(v4);
                    // branch -> 0xa378
                    // 0xa378
                    *(int32_t *)g4 = v6;
                    *(char *)(g4 + (int32_t)&g29) = 0;
                    return g4;
                }
            } else {
                int32_t v7 = *(int32_t *)(result + (int32_t)&g47); // 0xa35d
                if (v7 == 0) {
                    // 0xa372
                    if (v4 >= v3) {
                        // 0xa378
                        *(int32_t *)v1 = result;
                        *(char *)(g4 + (int32_t)&g29) = 0;
                        return g4;
                    }
                    // bb
                    v6 = function_a3c0(v4);
                    // branch -> 0xa378
                    // 0xa378
                    *(int32_t *)g4 = v6;
                    *(char *)(g4 + (int32_t)&g29) = 0;
                    return g4;
                }
                v5 = v7;
            }
            // 0xa354
            g8 = v5;
            result = v5;
            // branch -> 0xa356
        }
    }
    int32_t result3 = 0; // 0xa3a5
    if (v2 == *(int32_t *)(a2 + (int32_t)&g47)) {
        // bb129
        int32_t v8;
        result3 = function_a3c0(v8);
        // branch -> 0xa3a5
    }
    // 0xa3a5
    return result3;
}

// Address range: 0xa3c0 - 0xa3f3
int32_t function_a3c0(int32_t result) {
    // 0xa3c0
    int32_t v1; // bp+44
    unknown_14550((int32_t)&v1, g6, 0, g8, result);
    *(char *)(g4 + (int32_t)&g29) = 1;
    *(int32_t *)g4 = result;
    return result;
}

// Address range: 0xa3f3 - 0xa3f8
int32_t function_a3f3(void) {
    // 0xa3f3
    return g2;
}

// Address range: 0xa400 - 0xa4a2
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::_M_fill_insert(__gnu_cxx::__normal_iterator<unsigned char *, std::vector<unsigned char, std::allocator<unsigned char> > >, unsigned int, unsigned char const &)
int32_t _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    g4 = a3;
    g7 = a4;
    g8 = v1;
    g6 = a2;
    if (a3 == 0) {
        // bb
        function_a50c(0x2074c085);
        v1 = g8;
        // branch -> 0xa437
    }
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g29); // 0xa437
    g3 = v2;
    int32_t v3 = *(int32_t *)(v1 + (int32_t)&g37) - v2; // 0xa43d
    g2 = v3;
    if (v3 >= a3) {
        // bb26
        function_a538();
        v2 = g3;
        v1 = g8;
        // branch -> 0xa447
    }
    int32_t v4 = *(int32_t *)v1; // 0xa447
    g2 = v4;
    int32_t v5 = v2 - v4; // 0xa449
    uint32_t v6 = v5; // 0xa466
    if (-1 - v5 < a3) {
        int32_t v7 = function_a676(); // 0xa451
        g2 = v7;
        v4 = v7;
        v6 = v5;
        // branch -> 0xa457
    }
    int32_t v8 = v6 >= a3 ? v6 : a3; // 0xa45b
    int32_t v9 = v8 + v6; // 0xa466
    if (v9 < v6) {
        // bb28
        g2 = function_a5e8(v8);
        // branch -> 0xa47c
    }
    // 0xa47c
    if (v9 != 0) {
        // bb29
        function_a5e1();
        // branch -> 0xa484
    }
    // 0xa484
    return g6 - v4;
}

// Address range: 0xa4c4 - 0xa4d4
int32_t function_a4c4(void) {
    int32_t * v1 = (int32_t *)-0x74dfdbac; // 0xa4c4
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    g2 = v2 + 1 & 255 | v2 & -256;
    return function_db31da01();
}

// Address range: 0xa4d8 - 0xa4db
int32_t function_a4d8(void) {
    // 0xa4d8
    return 0;
}

// Address range: 0xa50c - 0xa531
int32_t function_a50c(int32_t a1) {
    int32_t v1 = a1 ^ 0x2074c085; // 0xa510
    g2 = v1;
    int32_t result = v1; // 0xa530
    if (v1 != 0) {
        // bb
        result = function_a671();
        // branch -> 0xa51d
    }
    // 0xa51d
    return result;
}

// Address range: 0xa538 - 0xa56c
int32_t function_a538(void) {
    // 0xa538
    g5 = (int32_t)*(char *)&g7;
    int32_t v1 = g3 - g6; // 0xa53d
    g7 = v1;
    int32_t v2 = g4; // 0xa53f
    int32_t v3 = v2; // 0xa54b
    if (v2 >= v1) {
        // bb
        function_a608();
        v3 = g4;
        // branch -> 0xa547
    }
    // 0xa547
    g7 = g3 - v3;
    int32_t result = v3; // 0xa569
    if (v3 == 0) {
        // bb10
        result = function_a581(0);
        // branch -> 0xa559
    }
    // 0xa559
    return result;
}

// Address range: 0xa581 - 0xa5dc
int32_t function_a581(int32_t a1) {
    int32_t v1 = g7 - g6; // 0xa587
    g7 = v1;
    *(int32_t *)(g8 + (int32_t)&g29) = g4 + a1;
    if (v1 != 0) {
        // 0xa58e
        g5 %= 256;
        // branch -> 0xa5a9
    }
    // 0xa5a9
    int32_t v2;
    int32_t v3 = v2 ^ 0x2074c085; // 0xa5ad
    g2 = v3;
    int32_t result = v3; // 0xa5d9
    if (v3 != 0) {
        // bb
        result = function_a671();
        // branch -> 0xa5ba
    }
    // 0xa5ba
    return result;
}

// Address range: 0xa5e1 - 0xa5e8
int32_t function_a5e1(void) {
    // 0xa5e1
    return g2;
}

// Address range: 0xa5e8 - 0xa603
int32_t function_a5e8(int32_t a1) {
    // 0xa5e8
    return g2;
}

// Address range: 0xa608 - 0xa624
int32_t function_a608(void) {
    int32_t v1 = g4; // 0xa608
    g4 = g5 % 256;
    g5 = v1 - g7;
    return g2;
}

// Address range: 0xa64a - 0xa671
int32_t function_a64a(int32_t a1) {
    int32_t * v1 = (int32_t *)0x548b0446; // 0xa64a
    *v1 = *v1 - 1;
    *(int32_t *)(int32_t)&g29 = 0;
    int32_t v2 = a1 ^ 0x2074c085; // 0xa65b
    g2 = v2;
    int32_t result = v2; // 0xa66c
    if (v2 != 0) {
        // bb
        result = function_a671();
        // branch -> 0xa664
    }
    // 0xa664
    return result;
}

// Address range: 0xa671 - 0xa672
int32_t function_a671(void) {
    // 0xa671
    return g2;
}

// Address range: 0xa676 - 0xa67d
int32_t function_a676(void) {
    // 0xa676
    return g2;
}

// Address range: 0xa690 - 0xa6f7
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, int>, std::_Select1st<std::pair<std::string const, int> >, std::less<std::string>, std::allocator<std::pair<std::string const, int> > >::equal_range(std::string const &)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE11equal_rangeERS1_(int32_t a1, int32_t a2, int32_t * a3) {
    int32_t v1 = a2 + (int32_t)&g29; // 0xa6b7
    int32_t result = v1; // 0xa6f3
    if (*(int32_t *)(a2 + (int32_t)&g37) == 0) {
        // bb
        result = function_a739(v1, (int32_t *)a1);
        // branch -> 0xa6c2
    }
    // 0xa6c2
    return result;
}

// Address range: 0xa70c - 0xa70d
int32_t function_a70c(void) {
    // 0xa70c
    return 0;
}

// Address range: 0xa720 - 0xa72c
int32_t function_a720(void) {
    int32_t * v1 = (int32_t *)-0x7a05d626; // 0xa720
    *v1 = *v1 - 1;
    unsigned char v2 = *(char *)&g6; // 0xa726
    *(char *)0 = v2 >> (char)&g29 | 16 * v2;
    return 0;
}

// Address range: 0xa739 - 0xa765
int32_t function_a739(int32_t a1, int32_t * a2) {
    int32_t result = (int32_t)a2;
    g7 = a1;
    *a2 = a1;
    *(int32_t *)(result + (int32_t)&g29) = g7;
    g2 = result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_a828();
        // branch -> 0xa75b
    }
    // 0xa75b
    return result;
}

// Address range: 0xa768 - 0xa780
int32_t function_a768(int32_t a1) {
    int32_t v1 = g8; // 0xa768
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g47); // 0xa768
    g3 = v2;
    int32_t v3 = *(int32_t *)(v1 + (int32_t)&g37); // 0xa76b
    g6 = v3;
    if (v2 == 0) {
        // bb
        function_a7c4();
        v3 = g6;
        // branch -> 0xa772
    }
    // 0xa772
    return function_a78b(v3, g8);
}

// Address range: 0xa780 - 0xa78b
int32_t function_a780(void) {
    // 0xa780
    return 0;
}

// Address range: 0xa78b - 0xa7a3
int32_t function_a78b(int32_t a1, int32_t a2) {
    // 0xa78b
    return *(int32_t *)(g3 + 16);
}

// Address range: 0xa7a7 - 0xa7b3
int32_t function_a7a7(void) {
    int32_t * v1 = (int32_t *)-0x7a05d626; // 0xa7a7
    *v1 = *v1 - 1;
    unsigned char v2 = *(char *)&g6; // 0xa7ad
    *(char *)0 = v2 >> (char)&g29 | 16 * v2;
    return 0;
}

// Address range: 0xa7b4 - 0xa7b5
int32_t function_a7b4(int16_t a1) {
    // 0xa7b4
    return 0;
}

// Address range: 0xa7bc - 0xa7bd
int32_t function_a7bc(void) {
    // 0xa7bc
    return 0;
}

// Address range: 0xa7c4 - 0xa7d2
int32_t function_a7c4(void) {
    // 0xa7c4
    if (g6 == 0) {
        // bb
        function_a816();
        // branch -> 0xa7c8
    }
    // 0xa7c8
    return function_a7e3(g8);
}

// Address range: 0xa7d8 - 0xa7e3
int32_t function_a7d8(void) {
    // 0xa7d8
    return 0;
}

// Address range: 0xa7e3 - 0xa7fd
int32_t function_a7e3(int32_t a1) {
    int32_t result = *(int32_t *)(g6 + 16); // 0xa7e3
    g3 = *(int32_t *)(result - 12) - g4;
    return result;
}

// Address range: 0xa812 - 0xa813
int32_t function_a812(void) {
    // 0xa812
    return 0;
}

// Address range: 0xa816 - 0xa828
int32_t function_a816(void) {
    // 0xa816
    int32_t v1;
    *(int32_t *)v1 = g8;
    int32_t result = 0; // eax
    *(int32_t *)(result + (int32_t)&g29) = 0;
    return result;
}

// Address range: 0xa828 - 0xa829
int32_t function_a828(void) {
    // 0xa828
    return g2;
}

// Address range: 0xa830 - 0xa859
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, int>, std::_Select1st<std::pair<std::string const, int> >, std::less<std::string>, std::allocator<std::pair<std::string const, int> > >::_M_erase_aux(std::_Rb_tree_const_iterator<std::pair<std::string const, int> >)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE12_M_erase_auxESt23_Rb_tree_const_iteratorIS2_E(int32_t a1) {
    // 0xa830
    int32_t result;
    return result;
}

// Address range: 0xa86b - 0xa890
int32_t function_a86b(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(int32_t)&g14; // 0xa873
    *v1 = *v1 - 1;
    int32_t result = a1 ^ 0x2074c085; // 0xa87b
    if (result != 0) {
        // 0xa890
        return result;
    }
    // 0xa884
    return result;
}

// Address range: 0xa8a0 - 0xa8f5
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, int>, std::_Select1st<std::pair<std::string const, int> >, std::less<std::string>, std::allocator<std::pair<std::string const, int> > >::erase(std::string const &)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE5eraseERS1_(int32_t a1, int32_t a2) {
    // 0xa8a0
    g8 = a1;
    int32_t v1; // bp-52
    unknown_14f30((int32_t)&v1, a1, a2);
    int32_t v2 = g8; // 0xa8cf
    g3 = *(int32_t *)(v2 + (int32_t)&g14);
    g6 = v1;
    int32_t v3;
    int32_t result = v3; // 0xa8f2
    if (*(int32_t *)(v2 + (int32_t)&g47) == v3) {
        // bb
        result = function_a930();
        v1 = g6;
        // branch -> 0xa8e4
    }
    // 0xa8e4
    if (v1 != result) {
        // 0xa8f2
        return result;
    }
    // 0xa8e8
    return function_a93b();
}

// Address range: 0xa915 - 0xa92c
int32_t function_a915(void) {
    // 0xa915
    g2 = g3;
    int32_t result = g3; // 0xa92b
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_a964();
        // branch -> 0xa924
    }
    // 0xa924
    return result;
}

// Address range: 0xa930 - 0xa93b
int32_t function_a930(void) {
    int32_t v1 = g8 + (int32_t)&g29; // 0xa930
    g4 = v1;
    int32_t result; // 0xa937
    if (v1 == g6) {
        // bb
        result = function_a93f();
        // branch -> 0xa937
    } else {
        // 0xa930
        result = g2;
        // branch -> 0xa937
    }
    // 0xa937
    return result;
}

// Address range: 0xa93b - 0xa93f
int32_t function_a93b(void) {
    // 0xa93b
    g3 = 0;
    return function_a915();
}

// Address range: 0xa93f - 0xa964
int32_t function_a93f(void) {
    int32_t v1 = g8; // 0xa93f
    unknown_13d50(v1, *(int32_t *)(v1 + (int32_t)&g37));
    *(int32_t *)(g8 + (int32_t)&g47) = g4;
    *(int32_t *)(g8 + (int32_t)&g37) = 0;
    *(int32_t *)(g8 + 16) = g4;
    *(int32_t *)(g8 + (int32_t)&g14) = 0;
    return function_a915();
}

// Address range: 0xa964 - 0xa965
int32_t function_a964(void) {
    // 0xa964
    return g2;
}

// Address range: 0xa970 - 0xa98c
// Demangled:     boost::exception_detail::error_info_injector<boost::gregorian::bad_year>::error_info_injector(boost::exception_detail::error_info_injector<boost::gregorian::bad_year> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian8bad_yearEEC1ERKS4_(int32_t a1, int32_t a2) {
    // 0xa970
    return a2 + (int32_t)&g29;
}

// Address range: 0xa9a0 - 0xaa04
int32_t function_a9a0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x3c70c46); // 0xa9a0
    *v2 = *v2 - 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + *(char *)&g2;
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g53;
    *(int32_t *)(v1 + (int32_t)&g47) = v3;
    if (v3 != 0) {
        // 0xa9b8
        // branch -> 0xa9c0
    }
    int32_t v4 = 0; // esi
    *(int32_t *)(v1 + (int32_t)&g37) = (int32_t)&g79;
    *(int32_t *)(v1 + 16) = *(int32_t *)(v4 + 16);
    int32_t v5 = *(int32_t *)(v4 + (int32_t)&g14); // 0xa9cd
    *(int32_t *)(v1 + (int32_t)&g14) = v5;
    int32_t v6 = *(int32_t *)(v4 + (int32_t)&g16); // 0xa9d3
    *(int32_t *)v1 = (int32_t)&g78;
    *(int32_t *)(v1 + (int32_t)&g16) = v6;
    int32_t result = a1 ^ 0x2074c085; // 0xa9e3
    g2 = result;
    if (result != 0) {
        // 0xa9f2
        return function_102c0(v1);
    }
    // 0xa9ec
    return result;
}

// Address range: 0xaa20 - 0xaa27
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE7rethrowEv(a1 - (int32_t)&g18); // 0xaa25
    return result;
}

// Address range: 0xaa30 - 0xaa4c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_year> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian8bad_yearEEEE7rethrowEv(int32_t a1) {
    // 0xaa30
    return 0;
}

// Address range: 0xaa50 - 0xaa57
int32_t function_aa50(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb8c; // 0xaa50
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xaaa0 - 0xaabc
// Demangled:     void boost::throw_exception<boost::gregorian::bad_year>(boost::gregorian::bad_year const &)
int32_t _ZN5boost15throw_exceptionINS_9gregorian8bad_yearEEEvRKT_(int32_t a1) {
    // 0xaaa0
    return 0;
}

// Address range: 0xaacb - 0xaace
int32_t function_aacb(void) {
    // 0xaacb
    return 0;
}

// Address range: 0xab55 - 0xab93
int32_t function_ab55(void) {
    int32_t * v1 = (int32_t *)0x241c89c6; // 0xab55
    *v1 = *v1 - 1;
    int32_t v2 = 0; // ebx
    *(int32_t *)(v2 + (int32_t)&g18) = (int32_t)&g56;
    unknown_119a0(v2);
    unknown_119a0(0);
    return 0;
}

// Address range: 0xab93 - 0xab95
int32_t function_ab93(void) {
    // 0xab93
    return 0;
}

// Address range: 0xaba0 - 0xabbc
// Demangled:     boost::exception_detail::error_info_injector<boost::gregorian::bad_month>::error_info_injector(boost::exception_detail::error_info_injector<boost::gregorian::bad_month> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_9gregorian9bad_monthEEC1ERKS4_(int32_t a1, int32_t a2) {
    // 0xaba0
    return a2 + (int32_t)&g29;
}

// Address range: 0xabd0 - 0xac22
int32_t function_abd0(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)0x3c70c46; // 0xabd0
    *v1 = *v1 - 1;
    char v2 = *(char *)0x4c0001f8; // 0xabdc
    int32_t v3 = 0; // ecx
    *(char *)0x4c0001f8 = (char)v3 | v2;
    char * v4 = (char *)(v3 + 0x52ff2404); // 0xabe9
    *v4 = *v4 + (char)v3;
    int32_t v5 = -0x38ffff01; // 0xabef
    int32_t v6 = ((v3 | v5) >> (int32_t)&g37) % 256 << (int32_t)&g37 | v5 & -0xff01; // 0xabf5
    char * v7 = (char *)v6; // 0xabf7
    *v7 = *v7 + 1;
    char * v8 = (char *)(v3 + 0x468b1043); // 0xabf9
    unsigned char v9 = *v8; // 0xabf9
    unsigned char v10 = v9 + (char)v3; // 0xabf9
    bool v11 = v10 < v9; // cf
    *v8 = v10;
    unsigned char v12 = (char)v6; // 0xabff
    unsigned char v13 = v12 - 119 + (char)v11; // 0xabff
    bool v14 = v11 ? v13 <= v12 : v12 > 118; // 0xabff
    int32_t v15 = (int32_t)(v13 - 117 + (char)v14) | v6 & -256; // 0xac02
    char * v16 = (char *)v15; // 0xac09
    *v16 = *v16 + 1;
    char * v17 = (char *)(v3 + 0x448b1843); // 0xac0b
    *v17 = *v17 + (char)v3;
    return v15 & ((int32_t)(char)&g18 | -256) ^ 0x2074c085;
}

// Address range: 0xac50 - 0xac57
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE7rethrowEv(a1 - (int32_t)&g18); // 0xac55
    return result;
}

// Address range: 0xac60 - 0xacb6
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::gregorian::bad_month> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_9gregorian9bad_monthEEEE7rethrowEv(int32_t a1) {
    int32_t result = unknown_157f0(0, a1); // 0xac8a
    *NULL = 0;
    g37 = &g87;
    g18 = &g88;
    return result;
}

// Address range: 0xacd0 - 0xacec
// Demangled:     void boost::throw_exception<boost::gregorian::bad_month>(boost::gregorian::bad_month const &)
int32_t _ZN5boost15throw_exceptionINS_9gregorian9bad_monthEEEvRKT_(int32_t a1) {
    // 0xacd0
    return 0;
}

// Address range: 0xacfb - 0xacfe
int32_t function_acfb(void) {
    // 0xacfb
    return 0;
}

// Address range: 0xad85 - 0xadc3
int32_t function_ad85(void) {
    int32_t * v1 = (int32_t *)0x241c89c6; // 0xad85
    *v1 = *v1 - 1;
    int32_t v2 = 0; // ebx
    *(int32_t *)(v2 + (int32_t)&g18) = (int32_t)&g56;
    unknown_11c40(v2);
    unknown_11c40(0);
    return 0;
}

// Address range: 0xadc3 - 0xadc5
int32_t function_adc3(void) {
    // 0xadc3
    return 0;
}

// Address range: 0xadd0 - 0xae08
int32_t _ZN5boost9date_time14microsec_clockINS_10posix_time5ptimeEE11create_timeEPFP2tmPKlS6_E(int32_t a1, int32_t a2) {
    // 0xadd0
    int32_t v1; // bp-60
    return &v1;
}

// Address range: 0xae0c - 0xb11c
int32_t function_ae0c(int32_t * a1, int32_t a2, int32_t a3, uint32_t a4, uint32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    int16_t v1 = a6;
    int32_t v2 = (int32_t)a1;
    int64_t v3 = a2; // bp+116
    int32_t * v4 = (int32_t *)-0x749fdbbc; // 0xae0c
    *v4 = *v4 - 1;
    *(char *)0 = __asm_insb((int16_t)0);
    int32_t v5 = 0; // bp+112
    int32_t v6 = a4 & (int32_t)&g94 & 0xffff; // 0xae30
    int32_t v7 = a4 % 0x10000; // 0xae3f
    if (v6 == 0) {
        // bb
        int32_t v8; // bp+52
        v7 = function_b1d1((int32_t)&v5, (int32_t)&v8);
        // branch -> 0xae3f
    }
    int32_t v9 = v7; // 0xb0f823
    if ((int16_t)v7 >= 32) {
        // bb178
        int64_t v10;
        v9 = function_b1d1(v6, (int32_t)v10);
        // branch -> 0xae49
    }
    uint32_t v11 = a5 % 0x10000; // 0xae49
    int32_t v12 = v11 + 1; // 0xae4f
    int32_t v13 = v12; // ecx
    int32_t v14 = v12 & (int32_t)&g94; // 0xae57
    if (v14 == 0) {
        // bb179
        v9 = function_b1e5(0, 0x10000 * a5 / 0x10000);
        v12 = v13;
        // branch -> 0xae66
    }
    if ((int16_t)v12 >= 13) {
        // bb181
        v9 = function_b1e5(v14, 0x10000 * a5 / 0x10000);
        // branch -> 0xae70
    }
    uint32_t v15 = a6 + 1900; // 0xae79
    int32_t v16 = v15 % 0x10000; // 0xae79
    int32_t v17 = v15 & (int32_t)&g94 & 0xffff; // 0xae7e
    if (v17 <= 1399) {
        // bb182
        v9 = function_b1db(0x10000 * a6 / 0x10000);
        // branch -> 0xae8d
    }
    if ((int16_t)v16 >= 0x2711) {
        // bb184
        v9 = function_b1db(0x10000 * a6 / 0x10000);
        // branch -> 0xae98
    }
    uint32_t v18; // 0xaea5
    int32_t v19; // 0xb020
    int32_t v20; // 0xb029
    int32_t v21; // 0xb032
    int32_t result; // 0xb078
    int32_t v22; // 0xafe0
    int32_t v23; // 0xb01a
    int32_t v24; // 0xb023
    int32_t v25; // 0xb02c
    int32_t v26; // 0xb038
    int32_t v27; // 0xb03a
    int32_t v28; // 0xb045
    int32_t v29; // 0xb04529
    int32_t v30; // 0xb050
    int32_t v31; // 0xb052
    int32_t v32; // 0xaea9
    int32_t v33; // 0xaf09
    int32_t v34; // 0xaf0f
    int32_t v35; // 0xaf1c
    int32_t v36; // 0xaf24
    int32_t v37; // 0xaf4c
    int32_t v38; // 0xaf53
    int32_t v39; // 0xaf73
    int32_t v40; // 0xaf9b
    int32_t v41; // 0xaffd
    uint32_t v42; // 0xb050
    int64_t v43; // 0xaea2
    int32_t v44; // 0xaea2
    uint64_t v45; // 0xaece
    uint64_t v46; // 0xaf31
    uint64_t v47; // 0xaf40
    uint16_t v48; // 0xaf9d
    uint16_t v49; // 0xafaa
    int32_t v50; // 0xb000
    uint64_t v51; // 0xb048
    uint32_t v52; // 0xaece
    uint64_t v53; // 0xaedd
    uint32_t v54; // 0xaf31
    uint32_t v55; // 0xb048
    int32_t v56; // 0xb052
    uint32_t v57; // 0xaedf
    uint32_t v58; // 0xaf42
    int32_t v59; // 0xaf90
    int32_t v60; // 0xaef1
    uint64_t v61; // 0xaf01
    uint64_t v62; // 0xaf6f
    int32_t v63; // 0xaf6f
    if ((int16_t)v13 < 12) {
        uint32_t v64 = v13 % 32; // 0xb085
        int32_t v65 = 1; // 0xb094
        if (v64 != 0) {
            // bb194
            v65 = 1 << v64;
            // branch -> bb195
        }
        // bb195
        int32_t v66; // bp+123
        if ((v65 & 2640) != 0) {
            // 0xb0f8
            if ((int16_t)v9 > (int16_t)(int32_t)&g20) {
                // 0xb101
                return &v66;
            }
        } else {
            // 0xb094
            if ((v65 & 4) != 0) {
                int32_t v67 = (int32_t)&g20 & -256 | (int32_t)&g18; // 0xb0f8
                if (v17 % 4 == 0) {
                    int16_t v68 = v16; // 0xb0a6
                    int32_t v69 = v16 & -0x10000; // 0xb0a6
                    int32_t v70 = 100 * 0x147b * ((v16 / 4 & 0x3ff8 | v69) & (int32_t)&g94) / 0x20000; // 0xb0bc
                    if (v68 == (int16_t)v70) {
                        uint16_t v71 = v68 - (int16_t)(((v16 / 16 & 4088 | v69) & (int32_t)&g94) * (int32_t)&g43 / 0x10000 * 16 * ((int32_t)&g29 + 1 + ((int32_t)&g29 + 1) * (int32_t)&g29)); // 0xb0e8
                        v67 = (int32_t)&g19 - 1 - (int32_t)(v71 == 0);
                        // branch -> 0xb0f8
                    } else {
                        v67 = &g19;
                    }
                }
                // 0xb0f8
                if ((int16_t)v9 > (int16_t)v67) {
                    // 0xb101
                    return &v66;
                }
            }
        }
        // 0xaea2
        v43 = v3;
        v44 = v43;
        v18 = 0;
        v32 = v5;
        if (v44 >= 0) {
            // 0xaeba
            if (a3 >= 0) {
                // 0xaec3
                if (v32 >= 0) {
                    // 0xaec7
                    v45 = 3600 * (int64_t)a3;
                    v52 = (int32_t)v45;
                    v53 = 60 * v43;
                    v57 = (int32_t)v53 + v52;
                    v60 = v57 + v32;
                    v61 = 0xf4240 * (int64_t)v60;
                    v33 = 0xf4240 * ((int32_t)(v53 / 0x100000000) + (int32_t)(v45 >> (int64_t)&g21) + (v32 >> 31) + (int32_t)(v57 < v52) + (int32_t)(v60 < v57)) + (int32_t)(v61 / 0x100000000);
                    v34 = (int32_t)v61 + v18;
                    g8 = v34;
                    // branch -> 0xaf81
                    // 0xaf81
                    g6 = (int32_t)(v34 < v18) + v33;
                    v59 = 14 - v14;
                    v40 = (int32_t)(0x2aaaaaab * (int64_t)v59 >> (int64_t)&g21) / 2;
                    v48 = (int16_t)v40 - (int16_t)(v59 >> 31);
                    v49 = v1 + 0x1a2c - v48;
                    v22 = (int32_t)(v49 / 4) & (int32_t)&g94;
                    v41 = ((int32_t)(v49 / 16) & (int32_t)&g94) * (int32_t)&g43 / 0x10000;
                    v50 = v6 - 0x7d2d + 365 * ((int32_t)v49 & (int32_t)&g94) + v22 - 0x147b * v22 / 0x20000 + v41 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v48 | v40 & -0x10000) - 2 + v11 & (int32_t)&g94) | 2) / 0x200000000);
                    g2 = v50;
                    *a1 = 1;
                    *(int32_t *)(v2 + (int32_t)&g29) = 0;
                    if (v50 == 0) {
                        // bb188
                        v23 = function_b140();
                        g2 = v23;
                        v19 = v23;
                        // branch -> 0xb020
                    } else {
                        // 0xaf81
                        v19 = g2;
                        // branch -> 0xb020
                    }
                    // 0xb020
                    v20 = v19;
                    if (v19 == -1) {
                        // bb189
                        v24 = function_b140();
                        g2 = v24;
                        v20 = v24;
                        // branch -> 0xb029
                    }
                    // 0xb029
                    v29 = v20;
                    if (v20 == -2) {
                        // bb190
                        v25 = function_b140();
                        g2 = v25;
                        v29 = v25;
                        // branch -> 0xb032
                    }
                    // 0xb032
                    v21 = g6;
                    v26 = g8;
                    v31 = v21;
                    v30 = v26;
                    v28 = v29;
                    if ((v26 || v21 ^ -0x80000000) == 0) {
                        // bb191
                        v27 = function_b1c0();
                        v31 = g6;
                        v30 = g8;
                        v28 = v27;
                        // branch -> 0xb040
                    }
                    // 0xb040
                    v51 = 0x1dd76000 * (int64_t)v28;
                    v55 = (int32_t)v51;
                    v42 = v55 + v30;
                    v56 = v28 * (int32_t)&g14 + v31 + (int32_t)(v51 >> (int64_t)&g21) + (int32_t)(v42 < v55);
                    *a1 = v42;
                    *(int32_t *)(v2 + (int32_t)&g29) = v56;
                    g2 = v2;
                    result = v2;
                    if ((0x10000 * a4 / 0x10000 ^ 0x2074c085) != 0) {
                        // bb192
                        result = function_b1d6();
                        // branch -> 0xb06e
                    }
                    // 0xb06e
                    return result;
                }
            }
        }
        // 0xaf18
        v35 = v44 >> 31;
        v36 = a3 >> 31;
        v46 = -60 * (int64_t)((v35 ^ v44) - v35);
        v54 = (int32_t)v46;
        v47 = -3600 * (int64_t)((v36 ^ a3) - v36);
        v58 = v54 + (int32_t)v47;
        v37 = v32 >> 31;
        v38 = (v37 ^ v32) - v37;
        v62 = 0xf4240 * (int64_t)(v58 - v38);
        v63 = v62;
        v39 = 0xf4240 * ((int32_t)(v38 < 0) + (int32_t)(v47 >> (int64_t)&g21) + (int32_t)(v46 >> (int64_t)&g21) + (int32_t)(v58 < v54) + (int32_t)(v58 < v38)) + (int32_t)(v62 / 0x100000000);
        g8 = v63 - v18;
        // branch -> 0xaf81
        // 0xaf81
        g6 = v39 + (int32_t)(v63 < v18);
        v59 = 14 - v14;
        v40 = (int32_t)(0x2aaaaaab * (int64_t)v59 >> (int64_t)&g21) / 2;
        v48 = (int16_t)v40 - (int16_t)(v59 >> 31);
        v49 = v1 + 0x1a2c - v48;
        v22 = (int32_t)(v49 / 4) & (int32_t)&g94;
        v41 = ((int32_t)(v49 / 16) & (int32_t)&g94) * (int32_t)&g43 / 0x10000;
        v50 = v6 - 0x7d2d + 365 * ((int32_t)v49 & (int32_t)&g94) + v22 - 0x147b * v22 / 0x20000 + v41 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v48 | v40 & -0x10000) - 2 + v11 & (int32_t)&g94) | 2) / 0x200000000);
        g2 = v50;
        *a1 = 1;
        *(int32_t *)(v2 + (int32_t)&g29) = 0;
        if (v50 == 0) {
            // bb188
            v23 = function_b140();
            g2 = v23;
            v19 = v23;
            // branch -> 0xb020
        } else {
            // 0xaf81
            v19 = g2;
            // branch -> 0xb020
        }
        // 0xb020
        v20 = v19;
        if (v19 == -1) {
            // bb189
            v24 = function_b140();
            g2 = v24;
            v20 = v24;
            // branch -> 0xb029
        }
        // 0xb029
        v29 = v20;
        if (v20 == -2) {
            // bb190
            v25 = function_b140();
            g2 = v25;
            v29 = v25;
            // branch -> 0xb032
        }
        // 0xb032
        v21 = g6;
        v26 = g8;
        v31 = v21;
        v30 = v26;
        v28 = v29;
        if ((v26 || v21 ^ -0x80000000) == 0) {
            // bb191
            v27 = function_b1c0();
            v31 = g6;
            v30 = g8;
            v28 = v27;
            // branch -> 0xb040
        }
        // 0xb040
        v51 = 0x1dd76000 * (int64_t)v28;
        v55 = (int32_t)v51;
        v42 = v55 + v30;
        v56 = v28 * (int32_t)&g14 + v31 + (int32_t)(v51 >> (int64_t)&g21) + (int32_t)(v42 < v55);
        *a1 = v42;
        *(int32_t *)(v2 + (int32_t)&g29) = v56;
        g2 = v2;
        result = v2;
        if ((0x10000 * a4 / 0x10000 ^ 0x2074c085) != 0) {
            // bb192
            result = function_b1d6();
            // branch -> 0xb06e
        }
        // 0xb06e
        return result;
    }
    // 0xaea2
    v43 = v3;
    v44 = v43;
    int32_t v72; // ebp
    v18 = v72;
    v32 = v5;
    if (v44 < 0 || a3 < 0) {
        // 0xaf18
        v35 = v44 >> 31;
        v36 = a3 >> 31;
        v46 = -60 * (int64_t)((v35 ^ v44) - v35);
        v54 = (int32_t)v46;
        v47 = -3600 * (int64_t)((v36 ^ a3) - v36);
        v58 = v54 + (int32_t)v47;
        v37 = v32 >> 31;
        v38 = (v37 ^ v32) - v37;
        v62 = 0xf4240 * (int64_t)(v58 - v38);
        v63 = v62;
        v39 = 0xf4240 * ((int32_t)(v38 < 0) + (int32_t)(v47 >> (int64_t)&g21) + (int32_t)(v46 >> (int64_t)&g21) + (int32_t)(v58 < v54) + (int32_t)(v58 < v38)) + (int32_t)(v62 / 0x100000000);
        g8 = v63 - v18;
        // branch -> 0xaf81
        // 0xaf81
        g6 = v39 + (int32_t)(v63 < v18);
        v59 = 14 - v14;
        v40 = (int32_t)(0x2aaaaaab * (int64_t)v59 >> (int64_t)&g21) / 2;
        v48 = (int16_t)v40 - (int16_t)(v59 >> 31);
        v49 = v1 + 0x1a2c - v48;
        v22 = (int32_t)(v49 / 4) & (int32_t)&g94;
        v41 = ((int32_t)(v49 / 16) & (int32_t)&g94) * (int32_t)&g43 / 0x10000;
        v50 = v6 - 0x7d2d + 365 * ((int32_t)v49 & (int32_t)&g94) + v22 - 0x147b * v22 / 0x20000 + v41 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v48 | v40 & -0x10000) - 2 + v11 & (int32_t)&g94) | 2) / 0x200000000);
        g2 = v50;
        *a1 = 1;
        *(int32_t *)(v2 + (int32_t)&g29) = 0;
        if (v50 == 0) {
            // bb188
            v23 = function_b140();
            g2 = v23;
            v19 = v23;
            // branch -> 0xb020
        } else {
            // 0xaf81
            v19 = g2;
            // branch -> 0xb020
        }
        // 0xb020
        v20 = v19;
        if (v19 == -1) {
            // bb189
            v24 = function_b140();
            g2 = v24;
            v20 = v24;
            // branch -> 0xb029
        }
        // 0xb029
        v29 = v20;
        if (v20 == -2) {
            // bb190
            v25 = function_b140();
            g2 = v25;
            v29 = v25;
            // branch -> 0xb032
        }
        // 0xb032
        v21 = g6;
        v26 = g8;
        v31 = v21;
        v30 = v26;
        v28 = v29;
        if ((v26 || v21 ^ -0x80000000) == 0) {
            // bb191
            v27 = function_b1c0();
            v31 = g6;
            v30 = g8;
            v28 = v27;
            // branch -> 0xb040
        }
        // 0xb040
        v51 = 0x1dd76000 * (int64_t)v28;
        v55 = (int32_t)v51;
        v42 = v55 + v30;
        v56 = v28 * (int32_t)&g14 + v31 + (int32_t)(v51 >> (int64_t)&g21) + (int32_t)(v42 < v55);
        *a1 = v42;
        *(int32_t *)(v2 + (int32_t)&g29) = v56;
        g2 = v2;
        result = v2;
        if ((0x10000 * a4 / 0x10000 ^ 0x2074c085) != 0) {
            // bb192
            result = function_b1d6();
            // branch -> 0xb06e
        }
        // 0xb06e
        return result;
    }
    // 0xaec3
    if (v32 >= 0) {
        // 0xaec7
        v45 = 3600 * (int64_t)a3;
        v52 = (int32_t)v45;
        v53 = 60 * v43;
        v57 = (int32_t)v53 + v52;
        v60 = v57 + v32;
        v61 = 0xf4240 * (int64_t)v60;
        v33 = 0xf4240 * ((int32_t)(v53 / 0x100000000) + (int32_t)(v45 >> (int64_t)&g21) + (v32 >> 31) + (int32_t)(v57 < v52) + (int32_t)(v60 < v57)) + (int32_t)(v61 / 0x100000000);
        v34 = (int32_t)v61 + v18;
        g8 = v34;
        // branch -> 0xaf81
        // 0xaf81
        g6 = (int32_t)(v34 < v18) + v33;
        v59 = 14 - v14;
        v40 = (int32_t)(0x2aaaaaab * (int64_t)v59 >> (int64_t)&g21) / 2;
        v48 = (int16_t)v40 - (int16_t)(v59 >> 31);
        v49 = v1 + 0x1a2c - v48;
        v22 = (int32_t)(v49 / 4) & (int32_t)&g94;
        v41 = ((int32_t)(v49 / 16) & (int32_t)&g94) * (int32_t)&g43 / 0x10000;
        v50 = v6 - 0x7d2d + 365 * ((int32_t)v49 & (int32_t)&g94) + v22 - 0x147b * v22 / 0x20000 + v41 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v48 | v40 & -0x10000) - 2 + v11 & (int32_t)&g94) | 2) / 0x200000000);
        g2 = v50;
        *a1 = 1;
        *(int32_t *)(v2 + (int32_t)&g29) = 0;
        if (v50 == 0) {
            // bb188
            v23 = function_b140();
            g2 = v23;
            v19 = v23;
            // branch -> 0xb020
        } else {
            // 0xaf81
            v19 = g2;
            // branch -> 0xb020
        }
        // 0xb020
        v20 = v19;
        if (v19 == -1) {
            // bb189
            v24 = function_b140();
            g2 = v24;
            v20 = v24;
            // branch -> 0xb029
        }
        // 0xb029
        v29 = v20;
        if (v20 == -2) {
            // bb190
            v25 = function_b140();
            g2 = v25;
            v29 = v25;
            // branch -> 0xb032
        }
        // 0xb032
        v21 = g6;
        v26 = g8;
        v31 = v21;
        v30 = v26;
        v28 = v29;
        if ((v26 || v21 ^ -0x80000000) == 0) {
            // bb191
            v27 = function_b1c0();
            v31 = g6;
            v30 = g8;
            v28 = v27;
            // branch -> 0xb040
        }
        // 0xb040
        v51 = 0x1dd76000 * (int64_t)v28;
        v55 = (int32_t)v51;
        v42 = v55 + v30;
        v56 = v28 * (int32_t)&g14 + v31 + (int32_t)(v51 >> (int64_t)&g21) + (int32_t)(v42 < v55);
        *a1 = v42;
        *(int32_t *)(v2 + (int32_t)&g29) = v56;
        g2 = v2;
        result = v2;
        if ((0x10000 * a4 / 0x10000 ^ 0x2074c085) != 0) {
            // bb192
            result = function_b1d6();
            // branch -> 0xb06e
        }
        // 0xb06e
        return result;
    }
    // 0xaf18
    v35 = v44 >> 31;
    v36 = a3 >> 31;
    v46 = -60 * (int64_t)((v35 ^ v44) - v35);
    v54 = (int32_t)v46;
    v47 = -3600 * (int64_t)((v36 ^ a3) - v36);
    v58 = v54 + (int32_t)v47;
    v37 = v32 >> 31;
    v38 = (v37 ^ v32) - v37;
    v62 = 0xf4240 * (int64_t)(v58 - v38);
    v63 = v62;
    v39 = 0xf4240 * ((int32_t)(v38 < 0) + (int32_t)(v47 >> (int64_t)&g21) + (int32_t)(v46 >> (int64_t)&g21) + (int32_t)(v58 < v54) + (int32_t)(v58 < v38)) + (int32_t)(v62 / 0x100000000);
    g8 = v63 - v18;
    // branch -> 0xaf81
    // 0xaf81
    g6 = v39 + (int32_t)(v63 < v18);
    v59 = 14 - v14;
    v40 = (int32_t)(0x2aaaaaab * (int64_t)v59 >> (int64_t)&g21) / 2;
    v48 = (int16_t)v40 - (int16_t)(v59 >> 31);
    v49 = v1 + 0x1a2c - v48;
    v22 = (int32_t)(v49 / 4) & (int32_t)&g94;
    v41 = ((int32_t)(v49 / 16) & (int32_t)&g94) * (int32_t)&g43 / 0x10000;
    v50 = v6 - 0x7d2d + 365 * ((int32_t)v49 & (int32_t)&g94) + v22 - 0x147b * v22 / 0x20000 + v41 + (int32_t)(0x66666667 * (int64_t)(153 * (12 * ((int32_t)v48 | v40 & -0x10000) - 2 + v11 & (int32_t)&g94) | 2) / 0x200000000);
    g2 = v50;
    *a1 = 1;
    *(int32_t *)(v2 + (int32_t)&g29) = 0;
    if (v50 == 0) {
        // bb188
        v23 = function_b140();
        g2 = v23;
        v19 = v23;
        // branch -> 0xb020
    } else {
        // 0xaf81
        v19 = g2;
        // branch -> 0xb020
    }
    // 0xb020
    v20 = v19;
    if (v19 == -1) {
        // bb189
        v24 = function_b140();
        g2 = v24;
        v20 = v24;
        // branch -> 0xb029
    }
    // 0xb029
    v29 = v20;
    if (v20 == -2) {
        // bb190
        v25 = function_b140();
        g2 = v25;
        v29 = v25;
        // branch -> 0xb032
    }
    // 0xb032
    v21 = g6;
    v26 = g8;
    v31 = v21;
    v30 = v26;
    v28 = v29;
    if ((v26 || v21 ^ -0x80000000) == 0) {
        // bb191
        v27 = function_b1c0();
        v31 = g6;
        v30 = g8;
        v28 = v27;
        // branch -> 0xb040
    }
    // 0xb040
    v51 = 0x1dd76000 * (int64_t)v28;
    v55 = (int32_t)v51;
    v42 = v55 + v30;
    v56 = v28 * (int32_t)&g14 + v31 + (int32_t)(v51 >> (int64_t)&g21) + (int32_t)(v42 < v55);
    *a1 = v42;
    *(int32_t *)(v2 + (int32_t)&g29) = v56;
    g2 = v2;
    result = v2;
    if ((0x10000 * a4 / 0x10000 ^ 0x2074c085) != 0) {
        // bb192
        result = function_b1d6();
        // branch -> 0xb06e
    }
    // 0xb06e
    return result;
}

// Address range: 0xb140 - 0xb182
int32_t function_b140(void) {
    // 0xb140
    int32_t v1; // 0xb148
    if ((g8 || g6 ^ -0x80000000) == 0) {
        // bb
        v1 = function_b19e();
        g2 = v1;
        // branch -> 0xb14a
    } else {
        // 0xb14a
        v1 = g2;
        // branch -> 0xb14a
    }
    // 0xb14a
    int32_t result; // eax
    int32_t v2;
    uint32_t v3; // 0xb15a
    int32_t v4; // 0xb15a
    if (v1 != 0) {
        int32_t v5 = v1; // 0xb153
        if (v1 == -1) {
            int32_t v6 = function_b1c0(); // 0xb151
            g2 = v6;
            v5 = v6;
            // branch -> 0xb153
        }
        // 0xb153
        int32_t v7; // 0xb156
        if (v5 == -2) {
            // bb6
            v7 = function_b1a8();
            result = v7;
            // branch -> 0xb158
        } else {
            v7 = v5;
        }
        // 0xb158
        v3 = g8;
        v4 = v3 + v7;
        g8 = v4;
        // branch -> 0xb15e
        // 0xb15e
        g6 += (int32_t)(v4 < v3);
        *(int32_t *)v2 = v4;
        *(int32_t *)(result + (int32_t)&g29) = g6;
        return result;
    }
    int32_t v8 = 0; // 0xb175
    if (v1 == -1) {
        int32_t v9 = function_b1b4(); // 0xb173
        result = v9;
        v8 = v9;
        // branch -> 0xb175
    }
    // 0xb175
    if (v8 == 0) {
        // 0xb179
        g8 = 0;
        // branch -> 0xb15e
        // 0xb15e
        g6 = -0x80000000;
        *(int32_t *)v2 = 0;
        *(int32_t *)(result + (int32_t)&g29) = g6;
        return result;
    }
    // 0xb158
    v3 = g8;
    v4 = v3 + v8;
    g8 = v4;
    // branch -> 0xb15e
    // 0xb15e
    g6 += (int32_t)(v4 < v3);
    *(int32_t *)v2 = v4;
    *(int32_t *)(result + (int32_t)&g29) = g6;
    return result;
}

// Address range: 0xb18e - 0xb191
int32_t function_b18e(void) {
    // 0xb18e
    return g2;
}

// Address range: 0xb19e - 0xb1a8
int32_t function_b19e(void) {
    int32_t v1 = g2; // 0xb19e
    int32_t result = v1; // 0xb1a4
    if (v1 != -2) {
        // bb
        result = function_b1c0();
        // branch -> 0xb1a3
    }
    // 0xb1a3
    return result;
}

// Address range: 0xb1a8 - 0xb1b4
int32_t function_b1a8(void) {
    // 0xb1a8
    g8 = -2;
    g6 = 0x7fffffff;
    return g2;
}

// Address range: 0xb1b4 - 0xb1c0
int32_t function_b1b4(void) {
    // 0xb1b4
    g8 = -1;
    g6 = 0x7fffffff;
    return g2;
}

// Address range: 0xb1c0 - 0xb1d1
int32_t function_b1c0(void) {
    // 0xb1c0
    return function_b1a8();
}

// Address range: 0xb1d1 - 0xb1d6
int32_t function_b1d1(int32_t a1, int32_t a2) {
    // 0xb1d1
    return unknown_10eb3();
}

// Address range: 0xb1d6 - 0xb1d7
int32_t function_b1d6(void) {
    // 0xb1d6
    return g2;
}

// Address range: 0xb1db - 0xb1e5
int32_t function_b1db(int32_t a1) {
    // 0xb1db
    return unknown_10f3b();
}

// Address range: 0xb1e5 - 0xb1ee
int32_t function_b1e5(int32_t a1, int32_t a2) {
    // 0xb1e5
    g2 = unknown_10fc3();
    return function_b18e();
}

// Address range: 0xb1f0 - 0xb261
// Demangled:     GetTimeMillis()
int32_t _Z13GetTimeMillisv(int32_t a1) {
    // 0xb1f0
    int32_t v1; // bp-40
    int32_t v2 = &v1; // 0xb1f4
    int32_t v3 = 0x2ed263d; // bp-28
    unknown_15fc0(v2, (int32_t)&g35);
    int32_t v4; // bp-36
    unknown_13ff0((int32_t)&v3, v2, (int32_t)&v4);
    g7 = v3;
    return -0x7c578000;
}

// Address range: 0xb265 - 0xb278
int32_t function_b265(int32_t a1) {
    int32_t * v1 = (int32_t *)0x652c244c; // 0xb265
    *v1 = *v1 - 1;
    // 0xb278
    return 0;
    // 0xb273
    int32_t result; // eax
    return result;
}

// Address range: 0xb280 - 0xb3c8
// Demangled:     void WriteCompactSize<CDataStream>(CDataStream &, unsigned long long)
int32_t _Z16WriteCompactSizeI11CDataStreamEvRT_y(int32_t a1, int32_t a2, int32_t a3) {
    int16_t * v1 = (int16_t *)0x2074c085; // bp-16
    int32_t v2; // bp-17
    int32_t v3; // 0xb2e3
    int32_t result; // 0xb2fb
    if (a3 != 0) {
        int32_t v4 = *(int32_t *)(a1 + (int32_t)&g29); // 0xb2a6
        v2 = -1;
        unknown_14de0(a1, v4, (int32_t)&v2, (int32_t)&v1);
        // branch -> 0xb2e3
        // 0xb2e3
        v3 = *(int32_t *)(a1 + (int32_t)&g29);
        int32_t v5; // bp-28
        unknown_14de0(a1, v3, (int32_t)&a2, (int32_t)&v5);
        result = (int32_t)v1 ^ 0x2074c085;
        if (result != 0) {
            // 0xb3c3
            return result;
        }
        // 0xb308
        return result;
    }
    // 0xb310
    if (a2 < 253) {
        // 0xb360
        v2 = a2;
        // branch -> 0xb2e3
        // 0xb2e3
        v3 = *(int32_t *)(a1 + (int32_t)&g29);
        unknown_14de0(a1, v3, (int32_t)&v2, (int32_t)&v1);
        result = (int32_t)v1 ^ 0x2074c085;
        if (result != 0) {
            // 0xb3c3
            return result;
        }
        // 0xb308
        return result;
    }
    // 0xb317
    int32_t v6; // 0xb2e7
    if (a2 < 0x10000) {
        int32_t v7 = *(int32_t *)(a1 + (int32_t)&g29); // 0xb385
        v2 = -3;
        unknown_14de0(a1, v7, (int32_t)&v2, (int32_t)&v1);
        int32_t v8; // bp-18
        v6 = &v8;
        // branch -> 0xb2e3
    } else {
        int32_t v9 = *(int32_t *)(a1 + (int32_t)&g29); // 0xb322
        v2 = -2;
        unknown_14de0(a1, v9, (int32_t)&v2, (int32_t)&v1);
        v6 = &a2;
        // branch -> 0xb2e3
    }
    // 0xb2e3
    v3 = *(int32_t *)(a1 + (int32_t)&g29);
    unknown_14de0(a1, v3, (int32_t)&a2, v6);
    result = (int32_t)v1 ^ 0x2074c085;
    if (result != 0) {
        // 0xb3c3
        return result;
    }
    // 0xb308
    return result;
}

// Address range: 0xb3d0 - 0xb448
// Demangled:     bool CDB::Exists<std::string>(std::string const &)
int32_t _ZN3CDB6ExistsISsEEbRKT_(int32_t * a1, int32_t a2) {
    int32_t v1 = *a1; // 0xb3f1
    int32_t result = v1; // 0xb444
    if (v1 == 0) {
        // bb
        result = function_b598(0x2074c085);
        // branch -> 0xb3fb
    }
    // 0xb3fb
    return result;
}

// Address range: 0xb4ba - 0xb4bb
int32_t function_b4ba(void) {
    // 0xb4ba
    return g2;
}

// Address range: 0xb4cc - 0xb4d5
int32_t function_b4cc(int16_t a1) {
    // 0xb4cc
    return 0;
}

// Address range: 0xb4fe - 0xb4ff
int32_t function_b4fe(void) {
    // 0xb4fe
    return 0;
}

// Address range: 0xb51c - 0xb520
int32_t function_b51c(void) {
    // 0xb51c
    int32_t v1;
    return &v1;
}

// Address range: 0xb54a - 0xb561
int32_t function_b54a(void) {
    // 0xb54a
    g2 = g4;
    int32_t result = g4; // 0xb560
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_b59c();
        // branch -> 0xb559
    }
    // 0xb559
    return result;
}

// Address range: 0xb568 - 0xb592
int32_t function_b568(int32_t a1, int32_t a2) {
    // 0xb568
    int32_t v1; // 0xb574
    if (!(bool)false) {
        // 0xb568
        v1 = 0;
        // branch -> 0xb56a
    } else {
        // bb
        v1 = function_b5c7();
        // branch -> 0xb56a
    }
    // 0xb56a
    g2 = unknown_14f30(a1, a2, v1);
    return function_b4ba();
}

// Address range: 0xb598 - 0xb59c
int32_t function_b598(int32_t a1) {
    // 0xb598
    g4 = 0;
    return function_b54a();
}

// Address range: 0xb59c - 0xb5a0
int32_t function_b59c(void) {
    // 0xb59c
    return g2;
}

// Address range: 0xb5a6 - 0xb5a7
int32_t function_b5a6(void) {
    // 0xb5a6
    return 0;
}

// Address range: 0xb5a7 - 0xb5a8
int32_t function_b5a7(void) {
    // 0xb5a7
    return g2;
}

// Address range: 0xb5bc - 0xb5bd
int32_t function_b5bc(void) {
    // 0xb5bc
    return 0;
}

// Address range: 0xb5c5 - 0xb5c7
int32_t function_b5c5(void) {
    // 0xb5c5
    return function_b5a7();
}

// Address range: 0xb5c7 - 0xb5cc
int32_t function_b5c7(void) {
    // 0xb5c7
    return unknown_11480();
}

// Address range: 0xb5d0 - 0xb702
// Demangled:     bool CDB::Write<std::string, int>(std::string const &, int const &, bool)
int32_t _ZN3CDB5WriteISsiEEbRKT_RKT0_b(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xb5d0
    g8 = a2;
    g2 = 0;
    int32_t v1 = 0; // 0xb6783
    int32_t v2 = (int32_t)a1; // 0xb618
    if (*a1 == 0) {
        int32_t v3 = function_b920(0x1000000 * a4 / 0x1000000, a3); // 0xb612
        g2 = v3;
        v1 = v3;
        v2 = g4;
        // branch -> 0xb618
    }
    if (*(char *)(v2 + (int32_t)&g47) != 0) {
        // bb128
        v1 = function_b929();
        // branch -> 0xb622
    }
    int32_t v4 = 0; // bp-148
    int32_t v5 = *(int32_t *)g8; // 0xb6a0
    v4 = v1;
    unknown_16850((int32_t)&v4, *(int32_t *)(v5 - 12), 0);
    int32_t v6 = *(int32_t *)g8; // 0xb6d3
    g2 = v6;
    int32_t v7 = *(int32_t *)(v6 - 12); // 0xb6d5
    g7 = v7;
    g95 = false;
    g96 = v7 < 0;
    if (v7 != 0) {
        // bb130
        function_b8f0();
        // branch -> 0xb6e1
    }
    // 0xb6e1
    return v1 - v4;
}

// Address range: 0xb7f4 - 0xb7fd
int32_t function_b7f4(int16_t a1) {
    // 0xb7f4
    return 0;
}

// Address range: 0xb835 - 0xb836
int32_t function_b835(void) {
    // 0xb835
    return 0;
}

// Address range: 0xb875 - 0xb87b
int32_t function_b875(void) {
    // 0xb875
    int32_t v1;
    return &v1;
}

// Address range: 0xb8cf - 0xb8ec
int32_t function_b8cf(void) {
    int32_t result = g6; // 0xb8dd
    g2 = result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_b924();
        // branch -> 0xb8e1
    }
    // 0xb8e1
    return result;
}

// Address range: 0xb8f0 - 0xb91a
int32_t function_b8f0(void) {
    // 0xb8f0
    int32_t v1; // 0xb8fc
    if (g96 == g95) {
        // 0xb8f0
        v1 = g2;
        // branch -> 0xb8f2
    } else {
        // bb
        v1 = function_b94d();
        // branch -> 0xb8f2
    }
    // 0xb8f2
    int32_t v2;
    int32_t v3;
    return unknown_15130(v3, v2, v1, g7 + v1, 0);
}

// Address range: 0xb920 - 0xb924
int32_t function_b920(int32_t a1, int32_t a2) {
    // 0xb920
    g6 = 0;
    return function_b8cf();
}

// Address range: 0xb924 - 0xb925
int32_t function_b924(void) {
    // 0xb924
    return g2;
}

// Address range: 0xb929 - 0xb948
int32_t function_b929(void) {
    // 0xb929
    return g2;
}

// Address range: 0xb94d - 0xb96d
int32_t function_b94d(void) {
    // 0xb94d
    unknown_11680();
    int32_t v1;
    return unknown_130d0(v1);
}

// Address range: 0xb972 - 0xb974
int32_t function_b972(void) {
    // 0xb972
    return 0;
}

// Address range: 0xb975 - 0xb976
int32_t function_b975(void) {
    // 0xb975
    return 0;
}

// Address range: 0xb97d - 0xb98c
int32_t function_b97d(void) {
    int32_t * v1 = (int32_t *)-0x76dbdbbc; // 0xb97d
    *v1 = *v1 - 1;
    int32_t * v2;
    return unknown_130d0((int32_t)&v2);
}

// Address range: 0xb98c - 0xb990
int32_t function_b98c(void) {
    // 0xb98c
    return 0;
}

// Address range: 0xb990 - 0xb9dd
// Demangled:     std::_Rb_tree<int, std::pair<int const, int>, std::_Select1st<std::pair<int const, int> >, std::less<int>, std::allocator<std::pair<int const, int> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<int const, int> const &)
int32_t _ZNSt8_Rb_treeIiSt4pairIKiiESt10_Select1stIS2_ESt4lessIiESaIS2_EE10_M_insert_EPKSt18_Rb_tree_node_baseSB_RKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0xb990
    g2 = 0;
    g6 = a4;
    g3 = a5;
    int32_t result = 0; // 0xb9d6
    if (a3 == 0) {
        // bb
        result = function_ba48(a2 + (int32_t)&g29, 1);
        // branch -> 0xb9d6
    }
    // 0xb9d6
    return result;
}

// Address range: 0xba12 - 0xba42
int32_t function_ba12(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7ce3dbbc; // 0xba12
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0xba19
    int32_t result = 0; // esi
    *(int32_t *)result = (v2 + 1 + (int32_t)false) % 256 | v2 & -256;
    g2 = result;
    if (a1 != 0x2074c085) {
        // bb
        result = function_ba60();
        // branch -> 0xba2c
    }
    // 0xba2c
    return result;
}

// Address range: 0xba48 - 0xba60
int32_t function_ba48(int32_t a1, int32_t a2) {
    // 0xba48
    return g2;
}

// Address range: 0xba60 - 0xba61
int32_t function_ba60(void) {
    // 0xba60
    return g2;
}

// Address range: 0xba70 - 0xbb08
// Demangled:     std::_Rb_tree<int, std::pair<int const, int>, std::_Select1st<std::pair<int const, int> >, std::less<int>, std::allocator<std::pair<int const, int> > >::_M_insert_unique(std::pair<int const, int> const &)
int32_t _ZNSt8_Rb_treeIiSt4pairIKiiESt10_Select1stIS2_ESt4lessIiESaIS2_EE16_M_insert_uniqueERKS2_(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    g6 = a2;
    g4 = v1;
    int32_t result = *(int32_t *)(a2 + (int32_t)&g37); // 0xba8f
    g8 = result;
    int32_t v2; // 0xbaf7
    if (result == 0) {
        // 0xbaf7
        v2 = a2 + (int32_t)&g29;
        g8 = v2;
        // branch -> 0xbb00
    } else {
        int32_t v3 = *(int32_t *)a3; // 0xba9e
        // branch -> 0xbab6
        while (true) {
            int32_t v4 = *(int32_t *)(result + 16); // 0xbab6
            int32_t result2; // 0xbb03
            int32_t v5; // 0xbaa8
            int32_t v6; // 0xbad6
            if (v4 > v3) {
                // 0xbaa8
                v5 = *(int32_t *)(result + (int32_t)&g37);
                if (v5 == 0) {
                    // 0xbb00
                    if (result != *(int32_t *)(a2 + (int32_t)&g47)) {
                        // 0xbb05
                        return result;
                    }
                    // bb129
                    result2 = function_bb20(v4);
                    // branch -> 0xbb05
                    // 0xbb05
                    return result2;
                    // 0xbad2
                    if (v4 >= v3) {
                        // 0xbad8
                        *(int32_t *)v1 = result;
                        *(char *)(g4 + (int32_t)&g29) = 0;
                        return g4;
                    }
                    // bb
                    v6 = function_bb20(v4);
                    // branch -> 0xbad8
                    // 0xbad8
                    *(int32_t *)g4 = v6;
                    *(char *)(g4 + (int32_t)&g29) = 0;
                    return g4;
                }
            } else {
                int32_t v7 = *(int32_t *)(result + (int32_t)&g47); // 0xbabd
                if (v7 == 0) {
                    // 0xbad2
                    if (v4 >= v3) {
                        // 0xbad8
                        *(int32_t *)v1 = result;
                        *(char *)(g4 + (int32_t)&g29) = 0;
                        return g4;
                    }
                    // bb
                    v6 = function_bb20(v4);
                    // branch -> 0xbad8
                    // 0xbad8
                    *(int32_t *)g4 = v6;
                    *(char *)(g4 + (int32_t)&g29) = 0;
                    return g4;
                }
                v5 = v7;
            }
            // 0xbab4
            g8 = v5;
            result = v5;
            // branch -> 0xbab6
        }
    }
    int32_t result3 = 0; // 0xbb05
    if (v2 == *(int32_t *)(a2 + (int32_t)&g47)) {
        // bb129
        int32_t v8;
        result3 = function_bb20(v8);
        // branch -> 0xbb05
    }
    // 0xbb05
    return result3;
}

// Address range: 0xbb20 - 0xbb53
int32_t function_bb20(int32_t result) {
    // 0xbb20
    int32_t v1; // bp+44
    unknown_17400((int32_t)&v1, g6, 0, g8, result);
    *(char *)(g4 + (int32_t)&g29) = 1;
    *(int32_t *)g4 = result;
    return result;
}

// Address range: 0xbb53 - 0xbb58
int32_t function_bb53(void) {
    // 0xbb53
    return g2;
}

// Address range: 0xbb60 - 0xbbb4
// Demangled:     std::_Rb_tree<int, std::pair<int const, int>, std::_Select1st<std::pair<int const, int> >, std::less<int>, std::allocator<std::pair<int const, int> > >::_M_insert_unique_(std::_Rb_tree_const_iterator<std::pair<int const, int> >, std::pair<int const, int> const &)
int32_t _ZNSt8_Rb_treeIiSt4pairIKiiESt10_Select1stIS2_ESt4lessIiESaIS2_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS2_ERKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t * a4) {
    int32_t v1 = (int32_t)a4;
    g6 = a2;
    g4 = a3;
    g8 = a1;
    g3 = v1;
    int32_t v2 = a3; // 0xbb9d
    if (a2 + (int32_t)&g29 == a3) {
        // bb
        function_bc68(0x2074c085);
        v2 = g4;
        v1 = g3;
        // branch -> 0xbb9a
    }
    uint32_t v3 = *(int32_t *)v1; // 0xbb9a
    uint32_t v4 = *(int32_t *)(v2 + 16); // 0xbb9d
    int32_t v5 = v3 - v4; // 0xbb9d
    g95 = ((v5 ^ v3) & (v4 ^ v3)) < 0;
    g97 = v5 == 0;
    g96 = v5 < 0;
    if (v3 >= v4) {
        // bb116
        function_bc18();
        v2 = g4;
        // branch -> 0xbba2
    }
    int32_t v6 = *(int32_t *)(g6 + (int32_t)&g47); // 0xbba2
    g2 = v6;
    int32_t result = v6; // 0xbbb0
    if (v6 == v2) {
        // bb117
        result = function_bcde();
        // branch -> 0xbbad
    }
    // 0xbbad
    return result;
}

// Address range: 0xbbec - 0xbc15
int32_t function_bbec(void) {
    int32_t result = g8; // 0xbbf7
    g2 = result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_bce7();
        // branch -> 0xbbff
    }
    // 0xbbff
    return result;
}

// Address range: 0xbc18 - 0xbc30
int32_t function_bc18(void) {
    // 0xbc18
    if (g97 || g96 != g95) {
        // bb
        function_bca8();
        // branch -> 0xbc1e
    }
    int32_t v1 = *(int32_t *)(g6 + 16); // 0xbc1e
    g2 = v1;
    int32_t result = v1; // 0xbc2c
    if (v1 == g4) {
        // bb3
        result = function_bcb0();
        // branch -> 0xbc29
    }
    // 0xbc29
    return result;
}

// Address range: 0xbc4d - 0xbc66
int32_t function_bc4d(void) {
    int32_t v1 = g2; // 0xbc4d
    unknown_174f0(g8, g6, v1, v1);
    return function_bbec();
}

// Address range: 0xbc68 - 0xbca2
int32_t function_bc68(int32_t a1) {
    int32_t v1 = g6; // 0xbc68
    int32_t v2; // bp+40
    if (*(int32_t *)(v1 + (int32_t)&g14) == 0) {
        // 0xbc80
        unknown_175d0((int32_t)&v2);
        *(int32_t *)g8 = a1;
        return function_bbec();
    }
    int32_t v3 = *(int32_t *)(v1 + 16); // 0xbc6f
    g2 = v3;
    if (*(int32_t *)(v3 + 16) < g3) {
        // bb
        function_bcb0();
        // branch -> 0xbc80
    }
    // 0xbc80
    unknown_175d0((int32_t)&v2);
    *(int32_t *)g8 = a1;
    return function_bbec();
}

// Address range: 0xbca8 - 0xbcaf
int32_t function_bca8(void) {
    // 0xbca8
    *(int32_t *)g8 = g4;
    return function_bbec();
}

// Address range: 0xbcb0 - 0xbcd4
int32_t function_bcb0(void) {
    // 0xbcb0
    unknown_174f0(g8, g6, 0, g2);
    return function_bbec();
}

// Address range: 0xbcd8 - 0xbcde
int32_t function_bcd8(void) {
    // 0xbcd8
    return 0;
}

// Address range: 0xbcde - 0xbce7
int32_t function_bcde(void) {
    // 0xbcde
    return function_bc4d();
}

// Address range: 0xbce7 - 0xbcec
int32_t function_bce7(void) {
    // 0xbce7
    return g2;
}

// Address range: 0xbcf0 - 0xbf49
// Demangled:     void CAddrMan::Serialize<CDataStream>(CDataStream &, int, int) const
int32_t _ZNK8CAddrMan9SerializeI11CDataStreamEEvRT_ii(int32_t a1, int32_t a2, int32_t a3) {
    // 0xbcf0
    g8 = a2;
    int32_t v1; // bp-64
    int32_t v2 = &v1; // 0xbd27
    unknown_15c40(v2, a1, (int32_t)"cs", (int32_t)"addrman.h", (int32_t)&g15, 0);
    int32_t v3 = g8; // 0xbd57
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g29); // 0xbd57
    int32_t v5; // bp-34
    int32_t v6 = &v5; // 0xbd65
    v5 = 0;
    int32_t v7; // bp-33
    unknown_15850(v3, v4, v6, (int32_t)&v7, 0);
    int32_t * v8 = (int32_t *)(a1 + (int32_t)&g30); // 0xbd8d
    int32_t * v9 = (int32_t *)(a1 + 84); // 0xbd90
    unknown_16f70(g8, *v8 - *v9, 0);
    int32_t v10 = *v9; // 0xbdae
    int32_t v11 = *v8 - v10; // 0xbdb1
    if (v11 != 0) {
        if (v11 < 0) {
            // bb
            v10 = function_c517();
            // branch -> 0xbdbd
        }
        int32_t v12 = g8; // 0xbdbd
        int32_t v13 = *(int32_t *)(v12 + (int32_t)&g29); // 0xbdbd
        unknown_15850(v12, v13, v10, v11 + v10, 0);
        // branch -> 0xbddb
    }
    // 0xbddb
    int32_t v14; // bp-36
    int32_t v15 = &v14; // 0xbddf
    int32_t * v16 = (int32_t *)(a1 + 176); // 0xbde6
    int32_t v17; // bp-40
    int32_t v18 = &v17; // 0xbdec
    v17 = *v16;
    int32_t v19 = g8; // 0xbdfa
    int32_t v20 = *(int32_t *)(v19 + (int32_t)&g29); // 0xbdfa
    unknown_15850(v19, v20, v18, v15, 0);
    v17 = *(int32_t *)(a1 + (int32_t)&g42);
    int32_t v21 = g8; // 0xbe35
    int32_t v22 = *(int32_t *)(v21 + (int32_t)&g29); // 0xbe35
    unknown_15850(v21, v22, v18, v15, 0);
    int32_t v23 = g8; // 0xbe51
    int32_t v24 = *(int32_t *)(v23 + (int32_t)&g29); // 0xbe51
    v17 = 256;
    unknown_15850(v23, v24, v18, v15, 0);
    int32_t v25; // bp-96
    g3 = &v25;
    v25 = 0;
    int32_t v26 = *(int32_t *)(a1 + 112); // 0xbea6
    g4 = v26;
    int32_t v27 = a1 + 104; // 0xbea9
    if (v26 == v27) {
        // bb149
        function_c28a(v27);
        // branch -> 0xbec0
    }
    // 0xbec0
    if (*v16 == 0) {
        // bb150
        function_c0de();
        // branch -> 0xbf38
    }
    // 0xbf38
    int32_t v28; // bp-100
    int32_t v29; // bp-112
    unknown_17850((int32_t)&v29, (int32_t)&v28);
    int32_t v30; // bp-176
    int32_t v31 = *(int32_t *)((int32_t)&v30 + (int32_t)&g24); // 0xbf38
    *(int32_t *)(a3 + (int32_t)&g14) = v31;
    int32_t v32 = *(int32_t *)(g4 + 88); // 0xbf3f
    int32_t result = v32; // eax
    if (v32 != 0) {
        // bb151
        result = function_bf77();
        // branch -> 0xbf46
    }
    // 0xbf46
    *(int32_t *)g9 = g4;
    return result;
}

// Address range: 0xbf4e - 0xbf77
int32_t function_bf4e(int32_t a1, int32_t a2, int32_t a3, int32_t result) {
    // 0xbf4e
    if (0 == a3) {
        // bb
        function_c0cd();
        // branch -> 0xbf5a
    }
    // 0xbf5a
    if (*(int32_t *)(a2 + 176) == a1) {
        // bb100
        function_c0cd();
        // branch -> 0xbf6e
    }
    // 0xbf6e
    return result;
}

// Address range: 0xbf77 - 0xc0bc
int32_t function_bf77(void) {
    // 0xbf77
    char v1;
    if ((v1 & 2) != 0) {
        // bb
        function_c3fc();
        // branch -> 0xbf82
    }
    // 0xbf82
    int32_t v2; // bp+96
    int32_t v3 = &v2; // 0xbf85
    v2 = *(int32_t *)(g4 + (int32_t)&g23);
    int32_t v4 = g8; // 0xbf94
    int32_t v5 = *(int32_t *)(v4 + (int32_t)&g29); // 0xbf94
    int32_t v6; // bp+104
    int32_t v7 = &v6; // 0xbf9b
    unknown_15850(v4, v5, v3, v7, 0);
    int32_t v8 = g8; // 0xbfbc
    int32_t v9 = *(int32_t *)(v8 + (int32_t)&g29); // 0xbfbc
    unknown_15850(v8, v9, g4 + (int32_t)&g14, g4 + (int32_t)&g14 + 16, 0);
    int32_t v10 = g8; // 0xbfe2
    int32_t v11 = *(int32_t *)(v10 + (int32_t)&g29); // 0xbfe2
    uint16_t v12 = *(int16_t *)(g4 + (int32_t)&g22); // 0xbfe9
    int16_t v13 = v12 >> (int16_t)&g37 | v12 << (int16_t)&g37; // bp+138
    int32_t v14; // bp+140
    unknown_15850(v10, v11, (int32_t)&v13, (int32_t)&v14, 0);
    int32_t v15 = g8; // 0xc020
    int32_t v16 = *(int32_t *)(v15 + (int32_t)&g29); // 0xc020
    unknown_15850(v15, v16, g4 + 60, g4 + 76, 0);
    v2 = *(int32_t *)(g4 + 76);
    int32_t v17 = g8; // 0xc058
    int32_t v18 = *(int32_t *)(v17 + (int32_t)&g29); // 0xc058
    unknown_15850(v17, v18, v3, v7, 0);
    int32_t v19 = *(int32_t *)(g4 + 84); // bp+132
    int32_t v20 = g8; // 0xc098
    int32_t v21 = *(int32_t *)(v20 + (int32_t)&g29); // 0xc098
    int32_t v22; // bp+136
    int32_t result = unknown_15850(v20, v21, (int32_t)&v19, (int32_t)&v22, 0); // 0xc0af
    return result;
}

// Address range: 0xc0c4 - 0xc0c7
int32_t function_c0c4(void) {
    // 0xc0c4
    return 137;
}

// Address range: 0xc0cd - 0xc0de
int32_t function_c0cd(void) {
    // 0xc0cd
    int32_t result;
    return result;
}

// Address range: 0xc0de - 0xc105
int32_t function_c0de(void) {
    // 0xc0de
    int32_t v1;
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g42); // 0xc0e2
    g2 = v2;
    if (v2 == 0) {
        // bb
        int32_t * v3;
        g2 = function_c28a((int32_t)&v3);
        // branch -> 0xc0f0
    }
    // 0xc0f0
    return function_c12d(0);
}

// Address range: 0xc105 - 0xc108
int32_t function_c105(void) {
    // 0xc105
    return g2;
}

// Address range: 0xc110 - 0xc113
int32_t function_c110(void) {
    // 0xc110
    return 137;
}

// Address range: 0xc12d - 0xc279
int32_t function_c12d(int32_t a1) {
    // 0xc12d
    if (*(char *)(g4 + (int32_t)&g31) == 0) {
        // bb
        function_c105();
        // branch -> 0xc133
    }
    // 0xc133
    int32_t v1;
    if (v1 != 0) {
        // bb19
        function_c472();
        // branch -> 0xc13f
    }
    // 0xc13f
    int32_t v2; // bp+104
    int32_t v3 = &v2; // 0xc142
    int32_t v4 = *(int32_t *)(g4 + (int32_t)&g23); // bp+96
    int32_t v5 = g8; // 0xc155
    int32_t v6 = *(int32_t *)(v5 + (int32_t)&g29); // 0xc155
    int32_t v7 = &v4; // 0xc15c
    unknown_15850(v5, v6, v7, v3, 0);
    int32_t v8 = g8; // 0xc179
    int32_t v9 = *(int32_t *)(v8 + (int32_t)&g29); // 0xc179
    unknown_15850(v8, v9, g4 + (int32_t)&g14, g4 + (int32_t)&g14 + 16, 0);
    int32_t v10 = g8; // 0xc19f
    int32_t v11 = *(int32_t *)(v10 + (int32_t)&g29); // 0xc19f
    uint16_t v12 = *(int16_t *)(g4 + (int32_t)&g22); // 0xc1a9
    int32_t v13 = v12 >> (int16_t)&g37 | v12 << (int16_t)&g37; // bp+138
    int32_t v14; // bp+140
    unknown_15850(v10, v11, (int32_t)&v13, (int32_t)&v14, 0);
    int32_t v15 = g8; // 0xc1dd
    int32_t v16 = *(int32_t *)(v15 + (int32_t)&g29); // 0xc1dd
    unknown_15850(v15, v16, g4 + 60, g4 + 76, 0);
    v4 = *(int32_t *)(g4 + 76);
    int32_t v17 = g8; // 0xc215
    int32_t v18 = *(int32_t *)(v17 + (int32_t)&g29); // 0xc215
    unknown_15850(v17, v18, v7, v3, 0);
    int32_t v19 = *(int32_t *)(g4 + 84); // bp+132
    int32_t v20 = g8; // 0xc255
    int32_t v21 = *(int32_t *)(v20 + (int32_t)&g29); // 0xc255
    int32_t v22; // bp+136
    int32_t result = unknown_15850(v20, v21, (int32_t)&v19, (int32_t)&v22, 0); // 0xc26c
    return result;
}

// Address range: 0xc281 - 0xc284
int32_t function_c281(void) {
    // 0xc281
    return 137;
}

// Address range: 0xc28a - 0xc397
int32_t function_c28a(int32_t a1) {
    // 0xc28a
    int32_t v1; // bp+72
    int32_t v2 = &v1; // 0xc28e
    g6 = v2;
    int32_t v3 = *(int32_t *)(a1 + 180); // 0xc296
    if (*(int32_t *)(a1 + 184) == v3) {
        // bb
        function_c3c1(v3);
        // branch -> 0xc2ac
    }
    // 0xc2ac
    int32_t v4; // bp+132
    int32_t v5 = &v4; // 0xc2ba
    v4 = *(int32_t *)(v3 + 20);
    int32_t v6 = g8; // 0xc2c8
    int32_t v7 = *(int32_t *)(v6 + (int32_t)&g29); // 0xc2c8
    int32_t v8; // bp+136
    unknown_15850(v6, v7, v5, (int32_t)&v8, 0);
    int32_t v9 = *(int32_t *)(v3 + 12); // 0xc2e8
    g4 = v9;
    int32_t v10 = v3 + 4; // 0xc2eb
    int32_t v11 = v9; // 0xc305
    if (v10 == v9) {
        // bb31
        function_c3a8(v10);
        v11 = g4;
        // branch -> 0xc2fa
    }
    int32_t v12 = g3; // 0xc303
    uint32_t v13 = *(int32_t *)(v11 + 16); // 0xc305
    int32_t v14; // bp+128
    int32_t v15; // bp+60
    int32_t v16;
    int32_t v17;
    int32_t v18; // 0xc378
    int32_t v19; // 0xc378
    if (v17 != 0) {
        int32_t v20 = v12;
      lab_0xc319:
        while (true) {
            int32_t v21 = v17; // 0xc319
            // branch -> 0xc319
            int32_t v22; // 0xc329
            while (true) {
                // 0xc319
                if (v13 > *(int32_t *)(v21 + 16)) {
                    int32_t v23 = *(int32_t *)(v21 + (int32_t)&g47); // 0xc31e
                    if (v23 == 0) {
                        v22 = v20;
                        // break -> 0xc325
                        break;
                    }
                    v21 = v23;
                    // continue -> 0xc319
                    continue;
                } else {
                    int32_t v24 = *(int32_t *)(v21 + (int32_t)&g37); // 0xc312
                    if (v24 == 0) {
                        v22 = v21;
                        // break (via goto) -> 0xc325
                        goto lab_0xc325;
                    }
                    v20 = v21;
                    v17 = v24;
                    // continue (via goto) -> 0xc319
                    goto lab_0xc319;
                }
                // 0xc325
                int32_t v25; // 0xc360
                int32_t v26; // 0xc360
                int32_t result; // 0xc38f
                if (v22 == v12) {
                    // 0xc32e
                    v14 = 0;
                    unknown_17850((int32_t)&v15, v2);
                    v25 = v16;
                    // branch -> 0xc360
                    // 0xc360
                    v26 = *(int32_t *)(v25 + (int32_t)&g14);
                    v14 = v26;
                    v18 = g8;
                    v19 = *(int32_t *)(v18 + (int32_t)&g29);
                    result = unknown_15850(v18, v19, (int32_t)&v14, v5, 0);
                    return result;
                }
                uint32_t v27 = *(int32_t *)(v22 + 16); // 0xc329
                if (v13 >= v27) {
                    v25 = v22;
                    // 0xc360
                    v26 = *(int32_t *)(v25 + (int32_t)&g14);
                    v14 = v26;
                    v18 = g8;
                    v19 = *(int32_t *)(v18 + (int32_t)&g29);
                    result = unknown_15850(v18, v19, (int32_t)&v14, v5, 0);
                    return result;
                }
                // 0xc32e
                v14 = 0;
                unknown_17850((int32_t)&v15, v2);
                v25 = v16;
                // branch -> 0xc360
                // 0xc360
                v26 = *(int32_t *)(v25 + (int32_t)&g14);
                v14 = v26;
                v18 = g8;
                v19 = *(int32_t *)(v18 + (int32_t)&g29);
                result = unknown_15850(v18, v19, (int32_t)&v14, v5, 0);
                return result;
            }
          lab_0xc325:
            // 0xc325
            if (v22 == v12) {
                // 0xc32e
                v14 = 0;
                unknown_17850((int32_t)&v15, v2);
                // branch -> 0xc360
                // 0xc360
                v14 = *(int32_t *)(v16 + (int32_t)&g14);
                v18 = g8;
                v19 = *(int32_t *)(v18 + (int32_t)&g29);
                return unknown_15850(v18, v19, (int32_t)&v14, v5, 0);
            }
            // 0xc329
            if (v13 >= *(int32_t *)(v22 + 16)) {
                // 0xc360
                v14 = *(int32_t *)(v22 + (int32_t)&g14);
                v18 = g8;
                v19 = *(int32_t *)(v18 + (int32_t)&g29);
                return unknown_15850(v18, v19, (int32_t)&v14, v5, 0);
            }
            // 0xc32e
            v14 = 0;
            unknown_17850((int32_t)&v15, v2);
            // branch -> 0xc360
            // 0xc360
            v14 = *(int32_t *)(v16 + (int32_t)&g14);
            v18 = g8;
            v19 = *(int32_t *)(v18 + (int32_t)&g29);
            return unknown_15850(v18, v19, (int32_t)&v14, v5, 0);
        }
    }
    // 0xc32e
    v14 = 0;
    unknown_17850((int32_t)&v15, v2);
    // branch -> 0xc360
    // 0xc360
    v14 = *(int32_t *)(v16 + (int32_t)&g14);
    v18 = g8;
    v19 = *(int32_t *)(v18 + (int32_t)&g29);
    return unknown_15850(v18, v19, (int32_t)&v14, v5, 0);
}

// Address range: 0xc3a1 - 0xc3a2
int32_t function_c3a1(void) {
    // 0xc3a1
    return 0;
}

// Address range: 0xc3a8 - 0xc3c1
int32_t function_c3a8(int32_t a1) {
    // 0xc3a8
    int32_t result;
    return result;
}

// Address range: 0xc3c1 - 0xc3fc
int32_t function_c3c1(int32_t a1) {
    // 0xc3c1
    unknown_14e00(g6, a1);
    int32_t v1; // bp+108
    unknown_14d50((int32_t)&v1);
    int32_t v2;
    int32_t v3 = v2 ^ 0x2074c085; // 0xc3e4
    g2 = v3;
    int32_t result = v3; // 0xc3fb
    if (v3 != 0) {
        // bb
        result = function_c50e();
        // branch -> 0xc3f1
    }
    // 0xc3f1
    return result;
}

// Address range: 0xc3fc - 0xc472
int32_t function_c3fc(void) {
    int32_t v1 = g8; // 0xc3fc
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g29); // 0xc3fc
    int32_t v3; // bp+136
    int32_t v4 = &v3; // 0xc3ff
    int32_t v5; // bp+132
    int32_t v6 = &v5; // 0xc406
    v5 = 0;
    unknown_15850(v1, v2, v6, v4, 0);
    v5 = *(int32_t *)(g4 + 48);
    int32_t v7 = g8; // 0xc451
    int32_t v8 = *(int32_t *)(v7 + (int32_t)&g29); // 0xc451
    return unknown_15850(v7, v8, v6, v4, 0);
}

// Address range: 0xc472 - 0xc4e8
int32_t function_c472(void) {
    int32_t v1 = g8; // 0xc472
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g29); // 0xc472
    int32_t v3; // bp+136
    int32_t v4 = &v3; // 0xc475
    int32_t v5; // bp+132
    int32_t v6 = &v5; // 0xc47c
    v5 = 0;
    unknown_15850(v1, v2, v6, v4, 0);
    v5 = *(int32_t *)(g4 + 48);
    int32_t v7 = g8; // 0xc4c7
    int32_t v8 = *(int32_t *)(v7 + (int32_t)&g29); // 0xc4c7
    return unknown_15850(v7, v8, v6, v4, 0);
}

// Address range: 0xc4e9 - 0xc4ea
int32_t function_c4e9(void) {
    // 0xc4e9
    return 0;
}

// Address range: 0xc4fa - 0xc4fb
int32_t function_c4fa(void) {
    // 0xc4fa
    return g2;
}

// Address range: 0xc50e - 0xc50f
int32_t function_c50e(void) {
    // 0xc50e
    return g2;
}

// Address range: 0xc513 - 0xc517
int32_t function_c513(void) {
    // 0xc513
    return function_c4fa();
}

// Address range: 0xc517 - 0xc51c
int32_t function_c517(void) {
    // 0xc517
    return unknown_11da0();
}

// Address range: 0xc520 - 0xc575
// Demangled:     std::_Rb_tree<int, std::pair<int const, CAddrInfo>, std::_Select1st<std::pair<int const, CAddrInfo> >, std::less<int>, std::allocator<std::pair<int const, CAddrInfo> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<int const, CAddrInfo> const &)
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE10_M_insert_EPKSt18_Rb_tree_node_baseSC_RKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0xc520
    g7 = a4;
    g8 = a5;
    int32_t v1 = a2 + (int32_t)&g29; // 0xc551
    int32_t result = v1; // 0xc56e
    if (a3 == 0) {
        // bb
        result = function_c5d8(a1, v1, 1);
        // branch -> 0xc56a
    }
    // 0xc56a
    return result;
}

// Address range: 0xc579 - 0xc580
int32_t function_c579(void) {
    int32_t * v1 = (int32_t *)-0x76efdbac; // 0xc579
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xc5a9 - 0xc5d7
int32_t function_c5a9(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 - 0x7cebdbbc); // 0xc5a9
    *v2 = *v2 - 1;
    int32_t v3 = 0; // 0xc5b0
    int32_t v4 = (v3 + 1 + (int32_t)false) % 256 | v3 & -256; // 0xc5b0
    g2 = v4;
    *(int32_t *)v4 = v1;
    int32_t result; // 0xc5d4
    if (a1 != 0x2074c085) {
        // bb
        result = function_c5f0();
        // branch -> 0xc5c1
    } else {
        // 0xc5a9
        result = g2;
        // branch -> 0xc5c1
    }
    // 0xc5c1
    return result;
}

// Address range: 0xc5d8 - 0xc5f0
int32_t function_c5d8(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(g7 + 16); // 0xc5dc
    int32_t v2 = g8; // 0xc5df
    int32_t v3 = v2 - v1; // 0xc5df
    return v3 < 0 != ((v3 ^ v2) & (v2 ^ v1)) < 0;
}

// Address range: 0xc5f0 - 0xc5f1
int32_t function_c5f0(void) {
    // 0xc5f0
    return g2;
}

// Address range: 0xc600 - 0xc698
// Demangled:     std::_Rb_tree<int, std::pair<int const, CAddrInfo>, std::_Select1st<std::pair<int const, CAddrInfo> >, std::less<int>, std::allocator<std::pair<int const, CAddrInfo> > >::_M_insert_unique(std::pair<int const, CAddrInfo> const &)
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE16_M_insert_uniqueERKS3_(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    g6 = a2;
    g4 = v1;
    int32_t result = *(int32_t *)(a2 + (int32_t)&g37); // 0xc61f
    g8 = result;
    int32_t v2; // 0xc687
    if (result == 0) {
        // 0xc687
        v2 = a2 + (int32_t)&g29;
        g8 = v2;
        // branch -> 0xc690
    } else {
        int32_t v3 = *(int32_t *)a3; // 0xc62e
        // branch -> 0xc646
        while (true) {
            int32_t v4 = *(int32_t *)(result + 16); // 0xc646
            int32_t result2; // 0xc693
            int32_t v5; // 0xc638
            int32_t v6; // 0xc666
            if (v4 > v3) {
                // 0xc638
                v5 = *(int32_t *)(result + (int32_t)&g37);
                if (v5 == 0) {
                    // 0xc690
                    if (result != *(int32_t *)(a2 + (int32_t)&g47)) {
                        // 0xc695
                        return result;
                    }
                    // bb129
                    result2 = function_c6b0(v4);
                    // branch -> 0xc695
                    // 0xc695
                    return result2;
                    // 0xc662
                    if (v4 >= v3) {
                        // 0xc668
                        *(int32_t *)v1 = result;
                        *(char *)(g4 + (int32_t)&g29) = 0;
                        return g4;
                    }
                    // bb
                    v6 = function_c6b0(v4);
                    // branch -> 0xc668
                    // 0xc668
                    *(int32_t *)g4 = v6;
                    *(char *)(g4 + (int32_t)&g29) = 0;
                    return g4;
                }
            } else {
                int32_t v7 = *(int32_t *)(result + (int32_t)&g47); // 0xc64d
                if (v7 == 0) {
                    // 0xc662
                    if (v4 >= v3) {
                        // 0xc668
                        *(int32_t *)v1 = result;
                        *(char *)(g4 + (int32_t)&g29) = 0;
                        return g4;
                    }
                    // bb
                    v6 = function_c6b0(v4);
                    // branch -> 0xc668
                    // 0xc668
                    *(int32_t *)g4 = v6;
                    *(char *)(g4 + (int32_t)&g29) = 0;
                    return g4;
                }
                v5 = v7;
            }
            // 0xc644
            g8 = v5;
            result = v5;
            // branch -> 0xc646
        }
    }
    int32_t result3 = 0; // 0xc695
    if (v2 == *(int32_t *)(a2 + (int32_t)&g47)) {
        // bb129
        int32_t v8;
        result3 = function_c6b0(v8);
        // branch -> 0xc695
    }
    // 0xc695
    return result3;
}

// Address range: 0xc6b0 - 0xc6e3
int32_t function_c6b0(int32_t result) {
    // 0xc6b0
    int32_t v1; // bp+44
    unknown_18b20((int32_t)&v1, g6, 0, g8, result);
    *(char *)(g4 + (int32_t)&g29) = 1;
    *(int32_t *)g4 = result;
    return result;
}

// Address range: 0xc6e3 - 0xc6e4
int32_t function_c6e3(void) {
    // 0xc6e3
    return g2;
}

// Address range: 0xc6f0 - 0xc744
// Demangled:     std::_Rb_tree<int, std::pair<int const, CAddrInfo>, std::_Select1st<std::pair<int const, CAddrInfo> >, std::less<int>, std::allocator<std::pair<int const, CAddrInfo> > >::_M_insert_unique_(std::_Rb_tree_const_iterator<std::pair<int const, CAddrInfo> >, std::pair<int const, CAddrInfo> const &)
int32_t _ZNSt8_Rb_treeIiSt4pairIKi9CAddrInfoESt10_Select1stIS3_ESt4lessIiESaIS3_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS3_ERKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t * a4) {
    int32_t v1 = (int32_t)a4;
    g6 = a2;
    g4 = a3;
    g8 = a1;
    g3 = v1;
    int32_t v2 = a3; // 0xc72d
    if (a2 + (int32_t)&g29 == a3) {
        // bb
        function_c7f8(0x2074c085);
        v2 = g4;
        v1 = g3;
        // branch -> 0xc72a
    }
    uint32_t v3 = *(int32_t *)v1; // 0xc72a
    uint32_t v4 = *(int32_t *)(v2 + 16); // 0xc72d
    int32_t v5 = v3 - v4; // 0xc72d
    g95 = ((v5 ^ v3) & (v4 ^ v3)) < 0;
    g97 = v5 == 0;
    g96 = v5 < 0;
    if (v3 >= v4) {
        // bb116
        function_c7a8();
        v2 = g4;
        // branch -> 0xc732
    }
    int32_t v6 = *(int32_t *)(g6 + (int32_t)&g47); // 0xc732
    g2 = v6;
    int32_t result = v6; // 0xc740
    if (v6 == v2) {
        // bb117
        result = function_c86e();
        // branch -> 0xc73d
    }
    // 0xc73d
    return result;
}

// Address range: 0xc77c - 0xc7a5
int32_t function_c77c(void) {
    int32_t result = g8; // 0xc787
    g2 = result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_c877();
        // branch -> 0xc78f
    }
    // 0xc78f
    return result;
}

// Address range: 0xc7a8 - 0xc7c0
int32_t function_c7a8(void) {
    // 0xc7a8
    if (g97 || g96 != g95) {
        // bb
        function_c838();
        // branch -> 0xc7ae
    }
    int32_t v1 = *(int32_t *)(g6 + 16); // 0xc7ae
    g2 = v1;
    int32_t result = v1; // 0xc7bc
    if (v1 == g4) {
        // bb3
        result = function_c840();
        // branch -> 0xc7b9
    }
    // 0xc7b9
    return result;
}

// Address range: 0xc7dd - 0xc7f6
int32_t function_c7dd(void) {
    int32_t v1 = g2; // 0xc7dd
    unknown_18c10(g8, g6, v1, v1);
    return function_c77c();
}

// Address range: 0xc7f8 - 0xc832
int32_t function_c7f8(int32_t a1) {
    int32_t v1 = g6; // 0xc7f8
    int32_t v2; // bp+40
    if (*(int32_t *)(v1 + (int32_t)&g14) == 0) {
        // 0xc810
        unknown_18cf0((int32_t)&v2, v1);
        *(int32_t *)g8 = a1;
        return function_c77c();
    }
    int32_t v3 = *(int32_t *)(v1 + 16); // 0xc7ff
    g2 = v3;
    if (*(int32_t *)(v3 + 16) < g3) {
        // bb
        function_c840();
        // branch -> 0xc810
    }
    // 0xc810
    unknown_18cf0((int32_t)&v2, g6);
    *(int32_t *)g8 = a1;
    return function_c77c();
}

// Address range: 0xc838 - 0xc83f
int32_t function_c838(void) {
    // 0xc838
    *(int32_t *)g8 = g4;
    return function_c77c();
}

// Address range: 0xc840 - 0xc864
int32_t function_c840(void) {
    // 0xc840
    unknown_18c10(g8, g6, 0, g2);
    return function_c77c();
}

// Address range: 0xc868 - 0xc86e
int32_t function_c868(void) {
    // 0xc868
    return 0;
}

// Address range: 0xc86e - 0xc877
int32_t function_c86e(void) {
    // 0xc86e
    return function_c7dd();
}

// Address range: 0xc877 - 0xc878
int32_t function_c877(void) {
    // 0xc877
    return g2;
}

// Address range: 0xc880 - 0xc8d2
// Demangled:     std::_Rb_tree<CNetAddr, std::pair<CNetAddr const, int>, std::_Select1st<std::pair<CNetAddr const, int> >, std::less<CNetAddr>, std::allocator<std::pair<CNetAddr const, int> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<CNetAddr const, int> const &)
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE10_M_insert_EPKSt18_Rb_tree_node_baseSC_RKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a2 + (int32_t)&g29; // 0xc8b2
    g5 = v1;
    g3 = a4;
    int32_t result = a3; // 0xc8cb
    if (a3 == 0) {
        // bb
        result = function_c948(v1);
        // branch -> 0xc8c7
    }
    // 0xc8c7
    return result;
}

// Address range: 0xc918 - 0xc948
int32_t function_c918(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7ce7dbbc; // 0xc918
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0xc91f
    int32_t result = 0; // edi
    *(int32_t *)result = (v2 + 1 + (int32_t)false) % 256 | v2 & -256;
    g2 = result;
    if (a1 != 0x2074c085) {
        // bb
        result = function_c96b();
        // branch -> 0xc932
    }
    // 0xc932
    return result;
}

// Address range: 0xc948 - 0xc95a
int32_t function_c948(int32_t a1) {
    // 0xc948
    return g3 + 16;
}

// Address range: 0xc95f - 0xc96b
int32_t function_c95f(void) {
    // 0xc95f
    return 0;
}

// Address range: 0xc96b - 0xc96c
int32_t function_c96b(void) {
    // 0xc96b
    return g2;
}

// Address range: 0xc970 - 0xc9b3
// Demangled:     std::_Rb_tree<CNetAddr, std::pair<CNetAddr const, int>, std::_Select1st<std::pair<CNetAddr const, int> >, std::less<CNetAddr>, std::allocator<std::pair<CNetAddr const, int> > >::_M_insert_unique(std::pair<CNetAddr const, int> const &)
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE16_M_insert_uniqueERKS3_(int32_t a1, int32_t a2, int32_t a3) {
    // 0xc970
    g3 = a2;
    g2 = 0;
    g6 = a1;
    g8 = a3;
    int32_t v1 = *(int32_t *)(a2 + (int32_t)&g37); // 0xc98f
    if (v1 != 0) {
        // 0xc9a9
        return v1 + 16;
    }
    // 0xc996
    return function_ca47(0x2074c085);
}

// Address range: 0xc9c3 - 0xc9c7
int32_t function_c9c3(void) {
    // 0xc9c3
    return g2;
}

// Address range: 0xc9c7 - 0xc9cf
int32_t function_c9c7(void) {
    // 0xc9c7
    int32_t result; // 0xc9cc
    if (g4 == *(int32_t *)(g3 + (int32_t)&g47)) {
        // bb
        result = function_ca18();
        // branch -> 0xc9cc
    } else {
        // 0xc9c7
        result = g2;
        // branch -> 0xc9cc
    }
    // 0xc9cc
    return result;
}

// Address range: 0xc9d5 - 0xc9d8
int32_t function_c9d5(void) {
    // 0xc9d5
    return 0;
}

// Address range: 0xc9f7 - 0xca10
int32_t function_c9f7(void) {
    int32_t result = g6; // 0xca02
    g2 = result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_ca4f();
        // branch -> 0xca06
    }
    // 0xca06
    return result;
}

// Address range: 0xca10 - 0xca14
int32_t function_ca10(void) {
    // 0xca10
    return 0;
}

// Address range: 0xca18 - 0xca47
int32_t function_ca18(void) {
    // 0xca18
    int32_t v1; // bp+44
    int32_t v2 = &v1; // 0xca18
    unknown_191f0(v2, 0, g4, g8);
    *(char *)(g6 + (int32_t)&g29) = 1;
    *(int32_t *)g6 = v2;
    return function_c9f7();
}

// Address range: 0xca47 - 0xca4f
int32_t function_ca47(int32_t a1) {
    // 0xca47
    g4 = g3 + (int32_t)&g29;
    return function_c9c7();
}

// Address range: 0xca4f - 0xca50
int32_t function_ca4f(void) {
    // 0xca4f
    return g2;
}

// Address range: 0xca60 - 0xcaa8
// Demangled:     std::_Rb_tree<CNetAddr, std::pair<CNetAddr const, int>, std::_Select1st<std::pair<CNetAddr const, int> >, std::less<CNetAddr>, std::allocator<std::pair<CNetAddr const, int> > >::_M_insert_unique_(std::_Rb_tree_const_iterator<std::pair<CNetAddr const, int> >, std::pair<CNetAddr const, int> const &)
int32_t _ZNSt8_Rb_treeI8CNetAddrSt4pairIKS0_iESt10_Select1stIS3_ESt4lessIS0_ESaIS3_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS3_ERKS3_(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xca60
    g6 = a2;
    g4 = a3;
    g8 = a1;
    int32_t v1 = a2 + (int32_t)&g29; // 0xca87
    int32_t result = v1; // 0xcaa5
    if (v1 == a3) {
        // bb
        result = function_cbb0(0x2074c085);
        // branch -> 0xca9a
    }
    // 0xca9a
    return result;
}

// Address range: 0xcacb - 0xcad4
int32_t function_cacb(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb94; // 0xcacb
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xcae0 - 0xcaec
int32_t function_cae0(int16_t a1) {
    int32_t * v1 = (int32_t *)-0x7bdbdbac; // 0xcae0
    *v1 = *v1 - 1;
    unsigned char v2 = *(char *)&g6; // 0xcae6
    *(char *)0 = v2 >> (char)&g29 | 16 * v2;
    return 0;
}

// Address range: 0xcb13 - 0xcb3c
int32_t function_cb13(void) {
    // 0xcb13
    int32_t v1;
    int32_t v2 = v1 ^ 0x2074c085; // 0xcb17
    g7 = v2;
    int32_t result = g8; // 0xcb1e
    g2 = result;
    if (v2 != 0) {
        // bb
        result = function_cc60();
        // branch -> 0xcb26
    }
    // 0xcb26
    return result;
}

// Address range: 0xcb69 - 0xcb6e
int32_t function_cb69(void) {
    // 0xcb69
    return 0;
}

// Address range: 0xcb7b - 0xcbaf
int32_t function_cb7b(void) {
    int32_t * v1 = (int32_t *)(g4 - 0x7bdbdbac); // 0xcb7b
    *v1 = *v1 - 1;
    *(char *)g6 = __asm_insb((int16_t)g7);
    // bb
    function_cc50();
    // branch -> 0xcb93
    // 0xcb93
    unknown_192e0(g8, g6, g7);
    return function_cb13();
}

// Address range: 0xcbb0 - 0xcbf5
int32_t function_cbb0(int32_t a1) {
    int32_t v1 = g6; // 0xcbb0
    if (*(int32_t *)(v1 + (int32_t)&g14) != 0) {
        // 0xcbe8
        return *(int32_t *)(v1 + 16) + 16;
    }
    // 0xcbb7
    int32_t v2; // bp+40
    unknown_193d0((int32_t)&v2, v1);
    *(int32_t *)g8 = a1;
    return function_cb13();
}

// Address range: 0xcbf9 - 0xcc0b
int32_t function_cbf9(void) {
    int32_t v1 = 0; // eax
    int32_t * v2 = (int32_t *)(v1 + 0x6c89b974 + 8 * v1); // 0xcbf9
    *v2 = *v2 + 1;
    return function_cc14(*(int32_t *)(g6 + 16));
}

// Address range: 0xcc14 - 0xcc30
int32_t function_cc14(int32_t a1) {
    // 0xcc14
    unknown_192e0(g8, g6, 0);
    return function_cb13();
}

// Address range: 0xcc30 - 0xcc50
int32_t function_cc30(void) {
    // 0xcc30
    unknown_192e0(g8, 0, 0);
    return function_cb13();
}

// Address range: 0xcc50 - 0xcc56
int32_t function_cc50(void) {
    // 0xcc50
    return function_cc14(g4);
}

// Address range: 0xcc56 - 0xcc60
int32_t function_cc56(void) {
    // 0xcc56
    return function_cc14(0);
}

// Address range: 0xcc60 - 0xcc61
int32_t function_cc60(void) {
    // 0xcc60
    return g2;
}

// Address range: 0xcc70 - 0xccb8
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, int>, std::_Select1st<std::pair<std::string const, int> >, std::less<std::string>, std::allocator<std::pair<std::string const, int> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<std::string const, int> const &)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE10_M_insert_EPKSt18_Rb_tree_node_baseSB_RKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = a3; // 0xccb1
    if (a3 == 0) {
        // bb
        result = function_cd28(a4, 1);
        // branch -> 0xccb1
    }
    // 0xccb1
    return result;
}

// Address range: 0xccbe - 0xccbf
int32_t function_ccbe(void) {
    // 0xccbe
    return 0;
}

// Address range: 0xccf5 - 0xcd22
int32_t function_ccf5(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 + 0x144683e8); // 0xccf5
    *v2 = *v2 - 1;
    int32_t v3 = 0; // ebx
    int32_t * v4 = (int32_t *)(v3 + 0x653c2454); // 0xccfb
    *v4 = v1 + *v4;
    *(int32_t *)0 = v3;
    int32_t result; // 0xcd1f
    // bb
    result = function_cd50();
    // branch -> 0xcd0c
    // 0xcd0c
    return result;
}

// Address range: 0xcd28 - 0xcd3f
int32_t function_cd28(int32_t a1, int32_t a2) {
    // 0xcd28
    return a1 + 16;
}

// Address range: 0xcd44 - 0xcd50
int32_t function_cd44(void) {
    // 0xcd44
    return false;
}

// Address range: 0xcd50 - 0xcd51
int32_t function_cd50(void) {
    // 0xcd50
    return g2;
}

// Address range: 0xcd6b - 0xcd6c
int32_t function_cd6b(void) {
    // 0xcd6b
    return 0;
}

// Address range: 0xcd80 - 0xcdfe
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, int>, std::_Select1st<std::pair<std::string const, int> >, std::less<std::string>, std::allocator<std::pair<std::string const, int> > >::_M_insert_unique(std::pair<std::string const, int> const &)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE16_M_insert_uniqueERKS2_(int32_t a1, int32_t a2, int32_t * a3) {
    // 0xcd80
    g2 = 0;
    g7 = a2;
    if (*(int32_t *)(a2 + (int32_t)&g37) == 0) {
        // bb
        function_ce75(a1, a2, (int32_t)a3);
        // branch -> 0xcdba
    }
    // 0xcdba
    return *a3;
}

// Address range: 0xce1d - 0xce3a
int32_t function_ce1d(void) {
    // 0xce1d
    int32_t result;
    return result;
}

// Address range: 0xce25 - 0xce26
int32_t function_ce25(int32_t a1) {
    // 0xce25
    return g2;
}

// Address range: 0xce3e - 0xce48
int32_t function_ce3e(void) {
    int32_t * v1 = (int32_t *)-0x7ad7dbac; // 0xce3e
    *v1 = *v1 - 1;
    unsigned char v2 = *(char *)&g6; // 0xce44
    *(char *)0 = v2 >> (char)&g29 | 16 * v2;
    return 0;
}

// Address range: 0xce56 - 0xce75
int32_t function_ce56(void) {
    int32_t result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_cef6();
        // branch -> 0xce6b
    }
    // 0xce6b
    return result;
}

// Address range: 0xce75 - 0xce8c
int32_t function_ce75(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g7 + (int32_t)&g29; // 0xce77
    g6 = v1;
    int32_t result; // 0xce89
    if (v1 == *(int32_t *)(a1 + (int32_t)&g47)) {
        // bb
        result = function_ceb8();
        // branch -> 0xce89
    } else {
        // 0xce75
        result = g2;
        // branch -> 0xce89
    }
    // 0xce89
    return result;
}

// Address range: 0xce90 - 0xceb2
int32_t function_ce90(void) {
    int32_t * v1 = (int32_t *)0x24448bc2; // 0xce90
    *v1 = *v1 - 1;
    uint32_t v2 = *(int32_t *)-12; // 0xce9c
    int32_t v3 = 0; // eax
    uint32_t v4 = *(int32_t *)(v3 - 12); // 0xce9f
    g2 = v4 <= v2 ? v4 : v2;
    return function_ce25(v3);
}

// Address range: 0xceb8 - 0xcef6
int32_t function_ceb8(void) {
    // 0xceb8
    int32_t v1; // bp+60
    int32_t v2;
    int32_t v3;
    unknown_199f0((int32_t)&v1, v2, 0, g6, v3);
    *(char *)(int32_t)&g29 = 1;
    return function_ce56();
}

// Address range: 0xcef6 - 0xcef7
int32_t function_cef6(void) {
    // 0xcef6
    return g2;
}

// Address range: 0xcf00 - 0xcf48
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, int>, std::_Select1st<std::pair<std::string const, int> >, std::less<std::string>, std::allocator<std::pair<std::string const, int> > >::_M_insert_unique_(std::_Rb_tree_const_iterator<std::pair<std::string const, int> >, std::pair<std::string const, int> const &)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsiESt10_Select1stIS2_ESt4lessISsESaIS2_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS2_ERKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xcf00
    g3 = a2;
    g8 = a1;
    int32_t v1 = a2 + (int32_t)&g29; // 0xcf27
    g6 = a4;
    int32_t result = v1; // 0xcf44
    if (v1 == a3) {
        // bb
        result = function_d050(0x2074c085);
        // branch -> 0xcf3a
    }
    // 0xcf3a
    return result;
}

// Address range: 0xcf6b - 0xcf74
int32_t function_cf6b(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb84; // 0xcf6b
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xcfad - 0xcfae
int32_t function_cfad(int16_t a1) {
    // 0xcfad
    return 0;
}

// Address range: 0xcfb3 - 0xcfdc
int32_t function_cfb3(void) {
    int32_t result = g8; // 0xcfbe
    g2 = result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_d100();
        // branch -> 0xcfc6
    }
    // 0xcfc6
    return result;
}

// Address range: 0xd009 - 0xd00e
int32_t function_d009(void) {
    // 0xd009
    return 0;
}

// Address range: 0xd01b - 0xd04a
int32_t function_d01b(void) {
    int32_t * v1 = (int32_t *)-0x7adbdbac; // 0xd01b
    *v1 = *v1 - 1;
    return 137;
}

// Address range: 0xd050 - 0xd064
int32_t function_d050(int32_t a1) {
    // 0xd050
    if (*(int32_t *)(g3 + (int32_t)&g14) == 0) {
        // bb
        function_d070();
        // branch -> 0xd057
    }
    int32_t v1 = *(int32_t *)(g3 + 16); // 0xd057
    g4 = v1;
    return v1 + 16;
}

// Address range: 0xd070 - 0xd092
int32_t function_d070(void) {
    // 0xd070
    int32_t v1; // bp+40
    unknown_19c80((int32_t)&v1, g6);
    return function_cfb3();
}

// Address range: 0xd098 - 0xd09f
int32_t function_d098(void) {
    // 0xd098
    *(int32_t *)g8 = 0;
    return function_cfb3();
}

// Address range: 0xd0a0 - 0xd0c4
int32_t function_d0a0(void) {
    // 0xd0a0
    unknown_19b70(g8);
    return function_cfb3();
}

// Address range: 0xd0c8 - 0xd0ce
int32_t function_d0c8(void) {
    // 0xd0c8
    return 0;
}

// Address range: 0xd0d0 - 0xd0d6
int32_t function_d0d0(void) {
    // 0xd0d0
    return 0;
}

// Address range: 0xd0d6 - 0xd0f6
int32_t function_d0d6(void) {
    // 0xd0d6
    unknown_19b70(g8);
    return function_cfb3();
}

// Address range: 0xd0f6 - 0xd100
int32_t function_d0f6(void) {
    // 0xd0f6
    return 0;
}

// Address range: 0xd100 - 0xd101
int32_t function_d100(void) {
    // 0xd100
    return g2;
}

// Address range: 0xd110 - 0xd185
// Demangled:     std::map<std::string, int, std::less<std::string>, std::allocator<std::pair<std::string const, int> > >::operator[](std::string const &)
int32_t _ZNSt3mapISsiSt4lessISsESaISt4pairIKSsiEEEixERS3_(int32_t a1, int32_t * a2) {
    // 0xd110
    g2 = 0;
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g37); // 0xd142
    if (v1 == 0) {
        // bb
        function_d22a(a1, (int32_t)a2, a1 + (int32_t)&g29);
        // branch -> 0xd14d
    }
    // 0xd14d
    return *(int32_t *)(v1 + 16);
}

// Address range: 0xd19a - 0xd1b6
int32_t function_d19a(int32_t a1) {
    // 0xd19a
    int32_t v1;
    if (v1 == a1) {
        // bb
        int32_t * v2;
        function_d1bf((int32_t)&v2);
        // branch -> 0xd1a4
    }
    // 0xd1a4
    return a1 + 16;
}

// Address range: 0xd1bf - 0xd1ce
int32_t function_d1bf(int32_t a1) {
    // 0xd1bf
    return g2;
}

// Address range: 0xd20d - 0xd22a
int32_t function_d20d(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 - 0x7ce3dbbc); // 0xd20d
    *v2 = *v2 - 1;
    char * v3 = (char *)v1; // 0xd213
    *v3 = (char)((int16_t)*v3 >> (int16_t)&g49);
    int32_t result = 0; // 0xd217
    g2 = result;
    // bb
    result = function_d234();
    // branch -> 0xd222
    // 0xd222
    return result;
}

// Address range: 0xd22a - 0xd234
int32_t function_d22a(int32_t a1, int32_t a2, int32_t a3) {
    // 0xd22a
    return function_d1bf(a1);
}

// Address range: 0xd234 - 0xd235
int32_t function_d234(void) {
    // 0xd234
    return g2;
}

// Address range: 0xd250 - 0xd284
// Demangled:     CDB::~CDB()
int32_t _ZN3CDBD1Ev(int32_t a1) {
    // 0xd250
    return 0;
}

// Address range: 0xd289 - 0xd28a
int32_t function_d289(int32_t a1) {
    // 0xd289
    return g2;
}

// Address range: 0xd28f - 0xd290
int32_t function_d28f(void) {
    // 0xd28f
    return 0;
}

// Address range: 0xd2b0 - 0xd2f8
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, Db *>, std::_Select1st<std::pair<std::string const, Db *> >, std::less<std::string>, std::allocator<std::pair<std::string const, Db *> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<std::string const, Db *> const &)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsP2DbESt10_Select1stIS4_ESt4lessISsESaIS4_EE10_M_insert_EPKSt18_Rb_tree_node_baseSD_RKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = a3; // 0xd2f1
    if (a3 == 0) {
        // bb
        result = function_d368(a4, 1);
        // branch -> 0xd2f1
    }
    // 0xd2f1
    return result;
}

// Address range: 0xd2fe - 0xd2ff
int32_t function_d2fe(void) {
    // 0xd2fe
    return 0;
}

// Address range: 0xd335 - 0xd362
int32_t function_d335(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 + 0x144683e8); // 0xd335
    *v2 = *v2 - 1;
    int32_t v3 = 0; // ebx
    int32_t * v4 = (int32_t *)(v3 + 0x653c2454); // 0xd33b
    *v4 = v1 + *v4;
    *(int32_t *)0 = v3;
    int32_t result; // 0xd35f
    // bb
    result = function_d390();
    // branch -> 0xd34c
    // 0xd34c
    return result;
}

// Address range: 0xd368 - 0xd37f
int32_t function_d368(int32_t a1, int32_t a2) {
    // 0xd368
    return a1 + 16;
}

// Address range: 0xd384 - 0xd390
int32_t function_d384(void) {
    // 0xd384
    return false;
}

// Address range: 0xd390 - 0xd391
int32_t function_d390(void) {
    // 0xd390
    return g2;
}

// Address range: 0xd3ab - 0xd3ac
int32_t function_d3ab(void) {
    // 0xd3ab
    return 0;
}

// Address range: 0xd3c0 - 0xd43e
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, Db *>, std::_Select1st<std::pair<std::string const, Db *> >, std::less<std::string>, std::allocator<std::pair<std::string const, Db *> > >::_M_insert_unique(std::pair<std::string const, Db *> const &)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsP2DbESt10_Select1stIS4_ESt4lessISsESaIS4_EE16_M_insert_uniqueERKS4_(int32_t a1, int32_t a2, int32_t * a3) {
    // 0xd3c0
    g2 = 0;
    g7 = a2;
    if (*(int32_t *)(a2 + (int32_t)&g37) == 0) {
        // bb
        function_d4b5((int32_t *)a1, a2, (int32_t)a3);
        // branch -> 0xd3fa
    }
    // 0xd3fa
    return *a3;
}

// Address range: 0xd45d - 0xd465
int32_t function_d45d(void) {
    // 0xd45d
    return g7;
}

// Address range: 0xd465 - 0xd47a
int32_t function_d465(int32_t result) {
    // 0xd465
    return result;
}

// Address range: 0xd47e - 0xd488
int32_t function_d47e(void) {
    int32_t * v1 = (int32_t *)-0x7ad7dbac; // 0xd47e
    *v1 = *v1 - 1;
    unsigned char v2 = *(char *)&g6; // 0xd484
    *(char *)0 = v2 >> (char)&g29 | 16 * v2;
    return 0;
}

// Address range: 0xd496 - 0xd4b5
int32_t function_d496(void) {
    int32_t result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_d536();
        // branch -> 0xd4ab
    }
    // 0xd4ab
    return result;
}

// Address range: 0xd4b5 - 0xd536
int32_t function_d4b5(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = g7 + (int32_t)&g29; // 0xd4b7
    if (v1 != *(int32_t *)(a2 + (int32_t)&g47)) {
        // 0xd4c9
        g4 = *(int32_t *)(*(int32_t *)(g2 + 16) - 12);
        g8 = *(int32_t *)(*(int32_t *)a3 - 12);
        return function_d465(v1);
    }
    // 0xd4f8
    int32_t v2; // bp+60
    unknown_1a670((int32_t)&v2, a2, 0, v1, a3);
    *a1 = a3;
    *(char *)((int32_t)a1 + (int32_t)&g29) = 1;
    return function_d496();
}

// Address range: 0xd536 - 0xd537
int32_t function_d536(void) {
    // 0xd536
    return g2;
}

// Address range: 0xd540 - 0xd588
// Demangled:     std::_Rb_tree<std::string, std::pair<std::string const, Db *>, std::_Select1st<std::pair<std::string const, Db *> >, std::less<std::string>, std::allocator<std::pair<std::string const, Db *> > >::_M_insert_unique_(std::_Rb_tree_const_iterator<std::pair<std::string const, Db *> >, std::pair<std::string const, Db *> const &)
int32_t _ZNSt8_Rb_treeISsSt4pairIKSsP2DbESt10_Select1stIS4_ESt4lessISsESaIS4_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS4_ERKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xd540
    g3 = a2;
    g8 = a1;
    int32_t v1 = a2 + (int32_t)&g29; // 0xd567
    g6 = a4;
    int32_t result = v1; // 0xd584
    if (v1 == a3) {
        // bb
        result = function_d690(0x2074c085);
        // branch -> 0xd57a
    }
    // 0xd57a
    return result;
}

// Address range: 0xd5ab - 0xd5b4
int32_t function_d5ab(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb84; // 0xd5ab
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xd5f3 - 0xd61c
int32_t function_d5f3(void) {
    int32_t result = g8; // 0xd5fe
    g2 = result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_d740();
        // branch -> 0xd606
    }
    // 0xd606
    return result;
}

// Address range: 0xd649 - 0xd64e
int32_t function_d649(void) {
    // 0xd649
    return 0;
}

// Address range: 0xd65b - 0xd68a
int32_t function_d65b(void) {
    int32_t * v1 = (int32_t *)-0x7adbdbac; // 0xd65b
    *v1 = *v1 - 1;
    return 137;
}

// Address range: 0xd690 - 0xd6a4
int32_t function_d690(int32_t a1) {
    // 0xd690
    if (*(int32_t *)(g3 + (int32_t)&g14) == 0) {
        // bb
        function_d6b0();
        // branch -> 0xd697
    }
    int32_t v1 = *(int32_t *)(g3 + 16); // 0xd697
    g4 = v1;
    return v1 + 16;
}

// Address range: 0xd6b0 - 0xd6d2
int32_t function_d6b0(void) {
    // 0xd6b0
    int32_t v1; // bp+40
    unknown_1a900((int32_t)&v1, g6);
    return function_d5f3();
}

// Address range: 0xd6d8 - 0xd6df
int32_t function_d6d8(void) {
    // 0xd6d8
    *(int32_t *)g8 = 0;
    return function_d5f3();
}

// Address range: 0xd6e0 - 0xd704
int32_t function_d6e0(void) {
    // 0xd6e0
    unknown_1a7f0(g8);
    return function_d5f3();
}

// Address range: 0xd708 - 0xd70e
int32_t function_d708(void) {
    // 0xd708
    return 0;
}

// Address range: 0xd710 - 0xd716
int32_t function_d710(void) {
    // 0xd710
    return 0;
}

// Address range: 0xd716 - 0xd736
int32_t function_d716(void) {
    // 0xd716
    unknown_1a7f0(g8);
    return function_d5f3();
}

// Address range: 0xd736 - 0xd740
int32_t function_d736(void) {
    // 0xd736
    return 0;
}

// Address range: 0xd740 - 0xd741
int32_t function_d740(void) {
    // 0xd740
    return g2;
}

// Address range: 0xd750 - 0xd7c5
// Demangled:     std::map<std::string, Db *, std::less<std::string>, std::allocator<std::pair<std::string const, Db *> > >::operator[](std::string const &)
int32_t _ZNSt3mapISsP2DbSt4lessISsESaISt4pairIKSsS1_EEEixERS5_(int32_t a1, int32_t * a2) {
    // 0xd750
    g2 = 0;
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g37); // 0xd782
    g4 = v1;
    if (v1 == 0) {
        // bb
        function_d86a(a1, (int32_t)a2, a1 + (int32_t)&g29);
        // branch -> 0xd78d
    }
    int32_t v2 = *(int32_t *)(*a2 - 12); // 0xd797
    g6 = v2;
    int32_t result = *(int32_t *)(v1 + 16); // 0xd7ab
    g8 = *(int32_t *)(result - 12) - v2;
    return result;
}

// Address range: 0xd7da - 0xd7f6
int32_t function_d7da(int32_t a1) {
    // 0xd7da
    int32_t v1;
    if (v1 == a1) {
        // bb
        int32_t * v2;
        function_d7ff((int32_t)&v2);
        // branch -> 0xd7e4
    }
    // 0xd7e4
    return a1 + 16;
}

// Address range: 0xd7ff - 0xd80e
int32_t function_d7ff(int32_t a1) {
    // 0xd7ff
    int32_t v1; // bp+52
    g4 = &v1;
    return g2;
}

// Address range: 0xd84d - 0xd86a
int32_t function_d84d(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 - 0x7ce3dbbc); // 0xd84d
    *v2 = *v2 - 1;
    char * v3 = (char *)v1; // 0xd853
    *v3 = (char)((int16_t)*v3 >> (int16_t)&g49);
    int32_t result = 0; // 0xd857
    g2 = result;
    // bb
    result = function_d874();
    // branch -> 0xd862
    // 0xd862
    return result;
}

// Address range: 0xd86a - 0xd874
int32_t function_d86a(int32_t a1, int32_t a2, int32_t a3) {
    // 0xd86a
    return function_d7ff(a1);
}

// Address range: 0xd874 - 0xd875
int32_t function_d874(void) {
    // 0xd874
    return g2;
}

// Address range: 0xd890 - 0xd960
// Demangled:     std::vector<int, std::allocator<int> >::operator=(std::vector<int, std::allocator<int> > const &)
int32_t _ZNSt6vectorIiSaIiEEaSERKS1_(int32_t * a1, int32_t a2) {
    int32_t result = (int32_t)a1;
    g4 = result;
    if (result == a2) {
        // 0xd8fa
        return result;
    }
    int32_t v1 = *(int32_t *)(a2 + (int32_t)&g29); // 0xd8bb
    int32_t v2 = *(int32_t *)a2; // 0xd8be
    int32_t v3 = *a1; // 0xd8c0
    g2 = v3;
    int32_t v4 = v1 - v2; // 0xd8cb
    int32_t v5 = v4 / 4; // 0xd8cd
    g8 = v5;
    int32_t v6 = v3; // 0xd8e2
    int32_t v7 = result; // 0xd8dd
    if (v5 > (*(int32_t *)(result + (int32_t)&g37) - v3) / 4) {
        int32_t v8 = function_d978(v1); // 0xd8d7
        g2 = v8;
        v6 = v8;
        v7 = g4;
        // branch -> 0xd8dd
    }
    int32_t v9 = *(int32_t *)(v7 + (int32_t)&g29); // 0xd8dd
    int32_t v10 = v9 - v6; // 0xd8e2
    int32_t v11 = v10 / 4; // 0xd8e4
    g7 = v11;
    if (v5 <= v11) {
        // 0xd8ef
        int32_t v12; // 0xd8f7
        if (v4 >= 4) {
            // bb121
            v12 = function_d9d0(v9);
            // branch -> 0xd8f7
        } else {
            v12 = v6;
        }
        // 0xd8f7
        *(int32_t *)(g4 + (int32_t)&g29) = v12;
        // branch -> 0xd8fa
        // 0xd8fa
        return g4;
    }
    int32_t result2 = v2 + v11 * (int32_t)&g29; // 0xd928
    int32_t v13 = v6; // 0xd93c
    if (v10 >= 4) {
        // bb123
        v13 = function_d9f0(v9, result2);
        // branch -> 0xd938
    }
    int32_t v14 = v13 + v5 * (int32_t)&g29; // 0xd93c
    if (v1 - result2 >= 4) {
        // 0xd94a
        return result2;
    }
    // 0xd8f7
    *(int32_t *)(g4 + (int32_t)&g29) = v14;
    // branch -> 0xd8fa
    // 0xd8fa
    return g4;
}

// Address range: 0xd964 - 0xd973
int32_t function_d964(void) {
    // 0xd964
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + 0xb504); // 0xd964
    *v2 = *v2 - 1;
    char v3 = *(char *)&g2; // 0xd96a
    int32_t v4 = 0; // eax
    *(char *)v4 = (char)v4 + v3;
    int32_t v5 = 0; // ebx
    int32_t result = v5 + v4; // 0xd96c
    *(int32_t *)(v5 + (int32_t)&g29) = result;
    return result;
}

// Address range: 0xd978 - 0xd9bf
int32_t function_d978(int32_t a1) {
    int32_t v1 = g8; // 0xd978
    int32_t v2 = v1; // 0xd980
    if (v1 == 0) {
        // bb
        g2 = function_da50();
        v2 = g8;
        // branch -> 0xd980
    }
    // 0xd980
    int32_t v3; // 0xd9a1
    if (v2 < 0x40000000) {
        // 0xd980
        v3 = g2;
        // branch -> 0xd98c
    } else {
        int32_t v4 = function_da64(); // 0xd986
        g2 = v4;
        v3 = v4;
        v2 = g8;
        // branch -> 0xd98c
    }
    int32_t v5 = v2 * (int32_t)&g29; // 0xd98c
    if (v2 != 0) {
        // bb13
        function_da30(v5);
        // branch -> 0xd9a9
    }
    // 0xd9a9
    *(int32_t *)g4 = v3;
    return v3 + v5;
}

// Address range: 0xd9c0 - 0xd9c7
int32_t function_d9c0(int32_t a1) {
    int32_t v1 = g5; // 0xd9c1
    char * v2 = (char *)(v1 + 0x30e90443); // 0xd9c1
    *v2 = *v2 | (char)v1;
    return g2;
}

// Address range: 0xd9d0 - 0xd9de
int32_t function_d9d0(int32_t a1) {
    // 0xd9d0
    return g2;
}

// Address range: 0xd9e3 - 0xd9ef
int32_t function_d9e3(void) {
    int32_t v1 = 0; // ebx
    int32_t v2;
    int32_t result = v2 + v1; // 0xd9e5
    *(int32_t *)(v1 + (int32_t)&g29) = result;
    return result;
}

// Address range: 0xd9f0 - 0xd9fe
int32_t function_d9f0(int32_t a1, int32_t a2) {
    // 0xd9f0
    return g2;
}

// Address range: 0xda0e - 0xda1d
int32_t function_da0e(void) {
    char * v1 = (char *)0x24548b03; // 0xda0e
    unsigned char v2 = *v1; // 0xda0e
    int32_t v3 = 0; // ecx
    unsigned char v4 = (char)v3; // 0xda0e
    bool v5 = false; // cf
    char v6 = v5; // 0xda0e
    char v7 = v2 - v4; // 0xda0e
    bool v8 = v5 ? v4 != -1 | v2 < v7 - v6 : v2 < v4; // 0xda0e
    *v1 = v7 + v6;
    char * v9 = (char *)(v3 + 0x2914247c); // 0xda14
    *v9 = (char)v8 + *v9 - (char)v3;
    return 0;
}

// Address range: 0xda20 - 0xda29
int32_t function_da20(int32_t a1) {
    // 0xda20
    return g2;
}

// Address range: 0xda30 - 0xda3f
int32_t function_da30(int32_t a1) {
    // 0xda30
    return g2;
}

// Address range: 0xda44 - 0xda49
int32_t function_da44(void) {
    // 0xda44
    return 0;
}

// Address range: 0xda50 - 0xda5f
int32_t function_da50(void) {
    // 0xda50
    return g2;
}

// Address range: 0xda5f - 0xda60
int32_t function_da5f(void) {
    // 0xda5f
    return g2;
}

// Address range: 0xda64 - 0xda65
int32_t function_da64(void) {
    // 0xda64
    return g2;
}

// Address range: 0xda70 - 0xda97
// Demangled:     std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >::operator=(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const &)
int32_t _ZNSt6vectorIS_IiSaIiEESaIS1_EEaSERKS3_(int32_t a1, int32_t a2) {
    // 0xda70
    return 0;
}

// Address range: 0xdb00 - 0xdb41
int32_t function_db00(int32_t a1) {
    int32_t v1 = g4; // 0xdb00
    g4 = v1 + (int32_t)&g47;
    int32_t v2 = g8; // 0xdb07
    g8 = v2 + (int32_t)&g47;
    unknown_1b300(v2, v1);
    int32_t v3 = g6 - 1; // 0xdb12
    g6 = v3;
    if (v3 != 0) {
        // bb
        function_db00(v2);
        // branch -> 0xdb17
    }
    int32_t v4 = g3; // 0xdb1b
    g3 = a1;
    int32_t v5;
    g2 = 3 * v5;
    int32_t v6 = v4 + v5 * 3 * (int32_t)&g29; // 0xdb24
    g6 = v6;
    int32_t v7 = v6; // 0xdb38
    int32_t v8;
    if (v6 == v8) {
        // bb9
        function_db4d();
        v7 = g6;
        // branch -> 0xdb2d
    }
    int32_t v9 = *(int32_t *)v7; // 0xdb38
    g2 = v9;
    int32_t result = v9; // 0xdb3e
    if (v9 == 0) {
        // bb10
        result = function_db46();
        // branch -> 0xdb3e
    }
    // 0xdb3e
    return result;
}

// Address range: 0xdb46 - 0xdb4d
int32_t function_db46(void) {
    // 0xdb46
    return g2;
}

// Address range: 0xdb4d - 0xdb4e
int32_t function_db4d(void) {
    // 0xdb4d
    return g2;
}

// Address range: 0xdb50 - 0xdb78
int32_t function_db50(int32_t a1) {
    // 0xdb50
    *(int32_t *)(g3 + (int32_t)&g29) = 4 * (g2 & -115 | 82) + g3;
    g2 = g3;
    int32_t result = g3; // 0xdb77
    if (a1 != 0x2074c085) {
        // bb
        result = function_dcf8();
        // branch -> 0xdb70
    }
    // 0xdb70
    return result;
}

// Address range: 0xdb78 - 0xdbd0
int32_t function_db78(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t v1 = 0; // 0xdb78
    int32_t v2 = 0; // 0xdb78
    int32_t v3 = v2 * (int32_t)&g29 + v1; // 0xdb78
    g8 = v3;
    int32_t v4 = -0x55555555 * v2; // 0xdb7b
    g2 = v4;
    if (v4 >= 1) {
        // branch -> 0xdb88
        while (true) {
            int32_t v5 = g6; // 0xdb8f
            g6 = v5 + (int32_t)&g47;
            unknown_1b300(v5, v1);
            int32_t v6 = v4 - 1; // 0xdb9a
            v4 = v6;
            if (v6 == 0) {
                int32_t v7 = 0; // ebp
                int32_t v8 = *(int32_t *)(v7 + (int32_t)&g29); // 0xdba3
                g2 = v8;
                g6 = v7;
                int32_t v9 = *(int32_t *)((int32_t)a2 + (int32_t)&g29); // 0xdba9
                int32_t v10 = *a2 + (v8 - v7 & -4); // 0xdbbf
                g8 = v10;
                // branch -> 0xdbc1
                // 0xdbc1
                g4 = v8;
                if (v9 == v10) {
                    // 0xdbcb
                    return function_dcc1();
                }
                // bb
                function_dc37();
                // branch -> 0xdbcb
                // 0xdbcb
                return function_dcc1();
            }
            // 0xdb88
            v1 += (int32_t)&g47;
            // branch -> 0xdb88
        }
    }
    // 0xdbc1
    g4 = a3;
    if (a1 != v3) {
        // bb
        function_dc37();
        // branch -> 0xdbcb
    }
    // 0xdbcb
    return function_dcc1();
}

// Address range: 0xdbd0 - 0xdbdf
int32_t function_dbd0(void) {
    // 0xdbd0
    int32_t result; // 0xdbdc
    if ((uint32_t)g6 < 0x40000000) {
        // 0xdbd0
        result = g2;
        // branch -> 0xdbdc
    } else {
        // bb
        result = function_dcd0();
        // branch -> 0xdbdc
    }
    // 0xdbdc
    return result;
}

// Address range: 0xdbe0 - 0xdc19
int32_t function_dbe0(int32_t a1) {
    int32_t v1 = g2; // 0xdbe0
    g7 = v1;
    *(int32_t *)(g4 + (int32_t)&g37) = g6 + v1;
    g6 = 0;
    *(int32_t *)g4 = g7;
    *(int32_t *)(g4 + (int32_t)&g29) = g7;
    int32_t v2 = g8; // 0xdbf5
    int32_t v3 = *(int32_t *)(v2 + (int32_t)&g29) - v2; // 0xdbfa
    int32_t result = v3 / 4; // 0xdbfc
    g2 = result;
    if (v3 < 4) {
        // bb
        result = function_dc22();
        // branch -> 0xdc03
    }
    // 0xdc03
    return result;
}

// Address range: 0xdc22 - 0xdc2d
int32_t function_dc22(void) {
    // 0xdc22
    *(int32_t *)(g4 + (int32_t)&g29) = g6 + g7;
    g4 += (int32_t)&g47;
    return g2;
}

// Address range: 0xdc30 - 0xdc34
int32_t function_dc30(int32_t a1) {
    // 0xdc30
    *(char *)g6 = (char)g5 & *(char *)&g6;
    return g2;
}

// Address range: 0xdc37 - 0xdc65
int32_t function_dc37(void) {
    int32_t v1 = g8; // 0xdc3b
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g29); // 0xdc3b
    int32_t v3 = v2 - v1; // edi
    *(int32_t *)g4 = 0;
    *(int32_t *)(g4 + (int32_t)&g29) = 0;
    g6 = v3 / 4;
    *(int32_t *)(g4 + (int32_t)&g37) = 0;
    int32_t result; // 0xdc63
    if (v3 >= 4) {
        // bb
        result = function_dbd0();
        // branch -> 0xdc5f
    } else {
        // 0xdc37
        result = g2;
        // branch -> 0xdc5f
    }
    // 0xdc5f
    g6 = 0;
    return result;
}

// Address range: 0xdc97 - 0xdc98
int32_t function_dc97(void) {
    // 0xdc97
    return 0;
}

// Address range: 0xdc9c - 0xdc9e
int32_t function_dc9c(void) {
    // 0xdc9c
    return 0;
}

// Address range: 0xdcab - 0xdcc1
int32_t function_dcab(void) {
    int32_t * v1 = (int32_t *)-0x76dbdbac; // 0xdcab
    *v1 = *v1 - 1;
    int32_t result = 0; // 0xdcb6
    *(int32_t *)(int32_t)&g37 = result;
    return result;
}

// Address range: 0xdcc1 - 0xdcd0
int32_t function_dcc1(void) {
    // 0xdcc1
    int32_t v1;
    return g6 + v1 * 3 * (int32_t)&g29;
}

// Address range: 0xdcd0 - 0xdcd1
int32_t function_dcd0(void) {
    // 0xdcd0
    return g2;
}

// Address range: 0xdce0 - 0xdced
int32_t function_dce0(int32_t a1) {
    int32_t v1 = g2; // 0xdce0
    int32_t result = unknown_17a90(v1 + 119 & (int32_t)(char)&g29 | v1 & -256); // 0xdce8
    return result;
}

// Address range: 0xdcf8 - 0xdcf9
int32_t function_dcf8(void) {
    // 0xdcf8
    return g2;
}

// Address range: 0xdcfe - 0xdcff
int32_t function_dcfe(void) {
    // 0xdcfe
    return 0;
}

// Address range: 0xdd10 - 0xddae
// Demangled:     unsigned long long ReadCompactSize<CDataStream>(CDataStream &)
int32_t _Z15ReadCompactSizeI11CDataStreamEyRT_(int32_t a1) {
    // 0xdd10
    g4 = a1;
    int32_t v1; // bp-18
    unknown_15880(a1, (int32_t)&v1, 1);
    int32_t result = v1 % 256; // 0xdd3d
    unsigned char v2 = (char)v1; // 0xdd42
    if (v2 < 253) {
        // 0xdd47
        return result;
    }
    if (v2 == -3) {
        // bb
        function_de00();
        result = g7;
        // branch -> 0xdd71
    }
    // 0xdd71
    if ((char)result == -2) {
        // bb18
        function_de28();
        // branch -> 0xdd7a
    }
    // 0xdd7a
    int32_t result2; // bp-36
    unknown_15880(g4, (int32_t)&result2, (int32_t)&g37);
    g2 = result2;
    int32_t v3;
    if (v3 == 0) {
        // bb19
        result2 = function_de4f();
        // branch -> 0xdda3
    }
    // 0xdda3
    return result2;
}

// Address range: 0xddb0 - 0xddb1
int32_t function_ddb0(int32_t a1) {
    // 0xddb0
    return g2;
}

// Address range: 0xde00 - 0xde24
int32_t function_de00(void) {
    // 0xde00
    int32_t v1; // bp+40
    unknown_15880(g4, (int32_t)&v1, 2);
    g7 = 0;
    return v1 % 0x10000;
}

// Address range: 0xde28 - 0xde4f
int32_t function_de28(void) {
    // 0xde28
    int32_t result; // bp+32
    unknown_15880(g4, (int32_t)&result, (int32_t)&g29);
    return result;
}

// Address range: 0xde4f - 0xde5f
int32_t function_de4f(void) {
    // 0xde4f
    return g2;
}

// Address range: 0xde5f - 0xde60
int32_t function_de5f(void) {
    // 0xde5f
    return g2;
}

// Address range: 0xde66 - 0xde67
int32_t function_de66(void) {
    // 0xde66
    return 0;
}

// Address range: 0xde80 - 0xdea6
// Demangled:     std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::_M_copy(std::_Rb_tree_node<int> const *, std::_Rb_tree_node<int> *)
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEE7_M_copyEPKSt13_Rb_tree_nodeIiEPS7_(int32_t a1, int32_t a2, int32_t a3) {
    // 0xde80
    return 0;
}

// Address range: 0xdec0 - 0xded0
int32_t function_dec0(int32_t a1) {
    // 0xdec0
    *(int32_t *)(g7 + (int32_t)&g47) = 0;
    *(int32_t *)g7 = g4;
    return *(int32_t *)(g4 + (int32_t)&g47);
}

// Address range: 0xded0 - 0xdf11
int32_t function_ded0(int32_t a1) {
    // 0xded0
    *(int32_t *)(g7 + (int32_t)&g37) = 0;
    *(int32_t *)(g7 + (int32_t)&g29) = g8;
    int32_t v1 = g2; // 0xdeda
    if (v1 != 0) {
        int32_t v2 = unknown_1bd00(v1, g7); // 0xdee9
        g2 = v2;
        *(int32_t *)(a1 + (int32_t)&g47) = v2;
        // branch -> 0xdef5
    }
    // 0xdef5
    if (*(int32_t *)(g4 + (int32_t)&g37) != 0) {
        // 0xdf0a
        return g2;
    }
    // 0xdf00
    return function_df5c();
}

// Address range: 0xdf1a - 0xdf1b
int32_t function_df1a(void) {
    // 0xdf1a
    return 0;
}

// Address range: 0xdf20 - 0xdf5c
int32_t function_df20(int32_t a1) {
    // 0xdf20
    *(int32_t *)(g4 + 16) = g2;
    *(int32_t *)(g4 + (int32_t)&g47) = 0;
    *(int32_t *)(g4 + (int32_t)&g37) = 0;
    *(int32_t *)(g4 + (int32_t)&g29) = g6;
    *(int32_t *)g4 = g8;
    *(int32_t *)(g6 + (int32_t)&g37) = g4;
    int32_t v1 = *(int32_t *)(g8 + (int32_t)&g47); // 0xdf3e
    int32_t result; // 0xdf4d
    if (v1 != 0) {
        // 0xdf42
        result = unknown_1bd00(v1, g4);
        *(int32_t *)(g4 + (int32_t)&g47) = result;
        // branch -> 0xdf55
    } else {
        result = 0;
    }
    // 0xdf55
    return result;
}

// Address range: 0xdf5c - 0xdf75
int32_t function_df5c(void) {
    int32_t result;
    int32_t v1;
    if (v1 != 0x2074c085) {
        // bb
        result = function_df92();
        // branch -> 0xdf6d
    }
    // 0xdf6d
    return result;
}

// Address range: 0xdf92 - 0xdf99
int32_t function_df92(void) {
    // 0xdf92
    return g2;
}

// Address range: 0xdfb0 - 0xdfbd
// Demangled:     std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::operator=(std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> > const &)
int32_t _ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEEaSERKS5_(int32_t a1, int32_t a2) {
    // 0xdfb0
    return 0;
}

// Address range: 0xdfc0 - 0xe04f
int32_t function_dfc0(int32_t a1) {
    int32_t v1 = g2; // 0xdfc0
    *(char *)v1 = (char)v1 + *(char *)&g2;
    int32_t v2 = g5; // 0xdfc2
    char * v3 = (char *)(v2 + 0x311c2444); // 0xdfc2
    char v4 = *v3 + (char)v2; // 0xdfc2
    *v3 = v4;
    int32_t result; // 0xe045
    if (v4 == 0) {
        // 0xe03a
        result = g4;
        if (a1 != 0x2074c085) {
            // 0xe04f
            return result;
        }
        // 0xe049
        return result;
    }
    // 0xdfcd
    unknown_17120(g4, *(int32_t *)(g4 + (int32_t)&g37));
    int32_t v5 = g4 + (int32_t)&g29; // 0xdfdc
    int32_t v6 = v5; // eax
    *(int32_t *)(g4 + (int32_t)&g47) = v5;
    *(int32_t *)(g4 + (int32_t)&g37) = 0;
    *(int32_t *)(g4 + 16) = v6;
    *(int32_t *)(g4 + (int32_t)&g14) = 0;
    int32_t v7 = *(int32_t *)(g8 + (int32_t)&g37); // 0xdff3
    if (v7 != 0) {
        int32_t v8 = unknown_1be30(g4, v7, v6); // 0xe005
        v6 = v8;
        *(int32_t *)(g4 + (int32_t)&g37) = v8;
        int32_t v9 = *(int32_t *)(v6 + (int32_t)&g37); // 0xe01a
        // branch -> 0xe01a
        while (v9 != 0) {
            // 0xe01a
            v6 = v9;
            v9 = *(int32_t *)(v6 + (int32_t)&g37);
            // continue -> 0xe01a
        }
        // 0xe021
        *(int32_t *)(g4 + (int32_t)&g47) = v6;
        int32_t v10 = *(int32_t *)(v6 + (int32_t)&g47); // 0xe02a5
        if (v10 != 0) {
            int32_t v11 = *(int32_t *)(v10 + (int32_t)&g47); // 0xe02a
            while (v11 != 0) {
                // 0xe028
                v10 = v11;
                v11 = *(int32_t *)(v10 + (int32_t)&g47);
                // continue -> 0xe028
            }
            // 0xe02a
            v6 = v10;
            // branch -> 0xe031
        }
        // 0xe031
        *(int32_t *)(g4 + 16) = v6;
        int32_t v12 = *(int32_t *)(g8 + (int32_t)&g14); // 0xe034
        *(int32_t *)(g4 + (int32_t)&g14) = v12;
        // branch -> 0xe03a
    }
    // 0xe03a
    result = g4;
    if (a1 != 0x2074c085) {
        // 0xe04f
        return result;
    }
    // 0xe049
    return result;
}

// Address range: 0xe060 - 0xe08d
// Demangled:     std::set<int, std::less<int>, std::allocator<int> > * std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > >::_M_allocate_and_copy<__gnu_cxx::__normal_iterator<std::set<int, std::less<int>, std::allocator<int> > const *, std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > > > >(unsigned int, __gnu_cxx::__normal_iterator<std::set<int, std::less<int>, std::allocator<int> > const *, std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > > >, __gnu_cxx::__normal_iterator<std::set<int, std::less<int>, std::allocator<int> > const *, std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > > >)
int32_t _ZNSt6vectorISt3setIiSt4lessIiESaIiEESaIS4_EE20_M_allocate_and_copyIN9__gnu_cxx17__normal_iteratorIPKS4_S6_EEEEPS4_jT_SE_(int32_t result, int32_t a2, int32_t a3) {
    // 0xe060
    return result;
}

// Address range: 0xe090 - 0xe098
int32_t function_e090(int32_t a1) {
    int32_t v1 = g2; // 0xe090
    *(char *)v1 = (char)v1 + *(char *)&g2;
    char * v2 = (char *)(g3 - 0x1f3ebffc); // 0xe092
    *v2 = (char)g5 + *v2;
    return g2;
}

// Address range: 0xe0a0 - 0xe0aa
int32_t function_e0a0(void) {
    int32_t * v1 = (int32_t *)0x74f739c5; // 0xe0a0
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xe0b0 - 0xe0be
int32_t function_e0b0(void) {
    int32_t result = g4 + (int32_t)&g29; // 0xe0b4
    *(int32_t *)result = 0;
    return result;
}

// Address range: 0xe0c0 - 0xe140
int32_t function_e0c0(int32_t a1) {
    int32_t v1 = g2; // 0xe0c0
    *(char *)v1 = (char)v1 | *(char *)&g2;
    int32_t v2 = g2; // 0xe0c2
    *(char *)v2 = (char)v2 + *(char *)&g2;
    uint32_t v3 = g4; // 0xe0c4
    unsigned char v4 = (char)(v3 >> (int32_t)&g37); // 0xe0c4
    int32_t v5 = g2; // 0xe0c4
    unsigned char v6 = (char)v5; // 0xe0c4
    unsigned char v7 = v4 + v6; // 0xe0c4
    int32_t v8 = ((int32_t)v7 << (int32_t)&g37 | v3 & -0xff01) + 1; // ebx
    unsigned char v9 = (char)(v7 < v4) + v6; // 0xe0c7
    int32_t v10 = (int32_t)v9 | v5 & -256; // 0xe0c7
    char * v11 = (char *)v10; // 0xe0c9
    *v11 = *v11 + v9;
    int32_t v12 = g5; // 0xe0cb
    char * v13 = (char *)(v12 + 0x43890c43); // 0xe0cb
    unsigned char v14 = *v13; // 0xe0cb
    unsigned char v15 = v14 + (char)v12; // 0xe0cb
    *v13 = v15;
    char * v16 = (char *)(v8 - 0x2d7af7aa); // 0xe0d1
    unsigned char v17 = (char)g5 + *v16 + (char)(v15 < v14); // 0xe0d1
    *v16 = v17;
    if (v17 != 0) {
        int32_t v18 = unknown_1bee0(v8, g7, v10); // 0xe0e4
        int32_t v19 = v18; // eax
        *(int32_t *)(v8 + 8) = v18;
        int32_t v20 = *(int32_t *)(v19 + (int32_t)&g37); // 0xe0f2
        // branch -> 0xe0f2
        while (v20 != 0) {
            // 0xe0f2
            v19 = v20;
            v20 = *(int32_t *)(v19 + (int32_t)&g37);
            // continue -> 0xe0f2
        }
        // 0xe0f9
        *(int32_t *)(v8 + 12) = v19;
        int32_t v21 = *(int32_t *)(v19 + (int32_t)&g47); // 0xe1024
        if (v21 != 0) {
            int32_t v22 = *(int32_t *)(v21 + (int32_t)&g47); // 0xe102
            while (v22 != 0) {
                // 0xe100
                v21 = v22;
                v22 = *(int32_t *)(v21 + (int32_t)&g47);
                // continue -> 0xe100
            }
            // 0xe102
            v19 = v21;
            // branch -> 0xe109
        }
        // 0xe109
        *(int32_t *)(v8 + 16) = v19;
        int32_t v23 = *(int32_t *)(g8 + (int32_t)&g14); // 0xe10c
        *(int32_t *)(v8 + 20) = v23;
        // branch -> 0xe112
    }
    // 0xe112
    g4 = v8 + 24;
    if (g8 + (int32_t)&g16 != g6) {
        // bb
        function_e0b0();
        // branch -> 0xe11c
    }
    // 0xe11c
    if (a1 != 0x2074c085) {
        // 0xe13f
        return g3;
    }
    // 0xe12b
    return g3;
}

// Address range: 0xe15f - 0xe160
int32_t function_e15f(void) {
    // 0xe15f
    return 0;
}

// Address range: 0xe17f - 0xe180
int32_t function_e17f(void) {
    // 0xe17f
    return 0;
}

// Address range: 0xe180 - 0xe181
int32_t function_e180(int32_t a1) {
    // 0xe180
    return g2;
}

// Address range: 0xe190 - 0xe218
// Demangled:     std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > >::operator=(std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > > const &)
int32_t _ZNSt6vectorISt3setIiSt4lessIiESaIiEESaIS4_EEaSERKS6_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    g6 = v1;
    int32_t v2 = *(int32_t *)(a2 + (int32_t)&g29); // 0xe1b7
    g5 = v2;
    int32_t v3 = *(int32_t *)a2; // 0xe1ba
    g4 = v3;
    int32_t v4 = *a1; // 0xe1bc
    g3 = v4;
    uint32_t result = -0x55555555 * (v2 - v3 >> (int32_t)&g25); // 0xe1c5
    g8 = result;
    int32_t v5 = *(int32_t *)(v1 + (int32_t)&g37); // 0xe1d1
    int32_t v6 = v4; // 0xe1ee
    if (result > -0x55555555 * (v5 - v4 >> (int32_t)&g25)) {
        // bb
        function_e358(result, a2);
        v1 = g6;
        v6 = g3;
        // branch -> 0xe1e7
    }
    int32_t v7 = *(int32_t *)(v1 + (int32_t)&g29); // 0xe1e7
    int32_t v8 = v7 - v6 >> (int32_t)&g25; // 0xe1f0
    g2 = v8;
    if (result > -0x55555555 * v8) {
        // bb112
        function_e288((int32_t *)v7);
        // branch -> 0xe203
    }
    // 0xe203
    return result;
}

// Address range: 0xe21b - 0xe21e
int32_t function_e21b(void) {
    int32_t v1 = 0; // eax
    int32_t result = v1 + (int32_t)(char)&g36 & 255 | v1 & -256; // 0xe21b
    return result;
}

// Address range: 0xe220 - 0xe288
int32_t function_e220(int32_t a1) {
    // 0xe220
    int32_t * v1;
    unknown_1c140((int32_t)&v1);
    int32_t v2 = a1 * 3 * (int32_t)&g37; // 0xe23a
    int32_t v3 = g3 + v2; // 0xe23a
    int32_t result; // edi
    int32_t v4;
    int32_t v5;
    if (v3 != v4) {
        unknown_17300(*(int32_t *)(v3 + (int32_t)&g37));
        // branch -> 0xe248
        while (0 != v3 + (int32_t)&g16) {
            // 0xe248
            v3 += (int32_t)&g16;
            unknown_17300(*(int32_t *)(v3 + (int32_t)&g37));
            // continue -> 0xe248
        }
        // 0xe25e
        result = 0;
        v5 = result;
        // branch -> 0xe25e
    }
    int32_t v6 = *(int32_t *)v5; // 0xe262
    *(int32_t *)(v5 + (int32_t)&g29) = v6 + v2;
    g2 = result;
    int32_t v7;
    if (v7 != 0x2074c085) {
        // bb
        result = function_e3c1();
        // branch -> 0xe280
    }
    // 0xe280
    return result;
}

// Address range: 0xe288 - 0xe2d8
int32_t function_e288(int32_t * a1) {
    int32_t v1 = g2; // 0xe288
    int32_t v2 = v1 * (int32_t)&g37 + g4; // 0xe288
    g8 = v2;
    int32_t v3 = -0x55555555 * v1; // 0xe28b
    int32_t result2; // 0xe2d6
    if (v3 < 1) {
        // 0xe288
        // branch -> 0xe2c8
    } else {
        int32_t v4 = v3; // esi
        int32_t v5 = g4; // 0xe298
        // branch -> 0xe298
        while (true) {
            // 0xe298
            g3 += (int32_t)&g16;
            unknown_1c140(v5);
            int32_t v6 = v4 - 1; // 0xe2aa
            v4 = v6;
            if (v6 == 0) {
                int32_t v7 = g6; // 0xe2af
                int32_t result = *(int32_t *)(v7 + (int32_t)&g29); // 0xe2af
                g3 = v7;
                int32_t v8 = *(int32_t *)((int32_t)a1 + (int32_t)&g29); // 0xe2ba
                g5 = v8;
                int32_t v9 = *a1 + (result - v7 & -8); // 0xe2c2
                g8 = v9;
                // branch -> 0xe2c8
                // 0xe2c8
                if (v8 != v9) {
                    // 0xe2d4
                    g3 = g6;
                    return result;
                }
                // bb
                result2 = function_e3b1();
                // branch -> 0xe2d4
                // 0xe2d4
                g3 = g6;
                return result2;
            }
            // 0xe298
            v5 += (int32_t)&g16;
            // branch -> 0xe298
        }
    }
    // 0xe2c8
    result2 = v3;
    if (g5 == v2) {
        // bb
        result2 = function_e3b1();
        // branch -> 0xe2d4
    }
    // 0xe2d4
    g3 = g6;
    return result2;
}

// Address range: 0xe2d8 - 0xe2ed
int32_t function_e2d8(void) {
    int32_t result = g4 + (int32_t)&g29; // 0xe2dc
    *(int32_t *)result = 0;
    *(int32_t *)(g4 + (int32_t)&g37) = 0;
    return result;
}

// Address range: 0xe2f0 - 0xe358
int32_t function_e2f0(int32_t a1) {
    int32_t v1 = g2; // 0xe2f0
    *(char *)v1 = (char)v1 + *(char *)&g2;
    int32_t v2 = g2; // 0xe2f2
    *(char *)v2 = (char)v2 + *(char *)&g2;
    *(int32_t *)(g4 + (int32_t)&g47) = g2;
    *(int32_t *)(g4 + 16) = g2;
    int32_t v3 = *(int32_t *)(g8 + (int32_t)&g37); // 0xe2fa
    if (v3 != 0) {
        int32_t v4 = unknown_1c010(g4, v3, g2); // 0xe30c
        int32_t v5 = v4; // eax
        *(int32_t *)(g4 + (int32_t)&g37) = v4;
        int32_t v6 = *(int32_t *)(v5 + (int32_t)&g37); // 0xe31a
        // branch -> 0xe31a
        while (v6 != 0) {
            // 0xe31a
            v5 = v6;
            v6 = *(int32_t *)(v5 + (int32_t)&g37);
            // continue -> 0xe31a
        }
        // 0xe321
        *(int32_t *)(g4 + (int32_t)&g47) = v5;
        int32_t v7 = *(int32_t *)(v5 + (int32_t)&g47); // 0xe32a4
        if (v7 != 0) {
            int32_t v8 = *(int32_t *)(v7 + (int32_t)&g47); // 0xe32a
            while (v8 != 0) {
                // 0xe328
                v7 = v8;
                v8 = *(int32_t *)(v7 + (int32_t)&g47);
                // continue -> 0xe328
            }
            // 0xe32a
            v5 = v7;
            // branch -> 0xe331
        }
        // 0xe331
        *(int32_t *)(g4 + 16) = v5;
        int32_t v9 = *(int32_t *)(g8 + (int32_t)&g14); // 0xe334
        *(int32_t *)(g4 + (int32_t)&g14) = v9;
        // branch -> 0xe33a
    }
    // 0xe33a
    g4 += (int32_t)&g16;
    if (g6 != g8 + (int32_t)&g16) {
        // bb
        function_e2d8();
        // branch -> 0xe344
    }
    // 0xe344
    return g3 + a1 * 3 * (int32_t)&g37;
}

// Address range: 0xe358 - 0xe36f
int32_t function_e358(int32_t a1, int32_t a2) {
    int32_t result = unknown_1c1f0(g6, g8, g4, g5); // 0xe367
    g8 = *(int32_t *)(g6 + (int32_t)&g29);
    return result;
}

// Address range: 0xe370 - 0xe397
int32_t function_e370(int16_t a1) {
    int32_t v1 = g4; // 0xe371
    int32_t result = g2; // 0xe373
    g3 = result;
    int32_t v2; // 0xe38e
    if (g8 != v1) {
        int32_t v3 = v1 + (int32_t)&g16; // 0xe37e
        int32_t v4 = unknown_17300(v1); // 0xe385
        while (g8 != v3) {
            // 0xe378
            v1 = v3;
            v3 = v1 + (int32_t)&g16;
            v4 = unknown_17300(v1);
            // continue -> 0xe378
        }
        // 0xe38e
        v2 = g6;
        g4 = v2;
        result = v4;
        // branch -> 0xe390
    }
    if (v2 == 0) {
        // bb
        result = function_e39c();
        // branch -> 0xe394
    }
    // 0xe394
    return result;
}

// Address range: 0xe39c - 0xe3b1
int32_t function_e39c(void) {
    // 0xe39c
    *(int32_t *)g6 = g3;
    *(int32_t *)(g6 + (int32_t)&g37) = g3;
    return g3;
}

// Address range: 0xe3b1 - 0xe3c1
int32_t function_e3b1(void) {
    // 0xe3b1
    int32_t v1;
    return g3 + v1 * 3 * (int32_t)&g37;
}

// Address range: 0xe3c1 - 0xe3c2
int32_t function_e3c1(void) {
    // 0xe3c1
    return g2;
}

// Address range: 0xe3e4 - 0xe3e5
int32_t function_e3e4(void) {
    // 0xe3e4
    return 0;
}

// Address range: 0xe400 - 0xe680
// Demangled:     void CAddrMan::Unserialize<CDataStream>(CDataStream &, int, int)
int32_t _ZN8CAddrMan11UnserializeI11CDataStreamEEvRT_ii(int32_t a1) {
    // 0xe400
    int32_t v1; // bp-668
    unknown_18350((int32_t)&v1, a1, (int32_t)"cs", (int32_t)"addrman.h", (int32_t)&g15, 0);
    char * v2;
    g4 = (int32_t)v2;
    int32_t v3; // bp-645
    return &v3;
}

// Address range: 0xe68e - 0xe68f
int32_t function_e68e(void) {
    // 0xe68e
    return g2;
}

// Address range: 0xe6fc - 0xe6fd
int32_t function_e6fc(void) {
    // 0xe6fc
    return 0;
}

// Address range: 0xe701 - 0xe703
int32_t function_e701(void) {
    // 0xe701
    return function_e68e();
}

// Address range: 0xe76b - 0xe85d
int32_t function_e76b(char a1) {
    int32_t v1 = 0; // ebp
    int32_t * v2 = (int32_t *)(v1 + 0x1800a8); // 0xe76b
    *v2 = *v2 - 1;
    int32_t v3 = 0; // ecx
    char * v4 = (char *)(v3 + 0x248489c7); // 0xe771
    *v4 = *v4 + (char)v3;
    int32_t v5 = &a1; // 0xe777
    char v6 = v5; // 0xe778
    a1 += v6;
    char * v7 = (char *)(v3 + 0x248489c3); // 0xe77a
    *v7 = *v7 + (char)v3;
    a1 += v6;
    char * v8 = (char *)(v1 - 0x768fdb8c); // 0xe783
    *v8 = (char)v3 + *v8;
    char v9 = *(char *)&g8; // 0xe789
    g8 = 1;
    unsigned char v10 = v9 & (char)&g40; // 0xe78a
    int32_t v11 = v5 & -256 | (int32_t)v10; // 0xe78a
    int32_t result = v11; // eax
    char * v12 = (char *)v11; // 0xe78c
    *v12 = *v12 + v10;
    char * v13 = (char *)(v1 - 0x729c8b25); // 0xe78e
    *v13 = (char)result + *v13;
    char v14 = (char)result - 57; // 0xe795
    int32_t v15 = (int32_t)v14 & -256 | (int32_t)v14; // 0xe798
    result = v15;
    char * v16 = (char *)v15; // 0xe79a
    *v16 = *v16 + v14;
    uint32_t v17 = 2; // 0xe79c
    int32_t v18 = result; // 0xe79c
    char v19 = v18; // 0xe79c
    char * v20 = (char *)v18; // 0xe79f
    *v20 = *v20 | v19;
    int32_t v21 = result; // 0xe7a1
    char * v22 = (char *)v21; // 0xe7a1
    *v22 = *v22 + (char)v21;
    uint32_t v23 = (256 * (int32_t)((char)(v17 / 256) + v19) | v17 & -0xff01) + 1; // 0xe7a3
    unsigned char v24 = (char)(v23 >> (int32_t)&g37); // 0xe7a3
    int32_t v25 = result; // 0xe7a3
    unsigned char v26 = (char)v25; // 0xe7a3
    unsigned char v27 = v24 + v26; // 0xe7a3
    int32_t v28 = ((int32_t)v27 << (int32_t)&g37 | v23 & -0xff01) + 1; // ebx
    unsigned char v29 = (char)(v27 < v24) + v26; // 0xe7a6
    int32_t v30 = (int32_t)v29 | v25 & -256; // 0xe7a6
    char * v31 = (char *)v30; // 0xe7a8
    *v31 = *v31 + v29;
    char * v32 = (char *)(v3 + 0x43890c43); // 0xe7aa
    unsigned char v33 = *v32; // 0xe7aa
    unsigned char v34 = v33 + (char)v3; // 0xe7aa
    *v32 = v34;
    char * v35 = (char *)(v28 - 0x2d7af7aa); // 0xe7b0
    unsigned char v36 = (char)v3 + *v35 + (char)(v34 < v33); // 0xe7b0
    *v35 = v36;
    if (v36 != 0) {
        // 0xe7b8
        *(int32_t *)(g9 + (int32_t)&g37) = v30;
        *(int32_t *)(g9 + (int32_t)&g29) = 0;
        *(int32_t *)g9 = v28;
        int32_t v37 = unknown_1c280((int32_t)a1); // 0xe7c3
        result = v37;
        *(int32_t *)(v28 + 8) = v37;
        int32_t v38 = result; // 0xe7d9
        int32_t v39 = *(int32_t *)(v38 + (int32_t)&g37); // 0xe7d2
        // branch -> 0xe7d2
        while (v39 != 0) {
            // 0xe7d2
            v38 = v39;
            v39 = *(int32_t *)(v38 + (int32_t)&g37);
            // continue -> 0xe7d2
        }
        // 0xe7d9
        *(int32_t *)(v28 + 12) = v38;
        int32_t v40 = result; // 0xe7e22
        int32_t v41 = *(int32_t *)(v40 + (int32_t)&g47); // 0xe7e25
        if (v41 != 0) {
            int32_t v42 = *(int32_t *)(v41 + (int32_t)&g47); // 0xe7e2
            while (v42 != 0) {
                // 0xe7e0
                v41 = v42;
                v42 = *(int32_t *)(v41 + (int32_t)&g47);
                // continue -> 0xe7e0
            }
            // 0xe7e2
            v40 = v41;
            // branch -> 0xe7e9
        }
        // 0xe7e9
        *(int32_t *)(v28 + 16) = v40;
        *(int32_t *)(v28 + 20) = *(int32_t *)(g9 + 132);
        // branch -> 0xe7f6
    }
    int32_t v43 = *(int32_t *)(g9 + (int32_t)&g40); // 0xe7fd
    *(int32_t *)(g9 + (int32_t)&g29) = g9 + 148;
    *(int32_t *)(g9 + (int32_t)&g39) = v43;
    *(int32_t *)g9 = *(int32_t *)(g9 + 48) + 180;
    result = unknown_1c590();
    uint32_t v44 = *(int32_t *)(g9 + (int32_t)&g39); // 0xe827
    int32_t v45 = *(int32_t *)(g9 + 148); // 0xe82e
    v28 = v45;
    int32_t v46 = v45; // 0xe856
    if (v44 != v45) {
        int32_t v47 = *(int32_t *)(v45 + 8); // 0xe839
        *(int32_t *)g9 = v45;
        v28 += 24;
        *(int32_t *)(g9 + (int32_t)&g29) = v47;
        int32_t * v48;
        result = unknown_17570((int32_t)a1, (int32_t)&v48);
        while (v44 != v28) {
            // 0xe839
            v45 = v28;
            v47 = *(int32_t *)(v45 + 8);
            *(int32_t *)g9 = v45;
            v28 += 24;
            *(int32_t *)(g9 + (int32_t)&g29) = v47;
            result = unknown_17570((int32_t)a1, (int32_t)&v48);
            // continue -> 0xe839
        }
        // 0xe84f
        v46 = *(int32_t *)(g9 + 148);
        // branch -> 0xe856
    }
    int32_t v49 = v46; // 0xe85a
    if (v46 == 0) {
        // bb
        result = function_e862();
        v49 = g4;
        // branch -> 0xe85a
    }
    // 0xe85a
    *(int32_t *)g9 = v49;
    return result;
}

// Address range: 0xe862 - 0xe89c
int32_t function_e862(void) {
    // 0xe862
    int32_t v1;
    unknown_17570(g8, v1);
    int32_t v2; // bp+516
    return &v2;
}

// Address range: 0xe89c - 0xe8de
int32_t function_e89c(int32_t a1) {
    // 0xe89c
    int32_t v1;
    int32_t v2 = *(int32_t *)(v1 + 108); // 0xe8a4
    int32_t v3; // bp+516
    if (v2 != 0) {
        int32_t v4 = a1;
        // branch -> 0xe8b9
      lab_0xe8b9:
        while (true) {
            int32_t v5 = v2; // 0xe8b9
            // branch -> 0xe8b9
            int32_t v6; // 0xe8cb
            while (true) {
                // 0xe8b9
                if (*(int32_t *)(v5 + 16) < g7) {
                    int32_t v7 = *(int32_t *)(v5 + 12); // 0xe8be
                    if (v7 == 0) {
                        v6 = v4;
                        // break -> 0xe8c5
                        break;
                    }
                    v5 = v7;
                    // continue -> 0xe8b9
                    continue;
                } else {
                    int32_t v8 = *(int32_t *)(v5 + 8); // 0xe8b2
                    if (v8 == 0) {
                        v6 = v5;
                        // break (via goto) -> 0xe8c5
                        goto lab_0xe8c5;
                    }
                    v4 = v5;
                    v2 = v8;
                    // continue (via goto) -> 0xe8b9
                    goto lab_0xe8b9;
                }
                // 0xe8c5
                if (v6 != a1) {
                    // 0xe8cb
                    // branch -> 0xe8d4
                    // 0xe8d4
                    return &v3;
                }
                // 0xe8d4
                return &v3;
            }
          lab_0xe8c5:
            // 0xe8c5
            if (v6 != a1) {
                // 0xe8cb
                // branch -> 0xe8d4
                // 0xe8d4
                return &v3;
            }
            // 0xe8d4
            return &v3;
        }
    }
    // 0xe8d4
    return &v3;
}

// Address range: 0xe940 - 0xe9a6
int32_t function_e940(int32_t a1) {
    int32_t v1 = g2; // 0xe940
    *(char *)v1 = (char)v1 + *(char *)&g2;
    int32_t v2 = g2; // 0xe942
    *(char *)v2 = (char)v2 + *(char *)&g2;
    __asm_rep_movsd_memcpy((char *)g6, (char *)g8, g5);
    int32_t v3 = g2; // bp+184
    unknown_1aaf0(g7, a1, (int32_t)&v3);
    unsigned char result;
    return result;
}

// Address range: 0xe9aa - 0xead3
int32_t function_e9aa(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // esi
    int32_t v2 = 0; // 0xe9af
    int32_t v3 = (int32_t)((char)v2 + *(char *)&g6) | v2 & -256; // 0xe9af
    char * v4 = (char *)(v3 + 0x7e00007a); // 0xe9bc
    *v4 = (char)(v3 / 256) + *v4;
    unsigned char v5 = 117; // 0xe9c7
    int32_t v6 = 0; // 0xe9c9
    g3 = 1;
    unsigned char v7 = v5 & 8; // 0xe9d3
    int32_t v8 = v7; // 0xe9d3
    char * v9 = (char *)v8; // 0xe9d7
    *v9 = *v9 + v7;
    int32_t v10 = 256 * (int32_t)v5 ^ v6 & 0xff00 | v6 & -0xff01; // 0xe9dd
    unknown_15f70(v1, v10, v8);
    unknown_15f70(a2, g3 + 40, (int32_t)&g37);
    unknown_15f70(a2, v1, g3 + 36 - v1);
    uint16_t v11 = *(int16_t *)(g3 + 36); // 0xea15
    int16_t v12 = v11 >> (int16_t)&g37 | v11 << (int16_t)&g37; // bp+179
    unknown_15f70(a2, (int32_t)&v12, 2);
    int32_t v13 = g3 + 60; // 0xea40
    *(int16_t *)(g3 + 36) = llvm_bswap_i16(v12);
    int32_t v14 = g3 + 76; // 0xea5e
    unknown_15f70(a2, v13, v14 - v13);
    unknown_15f70(a2, v14, (int32_t)&g37);
    unknown_15f70(a2, g3 + 84, (int32_t)&g29);
    int32_t v15 = *(int32_t *)(a1 + 132); // 0xeaaf
    if (v15 != 0) {
        // 0xeac9
        return v15 + 16;
    }
    // 0xeab9
    return function_eafc();
}

// Address range: 0xeae3 - 0xeaf3
int32_t function_eae3(void) {
    int32_t v1 = g6; // 0xeae3
    int32_t v2 = v1; // 0xeae9
    int32_t v3;
    if (v3 == v1) {
        // bb
        function_eafc();
        v2 = g6;
        // branch -> 0xeae9
    }
    // 0xeae9
    return v2 + 16;
}

// Address range: 0xeafc - 0xeb3b
int32_t function_eafc(void) {
    // 0xeafc
    return *(int32_t *)(g3 + (int32_t)&g21);
}

// Address range: 0xeb40 - 0xebba
int32_t function_eb40(int32_t a1) {
    int32_t v1 = g2; // 0xeb40
    *(char *)v1 = (char)v1 + *(char *)&g2;
    int32_t v2; // bp+756
    unknown_1ae60((int32_t)&v2);
    int32_t * v3 = (int32_t *)(a1 + (int32_t)&g39); // 0xeb64
    g2 = *v3;
    int32_t v4 = g2; // 0xeb6d
    int32_t v5 = *(int32_t *)(a1 + 148); // 0xeb6f
    *(int32_t *)(g3 + (int32_t)&g32) = (v4 - v5) / 4;
    int32_t v6; // 0xeb81
    if (v4 == *(int32_t *)(a1 + (int32_t)&g40)) {
        // bb
        v6 = function_eef4();
        g2 = v6;
        // branch -> 0xeb87
    } else {
        // 0xeb87
        v6 = g2;
        // branch -> 0xeb87
    }
    int32_t v7 = (int32_t)&g29; // 0xeb91
    if (v6 != 0) {
        // 0xeb8b
        *(int32_t *)v6 = 0;
        v7 = g2 + (int32_t)&g29;
        // branch -> 0xeb8d
    }
    // 0xeb8d
    *v3 = v7;
    int32_t v8;
    int32_t result; // 0xebb6
    if (v8 == 256) {
        // bb14
        result = function_ebf1();
        // branch -> 0xeba7
    } else {
        // 0xeb8d
        result = v7;
        // branch -> 0xeba7
    }
    // 0xeba7
    return result;
}

// Address range: 0xebf1 - 0xec50
int32_t function_ebf1(void) {
    // 0xebf1
    int32_t v1;
    int32_t v2 = *(int32_t *)(v1 + 176); // 0xebfc
    int32_t v3;
    int32_t v4 = v3 + 1; // 0xec02
    g7 = v4;
    int32_t v5 = v2; // 0xec18
    if (v2 > v4) {
        // bb
        v5 = function_e89c(v4);
        // branch -> 0xec14
    }
    // 0xec14
    *(int32_t *)(v1 + (int32_t)&g32) = v5;
    int32_t v6 = *(int32_t *)(int32_t)&g42; // 0xec1b
    g2 = v6;
    if (v6 < 1) {
        // bb12
        g2 = function_f1be();
        // branch -> 0xec29
    }
    // 0xec29
    return function_eda0(0, 0);
}

// Address range: 0xec50 - 0xec51
int32_t function_ec50(void) {
    // 0xec50
    return g2;
}

// Address range: 0xec64 - 0xec65
int32_t function_ec64(void) {
    // 0xec64
    return g2;
}

// Address range: 0xed6d - 0xed6e
int32_t function_ed6d(void) {
    // 0xed6d
    return 0;
}

// Address range: 0xed87 - 0xeda0
int32_t function_ed87(void) {
    // 0xed87
    int32_t v1;
    return *(int32_t *)(v1 + (int32_t)&g42);
}

// Address range: 0xeda0 - 0xeda3
int32_t function_eda0(int32_t a1, int32_t a2) {
    // 0xeda0
    return g2;
}

// Address range: 0xedd0 - 0xee1e
int32_t function_edd0(int32_t a1) {
    int32_t v1 = g2; // 0xedd0
    *(char *)v1 = (char)v1 + *(char *)&g2;
    int32_t v2 = g2; // 0xedd2
    *(char *)v2 = (char)v2 + *(char *)&g2;
    int32_t v3 = g2; // 0xedd4
    int32_t v4 = ((g4 >> (int32_t)&g37) + v3) % 256 << (int32_t)&g37 | g4 & -0xff01; // ebx
    *(int32_t *)v3 = 2 * v3;
    int32_t v5 = g2; // 0xeddb
    *(char *)v5 = (char)v5 + *(char *)&g2;
    int32_t v6 = g2; // 0xeddd
    *(char *)v6 = (char)v6 + *(char *)&g2;
    uint32_t v7 = v4; // 0xeddf
    int32_t v8 = g2; // 0xeddf
    v4 = ((v7 >> (int32_t)&g37) + v8) % 256 << (int32_t)&g37 | v7 & -0xff01;
    *(int32_t *)v8 = 2 * v8;
    int32_t v9 = g2; // 0xede6
    *(char *)v9 = (char)v9 + *(char *)&g2;
    int32_t v10 = g2; // 0xede8
    *(char *)v10 = (char)v10 + *(char *)&g2;
    uint32_t v11 = v4; // 0xedea
    int32_t v12 = g2; // 0xedea
    v4 = 256 * ((v11 >> (int32_t)&g37) + v12) & 0xff00 | v11 & -0xff01;
    *(int32_t *)v12 = 2 * v12;
    int32_t v13 = g2; // 0xedf1
    *(char *)v13 = (char)v13 + *(char *)&g2;
    int32_t v14 = g2; // 0xedf3
    *(char *)v14 = (char)v14 + *(char *)&g2;
    int32_t v15 = g2; // 0xedf5
    g4 = 256 * v15 + v4 & 0xff00 | v4 & -0xff01;
    *(int32_t *)v15 = 2 * v15;
    int32_t v16 = g2; // 0xedfc
    *(char *)v16 = (char)v16 + *(char *)&g2;
    int32_t v17 = g2; // 0xedfe
    *(char *)v17 = (char)v17 + *(char *)&g2;
    uint32_t v18 = g7; // 0xee00
    int32_t v19 = g2; // 0xee00
    g7 = 256 * ((v18 >> (int32_t)&g37) + v19) & 0xff00 | v18 & -0xff01;
    *(int32_t *)v19 = 2 * v19;
    int32_t v20 = g2; // 0xee07
    *(char *)v20 = (char)v20 + *(char *)&g2;
    return g2;
}

// Address range: 0xee23 - 0xee53
int32_t function_ee23(int32_t a1, int32_t a2) {
    // 0xee23
    g2 = a2;
    if (a2 == 0) {
        // bb
        function_ec50();
        // branch -> 0xee2f
    }
    // 0xee2f
    int32_t v1; // bp+176
    g2 = unknown_15f70(a1, (int32_t)&v1, (int32_t)&g29);
    return function_ec64();
}

// Address range: 0xee53 - 0xee54
int32_t function_ee53(void) {
    // 0xee53
    return g2;
}

// Address range: 0xee54 - 0xee55
int32_t function_ee54(void) {
    // 0xee54
    return 0;
}

// Address range: 0xee55 - 0xee56
int32_t function_ee55(void) {
    // 0xee55
    return g2;
}

// Address range: 0xee6c - 0xee6e
int32_t function_ee6c(void) {
    // 0xee6c
    return function_ee53();
}

// Address range: 0xee86 - 0xee95
int32_t function_ee86(void) {
    int32_t * v1 = (int32_t *)0x241c89c6; // 0xee86
    *v1 = *v1 - 1;
    g2 = unknown_17180();
    return function_ee55();
}

// Address range: 0xee95 - 0xeead
int32_t function_ee95(int32_t a1) {
    // 0xee95
    int32_t v1; // bp+112
    g2 = unknown_17570((int32_t)&v1, a1);
    return function_ee55();
}

// Address range: 0xeeae - 0xeeaf
int32_t function_eeae(void) {
    // 0xeeae
    return 0;
}

// Address range: 0xeec7 - 0xeec9
int32_t function_eec7(void) {
    // 0xeec7
    return 0;
}

// Address range: 0xeed0 - 0xeef4
int32_t function_eed0(int32_t a1) {
    // 0xeed0
    int32_t v1; // bp+176
    return unknown_15f70(a1, (int32_t)&v1, (int32_t)&g29);
}

// Address range: 0xeef4 - 0xef19
int32_t function_eef4(void) {
    // 0xeef4
    int32_t v1; // bp+172
    int32_t v2;
    return unknown_17650(v2 + 148, g2, (int32_t)&v1);
}

// Address range: 0xef19 - 0xef2a
int32_t function_ef19(void) {
    // 0xef19
    return unknown_175d0(0);
}

// Address range: 0xef30 - 0xefc7
int32_t function_ef30(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + (int32_t)&g39); // 0xef3c
    int32_t v2 = *v1; // 0xef3c
    g2 = v2;
    int32_t v3 = a2 + (int32_t)&g32; // 0xef4a
    g4 = a2;
    int32_t v4 = v2; // 0xef72
    if (v2 == *(int32_t *)(a2 + (int32_t)&g40)) {
        int32_t v5 = function_f19c(v3); // 0xef65
        g2 = v5;
        v4 = v5;
        // branch -> 0xef6b
    }
    int32_t v6 = (int32_t)&g29; // 0xef78
    if (v4 != 0) {
        // 0xef6f
        *(int32_t *)v4 = *(int32_t *)(g4 + (int32_t)&g32);
        v6 = g2 + (int32_t)&g29;
        // branch -> 0xef74
    }
    // 0xef74
    *v1 = v6;
    uint32_t v7 = *(int32_t *)v3; // 0xef90
    g4 = a1;
    int32_t v8 = a1;
    int32_t v9 = *(int32_t *)(a2 + 108);
    // branch -> 0xefa2
  lab_0xefa2:
    while (true) {
        int32_t v10 = v9; // 0xefa2
        // branch -> 0xefa2
        int32_t v11; // 0xefb4
        int32_t result; // 0xefc4
        int32_t result2; // 0xefc411
        while (true) {
            // 0xefa2
            if (v7 > *(int32_t *)(v10 + 16)) {
                int32_t v12 = *(int32_t *)(v10 + 12); // 0xefa7
                if (v12 == 0) {
                    result2 = v12;
                    v11 = v8;
                    // break -> 0xefae
                    break;
                }
                v10 = v12;
                // continue -> 0xefa2
                continue;
            } else {
                // 0xef99
                g4 = v10;
                int32_t v13 = *(int32_t *)(v10 + 8); // 0xef9b
                if (v13 == 0) {
                    result2 = 0;
                    v11 = v10;
                    // break (via goto) -> 0xefae
                    goto lab_0xefae;
                }
                v8 = v10;
                v9 = v13;
                // continue (via goto) -> 0xefa2
                goto lab_0xefa2;
            }
            // 0xefae
            if (v11 == a1) {
                result = result2;
                // 0xefbd
                return result;
            }
            uint32_t v14 = *(int32_t *)(v11 + 16); // 0xefb4
            if (v7 >= v14) {
                // bb118
                result = function_f076();
                // branch -> 0xefbd
            } else {
                result = result2;
            }
            // 0xefbd
            return result;
        }
      lab_0xefae:
        // 0xefae
        if (v11 == a1) {
            // 0xefbd
            return result2;
        }
        // 0xefb4
        if (v7 >= *(int32_t *)(v11 + 16)) {
            // bb118
            result = function_f076();
            // branch -> 0xefbd
        } else {
            result = result2;
        }
        // 0xefbd
        return result;
    }
}

// Address range: 0xf076 - 0xf0a9
int32_t function_f076(void) {
    // 0xf076
    __asm_rep_movsd_memcpy((char *)(g4 + (int32_t)&g14), (char *)g3, (int32_t)&g14);
    int32_t v1;
    int32_t v2 = *(int32_t *)(v1 + 132); // 0xf08a
    if (v2 != 0) {
        // 0xf09f
        return v2 + 16;
    }
    // 0xf094
    return function_f0d2();
}

// Address range: 0xf0b9 - 0xf0c9
int32_t function_f0b9(void) {
    int32_t v1 = g8; // 0xf0b9
    int32_t v2 = v1; // 0xf0bf
    int32_t v3;
    if (v3 == v1) {
        // bb
        function_f0d2();
        v2 = g8;
        // branch -> 0xf0bf
    }
    // 0xf0bf
    return v2 + 16;
}

// Address range: 0xf0d2 - 0xf0fe
int32_t function_f0d2(void) {
    // 0xf0d2
    int32_t result;
    return result;
}

// Address range: 0xf100 - 0xf19c
int32_t function_f100(int32_t a1) {
    // 0xf100
    unknown_1ae60(g7);
    int32_t * v1 = (int32_t *)(a1 + (int32_t)&g32); // 0xf143
    int32_t v2;
    *(int32_t *)(v2 + (int32_t)&g21) = *v1;
    int32_t v3 = *(int32_t *)(a1 + (int32_t)&g29); // 0xf14d
    int32_t v4;
    if (v3 == *(int32_t *)(a1 + (int32_t)&g37)) {
        // 0xf182
        int32_t v5;
        unknown_17650(v4, v3, v5);
        // branch -> 0xf16c
    } else {
        // 0xf155
        if (v3 != 0) {
            // 0xf159
            *(int32_t *)v3 = *v1;
            // branch -> 0xf162
        }
        // 0xf162
        *(int32_t *)(v4 + (int32_t)&g29) = v3 + (int32_t)&g29;
        // branch -> 0xf16c
    }
    // 0xf16c
    *v1 = *v1 + 1;
    return function_ed87();
}

// Address range: 0xf19c - 0xf1be
int32_t function_f19c(int32_t a1) {
    // 0xf19c
    int32_t v1;
    return unknown_17650(a1 + 148, g2, v1);
}

// Address range: 0xf1be - 0xf2ce
int32_t function_f1be(void) {
    // 0xf1be
    int32_t v1;
    *(int32_t *)(v1 + (int32_t)&g42) = g2;
    int32_t v2;
    if (v2 < 1) {
        // bb
        function_f3b9(0);
        // branch -> 0xf1e3
    }
    // 0xf1e3
    int32_t v3; // bp+676
    int32_t result = &v3; // 0xf1ea
    int32_t v4 = 0; // bp+172
    int32_t v5;
    unknown_15f70(v5, (int32_t)&v4, (int32_t)&g29);
    g2 = v4;
    if (v4 < 1) {
        // bb35
        function_f39e();
        // branch -> 0xf251
    }
    // 0xf251
    g3 = 0;
    int32_t v6 = 0; // bp+176
    unknown_15f70(v5, (int32_t)&v6, (int32_t)&g29);
    int32_t v7 = *(int32_t *)(v1 + 108); // 0xf286
    g2 = v7;
    int32_t v8 = v7; // 0xf2a96
    if (v7 == 0) {
        // bb36
        v8 = function_f41d();
        // branch -> 0xf291
    }
    int32_t v9;
    int32_t v10 = v9;
    // branch -> 0xf2a9
  lab_0xf2a9:
    while (true) {
        int32_t v11 = v8; // 0xf2a9
        // branch -> 0xf2a9
        int32_t v12; // 0xf2bb
        while (true) {
            // 0xf2a9
            if (v6 > *(int32_t *)(v11 + 16)) {
                int32_t v13 = *(int32_t *)(v11 + 12); // 0xf2ae
                g2 = v13;
                if (v13 == 0) {
                    v12 = v10;
                    // break -> 0xf2b5
                    break;
                }
                v11 = v13;
                // continue -> 0xf2a9
                continue;
            } else {
                // 0xf2a0
                g4 = v11;
                int32_t v14 = *(int32_t *)(v11 + 8); // 0xf2a2
                g2 = v14;
                if (v14 == 0) {
                    v12 = v11;
                    // break (via goto) -> 0xf2b5
                    goto lab_0xf2b5;
                }
                v10 = v11;
                v8 = v14;
                // continue (via goto) -> 0xf2a9
                goto lab_0xf2a9;
            }
            // 0xf2b5
            if (v9 == v12) {
                // 0xf2c4
                return result;
            }
            uint32_t v15 = *(int32_t *)(v12 + 16); // 0xf2bb
            if (v6 >= v15) {
                // bb37
                function_f381();
                // branch -> 0xf2c4
            }
            // 0xf2c4
            return result;
        }
      lab_0xf2b5:
        // 0xf2b5
        if (v9 == v12) {
            // 0xf2c4
            return result;
        }
        // 0xf2bb
        if (v6 >= *(int32_t *)(v12 + 16)) {
            // bb37
            function_f381();
            // branch -> 0xf2c4
        }
        // 0xf2c4
        return result;
    }
}

// Address range: 0xf381 - 0xf39e
int32_t function_f381(void) {
    // 0xf381
    int32_t v1;
    int32_t result; // 0xf398
    if (v1 == 256) {
        // bb
        result = function_f3e8();
        // branch -> 0xf38e
    } else {
        // 0xf381
        result = g2;
        // branch -> 0xf38e
    }
    // 0xf38e
    return result;
}

// Address range: 0xf39e - 0xf3b9
int32_t function_f39e(void) {
    // 0xf39e
    return g2;
}

// Address range: 0xf3b9 - 0xf3e3
int32_t function_f3b9(int32_t a1) {
    // 0xf3b9
    int32_t v1; // bp+160
    int32_t result = unknown_17460((int32_t)&v1); // 0xf3c3
    g2 = result;
    if (a1 != 0x2074c085) {
        // bb
        result = function_f426();
        // branch -> 0xf3d8
    }
    // 0xf3d8
    return result;
}

// Address range: 0xf3e8 - 0xf41d
int32_t function_f3e8(void) {
    int32_t * v1 = (int32_t *)(g4 + (int32_t)&g30); // 0xf3e8
    *v1 = *v1 + 1;
    int32_t v2; // bp+176
    int32_t v3; // bp+96
    int32_t v4;
    return unknown_18710((int32_t)&v3, v4, (int32_t)&v2);
}

// Address range: 0xf400 - 0xf401
int32_t function_f400(int32_t a1) {
    // 0xf400
    return g2;
}

// Address range: 0xf41d - 0xf426
int32_t function_f41d(void) {
    // 0xf41d
    return g2;
}

// Address range: 0xf426 - 0xf427
int32_t function_f426(void) {
    // 0xf426
    return g2;
}

// Address range: 0xf430 - 0xf446
int32_t _GLOBAL__sub_I_nWalletDBUpdated(void) {
    // 0xf430
    return 0;
}

// Address range: 0xf470 - 0xf471
int32_t function_f470(void) {
    // 0xf470
    return g2;
}

// Address range: 0xf474 - 0xf47a
int32_t function_f474(void) {
    // 0xf474
    return 0;
}

// Address range: 0xf47e - 0xf484
int32_t function_f47e(void) {
    // 0xf47e
    return 0;
}

// Address range: 0xf4b5 - 0xf4c7
int32_t function_f4b5(void) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0xf4b5
    *v1 = *v1 - 1;
    int32_t v2 = 0x2074c085; // 0xf4bb
    g2 = v2;
    int32_t result = v2; // 0xf4c6
    if (v2 != 0) {
        // bb
        result = function_f4fc();
        // branch -> 0xf4c3
    }
    // 0xf4c3
    return result;
}

// Address range: 0xf4f7 - 0xf4fc
int32_t function_f4f7(void) {
    // 0xf4f7
    return function_f470();
}

// Address range: 0xf4fc - 0xf4fd
int32_t function_f4fc(void) {
    // 0xf4fc
    return g2;
}

// Address range: 0xf5f0 - 0xf5f1
int32_t _ZZN5boost15recursive_mutexC1EvE19__PRETTY_FUNCTION__(int32_t a1) {
    // 0xf5f0
    return g2;
}

// Address range: 0xf670 - 0xf671
int32_t _ZZN5boost11filesystem311path_traits7convertEPKcS3_RSsRKSt7codecvtIwc11__mbstate_tEE19__PRETTY_FUNCTION__(int32_t a1) {
    // 0xf670
    return g2;
}

// Address range: 0xff32 - 0xff33
int32_t function_ff32(void) {
    // 0xff32
    return g2;
}

// Address range: 0x101c0 - 0x101c1
int32_t function_101c0(int32_t a1) {
    // 0x101c0
    return g2;
}

// Address range: 0x102c0 - 0x102c1
int32_t function_102c0(int32_t a1) {
    // 0x102c0
    return g2;
}

// Address range: 0x107a0 - 0x107a1
int32_t function_107a0(int32_t a1, int32_t a2) {
    // 0x107a0
    return g2;
}

// Address range: 0xc6840f - 0xc68410
int32_t function_c6840f(void) {
    // 0xc6840f
    return g2;
}

// Address range: 0x75906601 - 0x75906602
int32_t function_75906601(void) {
    // 0x75906601
    return g2;
}

// Address range: 0x88000000 - 0x88000001
int32_t function_88000000(void) {
    // 0x88000000
    return g2;
}

// Address range: 0x89000119 - 0x8900011a
int32_t function_89000119(void) {
    // 0x89000119
    return g2;
}

// Address range: 0x891e7401 - 0x891e7402
int32_t function_891e7401(void) {
    // 0x891e7401
    return g2;
}

// Address range: 0x8b003169 - 0x8b00316a
int32_t function_8b003169(void) {
    // 0x8b003169
    return g2;
}

// Address range: 0xc7000000 - 0xc7000001
int32_t function_c7000000(void) {
    // 0xc7000000
    return g2;
}

// Address range: 0xdb31da01 - 0xdb31da02
int32_t function_db31da01(void) {
    // 0xdb31da01
    return g2;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected language: C++
// Detected functions: 1137
// Decompilation date: 2018-06-10 00:05:18
