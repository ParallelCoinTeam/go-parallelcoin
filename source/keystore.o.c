//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct has_fallback_type_ {
    int32_t e0;
};

struct has_fallback_type__5 {
    int32_t e0;
};

struct has_fallback_type__1 {
    int32_t e0;
};

struct has_fallback_type__1_6 {
    int32_t e0;
};

struct vector_unsignedchar_secure_allocator_unsignedchar__ {
    int32_t e0;
};

struct vector_unsignedchar_secure_allocator_unsignedchar___4 {
    int32_t e0;
};

struct vtable_eed0_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t);
};

struct vtable_ef28_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    void (*e2)(int32_t, int32_t, int32_t);
    int32_t (*e3)();
    int32_t (*e4)(int32_t, int32_t);
    int32_t (*e5)(int32_t, int32_t, int32_t *);
    int32_t (*e6)(int32_t, int32_t);
    void (*e7)(int32_t, int32_t, int32_t);
    void (*e8)(int32_t, int32_t);
    void (*e9)(int32_t, int32_t);
    void (*e10)(int32_t, int32_t, int32_t);
};

struct vtable_efa0_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_efb8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_efe8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_f028_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

struct vtable_f0c0_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t *, int32_t);
};

struct vtable_f0d8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)();
};

struct vtable_f0f8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_f128_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_f168_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

struct vtable_f208_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t);
    int32_t (*e3)(int32_t *);
    int32_t (*e4)();
};

struct vtable_f228_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t);
    int32_t (*e3)(int32_t *);
    int32_t (*e4)();
};

struct vtable_f248_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
};

struct vtable_f288_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t);
    int32_t (*e3)(int32_t);
};

// ------------------------- Classes --------------------------

// CBasicKeyStore (base classes: CKeyStore)
// CKeyStore
// N5boost10lock_errorE (base classes: N5boost16thread_exceptionE)
// N5boost12noncopyable_11noncopyableE
// N5boost16exception_detail10bad_alloc_E
// N5boost16exception_detail10clone_baseE
// N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE (base classes: N5boost16exception_detail10bad_alloc_E, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE (base classes: N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEEE (base classes: N5boost16exception_detail10clone_baseE, N5boost16exception_detail19error_info_injectorINS_17bad_function_callEEE)
// N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE (base classes: N5boost10lock_errorE, N5boost9exceptionE)
// N5boost16exception_detail19error_info_injectorINS_17bad_function_callEEE (base classes: N5boost17bad_function_callE, N5boost9exceptionE)
// N5boost16thread_exceptionE
// N5boost17bad_function_callE
// N5boost6detail15sp_counted_baseE
// N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE (base classes: N5boost6detail15sp_counted_baseE)
// N5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEEE (base classes: N5boost6detail15sp_counted_baseE)
// N5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEEE (base classes: N5boost6detail15sp_counted_baseE)
// N5boost6system12system_errorE
// N5boost8signals211signal_baseE (base classes: N5boost12noncopyable_11noncopyableE)
// N5boost8signals26detail19std_functional_baseE
// N5boost8signals26signalIFvP15CCryptoKeyStoreENS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIS4_EENS9_IFvRKNS0_10connectionES3_EEENS0_5mutexEEE (base classes: N5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEE)
// N5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEE (base classes: N5boost8signals211signal_baseE, N5boost8signals26detail19std_functional_baseE)
// N5boost9exceptionE

// ------------------- Function Prototypes --------------------

void _7e_auto_buffer(int32_t this, int32_t __in_chrg);
void _7e_pthread_mutex_scoped_lock(int32_t this, int32_t __in_chrg);
int32_t _GLOBAL__sub_I__ZNK9CKeyStore9GetPubKeyERK6CKeyIDR7CPubKey(void);
int32_t _ZltRK7uint160S1_(int32_t * a1, int32_t a2);
int32_t _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
void _ZN14CBasicKeyStore10AddCScriptERK7CScript(int32_t this, int32_t redeemScript);
void _ZN14CBasicKeyStore12AddKeyPubKeyERK4CKeyRK7CPubKey(int32_t this, int32_t key, int32_t pubkey);
int32_t _ZN14CBasicKeyStoreD0Ev(int32_t * a1);
int32_t _ZN14CBasicKeyStoreD1Ev(int32_t * a1);
void _ZN15CCryptoKeyStore10SetCryptedEv(int32_t this);
void _ZN15CCryptoKeyStore11EncryptKeysERSt6vectorIh16secure_allocatorIhEE(int32_t this, struct vector_unsignedchar_secure_allocator_unsignedchar__ vMasterKeyIn);
void _ZN15CCryptoKeyStore12AddKeyPubKeyERK4CKeyRK7CPubKey(int32_t this, int32_t key, int32_t pubkey);
void _ZN15CCryptoKeyStore13AddCryptedKeyERK7CPubKeyRKSt6vectorIhSaIhEE(int32_t this, int32_t vchPubKey, int32_t vchCryptedSecret);
void _ZN15CCryptoKeyStore4LockEv(int32_t this);
void _ZN15CCryptoKeyStore6UnlockERKSt6vectorIh16secure_allocatorIhEE(int32_t this, struct vector_unsignedchar_secure_allocator_unsignedchar__ vMasterKeyIn);
int32_t _ZN15CCryptoKeyStoreD0Ev(int32_t a1);
int32_t _ZN15CCryptoKeyStoreD1Ev(int32_t * a1);
int32_t _ZN21LockedPageManagerBaseI16MemoryPageLockerE11UnlockRangeEPvj(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZN21LockedPageManagerBaseI16MemoryPageLockerE9LockRangeEPvj(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZN4CKeyD1Ev(int32_t a1);
int32_t _ZN5boost10lock_errorD0Ev(int32_t * a1);
int32_t _ZN5boost10lock_errorD1Ev(int32_t * a1);
int32_t _ZN5boost10shared_ptrIKNS_16exception_detail10clone_baseEED1Ev(int32_t result);
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(int32_t * a1);
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(int32_t * a1);
int32_t _ZN5boost11unique_lockINS_5mutexEED1Ev(int32_t * a1);
int32_t _ZN5boost11unique_lockINS_5mutexEED2Ev_part_94(void);
int32_t _ZN5boost14checked_deleteINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS2_15connection_bodyISt4pairINS2_15slot_meta_groupENS_8optionalIiEEENS1_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSF_EEEEENS1_5mutexEEEEEEEEEvPT_(int32_t * a1);
int32_t _ZN5boost14checked_deleteINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS1_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS5_EEENSA_IFvRKNS1_10connectionES5_EEENS1_5mutexEE16invocation_stateEEEvPT_(int32_t a1);
int32_t _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(int32_t a1);
int32_t _ZN5boost15throw_exceptionINS_17bad_function_callEEEvRKT_(int32_t a1);
int32_t _ZN5boost16exception_detail10bad_alloc_D0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10bad_alloc_D1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1, int32_t a2);
int32_t _ZN5boost16exception_detail13get_bad_allocILi42EEENS_10shared_ptrIKNS0_10clone_baseEEEv(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEEC1ERKS3_(int32_t * a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_17bad_function_callEEC1ERKS3_(int32_t a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_17bad_function_callEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_17bad_function_callEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail20copy_boost_exceptionEPNS_9exceptionEPKS1_(int32_t a1, int32_t a2);
int32_t _ZN5boost16thread_exceptionD0Ev(int32_t * a1);
int32_t _ZN5boost16thread_exceptionD1Ev(int32_t * a1);
int32_t _ZN5boost17bad_function_callD0Ev(int32_t * a1);
int32_t _ZN5boost17bad_function_callD1Ev(int32_t * a1);
int32_t _ZN5boost6detail12shared_countD1Ev(int32_t * a1);
int32_t _ZN5boost6detail15sp_counted_base7destroyEv(int32_t * a1);
int32_t _ZN5boost6detail15sp_counted_baseD0Ev(int32_t * a1);
int32_t _ZN5boost6detail15sp_counted_baseD1Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE11get_deleterERKSt9type_info(void);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE7disposeEv(int32_t a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED0Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED1Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEE11get_deleterERKSt9type_info(void);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEE7disposeEv(int32_t a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEED0Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEED1Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEE11get_deleterERKSt9type_info(void);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEE7disposeEv(int32_t a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEED0Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEED1Ev(int32_t * a1);
int32_t _ZN5boost6system12system_errorD0Ev(int32_t * a1);
int32_t _ZN5boost6system12system_errorD1Ev(int32_t * a1);
int32_t _ZN5boost6system14error_categoryD0Ev(int32_t * a1);
int32_t _ZN5boost6system14error_categoryD1Ev(int32_t * a1);
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockC2EP15pthread_mutex_t_part_22(void);
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockD2Ev_part_23(void);
int32_t _ZN5boost7variantINS_10shared_ptrIvEENS_8signals26detail23foreign_void_shared_ptrENS_6detail7variant5void_ES8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_ED1Ev(int32_t * a1);
int32_t _ZN5boost8signals211signal_baseD0Ev(int32_t * a1);
int32_t _ZN5boost8signals211signal_baseD1Ev(int32_t * a1);
int32_t _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EE10deallocateEPSA_j(int32_t result, uint32_t a2);
void _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EE14destroy_back_nEjRKNS_17integral_constantIbLb0EEE(int32_t this, int32_t n, int32_t arg2);
int32_t _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EE18move_to_new_bufferEjRKNS_17integral_constantIbLb0EEE(int32_t a1, int32_t a2);
void _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EE19unchecked_push_backERKSA_(int32_t this, int32_t x);
int32_t _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EE19unchecked_push_backERKSA__part_543(void);
int32_t _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EED2Ev_part_514(void);
void _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE16invocation_state17connection_bodiesEv(int32_t this);
int32_t _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE16invocation_state17connection_bodiesEv_part_270(void);
int32_t _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE16invocation_stateC1ERKSJ_RKNS1_12grouped_listIiS8_NS_10shared_ptrINS1_15connection_bodyISt4pairINS1_15slot_meta_groupENS_8optionalIiEEENS0_5slot1IvS4_SB_EESH_EEEEEE(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE20disconnect_all_slotsEv(int32_t a1);
int32_t _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEEclES4_(int32_t a1, int32_t result);
int32_t _ZN5boost8signals26detail24slot_call_iterator_cacheINS1_9void_typeENS1_12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS0_10connectionES6_EEENS0_5mutexEE12slot_invokerEED1Ev(int32_t a1);
int32_t _ZN5boost8signals26signalIFvP15CCryptoKeyStoreENS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIS4_EENS9_IFvRKNS0_10connectionES3_EEENS0_5mutexEED0Ev(int32_t * a1);
int32_t _ZN5boost8signals26signalIFvP15CCryptoKeyStoreENS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIS4_EENS9_IFvRKNS0_10connectionES3_EEENS0_5mutexEED1Ev(int32_t * a1);
void _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEclES3_(int32_t this, int32_t arg1);
int32_t _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEclES3__part_617(void);
int32_t _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEED0Ev(int32_t * a1);
int32_t _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEED1Ev(int32_t * a1);
int32_t _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEED2Ev_part_362(void);
int32_t _ZN5boost9exceptionD0Ev(int32_t a1);
int32_t _ZN5boost9exceptionD1Ev(int32_t * a1);
int32_t _ZN9CKeyStore6AddKeyERK4CKey(void);
int32_t _ZN9CKeyStoreD0Ev(int32_t * a1);
int32_t _ZN9CKeyStoreD1Ev(int32_t * a1);
int32_t _ZN9CKeyStoreD2Ev_part_39(void);
void _ZNK14CBasicKeyStore10GetCScriptERK9CScriptIDR7CScript(int32_t this, int32_t hash, int32_t redeemScriptOut);
void _ZNK14CBasicKeyStore11HaveCScriptERK9CScriptID(int32_t this, int32_t hash);
int32_t _ZNK14CBasicKeyStore6GetKeyERK6CKeyIDR4CKey(int32_t a1, int32_t a2, int32_t * a3);
int32_t _ZNK14CBasicKeyStore7GetKeysERSt3setI6CKeyIDSt4lessIS1_ESaIS1_EE(int32_t a1, int32_t a2);
int32_t _ZNK14CBasicKeyStore7HaveKeyERK6CKeyID(int32_t a1, int32_t a2);
void _ZNK15CCryptoKeyStore6GetKeyERK6CKeyIDR4CKey(int32_t this, int32_t address, int32_t keyOut);
int32_t _ZNK15CCryptoKeyStore7GetKeysERSt3setI6CKeyIDSt4lessIS1_ESaIS1_EE(int32_t a1, int32_t a2);
int32_t _ZNK15CCryptoKeyStore7HaveKeyERK6CKeyID(int32_t a1, int32_t a2);
void _ZNK15CCryptoKeyStore9GetPubKeyERK6CKeyIDR7CPubKey(int32_t this, int32_t address, int32_t vchPubKeyOut);
int32_t _ZNK5boost10lock_error4whatEv(void);
void _ZNK5boost10shared_ptrINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS1_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS5_EEENSA_IFvRKNS1_10connectionES5_EEENS1_5mutexEE16invocation_stateEEptEv(int32_t this);
int32_t _ZNK5boost10shared_ptrINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS1_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS5_EEENSA_IFvRKNS1_10connectionES5_EEENS1_5mutexEE16invocation_stateEEptEv_isra_198_part_199(void);
void _ZNK5boost10shared_ptrINS_8signals26detail15connection_bodyISt4pairINS2_15slot_meta_groupENS_8optionalIiEEENS1_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSB_EEEEENS1_5mutexEEEEptEv(int32_t this);
int32_t _ZNK5boost10shared_ptrINS_8signals26detail15connection_bodyISt4pairINS2_15slot_meta_groupENS_8optionalIiEEENS1_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSB_EEEEENS1_5mutexEEEEptEv_isra_236_part_237(void);
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1);
void _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE5cloneEv(int32_t this);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE5cloneEv2(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE7rethrowEv(int32_t a1);
int32_t _ZNK5boost6system12system_error4whatEv(int32_t a1);
int32_t _ZNK5boost6system14error_category10equivalentEiRKNS0_15error_conditionE(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNK5boost6system14error_category10equivalentERKNS0_10error_codeEi(int32_t a1, int32_t * a2, int32_t a3);
int32_t _ZNK5boost6system14error_category23default_error_conditionEi(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNK5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE25force_cleanup_connectionsEPKNS1_12grouped_listIiS8_NS_10shared_ptrINS1_15connection_bodyISt4pairINS1_15slot_meta_groupENS_8optionalIiEEENS0_5slot1IvS4_SB_EESH_EEEEEE(int32_t a1, int32_t a2);
int32_t _ZNK5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE31nolock_cleanup_connections_fromEbRKSt14_List_iteratorINS_10shared_ptrINS1_15connection_bodyISt4pairINS1_15slot_meta_groupENS_8optionalIiEEENS0_5slot1IvS4_SB_EESH_EEEEEj(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
void _ZNK5boost8signals26detail14group_key_lessIiSt4lessIiEEclERKSt4pairINS1_15slot_meta_groupENS_8optionalIiEEESC_(int32_t this, int32_t key1, int32_t key2);
int32_t _ZNK5boost8signals26detail14group_key_lessIiSt4lessIiEEclERKSt4pairINS1_15slot_meta_groupENS_8optionalIiEEESC__isra_570_part_571(void);
int32_t _ZNK5boost8signals26detail15connection_bodyISt4pairINS1_15slot_meta_groupENS_8optionalIiEEENS0_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSA_EEEEENS0_5mutexEE27nolock_grab_tracked_objectsISt20back_insert_iteratorINS1_11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ESQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISR_EEEEEEvT_(int32_t a1, int32_t a2);
int32_t _ZNK5boost8signals26detail20slot_call_iterator_tINS1_12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS5_EEENSA_IFvRKNS0_10connectionES5_EEENS0_5mutexEE12slot_invokerESt14_List_iteratorINS_10shared_ptrINS1_15connection_bodyISt4pairINS1_15slot_meta_groupENS_8optionalIiEEENS0_5slot1IvS5_SC_EESI_EEEEESV_E18lock_next_callableEv(int32_t * a1);
int32_t _ZNK5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEE10lock_pimplEv(int32_t * a1, int32_t a2);
void _ZNK9CKeyStore9GetPubKeyERK6CKeyIDR7CPubKey(int32_t this, int32_t address, int32_t vchPubKeyOut);
int32_t _ZNKSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE4findERS2_(int32_t * a1, int32_t a2);
int32_t _ZNKSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE4findERS2_(int32_t * a1, int32_t a2);
int32_t _ZNKSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE4findERS2_(int32_t * a1, int32_t a2);
int32_t _ZNSt10_List_baseIN5boost10shared_ptrINS0_8signals26detail15connection_bodyISt4pairINS3_15slot_meta_groupENS0_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS0_8functionIFvSC_EEEEENS2_5mutexEEEEESaISJ_EED1Ev(int32_t * a1);
void _ZNSt12_Vector_baseIh16secure_allocatorIhEE13_M_deallocateEPhj(int32_t this, char * __p, int32_t __n);
int32_t _ZNSt3mapI6CKeyID4CKeySt4lessIS0_ESaISt4pairIKS0_S1_EEEixERS5_(int32_t a1);
int32_t _ZNSt3mapI6CKeyIDSt4pairI7CPubKeySt6vectorIhSaIhEEESt4lessIS0_ESaIS1_IKS0_S6_EEEixERS9_(int32_t a1, int32_t * a2);
int32_t _ZNSt3mapI9CScriptID7CScriptSt4lessIS0_ESaISt4pairIKS0_S1_EEEixERS5_(int32_t a1);
int32_t _ZNSt6vectorIh16secure_allocatorIhEEaSERKS2_(int32_t * a1, int32_t a2);
int32_t _ZNSt6vectorIh16secure_allocatorIhEED1Ev(int32_t * a1);
int32_t _ZNSt6vectorIhSaIhEEaSERKS1_(int32_t * a1, int32_t a2);
int32_t _ZNSt6vectorIhSaIhEED1Ev(int32_t * a1);
int32_t _ZNSt8_Rb_treeI6CKeyIDS0_St9_IdentityIS0_ESt4lessIS0_ESaIS0_EE10_M_insert_EPKSt18_Rb_tree_node_baseS9_RKS0_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeI6CKeyIDS0_St9_IdentityIS0_ESt4lessIS0_ESaIS0_EE16_M_insert_uniqueERKS0_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeI6CKeyIDS0_St9_IdentityIS0_ESt4lessIS0_ESaIS0_EE8_M_eraseEPSt13_Rb_tree_nodeIS0_E(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE10_M_insert_EPKSt18_Rb_tree_node_baseSD_RKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5);
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE16_M_insert_uniqueERKS4_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS4_ERKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE8_M_eraseEPSt13_Rb_tree_nodeIS4_E(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE10_M_insert_EPKSt18_Rb_tree_node_baseSH_RKS8_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE16_M_insert_uniqueERKS8_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS8_ERKS8_(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE8_M_eraseEPSt13_Rb_tree_nodeIS8_E(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE10_M_insert_EPKSt18_Rb_tree_node_baseSD_RKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE16_M_insert_uniqueERKS4_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS4_ERKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t _ZNSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE8_M_eraseEPSt13_Rb_tree_nodeIS4_E(int32_t a1, int32_t a2);
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE10_M_insert_EPKSt18_Rb_tree_node_baseSB_RKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE16_M_insert_uniqueERKS2_(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeISt4pairIN5boost8signals26detail15slot_meta_groupENS1_8optionalIiEEES0_IKS7_St14_List_iteratorINS1_10shared_ptrINS3_15connection_bodyIS7_NS2_5slot1IvP15CCryptoKeyStoreNS1_8functionIFvSE_EEEEENS2_5mutexEEEEEEESt10_Select1stISN_ENS3_14group_key_lessIiSt4lessIiEEESaISN_EE10_M_insert_EPKSt18_Rb_tree_node_baseSY_RKSN_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5);
int32_t _ZNSt8_Rb_treeISt4pairIN5boost8signals26detail15slot_meta_groupENS1_8optionalIiEEES0_IKS7_St14_List_iteratorINS1_10shared_ptrINS3_15connection_bodyIS7_NS2_5slot1IvP15CCryptoKeyStoreNS1_8functionIFvSE_EEEEENS2_5mutexEEEEEEESt10_Select1stISN_ENS3_14group_key_lessIiSt4lessIiEEESaISN_EE16_M_insert_uniqueERKSN_(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeISt4pairIN5boost8signals26detail15slot_meta_groupENS1_8optionalIiEEES0_IKS7_St14_List_iteratorINS1_10shared_ptrINS3_15connection_bodyIS7_NS2_5slot1IvP15CCryptoKeyStoreNS1_8functionIFvSE_EEEEENS2_5mutexEEEEEEESt10_Select1stISN_ENS3_14group_key_lessIiSt4lessIiEEESaISN_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorISN_ERKSN_(int32_t a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t _ZNSt8_Rb_treeISt4pairIN5boost8signals26detail15slot_meta_groupENS1_8optionalIiEEES0_IKS7_St14_List_iteratorINS1_10shared_ptrINS3_15connection_bodyIS7_NS2_5slot1IvP15CCryptoKeyStoreNS1_8functionIFvSE_EEEEENS2_5mutexEEEEEEESt10_Select1stISN_ENS3_14group_key_lessIiSt4lessIiEEESaISN_EE7_M_copyEPKSt13_Rb_tree_nodeISN_EPSX_(int32_t a1, int32_t a2, int32_t a3);
int32_t _ZNSt8_Rb_treeISt4pairIN5boost8signals26detail15slot_meta_groupENS1_8optionalIiEEES0_IKS7_St14_List_iteratorINS1_10shared_ptrINS3_15connection_bodyIS7_NS2_5slot1IvP15CCryptoKeyStoreNS1_8functionIFvSE_EEEEENS2_5mutexEEEEEEESt10_Select1stISN_ENS3_14group_key_lessIiSt4lessIiEEESaISN_EE8_M_eraseEPSt13_Rb_tree_nodeISN_E(int32_t a1, int32_t a2);
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D0Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D1Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1);
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1);
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1);
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1);
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED1Ev(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE7rethrowEv(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_17bad_function_callEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_17bad_function_callEED1Ev(int32_t a1);
int32_t function_101e(int32_t a1, int32_t a2);
int32_t function_10ae(void);
int32_t function_10bc(void);
int32_t function_10d7(void);
int32_t function_10df(void);
int32_t function_10e0(void);
int32_t function_10f3(int32_t a1);
int32_t function_1107(void);
int32_t function_111d(void);
int32_t function_124e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_12e8(void);
int32_t function_1301(void);
int32_t function_14090(int32_t a1, int32_t a2);
int32_t function_1657(void);
int32_t function_1660(void);
int32_t function_16e2(void);
int32_t function_16f8(void);
int32_t function_1710(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_171d(void);
int32_t function_1723(void);
int32_t function_1724(void);
int32_t function_173b(int32_t a1);
int32_t function_1757(void);
int32_t function_186d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_18e0(void);
int32_t function_1c3f(void);
int32_t function_1c60(void);
int32_t function_1c70(void);
int32_t function_1c88(int32_t result, int32_t a2, int32_t a3);
int32_t function_1c9c(void);
int32_t function_1ca8(int32_t a1);
int32_t function_1cd0(int32_t a1);
int32_t function_1ce3(void);
int32_t function_1cf8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1d10(int32_t a1);
int32_t function_1d28(void);
int32_t function_1d40(int32_t a1);
int32_t function_1d60(void);
int32_t function_1d74(void);
int32_t function_1d85(void);
int32_t function_1da4(void);
int32_t function_1dab(void);
int32_t function_1fb7(int32_t a1);
int32_t function_1fe9(void);
int32_t function_2018(int32_t a1, int32_t a2, int32_t a3);
int32_t function_20aa(void);
int32_t function_210d(void);
int32_t function_2191(int32_t a1);
int32_t function_21a4(int32_t * a1, uint32_t a2);
int32_t function_221d(void);
int32_t function_2235(void);
int32_t function_2242(void);
int32_t function_2249(void);
int32_t function_225a(void);
int32_t function_2276(void);
int32_t function_227f(void);
int32_t function_2331(void);
int32_t function_239(void);
int32_t function_29b3(int32_t a1);
int32_t function_29f3(int32_t a1);
int32_t function_2a1(int32_t a1);
int32_t function_2a33(int32_t a1);
int32_t function_2a73(int32_t a1);
int32_t function_2aa(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2ab3(int32_t a1);
int32_t function_2af3(int32_t a1);
int32_t function_2b33(int32_t a1);
int32_t function_2b8e(int32_t a1);
int32_t function_2bd3(int32_t a1);
int32_t function_2c13(int32_t a1);
int32_t function_2c52(void);
int32_t function_2ce(void);
int32_t function_327(int32_t a1, int32_t a2, int32_t a3);
int32_t function_380a(int32_t a1);
int32_t function_3851(int32_t a1);
int32_t function_38b3(int32_t a1);
int32_t function_38e1(int32_t a1);
int32_t function_3990(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3a30(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3b8a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3bef(void);
int32_t function_3bf5(void);
int32_t function_3c0f(void);
int32_t function_3c1d(void);
int32_t function_3c56(int32_t a1, int32_t a2);
int32_t function_3c70(void);
int32_t function_3c95(void);
int32_t function_3c97(void);
int32_t function_3c9c(void);
int32_t function_3cee(int32_t a1, int32_t a2);
int32_t function_3d08(void);
int32_t function_3d2d(void);
int32_t function_3d2f(void);
int32_t function_3d34(void);
int32_t function_3dbf(void);
int32_t function_3e18(void);
int32_t function_3e1a(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3e1f(void);
int32_t function_3e44(void);
int32_t function_3e47(void);
int32_t function_3e52(void);
int32_t function_3e63(void);
int32_t function_3e69(void);
int32_t function_3e70(void);
int32_t function_3e72(void);
int32_t function_3e7e(void);
int32_t function_3ee7(void);
int32_t function_3f5c(void);
int32_t function_3fab(int32_t a1);
int32_t function_402c(void);
int32_t function_4092(int32_t a1, int32_t a2);
int32_t function_4182(int32_t a1);
int32_t function_42a3(void);
int32_t function_4413(void);
int32_t function_44c6(void);
int32_t function_45f0(int32_t a1);
int32_t function_4602(void);
int32_t function_4608(void);
int32_t function_6d56(int32_t a1);
int32_t function_7da0(int32_t a1);
int32_t function_7e10(int32_t a1);
int32_t function_7e70(int32_t a1);
int32_t function_7ef0(int32_t a1);
int32_t function_7fb0(int32_t a1);
int32_t function_7fe0(int32_t a1);
int32_t function_8(void);
int32_t function_8040(int32_t a1);
int32_t function_80e0(int32_t a1);
int32_t function_8140(int32_t a1);
int32_t function_81b0(int32_t a1);
int32_t function_8250(int32_t a1);
int32_t function_8280(int32_t a1);
int32_t function_82b0(int32_t a1);
int32_t function_8320(int32_t a1);
int32_t function_843(void);
int32_t function_85aa(void);
int32_t function_85b3(void);
int32_t function_85c7(void);
int32_t function_8690(void);
int32_t function_8720(void);
int32_t function_8760(int32_t a1);
int32_t function_8791(void);
int32_t function_87b0(void);
int32_t function_8808(int32_t a1);
int32_t function_8819(void);
int32_t function_888d(int32_t a1);
int32_t function_889b(void);
int32_t function_88a6(int32_t a1);
int32_t function_88d(int32_t a1);
int32_t function_88d0(void);
int32_t function_88f5(void);
int32_t function_8900(int32_t a1, int32_t a2);
int32_t function_894b7401(void);
int32_t function_8974(void);
int32_t function_898(void);
int32_t function_89ad(void);
int32_t function_8a30(int32_t a1);
int32_t function_8a42(void);
int32_t function_8a49(void);
int32_t function_8a54(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8a70(int32_t a1);
int32_t function_8aac(void);
int32_t function_8b81(void);
int32_t function_8b92(int32_t a1);
int32_t function_8be5(void);
int32_t function_8be8(int32_t a1);
int32_t function_8bf0(int32_t a1, int32_t a2);
int32_t function_8c3(void);
int32_t function_8c53(void);
int32_t function_8c60(void);
int32_t function_8c78(int32_t a1, int32_t a2);
int32_t function_8c8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8c98(void);
int32_t function_8ca0(void);
int32_t function_8cba(void);
int32_t function_8d78(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8d8(void);
int32_t function_8e98(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8ec0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17);
int32_t function_8f0(void);
int32_t function_8f86(void);
int32_t function_8f8b(void);
int32_t function_8fa6(void);
int32_t function_8faf(void);
int32_t function_8fda(void);
int32_t function_8fe6(void);
int32_t function_903b(void);
int32_t function_9052(void);
int32_t function_9066(int32_t a1);
int32_t function_908(void);
int32_t function_91b3(int32_t a1);
int32_t function_91e(void);
int32_t function_9213(void);
int32_t function_921f(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_928e(void);
int32_t function_929d(int32_t a1);
int32_t function_92b4(void);
int32_t function_92e(int32_t a1);
int32_t function_9413(void);
int32_t function_941f(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_9510(int32_t a1, int32_t a2, int32_t a3);
int32_t function_95c0(void);
int32_t function_96e3(void);
int32_t function_96f2(void);
int32_t function_971e(void);
int32_t function_9808(int32_t a1);
int32_t function_9828(void);
int32_t function_9848(void);
int32_t function_984d(void);
int32_t function_9852(void);
int32_t function_988(void);
int32_t function_98af(void);
int32_t function_98c0(void);
int32_t function_98d4(void);
int32_t function_98e(void);
int32_t function_98ef(int32_t a1, int32_t a2, int32_t a3);
int32_t function_98f(void);
int32_t function_9910(void);
int32_t function_9920(void);
int32_t function_9940(void);
int32_t function_9951(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_996d(void);
int32_t function_997c(void);
int32_t function_99b2(void);
int32_t function_99e(void);
int32_t function_9a07(void);
int32_t function_9a17(void);
int32_t function_9a28(void);
int32_t function_9a4d(void);
int32_t function_9a58(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_9a62(void);
int32_t function_9d62(void);
int32_t function_9dc0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_9e78(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_9ea8(int32_t a1);
int32_t function_9ec7(void);
int32_t function_9f71(void);
int32_t function_9f78(void);
int32_t function_9fab(void);
int32_t function_9fc1(void);
int32_t function_a079(void);
int32_t function_a07c(void);
int32_t function_a09e(void);
int32_t function_a0b3(void);
int32_t function_a144(void);
int32_t function_a160(int32_t a1);
int32_t function_a181(void);
int32_t function_a1cc(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_a246(void);
int32_t function_a2b6(void);
int32_t function_a2c3(int32_t a1);
int32_t function_a334(int32_t a1);
int32_t function_a339(void);
int32_t function_a33e(void);
int32_t function_a34b(int32_t a1);
int32_t function_a3c4(int32_t a1);
int32_t function_a3c9(int32_t a1);
int32_t function_a3ce(int32_t a1);
int32_t function_a3db(int32_t a1);
int32_t function_a456(void);
int32_t function_a463(int32_t a1);
int32_t function_a50e(void);
int32_t function_a560(void);
int32_t function_a56f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_a588(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_a5ac(void);
int32_t function_a5f(void);
int32_t function_a609(void);
int32_t function_a621(void);
int32_t function_a649(void);
int32_t function_a65f(void);
int32_t function_a67(void);
int32_t function_a6a6(void);
int32_t function_a732(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_a768(int32_t a1, int32_t a2);
int32_t function_a780(void);
int32_t function_a80(void);
int32_t function_a840(int32_t result);
int32_t function_a85(void);
int32_t function_a873(void);
int32_t function_a8b2(int32_t result, char a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_a950(void);
int32_t function_a95e(void);
int32_t function_a9a0(void);
int32_t function_a9c7(void);
int32_t function_ab0e(void);
int32_t function_ab20(int32_t result);
int32_t function_ab48(int32_t a1, int32_t a2, int32_t a3);
int32_t function_ab86(void);
int32_t function_ab8f(void);
int32_t function_abdb(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_ace4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_ad08(int32_t a1, int32_t a2, int32_t a3);
int32_t function_ad2d(void);
int32_t function_ad48(void);
int32_t function_ae01(void);
int32_t function_ae08(void);
int32_t function_ae3b(void);
int32_t function_ae51(void);
int32_t function_ae8(void);
int32_t function_aecb(void);
int32_t function_af13(void);
int32_t function_af40(void);
int32_t function_af66(void);
int32_t function_af8(void);
int32_t function_afb0(int32_t a1);
int32_t function_aff8(void);
int32_t function_b000(void);
int32_t function_b028(void);
int32_t function_b030(int32_t a1);
int32_t function_b036(void);
int32_t function_b056(void);
int32_t function_b060(void);
int32_t function_b10(void);
int32_t function_b18(void);
int32_t function_b237(void);
int32_t function_b238(void);
int32_t function_b24b(void);
int32_t function_b2b5(void);
int32_t function_b30(char a1);
int32_t function_b308(void);
int32_t function_b353(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_b380(void);
int32_t function_b388(int32_t a1, int32_t a2);
int32_t function_b3b1(void);
int32_t function_b3dd(void);
int32_t function_b48(void);
int32_t function_b491(void);
int32_t function_b498(void);
int32_t function_b4cb(void);
int32_t function_b4e1(void);
int32_t function_b55b(void);
int32_t function_b5a3(void);
int32_t function_b5d0(void);
int32_t function_b5f6(void);
int32_t function_b640(int32_t a1);
int32_t function_b688(void);
int32_t function_b690(void);
int32_t function_b6b8(void);
int32_t function_b6c0(int32_t a1);
int32_t function_b6c6(void);
int32_t function_b6e6(void);
int32_t function_b6f0(void);
int32_t function_b7fd(void);
int32_t function_b80d(void);
int32_t function_b825(int32_t a1);
int32_t function_b82e(void);
int32_t function_b834(void);
int32_t function_b8b1(void);
int32_t function_b8e8(void);
int32_t function_b905(int32_t a1);
int32_t function_b919(void);
int32_t function_b956(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_b980(void);
int32_t function_b990(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_b9bd(void);
int32_t function_b9d8(void);
int32_t function_ba91(void);
int32_t function_ba98(void);
int32_t function_bacb(void);
int32_t function_bae1(void);
int32_t function_bb5b(void);
int32_t function_bba3(void);
int32_t function_bbd0(void);
int32_t function_bbf6(void);
int32_t function_bc40(int32_t a1);
int32_t function_bc88(void);
int32_t function_bc90(void);
int32_t function_bcb8(void);
int32_t function_bcc0(int32_t a1);
int32_t function_bcc6(void);
int32_t function_bce6(void);
int32_t function_bcf0(void);
int32_t function_be39(void);
int32_t function_be4c(void);
int32_t function_be6a(int32_t a1);
int32_t function_be73(void);
int32_t function_beea(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_bf63(void);
int32_t function_bf80(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_bf94(void);
int32_t function_c006(void);
int32_t function_c073(void);
int32_t function_c090(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_c0a4(void);
int32_t function_c0da(int32_t * a1);
int32_t function_c162(void);
int32_t function_c1be(void);
int32_t function_c1d8(void);
int32_t function_c1e7(void);
int32_t function_c20a(void);
int32_t function_c2a0(void);
int32_t function_c372(int32_t a1, int32_t result);
int32_t function_c3a0(void);
int32_t function_c3bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_c40d(void);
int32_t function_c41a(void);
int32_t function_c42e(void);
int32_t function_c44c(void);
int32_t function_c481(void);
int32_t function_c520(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_c550(int32_t a1);
int32_t function_c560(int32_t a1);
int32_t function_c5f0(int32_t a1);
int32_t function_c739(void);
int32_t function_c7c7(int16_t a1);
int32_t function_c7d3(void);
int32_t function_c7e6(void);
int32_t function_c7ef(void);
int32_t function_c806(void);
int32_t function_c830(void);
int32_t function_c840(int32_t a1);
int32_t function_c868(void);
int32_t function_c890(void);
int32_t function_c8d0(void);
int32_t function_c900(void);
int32_t function_c910(void);
int32_t function_c939(void);
int32_t function_c948(void);
int32_t function_c978(void);
int32_t function_c998(void);
int32_t function_c9bb(void);
int32_t function_c9c4(void);
int32_t function_c9d1(void);
int32_t function_c9d6(void);
int32_t function_c9f9(void);
int32_t function_c9fe(void);
int32_t function_cb28(int32_t a1);
int32_t function_cb5b(void);
int32_t function_cb63(int32_t a1);
int32_t function_cb7d(void);
int32_t function_cb80(int32_t a1);
int32_t function_cb88(void);
int32_t function_cbde(int32_t a1);
int32_t function_cc08(int32_t a1);
int32_t function_cc18(int32_t a1);
int32_t function_cce8(void);
int32_t function_cd18(void);
int32_t function_cd2d(void);
int32_t function_cd4a(void);
int32_t function_cd4f(int32_t a1);
int32_t function_cd73(void);
int32_t function_cda2(void);
int32_t function_cdd9(int32_t a1);
int32_t function_cde0(void);
int32_t function_ce08(void);
int32_t function_ce38(void);
int32_t function_ce9e(void);
int32_t function_cf31(void);
int32_t function_cf41(int32_t a1);
int32_t function_cf5c(void);
int32_t function_cf6d(void);
int32_t function_cf98(int32_t a1);
int32_t function_cfc7(void);
int32_t function_cfe4(void);
int32_t function_cff2(int32_t a1);
int32_t function_cff7(int32_t a1);
int32_t function_cffc(int32_t a1);
int32_t function_d020(void);
int32_t function_d025(void);
int32_t function_d049(void);
int32_t function_d084(int32_t a1);
int32_t function_d14a(void);
int32_t function_d151(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d196(int32_t a1, int32_t a2);
int32_t function_d259(void);
int32_t function_d25e(void);
int32_t function_d29c(void);
int32_t function_d29d(void);
int32_t function_d2ae(void);
int32_t function_d2bb(void);
int32_t function_d2be(void);
int32_t function_d2c4(void);
int32_t function_d31f(int32_t a1);
int32_t function_d377(void);
int32_t function_d382(void);
int32_t function_d385(void);
int32_t function_d390(void);
int32_t function_d39c(int32_t result);
int32_t function_d3c8(void);
int32_t function_d3d0(void);
int32_t function_d410(void);
int32_t function_d415(void);
int32_t function_d41a(int32_t a1);
int32_t function_d525(void);
int32_t function_d548(int32_t a1);
int32_t function_d580(void);
int32_t function_d5b0(void);
int32_t function_d5c7(void);
int32_t function_d5f0(int32_t a1);
int32_t function_d604(int32_t a1);
int32_t function_d630(int32_t a1, int32_t a2);
int32_t function_d639(int32_t * a1);
int32_t function_d79e(int32_t a1);
int32_t function_d7a8(void);
int32_t function_d7bd(void);
int32_t function_d7d2(void);
int32_t function_d800(void);
int32_t function_d801(void);
int32_t function_d806(void);
int32_t function_d809(int32_t a1);
int32_t function_d8b6(int32_t a1);
int32_t function_d906(void);
int32_t function_d90a(int32_t * a1);
int32_t function_d9a8(int32_t a1, int32_t a2);
int32_t function_d9bd(void);
int32_t function_da1a(void);
int32_t function_da80(int32_t a1, int32_t result);
int32_t function_da9f(void);
int32_t function_daaa(int32_t a1);
int32_t function_db36(uint32_t a1);
int32_t function_dbcd(int32_t a1, int32_t a2);
int32_t function_dbd4(int32_t * a1);
int32_t function_dc2(void);
int32_t function_dc89(void);
int32_t function_dc90(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_dca5(void);
int32_t function_dcc4(int32_t a1);
int32_t function_dd45(void);
int32_t function_dd50(void);
int32_t function_dd58(int32_t a1);
int32_t function_dd64(int32_t a1, int32_t a2, int32_t a3);
int32_t function_dd8d(int32_t a1);
int32_t function_dd97(void);
int32_t function_ddc0(void);
int32_t function_ddc5(void);
int32_t function_de1a(void);
int32_t function_de36(void);
int32_t function_de3f(void);
int32_t function_de5e(void);
int32_t function_de9c(void);
int32_t function_deb2(void);
int32_t function_dec4(void);
int32_t function_deea(void);
int32_t function_deef(void);
int32_t function_df13(void);
int32_t function_df37(void);
int32_t function_df53(int32_t a1);
int32_t function_df58(void);
int32_t function_df7b(int32_t a1);
int32_t function_df92(void);
int32_t function_dfb6(void);
int32_t function_dfda(void);
int32_t function_dffe(int32_t * a1);
int32_t function_e07b(void);
int32_t function_e0a1(void);
int32_t function_e0a6(void);
int32_t function_e350(int32_t a1);
int32_t function_e368(int32_t a1);
int32_t function_e3c8(int32_t a1);
int32_t function_e3d0(int32_t a1);
int32_t function_e3f0(void);
int32_t function_e3fa(void);
int32_t function_e418(int32_t a1);
int32_t function_e448(int32_t a1);
int32_t function_e44f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_e478(int32_t a1);
int32_t function_e4bd(void);
int32_t function_e4c5(void);
int32_t function_e4e9(void);
int32_t function_e4ef(void);
int32_t function_e5c8(int32_t a1, int32_t result);
int32_t function_e5d4(void);
int32_t function_e660(int32_t * a1);
int32_t function_e6d0(void);
int32_t function_e700(void);
int32_t function_e730(int32_t a1);
int32_t function_e7b0(int32_t a1);
int32_t function_e7b8(int32_t a1);
int32_t function_e8008bb1(void);
int32_t function_e878(int32_t a1);
int32_t function_e881(int16_t a1);
int32_t function_e888(void);
int32_t function_e8d0(int32_t a1);
int32_t function_e950(int32_t a1);
int32_t function_e9aa(int32_t a1);
int32_t function_e9b2(void);
int32_t function_e9b8(int32_t * a1);
int32_t function_e9c5(int32_t a1);
int32_t function_e9d6(void);
int32_t function_e9f8(void);
int32_t function_ea55(void);
int32_t function_ea92(void);
int32_t function_eaa0(void);
int32_t function_eaab(void);
int32_t function_eac4(void);
int32_t function_eaea(void);
int32_t function_eaef(void);
int32_t function_eaf8(void);
int32_t function_eb00(void);
int32_t function_eb0a(void);
int32_t function_eb0f(void);
int32_t function_eb57(void);
int32_t function_ebc7(void);
int32_t function_ebc8(void);
int32_t function_ebf1(int32_t a1, int16_t a2);
int32_t function_ebf7(void);
int32_t function_ec08(void);
int32_t function_ec29(void);
int32_t function_ec71(int32_t a1);
int32_t function_ec7c(void);
int32_t function_ec8b(void);
int32_t function_ec90(void);
int32_t function_eca0(void);
int32_t function_eca5(char a1);
int32_t function_ecc1(void);
int32_t function_ecd3(int32_t a1);
int32_t function_eda4(void);
int32_t function_edae(void);
int32_t function_edb8(void);
int32_t function_edbe(int32_t a1);
int32_t function_f302b277(void);
int32_t unknown_1003e(void);
int32_t unknown_10072(void);
int32_t unknown_100a6(void);
int32_t unknown_10176(void);
int32_t unknown_103e0(int32_t a1);
int32_t unknown_10470(int32_t a1);
int32_t unknown_104f0(int32_t a1);
int32_t unknown_1070e(void);
int32_t unknown_10b80(int32_t a1, int32_t a2);
int32_t unknown_10b8e(void);
int32_t unknown_10bc2(void);
int32_t unknown_11450(int32_t a1, int32_t a2);
int32_t unknown_115d0(int32_t a1);
int32_t unknown_117f0(int32_t a1, int32_t a2);
int32_t unknown_118e2(void);
int32_t unknown_11980(int32_t a1);
int32_t unknown_11ad0(int32_t a1, int32_t a2);
int32_t unknown_11b5e(void);
int32_t unknown_11b92(void);
int32_t unknown_11bc6(void);
int32_t unknown_11c2e(void);
int32_t unknown_11f50(int32_t a1);
int32_t unknown_12190(int32_t a1, int32_t a2);
int32_t unknown_12280(int32_t a1);
int32_t unknown_12380(int32_t a1, int32_t a2);
int32_t unknown_123a0(int32_t a1, int32_t a2);
int32_t unknown_12410(int32_t a1, int32_t a2);
int32_t unknown_12440(int32_t a1, int32_t a2);
int32_t unknown_124d0(int32_t a1, int32_t a2);
int32_t unknown_127a0(int32_t a1, int32_t a2);
int32_t unknown_12a20(int32_t a1);
int32_t unknown_12a80(int32_t a1);
int32_t unknown_12b30(int32_t a1, int32_t a2);
int32_t unknown_12b80(int32_t a1);
int32_t unknown_12c30(int32_t a1);
int32_t unknown_12ce0(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_12fb0(int32_t a1, int32_t a2);
int32_t unknown_12fc0(int32_t a1);
int32_t unknown_13080(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_13110(int32_t a1, int32_t a2);
int32_t unknown_13210(int32_t a1);
int32_t unknown_13230(int32_t a1);
int32_t unknown_13420(int32_t a1, int32_t a2);
int32_t unknown_13450(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t unknown_13550(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t unknown_135c0(int32_t a1, int32_t a2);
int32_t unknown_13600(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_13610(int32_t a1, int32_t a2);
int32_t unknown_13650(int32_t a1, int32_t a2);
int32_t unknown_137a0(int32_t a1, int32_t a2);
int32_t unknown_13850(int32_t a1, int32_t a2);
int32_t unknown_138a0(int32_t a1);
int32_t unknown_13990(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t unknown_13ab0(int32_t a1, int32_t a2);
int32_t unknown_13b00(int32_t a1, int32_t a2);
int32_t unknown_13b40(void);
int32_t unknown_13c10(int32_t a1);
int32_t unknown_13cb0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_13d50(int32_t a1, int32_t a2);
int32_t unknown_13da0(int32_t a1, int32_t a2);
int32_t unknown_13e40(int32_t a1, int32_t a2);
int32_t unknown_13ea0(int32_t a1);
int32_t unknown_13f90(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_140b0(int32_t a1, int32_t a2);
int32_t unknown_143f0(int32_t a1);
int32_t unknown_14470(int32_t a1);
int32_t unknown_144d0(int32_t a1);
int32_t unknown_14500(int32_t a1);
int32_t unknown_14590(int32_t a1);
int32_t unknown_14610(int32_t a1);
int32_t unknown_14af0(int32_t a1);
int32_t unknown_14e40(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_15010(int32_t a1);
int32_t unknown_15960(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_15a60(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_15bc0(int32_t a1, int32_t a2);
int32_t unknown_15e70(int32_t a1);
int32_t unknown_16650(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_16750(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_168e0(int32_t a1, int32_t a2);
int32_t unknown_16bf0(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_16dc0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_17250(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_17350(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_174e0(int32_t a1, int32_t a2);
int32_t unknown_177f0(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_17d40(int32_t a1, int32_t a2);
int32_t unknown_17db0(int32_t a1, int32_t a2);
int32_t unknown_17ec0(int32_t a1, int32_t a2);
int32_t unknown_18160(int32_t a1, int32_t a2);
int32_t unknown_182d0(void);
int32_t unknown_18a60(int32_t a1, int32_t a2);
int32_t unknown_18bf0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_18d30(int32_t a1, int32_t a2);
int32_t unknown_19190(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_19320(void);
int32_t unknown_19b30(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_1a780(int32_t a1, int32_t a2);
int32_t unknown_1af80(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_1b650(int32_t a1, int32_t a2);
int32_t unknown_1b750(int32_t a1, int32_t a2);
int32_t unknown_1ba00(int32_t a1, int32_t a2);
int32_t unknown_1c7f0(int32_t a1);
int32_t unknown_89008819(void);
int32_t unknown_8b000004(int32_t a1);
int32_t unknown_f014527(void);
int32_t unknown_f070(int32_t a1);
int32_t unknown_fbd6(void);
int32_t unknown_fd16(void);
int32_t unknown_fea6(void);
void visitation_impl_invoke_3c_boost_3a__3a_detail_3a__3a_variant_3a__3a_copy_into_2c__20_const_20_void_2a__2c__20_boost_3a__3a_variant_3c_boost_3a__3a_shared_ptr_3c_void_3e__2c__20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_foreign_void_shared_ptr_3e__3a__3a_has_fallback_type__3e_(int32_t arg0, int32_t arg1, char * arg2, int32_t arg3, struct has_fallback_type_ arg4, int32_t arg5);
void visitation_impl_invoke_3c_boost_3a__3a_detail_3a__3a_variant_3a__3a_destroyer_2c__20_void_2a__2c__20_boost_3a__3a_variant_3c_boost_3a__3a_shared_ptr_3c_void_3e__2c__20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_foreign_void_shared_ptr_3e__3a__3a_has_fallback_type__3e_(int32_t arg0, int32_t arg1, char * arg2, int32_t arg3, struct has_fallback_type__5 arg4, int32_t arg5);
void visitation_impl_invoke_3c_boost_3a__3a_detail_3a__3a_variant_3a__3a_invoke_visitor_3c_const_20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_expired_weak_ptr_visitor_3e__2c__20_const_20_void_2a__2c__20_boost_3a__3a_variant_3c_boost_3a__3a_weak_ptr_3c_void_3e__2c__20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_foreign_void_weak_ptr_3e__3a__3a_has_fallback_type__3e_(int32_t arg0, int32_t arg1, char * arg2, int32_t arg3, struct has_fallback_type__1_6 arg4, int32_t arg5);
void visitation_impl_invoke_3c_boost_3a__3a_detail_3a__3a_variant_3a__3a_invoke_visitor_3c_const_20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_lock_weak_ptr_visitor_3e__2c__20_const_20_void_2a__2c__20_boost_3a__3a_variant_3c_boost_3a__3a_weak_ptr_3c_void_3e__2c__20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_foreign_void_weak_ptr_3e__3a__3a_has_fallback_type__3e_(int32_t arg0, int32_t arg1, char * arg2, int32_t arg3, struct has_fallback_type__1 arg4, int32_t arg5);

// --------------------- Global Variables ---------------------

bool g1 = false; // cf
int16_t g2 = 0; // cs
bool g3 = false; // df
int32_t g4 = 0; // eax
int32_t g5 = 0; // ebp
int32_t g6 = 0; // ebx
int32_t g7 = 0; // ecx
int32_t g8 = 0; // edi
int32_t g9 = 0; // edx
int32_t g10 = 0; // esi
int32_t g11 = 0; // esp
int16_t g12 = 0; // fs
int32_t g13 = 20;
char * g14 = "\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
int32_t g15 = -0x4b748fdc;
int16_t * g16 = (int16_t *)0x8424;
int32_t g17 = 132;
int16_t * g18 = (int16_t *)0x247c8900;
int32_t g19 = 0x74247c89;
int32_t g20 = 0x1415;
char g21 = 0;
int16_t * g22 = (int16_t *)0x249c8b6c;
int32_t g23 = 0x26b48d90;
int32_t g24 = 0;
int32_t g25 = 0x652cec83;
int32_t g26 = 0x14a1;
int32_t g27 = 20;
int32_t g28 = 0x24448900;
int32_t g29 = -0x38ffff93;
int32_t g31 = 128;
int32_t g30 = -0x38ffffcd;
int32_t g32 = -0x72000001;
int32_t g33 = 182;
int32_t g34 = -0x73000000;
int32_t g35 = 0x27bc8d00;
int32_t g36 = 0x27bc;
int32_t g37 = -0x5e9b0000;
int32_t g38 = 0xc2444c7;
int32_t g39 = 0x14a165;
int32_t g40 = 0x2680;
int32_t g42 = 0x37b0;
int32_t g44 = 0xa480;
int32_t g47 = 0;
int32_t g49 = 0x3f00;
int32_t g73 = 0x14a1;
int32_t g50 = 0;
int32_t g52 = 0x43b0;
int32_t g53 = 0x3a00;
int32_t g58 = 0x3fd0;
int32_t g60 = 0x4240;
int32_t g61 = 0x3b40;
int32_t g62 = 0x25c0;
int32_t g66 = 0x3f70;
int32_t g68 = 0x4140;
int32_t g69 = 0x3960;
int32_t g70 = 8;
char (*g71)[90] = "N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE";
int32_t g72 = 0x1c0000fb;
int32_t g74 = 0x2cec8300;
bool g75 = false; // if
bool g76 = false; // nt
bool g77 = false; // of
bool g78 = false; // pf
bool g79 = false; // sf
bool g80 = false; // tf
struct vtable_eed0_type g41 = {
    .e0 = _ZN5boost6system12system_errorD1Ev,
    .e1 = _ZN5boost6system12system_errorD0Ev,
    .e2 = _ZNK5boost6system12system_error4whatEv
};
struct vtable_ef28_type g43 = {
    .e0 = _ZN14CBasicKeyStoreD1Ev,
    .e1 = _ZN14CBasicKeyStoreD0Ev,
    .e2 = _ZN14CBasicKeyStore12AddKeyPubKeyERK4CKeyRK7CPubKey,
    .e3 = _ZN9CKeyStore6AddKeyERK4CKey,
    .e4 = _ZNK14CBasicKeyStore7HaveKeyERK6CKeyID,
    .e5 = _ZNK14CBasicKeyStore6GetKeyERK6CKeyIDR4CKey,
    .e6 = _ZNK14CBasicKeyStore7GetKeysERSt3setI6CKeyIDSt4lessIS1_ESaIS1_EE,
    .e7 = _ZNK9CKeyStore9GetPubKeyERK6CKeyIDR7CPubKey,
    .e8 = _ZN14CBasicKeyStore10AddCScriptERK7CScript,
    .e9 = _ZNK14CBasicKeyStore11HaveCScriptERK9CScriptID,
    .e10 = _ZNK14CBasicKeyStore10GetCScriptERK9CScriptIDR7CScript
};
struct vtable_efa0_type g45 = {
    .e0 = _ZN5boost16thread_exceptionD1Ev,
    .e1 = _ZN5boost16thread_exceptionD0Ev,
    .e2 = _ZN9CKeyStore6AddKeyERK4CKey
};
struct vtable_efb8_type g46 = {
    .e0 = _ZN5boost10lock_errorD1Ev,
    .e1 = _ZN5boost10lock_errorD0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv
};
struct vtable_efe8_type g48 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv
};
struct vtable_f028_type g51 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv
};
struct vtable_f0c0_type g54 = {
    .e0 = _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEED1Ev,
    .e1 = _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEED0Ev,
    .e2 = _ZNK5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEE10lock_pimplEv
};
struct vtable_f0d8_type g55 = {
    .e0 = _ZN5boost8signals211signal_baseD1Ev,
    .e1 = _ZN5boost8signals211signal_baseD0Ev,
    .e2 = _ZN9CKeyStore6AddKeyERK4CKey,
    .e3 = function_8
};
struct vtable_f0f8_type g56 = {
    .e0 = _ZN5boost17bad_function_callD1Ev,
    .e1 = _ZN5boost17bad_function_callD0Ev,
    .e2 = _ZN9CKeyStore6AddKeyERK4CKey
};
struct vtable_f128_type g57 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_17bad_function_callEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_17bad_function_callEED0Ev,
    .e2 = _ZN9CKeyStore6AddKeyERK4CKey
};
struct vtable_f168_type g59 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED0Ev,
    .e2 = _ZN9CKeyStore6AddKeyERK4CKey,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE5cloneEv2,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE7rethrowEv
};
struct vtable_f208_type g63 = {
    .e0 = _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEED1Ev,
    .e1 = _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEED0Ev,
    .e2 = _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEE7disposeEv,
    .e3 = _ZN5boost6detail15sp_counted_base7destroyEv,
    .e4 = _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEE11get_deleterERKSt9type_info
};
struct vtable_f228_type g64 = {
    .e0 = _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEED1Ev,
    .e1 = _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEED0Ev,
    .e2 = _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEE7disposeEv,
    .e3 = _ZN5boost6detail15sp_counted_base7destroyEv,
    .e4 = _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEE11get_deleterERKSt9type_info
};
struct vtable_f248_type g65 = {
    .e0 = _ZN5boost16exception_detail10bad_alloc_D1Ev,
    .e1 = _ZN5boost16exception_detail10bad_alloc_D0Ev
};
struct vtable_f288_type g67 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev,
    .e2 = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv
};

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x3
// From class:    CBasicKeyStore
// Type:          virtual member function
// Demangled:     CKeyStore::AddKey(CKey const &)
int32_t _ZN9CKeyStore6AddKeyERK4CKey(void) {
    // 0x0
    return 0;
}

// Address range: 0x8 - 0x9
// From class:    N5boost8signals211signal_baseE
// Type:          virtual member function
int32_t function_8(void) {
    // 0x8
    return 0;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x10 - 0x11
// Line range:    411 - 243
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_function_call> >::clone() const
void _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE5cloneEv(int32_t this) {
    // 0x10
    return;
}

// From module:   /usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp
// Address range: 0x34 - 0x35
// Line range:    34 - 87
void _7e_pthread_mutex_scoped_lock(int32_t this, int32_t __in_chrg) {
    // 0x34
    return;
}

// From module:   /usr/include/boost/variant/detail/visitation_impl.hpp
// Address range: 0x80 - 0x83
// Line range:    179 - 205
void visitation_impl_invoke_3c_boost_3a__3a_detail_3a__3a_variant_3a__3a_invoke_visitor_3c_const_20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_lock_weak_ptr_visitor_3e__2c__20_const_20_void_2a__2c__20_boost_3a__3a_variant_3c_boost_3a__3a_weak_ptr_3c_void_3e__2c__20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_foreign_void_weak_ptr_3e__3a__3a_has_fallback_type__3e_(int32_t arg0, int32_t arg1, char * arg2, int32_t arg3, struct has_fallback_type__1 arg4, int32_t arg5) {
    // 0x80
    return;
}

// From module:   /usr/include/boost/variant/detail/visitation_impl.hpp
// Address range: 0xc0 - 0xcf
// Line range:    179 - 36
void visitation_impl_invoke_3c_boost_3a__3a_detail_3a__3a_variant_3a__3a_copy_into_2c__20_const_20_void_2a__2c__20_boost_3a__3a_variant_3c_boost_3a__3a_shared_ptr_3c_void_3e__2c__20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_foreign_void_shared_ptr_3e__3a__3a_has_fallback_type__3e_(int32_t arg0, int32_t arg1, char * arg2, int32_t arg3, struct has_fallback_type_ arg4, int32_t arg5) {
    // 0xc0
    return;
}

// From module:   /usr/include/boost/smart_ptr/shared_ptr.hpp
// Address range: 0xd0 - 0xee
// Line range:    416 - 121
void _ZNK5boost10shared_ptrINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS1_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS5_EEENSA_IFvRKNS1_10connectionES5_EEENS1_5mutexEE16invocation_stateEEptEv(int32_t this) {
    int32_t v1 = 0; // eax
    unsigned char v2 = (char)v1 & (char)&g37 & 8;
    char * v3 = (char *)((int32_t)v2 | v1 & -256);
    *v3 = *v3 + v2;
}

// From module:   /usr/include/boost/variant/detail/visitation_impl.hpp
// Address range: 0x100 - 0x103
// Line range:    179 - 383
void visitation_impl_invoke_3c_boost_3a__3a_detail_3a__3a_variant_3a__3a_destroyer_2c__20_void_2a__2c__20_boost_3a__3a_variant_3c_boost_3a__3a_shared_ptr_3c_void_3e__2c__20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_foreign_void_shared_ptr_3e__3a__3a_has_fallback_type__3e_(int32_t arg0, int32_t arg1, char * arg2, int32_t arg3, struct has_fallback_type__5 arg4, int32_t arg5) {
    // 0x100
    return;
}

// From module:   /usr/include/boost/smart_ptr/shared_ptr.hpp
// Address range: 0x104 - 0x105
// Line range:    416 - 223
void _ZNK5boost10shared_ptrINS_8signals26detail15connection_bodyISt4pairINS2_15slot_meta_groupENS_8optionalIiEEENS1_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSB_EEEEENS1_5mutexEEEEptEv(int32_t this) {
    // 0x104
    return;
}

// From module:   /usr/include/boost/signals2/detail/signal_template.hpp
// Address range: 0x138 - 0x140
// Line range:    389 - 154
void _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE16invocation_state17connection_bodiesEv(int32_t this) {
    // 0x138
    int32_t v1;
    char * v2 = (char *)(v1 + 0x27bc); // bp+138
    *v2 = (char)0 + *v2;
    char v3 = *(char *)&g4;
    int32_t v4 = 0; // eax
    *(char *)v4 = (char)v4 + v3;
}

// From module:   /usr/include/boost/variant/detail/visitation_impl.hpp
// Address range: 0x140 - 0x16e
// Line range:    179 - 386
void visitation_impl_invoke_3c_boost_3a__3a_detail_3a__3a_variant_3a__3a_invoke_visitor_3c_const_20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_expired_weak_ptr_visitor_3e__2c__20_const_20_void_2a__2c__20_boost_3a__3a_variant_3c_boost_3a__3a_weak_ptr_3c_void_3e__2c__20_boost_3a__3a_signals2_3a__3a_detail_3a__3a_foreign_void_weak_ptr_3e__3a__3a_has_fallback_type__3e_(int32_t arg0, int32_t arg1, char * arg2, int32_t arg3, struct has_fallback_type__1_6 arg4, int32_t arg5) {
    // 0x140
    return;
}

// From module:   /usr/include/boost/signals2/detail/auto_buffer.hpp
// Address range: 0x180 - 0x19e
// Line range:    252 - 236
void _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EE14destroy_back_nEjRKNS_17integral_constantIbLb0EEE(int32_t this, int32_t n, int32_t arg2) {
    // bb
    function_2aa((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0);
    // branch -> 0x19a
}

// From module:   /usr/include/boost/signals2/detail/auto_buffer.hpp
// Address range: 0x1a0 - 0x1d1
// Line range:    599 - 98
void _7e_auto_buffer(int32_t this, int32_t __in_chrg) {
    // 0x1a0
    return;
}

// From module:   /usr/include/boost/signals2/detail/auto_buffer.hpp
// Address range: 0x1d4 - 0x1e1
// Line range:    761 - 1388
void _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EE19unchecked_push_backERKSA_(int32_t this, int32_t x) {
    // 0x1d4
    return;
}

// From module:   /usr/include/boost/signals2/detail/slot_groups.hpp
// Address range: 0x208 - 0x237
// Line range:    37 - 828
// Demangled:     boost::signals2::detail::group_key_less<int, std::less<int> >::operator()(std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> > const &, std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> > const &) const
void _ZNK5boost8signals26detail14group_key_lessIiSt4lessIiEEclERKSt4pairINS1_15slot_meta_groupENS_8optionalIiEEESC_(int32_t this, int32_t key1, int32_t key2) {
    // 0x208
    return;
}

// Address range: 0x239 - 0x23a
int32_t function_239(void) {
    // 0x239
    return 0;
}

// From module:   /usr/include/boost/signals2/detail/signal_template.hpp
// Address range: 0x23c - 0x29c
// Line range:    690 - 1091
void _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEclES3_(int32_t this, int32_t arg1) {
    int32_t * v1 = (int32_t *)-0x367aff8a;
    uint32_t v2 = *v1 - 1;
    *v1 = v2;
    if (v2 >= 0) {
        // 0x244
        return;
    }
    // 0x278
    if (*(int32_t *)*(int32_t *)4 != 0) {
        // 0x285
        // branch -> 0x295
    }
}

// Address range: 0x2a1 - 0x2aa
int32_t function_2a1(int32_t a1) {
    // 0x2a1
    return 0;
}

// Address range: 0x2aa - 0x2c9
int32_t function_2aa(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2aa
    return g4;
}

// Address range: 0x2ce - 0x2e0
int32_t function_2ce(void) {
    // 0x2ce
    return g4;
}

// From module:   /usr/include/c++/4.6/bits/stl_vector.h
// Address range: 0x2e0 - 0x313
// Line range:    153 - 418
// Demangled:     std::_Vector_base<unsigned char, secure_allocator<unsigned char> >::_M_deallocate(unsigned char *, unsigned int)
void _ZNSt12_Vector_baseIh16secure_allocatorIhEE13_M_deallocateEPhj(int32_t this, char * __p, int32_t __n) {
    // 0x2e0
    if (g4 == 0) {
        // bb
        function_327((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", g6, g10);
        // branch -> 0x2ff
    }
}

// Address range: 0x327 - 0x340
int32_t function_327(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    if (result != 0) {
        // 0x340
    }
    // 0x334
    return result;
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x350 - 0x3ee
// Line range:    54 - 395
// Demangled:     CCryptoKeyStore::SetCrypted()
void _ZN15CCryptoKeyStore10SetCryptedEv(int32_t this) {
    int32_t v1 = g6; // bp+353
    g6 = this;
    int32_t v2 = g10; // bp+367
    int32_t v3; // bp-24
    g10 = &v3;
    int32_t v4 = g8;
    g8 = 1;
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v3, this + 4, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", 56, 0);
    int32_t v5 = g6;
    char * v6 = (char *)(v5 + 172);
    if (*v6 == 0) {
        // 0x3b0
        g8 = 0;
        if (*(int32_t *)(v5 + 108) == 0) {
            // 0x3e0
            *v6 = 1;
            g8 = 1;
            // branch -> 0x3b9
        }
    }
    // 0x3b9
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v3);
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x3ee
        return;
    }
    // 0x3d0
    g6 = v1;
    g10 = v2;
    g8 = v4;
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x400 - 0x4cc
// Line range:    42 - 464
// From class:    CBasicKeyStore
// Type:          virtual member function
// Demangled:     CBasicKeyStore::GetCScript(CScriptID const &, CScript &) const
void _ZNK14CBasicKeyStore10GetCScriptERK9CScriptIDR7CScript(int32_t this, int32_t hash, int32_t redeemScriptOut) {
    // 0x400
    g10 = this;
    g5 = hash;
    int32_t v1; // bp-40
    g6 = &v1;
    g8 = redeemScriptOut;
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, this + 4, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", 44, 0);
    int32_t v2 = g10; // bp+462
    g10 = v2 + 116;
    int32_t v3 = 0; // bp-48
    _ZNKSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE4findERS2_(&v3, v2 + 112);
    int32_t v4;
    if (v4 == g10) {
        // 0x4c8
        // branch -> 0x497
    } else {
        // 0x483
        _ZNSt6vectorIhSaIhEEaSERKS1_((int32_t *)g8, v4 + (int32_t)&g18);
        // branch -> 0x497
    }
    // 0x497
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v1);
    int32_t v5;
    if (v5 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x4cc
        return;
    }
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x4f0 - 0x591
// Line range:    36 - 765
// From class:    CBasicKeyStore
// Type:          virtual member function
// Demangled:     CBasicKeyStore::HaveCScript(CScriptID const &) const
void _ZNK14CBasicKeyStore11HaveCScriptERK9CScriptID(int32_t this, int32_t hash) {
    // 0x4f0
    g6 = this;
    g8 = hash;
    int32_t v1; // bp-24
    g10 = &v1;
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, this + 4, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", 38, 0);
    int32_t v2 = g6; // bp+546
    g6 = v2 + 116;
    int32_t v3 = 0; // bp-32
    _ZNKSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE4findERS2_(&v3, v2 + 112);
    int32_t v4 = g6; // bp+563
    int32_t v5;
    g6 = (int32_t)(v4 != v5) | v4 & -256;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v1);
    int32_t v6;
    if (v6 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x591
        return;
    }
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x5a0 - 0x7db
// Line range:    142 - 160
// Demangled:     CCryptoKeyStore::GetKey(CKeyID const &, CKey &) const
void _ZNK15CCryptoKeyStore6GetKeyERK6CKeyIDR4CKey(int32_t this, int32_t address, int32_t keyOut) {
    struct vector_unsignedchar_secure_allocator_unsignedchar__ vchSecret; // bp-128
    // 0x5a0
    g6 = this;
    int32_t v1; // bp-112
    g8 = &v1;
    g5 = address;
    g10 = keyOut;
    int32_t v2 = this + 4;
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, v2, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", (int32_t)"$\f m", 0);
    int32_t v3 = g6; // bp+609
    int32_t v4; // bp-132
    if (*(char *)(v3 + 172) != 0) {
        // 0x6e8
        _ZNKSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE4findERS2_(&v4, v3 + (int32_t)&g28);
        int32_t v5;
        int32_t v6 = v5; // bp+717
        if (v5 == g6 + 140) {
            // bb156
            function_8f0();
            v6 = 0;
            // branch -> 0x717
        }
        unsigned char v7 = *(char *)(v6 + (int32_t)&g18); // bp+717
        int32_t v8 = v7; // bp+717
        g4 = v8;
        g7 = &g17;
        vchSecret = (struct vector_unsignedchar_secure_allocator_unsignedchar__){
            .e0 = 0
        };
        if ((v7 || 1) == 3) {
            // 0x75c
            return;
        }
        if (v7 == 6) {
            int32_t v9 = function_8c8(vchSecret.e0, 0, 0); // bp+742
            g4 = v9;
            v8 = v9;
            // branch -> 0x748
        }
        // 0x748
        if ((char)v8 == 4) {
            // bb161
            int32_t * v10;
            function_8c8(0, (int32_t)&v10, (int32_t)&v10);
            // branch -> 0x750
        }
        // 0x750
        // branch -> 0x75c
        // 0x75c
        return;
    }
    int32_t v11 = 0; // bp-104
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v11, v2, (int32_t)"cs_KeyStore", (int32_t)"keystore.h", 76, 0);
    int32_t v12 = g6;
    g6 = v12 + (int32_t)&g21;
    _ZNKSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE4findERS2_(&vchSecret.e0, v12 + (int32_t)&g20);
    int32_t v13 = v4; // eax
    int32_t v14 = v4;
    if (v4 == g6) {
        int32_t v15 = function_8d8(); // bp+669
        v13 = v15;
        v14 = v15;
        // branch -> 0x66f
    }
    // 0x66f
    *(int32_t *)g10 = *(int32_t *)(v14 + (int32_t)&g18);
    *(int32_t *)(g10 + 4) = *(int32_t *)(v13 + 40);
    *(int32_t *)(g10 + 8) = *(int32_t *)(v13 + 44);
    int32_t v16 = *(int32_t *)(v13 + 48); // bp+680
    *(int32_t *)(g10 + (int32_t)&g37) = v16;
    int32_t v17 = *(int32_t *)(v13 + 52); // bp+686
    *(int32_t *)(g10 + (int32_t)&g13) = v17;
    int32_t v18 = *(int32_t *)(v13 + 56);
    *(int32_t *)(g10 + (int32_t)&g14) = v18;
    *(int32_t *)(g10 + 24) = *(int32_t *)(v13 + 60);
    int32_t v19 = *(int32_t *)(v13 + 64); // bp+698
    *(int32_t *)(g10 + (int32_t)&g15) = v19;
    int16_t v20 = *(int16_t *)(v13 + 68);
    *(int16_t *)(g10 + (int32_t)&g16) = v20;
    int32_t v21; // bp-108
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v21);
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v1);
    g4 = 1;
    int32_t v22;
    if (v22 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb153
        function_988();
        // branch -> 0x6d8
    }
}

// Address range: 0x843 - 0x84a
int32_t function_843(void) {
    // 0x843
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x7ea3dbbc); // bp+843
    *v2 = *v2 - 1;
    return 0;
}

// Address range: 0x88d - 0x88e
int32_t function_88d(int32_t a1) {
    // 0x88d
    return g4;
}

// Address range: 0x898 - 0x89a
int32_t function_898(void) {
    // 0x898
    return 0;
}

// Address range: 0x8c3 - 0x8c8
int32_t function_8c3(void) {
    // 0x8c3
    return 0;
}

// Address range: 0x8c8 - 0x8d2
int32_t function_8c8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8c8
    g7 = 65;
    return g4;
}

// Address range: 0x8d8 - 0x8ee
int32_t function_8d8(void) {
    int32_t v1 = 0; // bp+84
    return _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v1);
}

// Address range: 0x8f0 - 0x902
int32_t function_8f0(void) {
    // 0x8f0
    return _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)g8);
}

// Address range: 0x908 - 0x912
int32_t function_908(void) {
    // 0x908
    return function_88d(0);
}

// Address range: 0x91e - 0x929
int32_t function_91e(void) {
    // 0x91e
    unknown_f014527();
    return 0;
}

// Address range: 0x92e - 0x988
int32_t function_92e(int32_t a1) {
    // 0x92e
    int32_t v1; // esi
    if ((char)g4 == 0) {
        // 0x932
        *(char *)v1 = 0;
        return function_88d(1);
    }
    int32_t v2 = 0; // ebx
    g4 = 0;
    v1 = 0;
    *(int32_t *)(v1 + 2) = v2;
    int32_t v3 = *(int32_t *)(v2 + 4);
    *(int32_t *)(v1 + (int32_t)&g22) = v3;
    int32_t v4 = *(int32_t *)(v2 + 8); // bp+950
    *(int32_t *)(v1 + (int32_t)&g31) = v4;
    int32_t v5 = *(int32_t *)(v2 + (int32_t)&g37); // bp+956
    *(int32_t *)(v1 + (int32_t)&g39) = v5;
    int32_t v6 = *(int32_t *)(v2 + (int32_t)&g13);
    *(int32_t *)(v1 + 18) = v6;
    int32_t v7 = *(int32_t *)(v2 + (int32_t)&g14); // bp+962
    *(int32_t *)(v1 + 22) = v7;
    *(int32_t *)(v1 + 26) = *(int32_t *)(v2 + 24);
    int32_t v8 = *(int32_t *)(v2 + (int32_t)&g15);
    *(char *)v1 = 1;
    *(char *)(v1 + 1) = (char)g4;
    *(int32_t *)(v1 + 30) = v8;
    return function_88d(1);
}

// Address range: 0x988 - 0x989
int32_t function_988(void) {
    // 0x988
    return g4;
}

// Address range: 0x98e - 0x98f
int32_t function_98e(void) {
    // 0x98e
    return 0;
}

// Address range: 0x98f - 0x990
int32_t function_98f(void) {
    // 0x98f
    return g4;
}

// Address range: 0x99e - 0x9af
int32_t function_99e(void) {
    int32_t * v1 = (int32_t *)0x24448bc3;
    *v1 = *v1 - 1;
    int32_t * v2;
    g4 = _ZNSt6vectorIh16secure_allocatorIhEED1Ev(&v2);
    return function_98f();
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x9b0 - 0xa13
// Line range:    9 - 15
// From class:    CBasicKeyStore
// Type:          virtual member function
// Demangled:     CKeyStore::GetPubKey(CKeyID const &, CPubKey &) const
void _ZNK9CKeyStore9GetPubKeyERK6CKeyIDR7CPubKey(int32_t this, int32_t address, int32_t vchPubKeyOut) {
    // 0x9b0
    int32_t v1; // bp-66
    g6 = &v1;
}

// Address range: 0xa5f - 0xa60
int32_t function_a5f(void) {
    // 0xa5f
    return g4;
}

// Address range: 0xa67 - 0xa75
int32_t function_a67(void) {
    int32_t v1 = (bool)false ? 252 : 4;
    int32_t v2;
    *(char *)v2 = (char)(v1 + v2) + (char)v2;
    int32_t v3 = 0; // ecx
    char * v4 = (char *)(v3 - 0x3e2dce3f);
    *v4 = *v4 + (char)v3;
    return function_f302b277();
}

// Address range: 0xa80 - 0xa81
int32_t function_a80(void) {
    // 0xa80
    return g4;
}

// Address range: 0xa85 - 0xa90
int32_t function_a85(void) {
    // 0xa85
    return g4;
}

// Address range: 0xae8 - 0xaf1
int32_t function_ae8(void) {
    int32_t v1 = g9;
    unsigned char v2 = *(char *)(v1 + g10);
    g4 = v2;
    *(char *)(g8 + v1) = v2;
    return function_a80();
}

// Address range: 0xaf8 - 0xb0d
int32_t function_af8(void) {
    // 0xaf8
    *(int16_t *)g8 = *(int16_t *)&g10;
    g9 = 2;
    if (g4 % 2 == 0) {
        // bb
        function_a80();
        // branch -> 0xb0b
    }
    // 0xb0b
    return function_ae8();
}

// Address range: 0xb10 - 0xb17
int32_t function_b10(void) {
    // 0xb10
    return function_a85();
}

// Address range: 0xb18 - 0xb2c
int32_t function_b18(void) {
    // 0xb18
    *(int16_t *)0 = *(int16_t *)&g10;
    return -2;
}

// Address range: 0xb30 - 0xb48
int32_t function_b30(char a1) {
    // 0xb30
    int32_t v1;
    *(char *)v1 = a1;
    g4 = 64;
    return function_a5f();
}

// Address range: 0xb48 - 0xb49
int32_t function_b48(void) {
    // 0xb48
    return 0;
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0xb60 - 0xcb1
// Line range:    166 - 140
// Demangled:     CCryptoKeyStore::GetPubKey(CKeyID const &, CPubKey &) const
void _ZNK15CCryptoKeyStore9GetPubKeyERK6CKeyIDR7CPubKey(int32_t this, int32_t address, int32_t vchPubKeyOut) {
    // 0xb60
    g10 = this;
    int32_t v1; // bp-40
    int32_t v2 = &v1;
    g6 = v2;
    g8 = vchPubKeyOut;
    int32_t v3 = this + 4;
    g5 = address;
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, v3, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", (int32_t)"$\v$", 0);
    int32_t v4 = g10;
    int32_t v5;
    if (*(char *)(v4 + 172) == 0) {
        // 0xbc7
        _ZNK9CKeyStore9GetPubKeyERK6CKeyIDR7CPubKey(v4, g8, (int32_t)"keystore.cpp");
        // branch -> 0xbd9
        // 0xbd9
        *(int32_t *)g11 = v2;
        _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)v4);
        // branch -> 0xbe1
        // 0xbe1
        v5 = *(int32_t *)(g11 + 60);
        if ((v5 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
            // 0xcb1
            return;
        }
        // 0xbf4
        return;
    }
    int32_t v6 = v4 + (int32_t)&g28;
    g10 = v4 + 140;
    int32_t v7; // bp-48
    _ZNKSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE4findERS2_(&v7, v6);
    int32_t v8;
    if (v8 == g10) {
        // 0xc78
        _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v1);
        // branch -> 0xbe1
    } else {
        uint32_t v9 = g8;
        int32_t v10 = 65; // eax
        int32_t v11 = v8 + (int32_t)&g18;
        int32_t v12 = v11; // esi
        int32_t v13 = v9;
        int32_t v14 = 65;
        if (v9 % 2 != 0) {
            // 0xc88
            v12 = v8 + (int32_t)&g19;
            *(char *)v9 = *(char *)v11;
            int32_t v15 = g8 + 1;
            g8 = v15;
            v10 = 64;
            v13 = v15;
            v14 = 64;
            // branch -> 0xc43
        }
        int32_t v16 = v13;
        int32_t v17 = v14;
        if ((v13 & 2) != 0) {
            int32_t v18 = v12;
            v10 = v14 - 2;
            v12 = v18 + 2;
            *(int16_t *)v13 = *(int16_t *)v18;
            v16 = g8 + 2;
            v17 = v10;
            // branch -> 0xc4b
        }
        int32_t v19 = 0; // edx
        uint32_t v20 = v17 / 4;
        __asm_rep_movsd_memcpy((char *)v16, (char *)v12, v20);
        if ((v17 & 2) != 0) {
            // 0xc58
            v19 = 2;
            // branch -> 0xc63
        }
        // 0xc63
        if (v10 % 2 != 0) {
            char * v21 = (char *)(v19 + 4 * v20 + v16);
            // branch -> 0xbd9
        }
        // 0xbd9
        *(int32_t *)g11 = v2;
        int32_t v22 = &v7;
        _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)v22);
        // branch -> 0xbe1
    }
    // 0xbe1
    v5 = *(int32_t *)(g11 + 60);
    if ((v5 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
        // 0xcb1
        return;
    }
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0xcd0 - 0xd88
// Line range:    183 - 205
// Demangled:     CCryptoKeyStore::EncryptKeys(std::vector<unsigned char, secure_allocator<unsigned char> > &)
void _ZN15CCryptoKeyStore11EncryptKeysERSt6vectorIh16secure_allocatorIhEE(int32_t this, struct vector_unsignedchar_secure_allocator_unsignedchar__ vMasterKeyIn) {
    int32_t v1 = this + 4;
    int32_t v2; // bp-172
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v2, v1, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", (int32_t)&g36, 0);
    int32_t v3 = this;
    if (*(int32_t *)(this + 156) != 0) {
        // bb
        v3 = function_10ae();
        // branch -> 0xd48
    }
    // 0xd48
    if (*(char *)(v3 + 172) != 0) {
        // bb126
        function_10ae();
        // branch -> 0xd55
    }
    // 0xd55
    *(char *)(this + 172) = 1;
    int32_t v4 = this + (int32_t)&g21;
    int32_t v5 = *(int32_t *)(this + 100);
    if (v5 == v4) {
        // bb127
        function_101e(v5, 0x1000000 * v4 / 0x1000000);
        // branch -> 0xd7a
    }
}

// Address range: 0xdc2 - 0xdc3
int32_t function_dc2(void) {
    // 0xdc2
    return 0;
}

// Address range: 0x101e - 0x1065
int32_t function_101e(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 96); // 0x1022
    int32_t v2 = *v1; // 0x1022
    int32_t v3 = a1 + (int32_t)&g20; // 0x102b
    _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE8_M_eraseEPSt13_Rb_tree_nodeIS4_E(v3, v2);
    *v1 = 0;
    *(int32_t *)(a1 + 100) = a2;
    *(int32_t *)(a1 + 104) = a2;
    *(int32_t *)(a1 + 108) = 0;
    int32_t v4; // bp+96
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v4);
    g4 = 1;
    return function_10bc();
}

// Address range: 0x10ae - 0x10bc
int32_t function_10ae(void) {
    int32_t v1 = 0; // bp+96
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v1);
    return 0;
}

// Address range: 0x10bc - 0x10d7
int32_t function_10bc(void) {
    // 0x10bc
    int32_t v1;
    int32_t result; // 0x10d6
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_111d();
        // branch -> 0x10cc
    } else {
        // 0x10bc
        result = g4;
        // branch -> 0x10cc
    }
    // 0x10cc
    return result;
}

// Address range: 0x10d7 - 0x10de
int32_t function_10d7(void) {
    // 0x10d7
    return 0;
}

// Address range: 0x10df - 0x10e0
int32_t function_10df(void) {
    // 0x10df
    return 0;
}

// Address range: 0x10e0 - 0x10e1
int32_t function_10e0(void) {
    // 0x10e0
    return g4;
}

// Address range: 0x10f3 - 0x1107
int32_t function_10f3(int32_t a1) {
    int32_t * v1 = (int32_t *)0x24548bc3; // 0x10f3
    *v1 = *v1 - 1;
    g4 = a1;
    g9 = -a1;
    int32_t * v2;
    _ZNSt12_Vector_baseIh16secure_allocatorIhEE13_M_deallocateEPhj(0, (char *)&v2, (int32_t)&v2);
    g4 = (int32_t)&v2;
    return function_10e0();
}

// Address range: 0x1107 - 0x111d
int32_t function_1107(void) {
    // 0x1107
    g6 = 0;
    _ZNSt6vectorIhSaIhEED1Ev((int32_t *)0);
    g4 = _ZNSt6vectorIh16secure_allocatorIhEED1Ev((int32_t *)g10);
    return function_10e0();
}

// Address range: 0x111d - 0x1120
int32_t function_111d(void) {
    // 0x111d
    return g4;
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x1130 - 0x120a
// Line range:    22 - 140
// From class:    CBasicKeyStore
// Type:          virtual member function
// Demangled:     CBasicKeyStore::AddKeyPubKey(CKey const &, CPubKey const &)
void _ZN14CBasicKeyStore12AddKeyPubKeyERK4CKeyRK7CPubKey(int32_t this, int32_t key, int32_t pubkey) {
    // 0x1130
    int32_t v1; // bp-112
    g10 = &v1;
    g8 = pubkey;
    g6 = key;
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, this + 4, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", 24, 0);
    unsigned char v2 = *(char *)g8; // 0x118e
    g4 = v2;
    g9 = &g17;
    int32_t v3; // bp-104
    if ((v2 || 1) == 3) {
        // 0x11ab
        g8 = &v3;
        return;
    }
    // 0x119e
    if (v2 != 6) {
        // bb
        function_12e8();
        // branch -> 0x11a6
    }
    // 0x11a6
    // branch -> 0x11ab
    // 0x11ab
    g8 = &v3;
}

// Address range: 0x124e - 0x12e5
int32_t function_124e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t * v1 = (int32_t *)-0x7c97dbbc; // 0x124e
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x1254
    int32_t v3 = v2 - (int32_t)(char)&g18 & 255 | v2 & -256; // bp+84
    int32_t v4 = _ZNSt3mapI6CKeyID4CKeySt4lessIS0_ESaISt4pairIKS0_S1_EEEixERS5_((int32_t)&v3); // 0x1285
    *(int32_t *)v4 = *(int32_t *)g6;
    *(int32_t *)(v4 + 4) = *(int32_t *)(g6 + 4);
    *(int32_t *)(v4 + 8) = *(int32_t *)(g6 + 8);
    int32_t v5 = *(int32_t *)(g6 + (int32_t)&g37); // 0x129a
    *(int32_t *)(v4 + (int32_t)&g37) = v5;
    int32_t v6 = *(int32_t *)(g6 + (int32_t)&g13); // 0x12a0
    *(int32_t *)(v4 + (int32_t)&g13) = v6;
    int32_t v7 = *(int32_t *)(g6 + (int32_t)&g14); // 0x12a6
    *(int32_t *)(v4 + (int32_t)&g14) = v7;
    *(int32_t *)(v4 + 24) = *(int32_t *)(g6 + 24);
    int32_t v8 = *(int32_t *)(g6 + (int32_t)&g15); // 0x12b2
    *(int32_t *)(v4 + (int32_t)&g15) = v8;
    int16_t v9 = *(int16_t *)(g6 + (int32_t)&g16); // 0x12b8
    *(int16_t *)(v4 + (int32_t)&g16) = v9;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)g10);
    g4 = 1;
    int32_t result = 1; // 0x12e4
    if (a5 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_1301();
        // branch -> 0x12da
    }
    // 0x12da
    return result;
}

// Address range: 0x12e8 - 0x1301
int32_t function_12e8(void) {
    // 0x12e8
    return 0;
}

// Address range: 0x1301 - 0x1313
int32_t function_1301(void) {
    // 0x1301
    g6 = g4;
    return _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)g10);
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x1320 - 0x146b
// Line range:    108 - 124
// Demangled:     CCryptoKeyStore::AddKeyPubKey(CKey const &, CPubKey const &)
void _ZN15CCryptoKeyStore12AddKeyPubKeyERK4CKeyRK7CPubKey(int32_t this, int32_t key, int32_t pubkey) {
    struct vector_unsignedchar_secure_allocator_unsignedchar___4 vchSecret; // bp-128
    // 0x1320
    g10 = this;
    int32_t v1 = this + 4; // 0x134b
    g6 = v1;
    int32_t v2; // bp-112
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v2, v1, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", 111, 0);
    if (*(char *)(g10 + 172) == 0) {
        // bb
        function_1660();
        // branch -> 0x1396
    }
    int32_t v3 = g6; // 0x1396
    int32_t v4; // bp-104
    g6 = &v4;
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v4, v3, (int32_t)"cs_KeyStore", (int32_t)"keystore.h", 131, 0);
    int32_t v5 = g10; // 0x13c6
    int32_t v6 = *(int32_t *)(v5 + 160); // 0x13cc
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v4);
    if (*(int32_t *)(v5 + (int32_t)&g30) != v6) {
        // 0x140f
        vchSecret = (struct vector_unsignedchar_secure_allocator_unsignedchar___4){
            .e0 = 0
        };
        g4 = ((int32_t)&g16 | 2) - 2;
        if (((int32_t)&g16 || 2) == 2) {
            // bb132
            function_1710(0, 0, 0, vchSecret.e0, 0, 0, 0);
            // branch -> 0x1468
        }
        // 0x1468
        return;
    }
    // 0x13e4
    g6 = 0;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v2);
    g4 = g6;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb130
        function_171d();
        // branch -> 0x1404
    }
}

// Address range: 0x1657 - 0x165c
int32_t function_1657(void) {
    // 0x1657
    return 0;
}

// Address range: 0x1660 - 0x167f
int32_t function_1660(void) {
    // 0x1660
    int32_t v1;
    int32_t v2;
    _ZN14CBasicKeyStore12AddKeyPubKeyERK4CKeyRK7CPubKey(g10, v1, v2);
    int32_t * v3;
    g6 = (int32_t)&v3;
    return (int32_t)&v3;
}

// Address range: 0x16e2 - 0x16f4
int32_t function_16e2(void) {
    // 0x16e2
    g6 = 1;
    int32_t v1;
    return _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)v1);
}

// Address range: 0x16f8 - 0x170f
int32_t function_16f8(void) {
    // 0x16f8
    return 0;
}

// Address range: 0x1710 - 0x171d
int32_t function_1710(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x1710
    return g4;
}

// Address range: 0x171d - 0x171e
int32_t function_171d(void) {
    // 0x171d
    return g4;
}

// Address range: 0x1723 - 0x1724
int32_t function_1723(void) {
    // 0x1723
    return 0;
}

// Address range: 0x1724 - 0x1725
int32_t function_1724(void) {
    // 0x1724
    return g4;
}

// Address range: 0x173b - 0x1757
int32_t function_173b(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x7413143d; // 0x173b
    *v1 = *v1 - 1;
    g6 = 0;
    g4 = a1;
    g9 = -a1;
    char * v2 = NULL;
    int32_t * v3;
    _ZNSt12_Vector_baseIh16secure_allocatorIhEE13_M_deallocateEPhj((int32_t)&v2, v2, (int32_t)&v3);
    g4 = (int32_t)&v3;
    return function_1724();
}

// Address range: 0x1757 - 0x1765
int32_t function_1757(void) {
    int32_t v1 = 0; // eax
    g10 = v1;
    g6 = v1;
    g4 = _ZNSt6vectorIh16secure_allocatorIhEED1Ev((int32_t *)0);
    return function_1724();
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x1770 - 0x1829
// Line range:    29 - 140
// From class:    CBasicKeyStore
// Type:          virtual member function
// Demangled:     CBasicKeyStore::AddCScript(CScript const &)
void _ZN14CBasicKeyStore10AddCScriptERK7CScript(int32_t this, int32_t redeemScript) {
    // 0x1770
    int32_t v1; // bp-112
    g10 = &v1;
    g6 = redeemScript;
    int32_t v2; // bp-104
    g8 = &v2;
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, this + 4, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", 31, 0);
}

// Address range: 0x186d - 0x18da
int32_t function_186d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t * v1 = (int32_t *)-0x7c97dbbc; // 0x186d
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x1873
    int32_t v3 = v2 - (int32_t)(char)&g18 & 255 | v2 & -256; // bp+84
    int32_t v4 = _ZNSt3mapI9CScriptID7CScriptSt4lessIS0_ESaISt4pairIKS0_S1_EEEixERS5_((int32_t)&v3); // 0x18a4
    _ZNSt6vectorIhSaIhEEaSERKS1_((int32_t *)v4, g6);
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)g10);
    if (a5 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x18da
        return 1;
    }
    // 0x18cf
    return 1;
}

// Address range: 0x18e0 - 0x18e1
int32_t function_18e0(void) {
    // 0x18e0
    return 0;
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x1900 - 0x1b1c
// Line range:    130 - 140
// Demangled:     CCryptoKeyStore::AddCryptedKey(CPubKey const &, std::vector<unsigned char, std::allocator<unsigned char> > const &)
void _ZN15CCryptoKeyStore13AddCryptedKeyERK7CPubKeyRKSt6vectorIhSaIhEE(int32_t this, int32_t vchPubKey, int32_t vchCryptedSecret) {
    // 0x1900
    g5 = vchPubKey;
    g6 = vchCryptedSecret;
    int32_t v1 = this + 4; // 0x193b
    int32_t v2 = 0; // bp-260
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v2, v1, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", (int32_t)&g27, 0);
    _ZN15CCryptoKeyStore10SetCryptedEv(this);
    int32_t * v3;
    if (((char)&v3 & (char)&v3) == 0) {
        // bb
        function_1d28();
        // branch -> 0x197a
    }
    int32_t v4 = g6; // 0x197a
    g9 = 0;
    g8 = 0;
    int32_t v5 = *(int32_t *)(v4 + 4) - *(int32_t *)v4; // 0x199b
    g4 = v5;
    int32_t v6 = v5; // 0x19a9
    int32_t v7 = 0; // 0x19ab
    if (v5 != 0) {
        int32_t v8 = function_1cf8(0, 0, 0); // 0x19a1
        g4 = v8;
        v6 = v8;
        v7 = g8;
        // branch -> 0x19a7
    }
    int32_t v9 = v7; // 0x19c1
    if (v6 != 0) {
        // bb158
        function_1cd0(v7);
        v9 = g8;
        // branch -> 0x19c1
    }
    // 0x19c1
    g4 = 65;
    int32_t v10; // bp-169
    __asm_rep_movsd_memcpy((char *)&v10, (char *)g5, 16);
    bool v11 = false; // df
    int32_t v12 = (v11 ? -64 : 64) + (int32_t)&v10; // 0x19f4
    g8 = v12;
    g10 = v12;
    g7 = 0;
    uint32_t v13; // 0x19fc
    // 0x19c1
    v13 = g4;
    // branch -> 0x19fc
    // 0x19fc
    if (v13 % 2 != 0) {
        // bb161
        function_1c60();
        // branch -> 0x1a04
    }
    // 0x1a04
    int32_t v14; // bp-252
    int32_t v15 = &v14; // 0x1a04
    __asm_rep_movsd_memcpy((char *)&v14, (char *)&v10, (int32_t)&g13);
    int32_t v16 = v11 ? -4 * (int32_t)&g13 : 4 * (int32_t)&g13; // 0x1a11
    int32_t v17 = g9 + v9 - v7; // 0x1a19
    char * v18 = (char *)(v16 + v15); // 0x1a1d
    unsigned char v19 = *v18; // 0x1a1d
    g4 = v19;
    g10 = 0;
    *v18 = v19;
    g8 = 0;
    if (v17 != 0) {
        // bb163
        function_1ca8(v15);
        // branch -> 0x1a51
    }
    int32_t v20 = g10; // 0x1a51
    int32_t v21 = v20; // 0x1a74
    if (v17 != 0) {
        // bb164
        function_1c88(v20, v20, v20 + v17);
        v21 = g10;
        // branch -> 0x1a70
    }
    unsigned char v22 = *(char *)g5; // 0x1a70
    g4 = v22;
    g9 = &g17;
    if ((v22 || 1) == 3) {
        // 0x1a9b
        return;
    }
    // 0x1a8a
    if (v22 != 6) {
        // 0x1a8e
        if (v22 != 4) {
            // bb168
            function_1d10(g8 + v21);
            // branch -> 0x1a96
        }
    }
    // 0x1a96
    // branch -> 0x1a9b
}

// Address range: 0x1c3f - 0x1c5e
int32_t function_1c3f(void) {
    // 0x1c3f
    int32_t v1;
    int32_t result; // 0x1c5d
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_1d74();
        // branch -> 0x1c53
    } else {
        // 0x1c3f
        result = g4;
        // branch -> 0x1c53
    }
    // 0x1c53
    return result;
}

// Address range: 0x1c60 - 0x1c6c
int32_t function_1c60(void) {
    int32_t v1 = g7; // 0x1c60
    unsigned char result = *(char *)(v1 + g10); // 0x1c60
    *(char *)(g8 + v1) = result;
    return result;
}

// Address range: 0x1c70 - 0x1c85
int32_t function_1c70(void) {
    // 0x1c70
    *(int16_t *)g8 = *(int16_t *)&g10;
    g7 = 2;
    return function_1c60();
}

// Address range: 0x1c88 - 0x1c97
int32_t function_1c88(int32_t result, int32_t a2, int32_t a3) {
    // 0x1c88
    return result;
}

// Address range: 0x1c9c - 0x1ca1
int32_t function_1c9c(void) {
    // 0x1c9c
    return 0;
}

// Address range: 0x1ca8 - 0x1cc9
int32_t function_1ca8(int32_t a1) {
    int32_t result = g4; // 0x1cb4
    g10 = result;
    int32_t v1;
    g8 = v1 - a1;
    return result;
}

// Address range: 0x1cd0 - 0x1cdf
int32_t function_1cd0(int32_t a1) {
    // 0x1cd0
    return g4;
}

// Address range: 0x1ce3 - 0x1cf5
int32_t function_1ce3(void) {
    int32_t * v1 = (int32_t *)-0x74c3dbbc; // 0x1ce3
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x1cf8 - 0x1d10
int32_t function_1cf8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1cf8
    g8 = g4;
    int32_t v1 = g6; // 0x1d02
    int32_t result = *(int32_t *)(v1 + 4) - v1; // 0x1d07
    g9 = result;
    return result;
}

// Address range: 0x1d10 - 0x1d21
int32_t function_1d10(int32_t a1) {
    // 0x1d10
    return 0;
}

// Address range: 0x1d28 - 0x1d3b
int32_t function_1d28(void) {
    int32_t v1 = 0; // bp+72
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v1);
    g4 = 0;
    return function_1c3f();
}

// Address range: 0x1d40 - 0x1d5f
int32_t function_1d40(int32_t a1) {
    // 0x1d40
    return 64;
}

// Address range: 0x1d60 - 0x1d74
int32_t function_1d60(void) {
    // 0x1d60
    *(int16_t *)g8 = *(int16_t *)&g10;
    return g4 - 2;
}

// Address range: 0x1d74 - 0x1d75
int32_t function_1d74(void) {
    // 0x1d74
    return g4;
}

// Address range: 0x1d85 - 0x1d86
int32_t function_1d85(void) {
    // 0x1d85
    return g4;
}

// Address range: 0x1da4 - 0x1dab
int32_t function_1da4(void) {
    int32_t * v1 = (int32_t *)-0x7617143d; // 0x1da4
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x1dab - 0x1dad
int32_t function_1dab(void) {
    // 0x1dab
    return function_1d85();
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x1db0 - 0x1efa
// Line range:    79 - 412
// Demangled:     CCryptoKeyStore::Unlock(std::vector<unsigned char, secure_allocator<unsigned char> > const &)
void _ZN15CCryptoKeyStore6UnlockERKSt6vectorIh16secure_allocatorIhEE(int32_t this, struct vector_unsignedchar_secure_allocator_unsignedchar__ vMasterKeyIn) {
    // 0x1db0
    g10 = this;
    int32_t v1; // bp-204
    g5 = &v1;
    _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v1, this + 4, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", 82, 0);
    _ZN15CCryptoKeyStore10SetCryptedEv(g10);
    int32_t * v2;
    if (((char)&v2 & (char)&v2) == 0) {
        // bb
        function_1fe9();
        // branch -> 0x1e1f
    }
    int32_t v3 = *(int32_t *)(g10 + (int32_t)&g29); // 0x1e1f
    unsigned char v4 = *(char *)(v3 + (int32_t)&g18); // 0x1e33
    g4 = v4;
    g7 = &g17;
    if ((v4 || 1) == 3) {
        // 0x1e6d
        return;
    }
    // 0x1e5c
    if (v4 != 6) {
        // 0x1e60
        if (v4 != 4) {
            // bb140
            function_2018(0, 0, 0);
            // branch -> 0x1e68
        }
    }
    // 0x1e68
    // branch -> 0x1e6d
}

// Address range: 0x1fb7 - 0x1fc8
int32_t function_1fb7(int32_t a1) {
    // 0x1fb7
    int32_t result; // 0x1fc5
    if (g6 == 0) {
        // bb
        result = function_1fe9();
        // branch -> 0x1fbf
    } else {
        // 0x1fb7
        int32_t v1; // eax
        result = v1;
        // branch -> 0x1fbf
    }
    // 0x1fbf
    return result;
}

// Address range: 0x1fe9 - 0x2012
int32_t function_1fe9(void) {
    // 0x1fe9
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)g5);
    g4 = 0;
    int32_t result = 0; // 0x2011
    int32_t v1;
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_2249();
        // branch -> 0x2007
    }
    // 0x2007
    return result;
}

// Address range: 0x2018 - 0x2029
int32_t function_2018(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2018
    return 0;
}

// Address range: 0x20aa - 0x20ab
int32_t function_20aa(void) {
    // 0x20aa
    return g4;
}

// Address range: 0x210d - 0x210e
int32_t function_210d(void) {
    // 0x210d
    return g4;
}

// Address range: 0x2191 - 0x219f
int32_t function_2191(int32_t a1) {
    // 0x2191
    return 0;
}

// Address range: 0x21a4 - 0x2218
int32_t function_21a4(int32_t * a1, uint32_t a2) {
    // 0x21a4
    return a2 % 256;
}

// Address range: 0x221d - 0x221e
int32_t function_221d(void) {
    // 0x221d
    return g4;
}

// Address range: 0x2235 - 0x2242
int32_t function_2235(void) {
    // 0x2235
    if (g4 != 0) {
        // bb
        g4 = function_20aa();
        // branch -> 0x223d
    }
    // 0x223d
    return function_210d();
}

// Address range: 0x2242 - 0x2249
int32_t function_2242(void) {
    // 0x2242
    g4 = &g17;
    return function_221d();
}

// Address range: 0x2249 - 0x224a
int32_t function_2249(void) {
    // 0x2249
    return g4;
}

// Address range: 0x225a - 0x2271
int32_t function_225a(void) {
    // 0x225a
    int32_t v1;
    _ZNSt6vectorIh16secure_allocatorIhEED1Ev((int32_t *)v1);
    return _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev((int32_t *)g5);
}

// Address range: 0x2276 - 0x227f
int32_t function_2276(void) {
    // 0x2276
    g6 = _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEclES3__part_617();
    return function_225a();
}

// Address range: 0x227f - 0x2283
int32_t function_227f(void) {
    // 0x227f
    return 0;
}

// From module:   /parallelcoin/src/keystore.cpp
// Address range: 0x2290 - 0x232c
// Line range:    65 - 412
// Demangled:     CCryptoKeyStore::Lock()
void _ZN15CCryptoKeyStore4LockEv(int32_t this) {
    // 0x2290
    g6 = this;
    _ZN15CCryptoKeyStore10SetCryptedEv(this);
    int32_t * v1;
    if ((char)&v1 == 0) {
        // 0x22c8
        int32_t v2; // bp-24
        g10 = &v2;
        _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(&v2, g6 + 4, (int32_t)"cs_KeyStore", (int32_t)"keystore.cpp", 71, 0);
        int32_t v3 = g6; // 0x22fb
        int32_t v4 = *(int32_t *)(v3 + 160); // 0x22fb
        *(int32_t *)(v3 + (int32_t)&g30) = v4;
        _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(&v2);
        int32_t v5 = *(int32_t *)(g6 + (int32_t)&g33); // 0x230f
        int32_t v6 = v5; // 0x231d
        if (v5 == 0) {
            // bb
            v6 = function_2331();
            // branch -> 0x2319
        }
        // 0x2319
        _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEEclES4_(v6, g6);
        // branch -> 0x22b3
    }
    // 0x22b3
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x232c
        return;
    }
}

// Address range: 0x2331 - 0x2336
int32_t function_2331(void) {
    // 0x2331
    return _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEclES3__part_617();
}

// Address range: 0x2340 - 0x236a
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1) {
    // 0x2340
    *a1 = (int32_t)&g50;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x236a
    }
    // 0x2366
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x2590 - 0x25b5
// From class:    N5boost10lock_errorE
// Type:          virtual member function
// Demangled:     boost::lock_error::what() const
int32_t _ZNK5boost10lock_error4whatEv(void) {
    // 0x2590
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x25b5
    }
    // 0x25b1
    return (int32_t)"boost::lock_error";
}

// Address range: 0x25c0 - 0x25ea
// Demangled:     boost::detail::sp_counted_base::~sp_counted_base()
int32_t _ZN5boost6detail15sp_counted_baseD1Ev(int32_t * a1) {
    // 0x25c0
    *a1 = (int32_t)&g62;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x25ea
    }
    // 0x25e6
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x25f0 - 0x2640
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_base::destroy()
int32_t _ZN5boost6detail15sp_counted_base7destroyEv(int32_t * a1) {
    // 0x25f0
    if (a1 != NULL) {
        // 0x2608
        if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
            // 0x2615
            return *(int32_t *)(*a1 + 4);
        }
        // 0x2639
        return (int32_t)a1;
    }
    // 0x2628
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
        // 0x2635
        return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    }
    int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x2639
    // 0x2639
    return result;
}

// Address range: 0x2650 - 0x267a
// From class:    N5boost8signals211signal_baseE
// Type:          constructor
// Demangled:     boost::signals2::signal_base::~signal_base()
int32_t _ZN5boost8signals211signal_baseD1Ev(int32_t * a1) {
    // 0x2650
    *a1 = (int32_t)&g55;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x267a
    }
    // 0x2676
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x2680 - 0x26aa
// Demangled:     boost::system::error_category::~error_category()
int32_t _ZN5boost6system14error_categoryD1Ev(int32_t * a1) {
    // 0x2680
    *a1 = (int32_t)&g40;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x26aa
    }
    // 0x26a6
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x26b0 - 0x26e4
// Demangled:     boost::system::error_category::default_error_condition(int) const
int32_t _ZNK5boost6system14error_category23default_error_conditionEi(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t result = (int32_t)a1;
    *a1 = a3;
    *(int32_t *)(result + 4) = a2;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x26e4
        return result;
    }
    // 0x26de
    return result;
}

// Address range: 0x26f0 - 0x274f
// Demangled:     boost::system::error_category::equivalent(int, boost::system::error_condition const &) const
int32_t _ZNK5boost6system14error_category10equivalentEiRKNS0_15error_conditionE(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t result = 0; // 0x274d
    int32_t v1;
    if (*(int32_t *)(a3 + 4) == v1) {
        // 0x2748
        int32_t v2;
        result = *(int32_t *)a3 == v2;
        // branch -> 0x2734
    }
    // 0x2734
    int32_t v3;
    if (v3 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x274f
    }
    // 0x2741
    return result;
}

// Address range: 0x2760 - 0x279f
// Demangled:     boost::system::error_category::equivalent(boost::system::error_code const &, int) const
int32_t _ZNK5boost6system14error_category10equivalentERKNS0_10error_codeEi(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t result = 0; // 0x279d
    if (*(int32_t *)((int32_t)a2 + 4) == a1) {
        // 0x2798
        result = *a2 == a3;
        // branch -> 0x2781
    }
    // 0x2781
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x279f
        return result;
    }
    // 0x278e
    return result;
}

// Address range: 0x27b0 - 0x27da
// From class:    N5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEEE
// Type:          virtual member function
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEED1Ev(int32_t * a1) {
    // 0x27b0
    *a1 = (int32_t)&g62;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x27da
    }
    // 0x27d6
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x27e0 - 0x280a
// From class:    N5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEEE
// Type:          virtual member function
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEED1Ev(int32_t * a1) {
    // 0x27e0
    *a1 = (int32_t)&g62;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x280a
    }
    // 0x2806
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x2810 - 0x283a
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::~sp_counted_impl_p()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED1Ev(int32_t * a1) {
    // 0x2810
    *a1 = (int32_t)&g62;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x283a
    }
    // 0x2836
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x2840 - 0x2865
// From class:    N5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEEE
// Type:          virtual member function
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEE11get_deleterERKSt9type_info(void) {
    // 0x2840
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x2860
    }
    // 0x285c
    return 0;
}

// Address range: 0x2870 - 0x2895
// From class:    N5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEEE
// Type:          virtual member function
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEE11get_deleterERKSt9type_info(void) {
    // 0x2870
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x2890
    }
    // 0x288c
    return 0;
}

// Address range: 0x28a0 - 0x28f5
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::dispose()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE7disposeEv(int32_t a1) {
    int32_t result = *(int32_t *)(a1 + (int32_t)&g37); // 0x28b3
    if (result != 0) {
        // 0x28ba
        if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
            // 0x28c7
            return *(int32_t *)(*(int32_t *)result + 4);
        }
        // 0x28e9
        return result;
    }
    // 0x28d8
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
        // 0x28e5
        return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    }
    int32_t result2 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x28f0
    // 0x28e9
    return result2;
}

// Address range: 0x2900 - 0x2925
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::get_deleter(std::type_info const &)
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE11get_deleterERKSt9type_info(void) {
    // 0x2900
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x2920
    }
    // 0x291c
    return 0;
}

// Address range: 0x2930 - 0x2975
// From class:    N5boost8signals26signalIFvP15CCryptoKeyStoreENS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIS4_EENS9_IFvRKNS0_10connectionES3_EEENS0_5mutexEEE
// Type:          virtual member function
int32_t _ZNK5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEE10lock_pimplEv(int32_t * a1, int32_t a2) {
    int32_t result = (int32_t)a1; // eax
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x294b
    *a1 = *(int32_t *)(a2 + 4);
    *(int32_t *)(result + 4) = v1;
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)(v1 + 4); // 0x2957
        *v2 = *v2 + 1;
        // branch -> 0x295b
    }
    // 0x295b
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x296e
        return result;
    }
    // 0x2968
    return result;
}

// Address range: 0x2980 - 0x29ae
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::~sp_counted_impl_p()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED0Ev(int32_t * a1) {
    // 0x2980
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g62;
    int32_t result; // 0x29ab
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_29b3((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x29a7
    } else {
        // 0x2980
        result = g4;
        // branch -> 0x29a7
    }
    // 0x29a7
    return result;
}

// Address range: 0x29b3 - 0x29b8
int32_t function_29b3(int32_t a1) {
    // 0x29b3
    return g4;
}

// Address range: 0x29c0 - 0x29ee
// From class:    N5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEEE
// Type:          virtual member function
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEED0Ev(int32_t * a1) {
    // 0x29c0
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g62;
    int32_t result; // 0x29eb
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_29f3((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x29e7
    } else {
        // 0x29c0
        result = g4;
        // branch -> 0x29e7
    }
    // 0x29e7
    return result;
}

// Address range: 0x29f3 - 0x29f4
int32_t function_29f3(int32_t a1) {
    // 0x29f3
    return g4;
}

// Address range: 0x2a00 - 0x2a2e
// From class:    N5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEEE
// Type:          virtual member function
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEED0Ev(int32_t * a1) {
    // 0x2a00
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g62;
    int32_t result; // 0x2a2b
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_2a33((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x2a27
    } else {
        // 0x2a00
        result = g4;
        // branch -> 0x2a27
    }
    // 0x2a27
    return result;
}

// Address range: 0x2a33 - 0x2a34
int32_t function_2a33(int32_t a1) {
    // 0x2a33
    return g4;
}

// Address range: 0x2a40 - 0x2a6e
// Demangled:     boost::detail::sp_counted_base::~sp_counted_base()
int32_t _ZN5boost6detail15sp_counted_baseD0Ev(int32_t * a1) {
    // 0x2a40
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g62;
    int32_t result; // 0x2a6b
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_2a73((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x2a67
    } else {
        // 0x2a40
        result = g4;
        // branch -> 0x2a67
    }
    // 0x2a67
    return result;
}

// Address range: 0x2a73 - 0x2a74
int32_t function_2a73(int32_t a1) {
    // 0x2a73
    return g4;
}

// Address range: 0x2a80 - 0x2aae
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1) {
    // 0x2a80
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g50;
    int32_t result; // 0x2aab
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_2ab3((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x2aa7
    } else {
        // 0x2a80
        result = g4;
        // branch -> 0x2aa7
    }
    // 0x2aa7
    return result;
}

// Address range: 0x2ab3 - 0x2ab4
int32_t function_2ab3(int32_t a1) {
    // 0x2ab3
    return g4;
}

// Address range: 0x2ac0 - 0x2aee
// Demangled:     boost::system::error_category::~error_category()
int32_t _ZN5boost6system14error_categoryD0Ev(int32_t * a1) {
    // 0x2ac0
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g40;
    int32_t result; // 0x2aeb
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_2af3((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x2ae7
    } else {
        // 0x2ac0
        result = g4;
        // branch -> 0x2ae7
    }
    // 0x2ae7
    return result;
}

// Address range: 0x2af3 - 0x2af4
int32_t function_2af3(int32_t a1) {
    // 0x2af3
    return g4;
}

// Address range: 0x2b00 - 0x2b2e
// From class:    N5boost8signals211signal_baseE
// Type:          constructor
// Demangled:     boost::signals2::signal_base::~signal_base()
int32_t _ZN5boost8signals211signal_baseD0Ev(int32_t * a1) {
    // 0x2b00
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g55;
    int32_t result; // 0x2b2b
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_2b33((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x2b27
    } else {
        // 0x2b00
        result = g4;
        // branch -> 0x2b27
    }
    // 0x2b27
    return result;
}

// Address range: 0x2b33 - 0x2b34
int32_t function_2b33(int32_t a1) {
    // 0x2b33
    return g4;
}

// Address range: 0x2b40 - 0x2b89
int32_t _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EE10deallocateEPSA_j(int32_t result, uint32_t a2) {
    // 0x2b40
    g4 = result;
    if (a2 >= 11) {
        if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
            // bb110
            result = function_2b8e((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
            // branch -> 0x2b82
        }
        // 0x2b82
        return result;
    }
    // 0x2b5b
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    int32_t result2 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x2b6b
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result2 = function_2b8e((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x2b68
    }
    // 0x2b68
    return result2;
}

// Address range: 0x2b8e - 0x2b8f
int32_t function_2b8e(int32_t a1) {
    // 0x2b8e
    return g4;
}

// Address range: 0x2ba0 - 0x2bce
// From class:    N5boost17bad_function_callE
// Type:          constructor
// Demangled:     boost::bad_function_call::~bad_function_call()
int32_t _ZN5boost17bad_function_callD1Ev(int32_t * a1) {
    // 0x2ba0
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g56;
    int32_t result; // 0x2bcb
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_2bd3((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x2bc7
    } else {
        // 0x2ba0
        result = g4;
        // branch -> 0x2bc7
    }
    // 0x2bc7
    return result;
}

// Address range: 0x2bd3 - 0x2bd4
int32_t function_2bd3(int32_t a1) {
    // 0x2bd3
    return g4;
}

// Address range: 0x2be0 - 0x2c0e
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_exception::~thread_exception()
int32_t _ZN5boost16thread_exceptionD1Ev(int32_t * a1) {
    // 0x2be0
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g45;
    int32_t result; // 0x2c0b
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_2c13((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x2c07
    } else {
        // 0x2be0
        result = g4;
        // branch -> 0x2c07
    }
    // 0x2c07
    return result;
}

// Address range: 0x2c13 - 0x2c14
int32_t function_2c13(int32_t a1) {
    // 0x2c13
    return g4;
}

// Address range: 0x2c20 - 0x2c27
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1) {
    // 0x2c20
    return _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(a1 - 24);
}

// Address range: 0x2c30 - 0x2c4c
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1) {
    // 0x2c30
    return 0;
}

// Address range: 0x2c52 - 0x2c53
int32_t function_2c52(void) {
    // 0x2c52
    return 0;
}

// Address range: 0x353e - 0x356c
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockC2EP15pthread_mutex_t_part_22(void) {
    // 0x353e
    return 0;
}

// Address range: 0x3572 - 0x35a5
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockD2Ev_part_23(void) {
    // 0x3572
    return 0;
}

// Address range: 0x35a6 - 0x35d4
int32_t _ZN9CKeyStoreD2Ev_part_39(void) {
    // 0x35a6
    return 0;
}

// Address range: 0x35da - 0x3608
int32_t _ZN5boost11unique_lockINS_5mutexEED2Ev_part_94(void) {
    // 0x35da
    return 0;
}

// Address range: 0x360e - 0x363c
int32_t _ZNK5boost10shared_ptrINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS1_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS5_EEENSA_IFvRKNS1_10connectionES5_EEENS1_5mutexEE16invocation_stateEEptEv_isra_198_part_199(void) {
    // 0x360e
    return 0;
}

// Address range: 0x3642 - 0x3675
int32_t _ZNK5boost10shared_ptrINS_8signals26detail15connection_bodyISt4pairINS2_15slot_meta_groupENS_8optionalIiEEENS1_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSB_EEEEENS1_5mutexEEEEptEv_isra_236_part_237(void) {
    // 0x3642
    return 0;
}

// Address range: 0x3676 - 0x36a4
int32_t _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE16invocation_state17connection_bodiesEv_part_270(void) {
    // 0x3676
    return 0;
}

// Address range: 0x36aa - 0x36d8
int32_t _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEED2Ev_part_362(void) {
    // 0x36aa
    return 0;
}

// Address range: 0x36de - 0x370c
int32_t _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EED2Ev_part_514(void) {
    // 0x36de
    return 0;
}

// Address range: 0x3712 - 0x3745
int32_t _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EE19unchecked_push_backERKSA__part_543(void) {
    // 0x3712
    return 0;
}

// Address range: 0x3746 - 0x3774
int32_t _ZNK5boost8signals26detail14group_key_lessIiSt4lessIiEEclERKSt4pairINS1_15slot_meta_groupENS_8optionalIiEEESC__isra_570_part_571(void) {
    // 0x3746
    return 0;
}

// Address range: 0x377a - 0x37a8
int32_t _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEclES3__part_617(void) {
    // 0x377a
    return 0;
}

// Address range: 0x37b0 - 0x3805
// Demangled:     CKeyStore::~CKeyStore()
int32_t _ZN9CKeyStoreD1Ev(int32_t * a1) {
    // 0x37b0
    *a1 = (int32_t)&g42;
    int32_t v1 = (int32_t)a1 + 4; // 0x37ca
    g4 = v1;
    int32_t result; // 0x3800
    if (v1 != 0) {
        // 0x37fa
        result = function_6d56(v1);
        // branch -> 0x3805
        // 0x3805
        return result;
    }
    // 0x37e8
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
        // 0x37f5
        return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    }
    result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    // 0x3805
    return result;
}

// Address range: 0x380a - 0x3829
int32_t function_380a(int32_t a1) {
    // 0x380a
    return g4;
}

// Address range: 0x3830 - 0x384d
// From class:    N5boost17bad_function_callE
// Type:          constructor
// Demangled:     boost::bad_function_call::~bad_function_call()
int32_t _ZN5boost17bad_function_callD0Ev(int32_t * a1) {
    // 0x3830
    *a1 = (int32_t)&g56;
    return 0;
}

// Address range: 0x3851 - 0x386c
int32_t function_3851(int32_t a1) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x3851
    *v1 = *v1 - 1;
    int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x3857
    if (result == 0) {
        // 0x385f
        // branch -> 0x386c
    }
    // 0x386c
    return result;
}

// Address range: 0x3880 - 0x38ae
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::lock_error::~lock_error()
int32_t _ZN5boost10lock_errorD1Ev(int32_t * a1) {
    // 0x3880
    g4 = (int32_t)a1;
    *a1 = (int32_t)&g45;
    int32_t result; // 0x38ab
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_38b3((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x38a7
    } else {
        // 0x3880
        result = g4;
        // branch -> 0x38a7
    }
    // 0x38a7
    return result;
}

// Address range: 0x38b3 - 0x38b4
int32_t function_38b3(int32_t a1) {
    // 0x38b3
    return g4;
}

// Address range: 0x38c0 - 0x38dd
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_exception::~thread_exception()
int32_t _ZN5boost16thread_exceptionD0Ev(int32_t * a1) {
    // 0x38c0
    *a1 = (int32_t)&g45;
    return 0;
}

// Address range: 0x38e1 - 0x38fc
int32_t function_38e1(int32_t a1) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x38e1
    *v1 = *v1 - 1;
    int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x38e7
    if (result == 0) {
        // 0x38ef
        // branch -> 0x38fc
    }
    // 0x38fc
    return result;
}

// Address range: 0x3910 - 0x392d
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::lock_error::~lock_error()
int32_t _ZN5boost10lock_errorD0Ev(int32_t * a1) {
    // 0x3910
    *a1 = (int32_t)&g45;
    return 0;
}

// Address range: 0x3960 - 0x3967
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1) {
    // 0x3960
    return _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(a1 - 24);
}

// Address range: 0x3970 - 0x398c
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::clone() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1) {
    // 0x3970
    return 0;
}

// Address range: 0x3990 - 0x39e7
int32_t function_3990(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)-0x2fff383d; // 0x3990
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x3997
    *(char *)v2 = (char)v2 + *(char *)&g4;
    int32_t v3 = 0; // esi
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x3999
    int32_t v5 = 0; // ebx
    *(int32_t *)(v5 + 4) = v4;
    if (v4 != 0) {
        // 0x39a3
        // branch -> 0x39ab
    }
    // 0x39ab
    *(int32_t *)v5 = (int32_t)&g67;
    *(int32_t *)(v5 + 8) = *(int32_t *)(v3 + 8);
    int32_t v6 = *(int32_t *)(v3 + (int32_t)&g37); // 0x39c2
    *(int32_t *)(v5 + (int32_t)&g37) = v6;
    int32_t v7 = *(int32_t *)(v3 + (int32_t)&g13); // 0x39c8
    *(int32_t *)(v5 + (int32_t)&g14) = (int32_t)&g68;
    *(int32_t *)(v5 + 24) = (int32_t)&g69;
    *(int32_t *)(v5 + (int32_t)&g13) = v7;
    int32_t result = v5 + 24; // 0x39dc
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x39e7
        return result;
    }
    // 0x39e1
    return result;
}

// Address range: 0x3a00 - 0x3a07
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(a1 - (int32_t)&g15); // 0x3a05
    return result;
}

// Address range: 0x3a10 - 0x3a2c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::clone() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1) {
    // 0x3a10
    return 0;
}

// Address range: 0x3a30 - 0x3a94
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_3a30(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x4468bc3; // 0x3a30
    *v1 = *v1 - 1;
    int32_t v2 = 0; // ebx
    *(int32_t *)v2 = (int32_t)&g46;
    *(int32_t *)(v2 + 8) = (int32_t)&g47;
    *(int32_t *)(v2 + 4) = 0;
    int32_t v3 = 0; // esi
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g37); // 0x3a46
    *(int32_t *)(v2 + (int32_t)&g37) = v4;
    if (v4 != 0) {
        // 0x3a50
        // branch -> 0x3a58
    }
    int32_t v5 = *(int32_t *)(v3 + (int32_t)&g13); // 0x3a58
    *(int32_t *)(v2 + 8) = (int32_t)&g52;
    *(int32_t *)(v2 + (int32_t)&g13) = v5;
    int32_t v6 = *(int32_t *)(v3 + (int32_t)&g14); // 0x3a70
    *(int32_t *)(v2 + (int32_t)&g14) = v6;
    *(int32_t *)v2 = (int32_t)&g51;
    *(int32_t *)(v2 + (int32_t)&g15) = (int32_t)&g53;
    *(int32_t *)(v2 + 24) = *(int32_t *)(v3 + 24);
    int32_t result = v2 + (int32_t)&g15; // 0x3a89
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x3a94
        return result;
    }
    // 0x3a8e
    return result;
}

// Address range: 0x3ac0 - 0x3ae0
// Demangled:     CKeyStore::~CKeyStore()
int32_t _ZN9CKeyStoreD0Ev(int32_t * a1) {
    // 0x3ac0
    *a1 = (int32_t)&g42;
    return (int32_t)a1 + 4;
}

// Address range: 0x3b40 - 0x3b47
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE5cloneEv2(a1 - (int32_t)&g15); // 0x3b45
    return result;
}

// Address range: 0x3b50 - 0x3b6c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEEE
// Type:          virtual member function
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE5cloneEv2(int32_t a1) {
    // 0x3b50
    return 0;
}

// Address range: 0x3b8a - 0x3be6
int32_t function_3b8a(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x3c70c46); // 0x3b8a
    *v2 = *v2 - 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + *(char *)&g4;
    *(int32_t *)(v1 + 8) = (int32_t)&g47;
    *(int32_t *)(v1 + (int32_t)&g37) = v3;
    if (v3 != 0) {
        // 0x3ba2
        // branch -> 0x3baa
    }
    int32_t v4 = 0; // esi
    int32_t v5 = *(int32_t *)(v4 + (int32_t)&g13); // 0x3baa
    *(int32_t *)(v1 + 8) = (int32_t)&g60;
    *(int32_t *)(v1 + (int32_t)&g13) = v5;
    int32_t v6 = *(int32_t *)(v4 + (int32_t)&g14); // 0x3bc2
    *(int32_t *)(v1 + (int32_t)&g14) = v6;
    *(int32_t *)v1 = (int32_t)&g59;
    *(int32_t *)(v1 + (int32_t)&g15) = (int32_t)&g61;
    *(int32_t *)(v1 + 24) = *(int32_t *)(v4 + 24);
    int32_t result = v1 + (int32_t)&g15; // 0x3bdb
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x3be6
        return result;
    }
    // 0x3be0
    return result;
}

// Address range: 0x3bef - 0x3bf3
int32_t function_3bef(void) {
    // 0x3bef
    g4 = 0;
    return function_3c1d();
}

// Address range: 0x3bf5 - 0x3bf6
int32_t function_3bf5(void) {
    // 0x3bf5
    return g4;
}

// Address range: 0x3c0f - 0x3c11
int32_t function_3c0f(void) {
    // 0x3c0f
    return function_3bf5();
}

// Address range: 0x3c1d - 0x3c1e
int32_t function_3c1d(void) {
    // 0x3c1d
    return g4;
}

// Address range: 0x3c20 - 0x3c47
// From class:    N5boost6system12system_errorE
// Type:          constructor
// Demangled:     boost::system::system_error::~system_error()
int32_t _ZN5boost6system12system_errorD1Ev(int32_t * a1) {
    // 0x3c20
    *a1 = (int32_t)&g41;
    return *(int32_t *)((int32_t)a1 + (int32_t)&g13);
}

// Address range: 0x3c56 - 0x3c70
int32_t function_3c56(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x3c56
    *v1 = *v1 - 1;
    int32_t v2 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x3c5c
    g4 = v2;
    int32_t result = v2; // 0x3c6f
    if (v2 != 0) {
        // bb
        result = function_3c97();
        // branch -> 0x3c64
    }
    // 0x3c64
    return result;
}

// Address range: 0x3c70 - 0x3c71
int32_t function_3c70(void) {
    // 0x3c70
    return 0;
}

// Address range: 0x3c95 - 0x3c97
int32_t function_3c95(void) {
    // 0x3c95
    return 0;
}

// Address range: 0x3c97 - 0x3c98
int32_t function_3c97(void) {
    // 0x3c97
    return g4;
}

// Address range: 0x3c9c - 0x3ca7
int32_t function_3c9c(void) {
    int32_t result = 0; // eax
    int32_t * v1 = (int32_t *)(result - 4); // 0x3c9c
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x3cb0 - 0x3cd7
// From class:    N5boost6system12system_errorE
// Type:          constructor
// Demangled:     boost::system::system_error::~system_error()
int32_t _ZN5boost6system12system_errorD0Ev(int32_t * a1) {
    // 0x3cb0
    *a1 = (int32_t)&g41;
    return *(int32_t *)((int32_t)a1 + (int32_t)&g13);
}

// Address range: 0x3cee - 0x3d08
int32_t function_3cee(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x3cee
    *v1 = *v1 - 1;
    int32_t v2 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x3cf4
    g4 = v2;
    int32_t result = v2; // 0x3d07
    if (v2 != 0) {
        // bb
        result = function_3d2f();
        // branch -> 0x3cfc
    }
    // 0x3cfc
    return result;
}

// Address range: 0x3d08 - 0x3d09
int32_t function_3d08(void) {
    // 0x3d08
    return 0;
}

// Address range: 0x3d2d - 0x3d2f
int32_t function_3d2d(void) {
    // 0x3d2d
    return 0;
}

// Address range: 0x3d2f - 0x3d30
int32_t function_3d2f(void) {
    // 0x3d2f
    return g4;
}

// Address range: 0x3d34 - 0x3d3f
int32_t function_3d34(void) {
    int32_t result = 0; // eax
    int32_t * v1 = (int32_t *)(result - 4); // 0x3d34
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x3d40 - 0x3d96
// From class:    N5boost6system12system_errorE
// Type:          virtual member function
// Demangled:     boost::system::system_error::what() const
int32_t _ZNK5boost6system12system_error4whatEv(int32_t a1) {
    int32_t result = *(int32_t *)(a1 + (int32_t)&g13); // 0x3d5f
    if (*(int32_t *)(result - 12) == 0) {
        // 0x3d90
        return 0;
    }
    // 0x3d69
    g4 = result;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_3e1a((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0, 0);
        // branch -> 0x3d7c
    }
    // 0x3d7c
    return result;
}

// Address range: 0x3dbf - 0x3dc0
int32_t function_3dbf(void) {
    // 0x3dbf
    return g4;
}

// Address range: 0x3e18 - 0x3e1a
int32_t function_3e18(void) {
    // 0x3e18
    return function_3dbf();
}

// Address range: 0x3e1a - 0x3e1b
int32_t function_3e1a(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x3e1a
    return g4;
}

// Address range: 0x3e1f - 0x3e20
int32_t function_3e1f(void) {
    // 0x3e1f
    return 0;
}

// Address range: 0x3e44 - 0x3e46
int32_t function_3e44(void) {
    // 0x3e44
    return 0;
}

// Address range: 0x3e47 - 0x3e48
int32_t function_3e47(void) {
    // 0x3e47
    return 0;
}

// Address range: 0x3e52 - 0x3e53
int32_t function_3e52(void) {
    // 0x3e52
    return g4;
}

// Address range: 0x3e63 - 0x3e64
int32_t function_3e63(void) {
    // 0x3e63
    return 0;
}

// Address range: 0x3e69 - 0x3e6e
int32_t function_3e69(void) {
    // 0x3e69
    return 0;
}

// Address range: 0x3e70 - 0x3e72
int32_t function_3e70(void) {
    // 0x3e70
    return function_3e52();
}

// Address range: 0x3e72 - 0x3e7d
int32_t function_3e72(void) {
    int32_t result = 0; // eax
    int32_t * v1 = (int32_t *)(result - 4); // 0x3e72
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x3e7e - 0x3e81
int32_t function_3e7e(void) {
    // 0x3e7e
    return 0;
}

// Address range: 0x3e90 - 0x3ee1
// Demangled:     boost::exception::~exception()
int32_t _ZN5boost9exceptionD1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x3ea4
    *a1 = (int32_t)&g47;
    if (v2 != 0) {
        // 0x3eb1
        if ((char)v2 != 0) {
            // 0x3ed8
            *(int32_t *)(v1 + 4) = 0;
            // branch -> 0x3ebd
        }
    }
    // 0x3ebd
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x3ee1
        return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    }
    // 0x3eca
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x3ee7 - 0x3eea
int32_t function_3ee7(void) {
    // 0x3ee7
    return 0;
}

// Address range: 0x3f00 - 0x3f0a
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t a1) {
    // 0x3f00
    return function_7e10(a1 - 8);
}

// Address range: 0x3f10 - 0x3f57
// From class:    N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g48;
    int32_t v2 = v1 + 8; // 0x3f2a
    g4 = v2;
    *(int32_t *)v2 = (int32_t)&g49;
    function_7da0(g4);
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    *(int32_t *)v1 = (int32_t)&g45;
    int32_t result; // 0x3f56
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_3f5c();
        // branch -> 0x3f4f
    } else {
        // 0x3f10
        result = g4;
        // branch -> 0x3f4f
    }
    // 0x3f4f
    return result;
}

// Address range: 0x3f5c - 0x3f5d
int32_t function_3f5c(void) {
    // 0x3f5c
    return g4;
}

// Address range: 0x3f70 - 0x3f7a
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D1Ev(int32_t a1) {
    // 0x3f70
    return function_7ef0(a1 - (int32_t)&g14);
}

// Address range: 0x3f80 - 0x3fa7
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::bad_alloc_::~bad_alloc_()
int32_t _ZN5boost16exception_detail10bad_alloc_D1Ev(int32_t * a1) {
    // 0x3f80
    *a1 = (int32_t)&g65;
    int32_t result = (int32_t)a1 + (int32_t)&g14; // 0x3f9a
    *(int32_t *)result = (int32_t)&g66;
    return result;
}

// Address range: 0x3fab - 0x3fc6
int32_t function_3fab(int32_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x651c2444); // 0x3fab
    *v2 = *v2 - 1;
    int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x3fb1
    g4 = result;
    if (result != 0) {
        // 0x3fc6
        return result;
    }
    // 0x3fb9
    return function_7e10(v1);
}

// Address range: 0x3fd0 - 0x3fda
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_17bad_function_callEED1Ev(int32_t a1) {
    // 0x3fd0
    return function_7fb0(a1 - 8);
}

// Address range: 0x3fe0 - 0x4027
// From class:    N5boost16exception_detail19error_info_injectorINS_17bad_function_callEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::bad_function_call>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_17bad_function_callEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g57;
    int32_t v2 = v1 + 8; // 0x3ffa
    g4 = v2;
    *(int32_t *)v2 = (int32_t)&g58;
    function_7e70(g4);
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    *(int32_t *)v1 = (int32_t)&g56;
    int32_t result; // 0x4026
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_402c();
        // branch -> 0x401f
    } else {
        // 0x3fe0
        result = g4;
        // branch -> 0x401f
    }
    // 0x401f
    return result;
}

// Address range: 0x402c - 0x402d
int32_t function_402c(void) {
    // 0x402c
    return g4;
}

// Address range: 0x4040 - 0x4047
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1) {
    // 0x4040
    return _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev((int32_t *)(a1 - 24));
}

// Address range: 0x4050 - 0x4057
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev((int32_t *)(a1 - (int32_t)&g14)); // 0x4055
    return result;
}

// Address range: 0x4060 - 0x408e
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + 24) = (int32_t)&g50;
    *(int32_t *)v1 = (int32_t)&g65;
    *(int32_t *)(v1 + (int32_t)&g14) = (int32_t)&g66;
    return v1 + (int32_t)&g14;
}

// Address range: 0x4092 - 0x40b5
int32_t function_4092(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)0x35e8241c; // 0x4092
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x4098
    *(char *)v2 = (char)v2 + *(char *)&g4;
    int32_t result = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x409f
    if (result == 0) {
        // 0x40a8
        // branch -> 0x40b5
    }
    // 0x40b5
    return result;
}

// Address range: 0x40c0 - 0x40c7
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10bad_alloc_D0Ev((int32_t *)(a1 - (int32_t)&g14)); // 0x40c5
    return result;
}

// Address range: 0x40d0 - 0x40f7
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::bad_alloc_::~bad_alloc_()
int32_t _ZN5boost16exception_detail10bad_alloc_D0Ev(int32_t * a1) {
    // 0x40d0
    *a1 = (int32_t)&g65;
    int32_t result = (int32_t)a1 + (int32_t)&g14; // 0x40ea
    *(int32_t *)result = (int32_t)&g66;
    return result;
}

// Address range: 0x4130 - 0x413a
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1) {
    // 0x4130
    return function_8280(a1 - 24);
}

// Address range: 0x4140 - 0x414a
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1) {
    // 0x4140
    return function_8280(a1 - (int32_t)&g14);
}

// Address range: 0x4150 - 0x417e
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + 24) = (int32_t)&g50;
    *(int32_t *)v1 = (int32_t)&g65;
    *(int32_t *)(v1 + (int32_t)&g14) = (int32_t)&g66;
    return v1 + (int32_t)&g14;
}

// Address range: 0x4182 - 0x419d
int32_t function_4182(int32_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x651c2444); // 0x4182
    *v2 = *v2 - 1;
    int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x4188
    g4 = result;
    if (result != 0) {
        // 0x419d
        return result;
    }
    // 0x4190
    return function_7fe0(v1);
}

// Address range: 0x41b0 - 0x41b7
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED0Ev((int32_t *)(a1 - (int32_t)&g15)); // 0x41b5
    return result;
}

// Address range: 0x41c0 - 0x41c7
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED0Ev(int32_t a1) {
    // 0x41c0
    return _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED0Ev((int32_t *)(a1 - 8));
}

// Address range: 0x41d0 - 0x420c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_function_call> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g15) = (int32_t)&g50;
    g4 = v1 + 8;
    *(int32_t *)v1 = (int32_t)&g57;
    *(int32_t *)(v1 + 8) = (int32_t)&g58;
    int32_t result = function_8040(g4); // eax
    *(int32_t *)v1 = (int32_t)&g56;
    return result;
}

// Address range: 0x4230 - 0x423a
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED1Ev(int32_t a1) {
    // 0x4230
    return 0;
}

// Address range: 0x4240 - 0x424a
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED1Ev(int32_t a1) {
    // 0x4240
    return 0;
}

// Address range: 0x4250 - 0x429e
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_function_call> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g15) = (int32_t)&g50;
    g4 = v1 + 8;
    *(int32_t *)v1 = (int32_t)&g57;
    *(int32_t *)(v1 + 8) = (int32_t)&g58;
    function_80e0(g4);
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    *(int32_t *)v1 = (int32_t)&g56;
    int32_t result; // 0x429d
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_42a3();
        // branch -> 0x4296
    } else {
        // 0x4250
        result = g4;
        // branch -> 0x4296
    }
    // 0x4296
    return result;
}

// Address range: 0x42a3 - 0x42a4
int32_t function_42a3(void) {
    // 0x42a3
    return g4;
}

// Address range: 0x42b0 - 0x42b7
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_17bad_function_callEED0Ev(int32_t a1) {
    // 0x42b0
    return _ZN5boost16exception_detail19error_info_injectorINS_17bad_function_callEED0Ev((int32_t *)(a1 - 8));
}

// Address range: 0x42c0 - 0x42f5
// From class:    N5boost16exception_detail19error_info_injectorINS_17bad_function_callEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::bad_function_call>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_17bad_function_callEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g57;
    int32_t v2 = v1 + 8; // 0x42da
    g4 = v2;
    *(int32_t *)v2 = (int32_t)&g58;
    int32_t result = function_8140(g4); // eax
    *(int32_t *)v1 = (int32_t)&g56;
    return result;
}

// Address range: 0x4320 - 0x4327
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev((int32_t *)(a1 - (int32_t)&g15)); // 0x4325
    return result;
}

// Address range: 0x4330 - 0x4337
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1) {
    // 0x4330
    return _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev((int32_t *)(a1 - 8));
}

// Address range: 0x4340 - 0x437c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g15) = (int32_t)&g50;
    g4 = v1 + 8;
    *(int32_t *)v1 = (int32_t)&g48;
    *(int32_t *)(v1 + 8) = (int32_t)&g49;
    int32_t result = function_81b0(g4); // eax
    *(int32_t *)v1 = (int32_t)&g45;
    return result;
}

// Address range: 0x43a0 - 0x43aa
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1) {
    // 0x43a0
    return function_8760(a1 - (int32_t)&g15);
}

// Address range: 0x43b0 - 0x43ba
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1) {
    // 0x43b0
    return function_8760(a1 - 8);
}

// Address range: 0x43c0 - 0x440e
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g15) = (int32_t)&g50;
    g4 = v1 + 8;
    *(int32_t *)v1 = (int32_t)&g48;
    *(int32_t *)(v1 + 8) = (int32_t)&g49;
    function_8250(g4);
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    *(int32_t *)v1 = (int32_t)&g45;
    int32_t result; // 0x440d
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_4413();
        // branch -> 0x4406
    } else {
        // 0x43c0
        result = g4;
        // branch -> 0x4406
    }
    // 0x4406
    return result;
}

// Address range: 0x4413 - 0x4414
int32_t function_4413(void) {
    // 0x4413
    return g4;
}

// Address range: 0x4420 - 0x4427
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t a1) {
    // 0x4420
    return _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev((int32_t *)(a1 - 8));
}

// Address range: 0x4430 - 0x4465
// From class:    N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g48;
    int32_t v2 = v1 + 8; // 0x444a
    g4 = v2;
    *(int32_t *)v2 = (int32_t)&g49;
    int32_t result = function_82b0(g4); // eax
    *(int32_t *)v1 = (int32_t)&g45;
    return result;
}

// Address range: 0x4490 - 0x44c1
// Demangled:     boost::exception::~exception()
int32_t _ZN5boost9exceptionD0Ev(int32_t a1) {
    // 0x4490
    g4 = 0;
    function_8320(a1);
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x44c0
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_44c6();
        // branch -> 0x44b9
    }
    // 0x44b9
    return result;
}

// Address range: 0x44c6 - 0x44c7
int32_t function_44c6(void) {
    // 0x44c6
    return g4;
}

// Address range: 0x44d0 - 0x4555
// Demangled:     boost::detail::shared_count::~shared_count()
int32_t _ZN5boost6detail12shared_countD1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0x44eb
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)(v1 + 4); // 0x44f8
        int32_t v3 = *v2 - 1; // 0x44f8
        *v2 = v3;
        if (v3 == 0) {
            int32_t * v4 = (int32_t *)(v1 + 8); // 0x4528
            int32_t v5 = *v4; // 0x4528
            *v4 = v5 - 1;
            if (v5 == 1) {
                // 0x4532
                if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                    // 0x4555
                    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
                }
                // 0x453f
                return *(int32_t *)(*(int32_t *)v1 + (int32_t)&g37);
            }
            // 0x4502
            if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                // 0x4555
                return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
            }
            // 0x450f
            return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
        }
    }
    // 0x4502
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x4555
        return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    }
    // 0x450f
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x4560 - 0x4590
// Demangled:     boost::shared_ptr<boost::exception_detail::clone_base const>::~shared_ptr()
int32_t _ZN5boost10shared_ptrIKNS_16exception_detail10clone_baseEED1Ev(int32_t result) {
    // 0x4560
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x4590
        return result;
    }
    // 0x4581
    g4 = result + 4;
    return function_8a30((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
}

// Address range: 0x45a0 - 0x45e6
// From class:    N5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEEE
// Type:          virtual member function
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS2_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS2_10connectionES6_EEENS2_5mutexEE16invocation_stateEE7disposeEv(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g37); // 0x45b4
    if (v1 == 0) {
        // bb
        function_45f0((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x45bb
    }
    int32_t v2 = v1 + (int32_t)&g37; // 0x45bb
    g4 = v2;
    function_8a70(v2);
    int32_t v3 = v1 + 4; // 0x45c6
    g4 = v3;
    function_8a70(v3);
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x45e5
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb105
        result = function_4602();
        // branch -> 0x45de
    }
    // 0x45de
    return result;
}

// Address range: 0x45f0 - 0x4602
int32_t function_45f0(int32_t a1) {
    int32_t v1 = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x45f4
    g4 = v1;
    int32_t result = v1; // 0x4601
    if (v1 != 0) {
        // bb
        result = function_4602();
        // branch -> 0x45fd
    }
    // 0x45fd
    return result;
}

// Address range: 0x4602 - 0x4603
int32_t function_4602(void) {
    // 0x4602
    return g4;
}

// Address range: 0x4608 - 0x4609
int32_t function_4608(void) {
    // 0x4608
    return 0;
}

// Address range: 0x6d56 - 0x6d57
int32_t function_6d56(int32_t a1) {
    // 0x6d56
    return g4;
}

// Address range: 0x7da0 - 0x7da1
int32_t function_7da0(int32_t a1) {
    // 0x7da0
    return g4;
}

// Address range: 0x7e10 - 0x7e11
int32_t function_7e10(int32_t a1) {
    // 0x7e10
    return g4;
}

// Address range: 0x7e70 - 0x7e71
int32_t function_7e70(int32_t a1) {
    // 0x7e70
    return g4;
}

// Address range: 0x7ef0 - 0x7ef1
int32_t function_7ef0(int32_t a1) {
    // 0x7ef0
    return g4;
}

// Address range: 0x7fb0 - 0x7fb1
int32_t function_7fb0(int32_t a1) {
    // 0x7fb0
    return g4;
}

// Address range: 0x7fe0 - 0x7fe1
int32_t function_7fe0(int32_t a1) {
    // 0x7fe0
    return g4;
}

// Address range: 0x8040 - 0x8041
int32_t function_8040(int32_t a1) {
    // 0x8040
    return g4;
}

// Address range: 0x80e0 - 0x80e1
int32_t function_80e0(int32_t a1) {
    // 0x80e0
    return g4;
}

// Address range: 0x8140 - 0x8141
int32_t function_8140(int32_t a1) {
    // 0x8140
    return g4;
}

// Address range: 0x81b0 - 0x81b1
int32_t function_81b0(int32_t a1) {
    // 0x81b0
    return g4;
}

// Address range: 0x8250 - 0x8251
int32_t function_8250(int32_t a1) {
    // 0x8250
    return g4;
}

// Address range: 0x8280 - 0x8281
int32_t function_8280(int32_t a1) {
    // 0x8280
    return g4;
}

// Address range: 0x82b0 - 0x82b1
int32_t function_82b0(int32_t a1) {
    // 0x82b0
    return g4;
}

// Address range: 0x8320 - 0x8321
int32_t function_8320(int32_t a1) {
    // 0x8320
    return g4;
}

// Address range: 0x83b0 - 0x843f
int32_t _ZltRK7uint160S1_(int32_t * a1, int32_t a2) {
    // 0x83b0
    int32_t v1; // bp-60
    int32_t v2 = &v1; // 0x83b0
    int32_t v3 = 4; // 0x841d
    // branch -> 0x8411
    while (true) {
        int32_t v4 = 4 * v3; // 0x8411
        uint32_t v5 = *(int32_t *)(v2 + 24 + v4); // 0x8411
        uint32_t v6 = *(int32_t *)(v2 + 4 + v4); // 0x8415
        int32_t result = 1; // 0x843d
        if (v6 >= v5) {
            // 0x841b
            if (v6 == v5) {
                // 0x841d
                if (v3 == 0) {
                    // break -> 0x8425
                    break;
                }
                v3--;
                // continue -> 0x8411
                continue;
            }
            // 0x8425
            result = 0;
            // branch -> 0x8427
        }
        // 0x8427
        if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
            // 0x843f
        }
        // 0x8434
        return result;
    }
    // 0x8425
    // branch -> 0x8427
    // 0x8427
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x843f
    }
    // 0x8434
    return 0;
}

// Address range: 0x8450 - 0x8490
// Demangled:     boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr()
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1, int32_t a2) {
    int32_t v1 = *a1; // 0x8464
    if (v1 == 0) {
        // 0x8476
        return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    }
    // 0x846a
    if ((char)v1 != 0) {
        // 0x8488
        *a1 = 0;
        // branch -> 0x8476
    }
    // 0x8476
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x84a0 - 0x85a4
// Demangled:     boost::exception_detail::copy_boost_exception(boost::exception *, boost::exception const *)
int32_t _ZN5boost16exception_detail20copy_boost_exceptionEPNS_9exceptionEPKS1_(int32_t a1, int32_t a2) {
    // 0x84a0
    if (*(int32_t *)(a2 + 4) != 0) {
        // 0x84da
        int32_t v1;
        if (v1 != 0) {
            // 0x84f9
            // branch -> 0x8501
        }
        // 0x8501
        // branch -> 0x8529
    }
    int32_t v2 = 0; // edi
    int32_t v3 = *(int32_t *)(a2 + (int32_t)&g37); // 0x8529
    *(int32_t *)(a1 + (int32_t)&g37) = v3;
    int32_t v4 = *(int32_t *)(a2 + (int32_t)&g13); // 0x852f
    *(int32_t *)(a1 + (int32_t)&g13) = v4;
    *(int32_t *)(a1 + 8) = *(int32_t *)(a2 + 8);
    int32_t v5 = *(int32_t *)(a1 + 4); // 0x853b
    if (v5 != 0) {
        // 0x8542
        *(int32_t *)g11 = v5;
        // branch -> 0x854a
    }
    // 0x854a
    *(int32_t *)(a1 + 4) = v2;
    if (v2 != 0) {
        // 0x8551
        *(int32_t *)g11 = v2;
        // branch -> 0x8559
    }
    int32_t v6 = *(int32_t *)(g11 + (int32_t)&g14); // 0x8559
    if (v6 != 0) {
        // 0x8561
        *(int32_t *)g11 = v6;
        // branch -> 0x8569
    }
    int32_t v7 = *(int32_t *)(g11 + (int32_t)&g15); // 0x8569
    int32_t result = v7 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x856d
    if (result != 0) {
        // 0x85a4
        return result;
    }
    // 0x8576
    return result;
}

// Address range: 0x85aa - 0x85ab
int32_t function_85aa(void) {
    // 0x85aa
    return 0;
}

// Address range: 0x85b3 - 0x85b4
int32_t function_85b3(void) {
    // 0x85b3
    return g4;
}

// Address range: 0x85c7 - 0x85cb
int32_t function_85c7(void) {
    // 0x85c7
    return function_85b3();
}

// Address range: 0x85d0 - 0x8640
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::error_info_injector(boost::exception_detail::error_info_injector<boost::lock_error> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEEC1ERKS3_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1; // ebx
    *a1 = (int32_t)&g46;
    *(int32_t *)(v1 + 8) = (int32_t)&g47;
    *(int32_t *)(v1 + 4) = *(int32_t *)(a2 + 4);
    int32_t v2 = *(int32_t *)(a2 + (int32_t)&g37); // 0x85fc
    *(int32_t *)(v1 + (int32_t)&g37) = v2;
    if (v2 != 0) {
        // 0x8606
        // branch -> 0x860e
    }
    int32_t v3 = *(int32_t *)(a2 + (int32_t)&g13); // 0x860e
    *(int32_t *)(v1 + 8) = (int32_t)&g49;
    *(int32_t *)(v1 + (int32_t)&g13) = v3;
    int32_t v4 = *(int32_t *)(a2 + (int32_t)&g14); // 0x861b
    *(int32_t *)(v1 + (int32_t)&g14) = v4;
    *(int32_t *)v1 = (int32_t)&g48;
    *(int32_t *)(v1 + 24) = *(int32_t *)(a2 + 24);
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x8640
        return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    }
    // 0x863a
    return (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
}

// Address range: 0x8660 - 0x8667
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(a1 - (int32_t)&g15); // 0x8665
    return result;
}

// Address range: 0x8670 - 0x868c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1) {
    // 0x8670
    return 0;
}

// Address range: 0x8690 - 0x8697
int32_t function_8690(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb8c; // 0x8690
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x86e0 - 0x86fc
// Demangled:     void boost::throw_exception<boost::lock_error>(boost::lock_error const &)
int32_t _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(int32_t a1) {
    // 0x86e0
    return 0;
}

// Address range: 0x8720 - 0x872b
int32_t function_8720(void) {
    // 0x8720
    return unknown_89008819();
}

// Address range: 0x8760 - 0x878c
int32_t function_8760(int32_t a1) {
    unsigned char v1 = *(char *)&g4; // 0x8760
    int32_t v2 = g4; // 0x8760
    unsigned char v3 = (char)v2 + v1; // 0x8760
    g1 = v3 < v1;
    g78 = llvm_ctpop_i8(v3) % 2 == 0;
    *(char *)v2 = v3;
    g4 = unknown_10b80(g6 + 8, g4);
    return function_c5f0(g10);
}

// Address range: 0x8791 - 0x8792
int32_t function_8791(void) {
    // 0x8791
    return g4;
}

// Address range: 0x87b0 - 0x87ca
int32_t function_87b0(void) {
    // 0x87b0
    int32_t v1;
    g8 = v1 + 1;
    g6 = 1;
    int32_t v2 = 0; // eax
    unsigned char v3 = (char)v2 - (char)&g13 + (char)false; // 0x87b3
    int32_t v4 = (int32_t)v3 | v2 & -256; // 0x87b3
    g4 = v4;
    char * v5 = (char *)v4; // 0x87b5
    unsigned char v6 = *v5; // 0x87b5
    unsigned char v7 = v6 + v3; // 0x87b5
    g1 = v7 < v6;
    g78 = llvm_ctpop_i8(v7) % 2 == 0;
    *v5 = v7;
    function_c5f0(g6);
    return function_8791();
}

// Address range: 0x87d0 - 0x87fd
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::~vector()
int32_t _ZNSt6vectorIhSaIhEED1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0x87e3
    g4 = v1;
    int32_t result = v1; // 0x87fa2
    if (v1 == 0) {
        int32_t v2 = function_8808((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"); // 0x87e7
        g4 = v2;
        result = v2;
        // branch -> 0x87e9
    }
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb8
        result = function_8819();
        // branch -> 0x87f6
    }
    // 0x87f6
    return result;
}

// Address range: 0x8808 - 0x8819
int32_t function_8808(int32_t a1) {
    int32_t v1 = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x880c
    g4 = v1;
    int32_t result = v1; // 0x8818
    if (v1 != 0) {
        // bb
        result = function_8819();
        // branch -> 0x8815
    }
    // 0x8815
    return result;
}

// Address range: 0x8819 - 0x8820
int32_t function_8819(void) {
    // 0x8819
    return g4;
}

// Address range: 0x8830 - 0x8888
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::operator=(std::vector<unsigned char, std::allocator<unsigned char> > const &)
int32_t _ZNSt6vectorIhSaIhEEaSERKS1_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    g6 = v1;
    g8 = a2;
    int32_t v2 = v1; // 0x8860
    int32_t v3 = a2; // 0x885b
    if (v1 == a2) {
        // bb
        function_88a6((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        v2 = g6;
        v3 = g8;
        // branch -> 0x885b
    }
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x885b
    g9 = v4;
    int32_t v5 = *(int32_t *)v3; // 0x885e
    g5 = v5;
    int32_t v6 = *(int32_t *)v2; // 0x8860
    g4 = v6;
    int32_t v7 = v4 - v5; // 0x8867
    g10 = v7;
    int32_t result = v6; // 0x8879
    if (v7 <= *(int32_t *)(v2 + 8) - v6) {
        // bb17
        result = function_88d0();
        // branch -> 0x886f
    }
    // 0x886f
    g8 = result;
    if (v7 == 0) {
        // bb18
        result = function_888d(0);
        // branch -> 0x887d
    }
    // 0x887d
    return result;
}

// Address range: 0x888d - 0x8896
int32_t function_888d(int32_t a1) {
    int32_t v1 = g6; // 0x888d
    int32_t result = v1; // 0x8893
    if (v1 == 0) {
        // bb
        result = function_889b();
        // branch -> 0x8893
    }
    // 0x8893
    return result;
}

// Address range: 0x889b - 0x88a6
int32_t function_889b(void) {
    int32_t v1 = g8; // 0x889b
    int32_t result = g10 + v1; // eax
    *(int32_t *)g6 = v1;
    *(int32_t *)(g6 + 8) = result;
    *(int32_t *)(g6 + 4) = result;
    return result;
}

// Address range: 0x88a6 - 0x88cd
int32_t function_88a6(int32_t a1) {
    int32_t result = g6; // 0x88b1
    g4 = result;
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_8974();
        // branch -> 0x88b9
    }
    // 0x88b9
    return result;
}

// Address range: 0x88d0 - 0x88f0
int32_t function_88d0(void) {
    int32_t v1 = *(int32_t *)(g6 + 4); // 0x88d0
    int32_t result = g4; // 0x88d7
    uint32_t v2 = v1 - result; // 0x88d7
    if (g10 > v2) {
        // bb
        result = function_8900(v1, v2);
        // branch -> 0x88e1
    }
    // 0x88e1
    return result;
}

// Address range: 0x88f5 - 0x88fb
int32_t function_88f5(void) {
    // 0x88f5
    int32_t result;
    return result;
}

// Address range: 0x8900 - 0x8974
int32_t function_8900(int32_t a1, int32_t a2) {
    // 0x8900
    int32_t v1;
    int32_t * v2;
    if (a2 != 0) {
        int32_t v3 = g6; // 0x8958
        int32_t v4 = g8; // 0x895b
        g4 = v3;
        v2 = (int32_t *)(v4 + 4);
        v1 = v4 + *(int32_t *)(v3 + 4) - v3;
        // branch -> 0x8912
    } else {
        // 0x8900
        v2 = &g9;
        v1 = g5 + a2;
        // branch -> 0x8912
    }
    // 0x8912
    if (*v2 != v1) {
        // 0x8920
        return g10 + g6;
    }
    // 0x8918
    return g10 + g4;
}

// Address range: 0x8974 - 0x8975
int32_t function_8974(void) {
    // 0x8974
    return g4;
}

// Address range: 0x8980 - 0x89a9
// Demangled:     LockedPageManagerBase<MemoryPageLocker>::UnlockRange(void *, unsigned int)
int32_t _ZN21LockedPageManagerBaseI16MemoryPageLockerE11UnlockRangeEPvj(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8980
    return a1 + 4;
}

// Address range: 0x89ad - 0x8a21
int32_t function_89ad(void) {
    int32_t v1 = 0; // ebp
    int32_t * v2 = (int32_t *)(v1 - 0x217af040); // 0x89ad
    *v2 = *v2 + 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + *(char *)&g4;
    char * v4 = (char *)(v1 - 0x747bf00a); // 0x89b5
    *v4 = (char)v3 + *v4;
    *(char *)v3 = (char)v3 + *(char *)&g4;
    int32_t v5 = 0; // ebx
    char * v6 = (char *)(v5 - 0x1476dfb9); // 0x89bd
    *v6 = (char)0 + *v6;
    int32_t v7 = v3 & v5; // 0x89c7
    g6 = v7;
    int32_t v8 = v3 & v1 - 1; // 0x89c9
    g9 = v8;
    if (v7 > v8) {
        // bb
        function_8a49();
        // branch -> 0x89cf
    }
    int32_t v9 = g8; // 0x89cf
    int32_t v10 = v9 + 40; // 0x89cf
    int32_t v11 = *(int32_t *)(v9 + 44); // 0x89d8
    g4 = v11;
    int32_t v12 = v11; // 0x89f16
    int32_t v13 = v10; // 0x89fd
    int32_t * v14;
    if (v11 == 0) {
        // bb114
        v12 = function_8a70((int32_t)&v14);
        v13 = v10;
        // branch -> 0x89e3
    }
    int32_t v15 = v13; // esi
    int32_t v16 = g6;
    int32_t v17 = v13;
    // branch -> 0x89f1
  lab_0x89f1:
    while (true) {
        int32_t v18 = v12; // 0x89e8
        // branch -> 0x89f1
        int32_t v19; // 0x8a01
        int32_t v20; // 0x89fd
        int32_t v21; // 0x8a09
        int32_t v22; // 0x8a0e
        int32_t * v23; // 0x8a06
        while (true) {
            // 0x89f1
            if (*(int32_t *)(v18 + 16) >= v16) {
                // 0x89e8
                v15 = v18;
                int32_t v24 = *(int32_t *)(v18 + 8); // 0x89ea
                g4 = v24;
                if (v24 == 0) {
                    v20 = v18;
                    // break (via goto) -> 0x89fd
                    goto lab_0x89fd;
                }
                v17 = v18;
                v12 = v24;
                // continue (via goto) -> 0x89f1
                goto lab_0x89f1;
            } else {
                int32_t v25 = *(int32_t *)(v18 + 12); // 0x89f6
                g4 = v25;
                if (v25 == 0) {
                    v20 = v17;
                    // break -> 0x89fd
                    break;
                }
                v18 = v25;
                // continue -> 0x89f1
                continue;
            }
            v19 = v20;
            if (v13 == v20) {
                int32_t v26 = function_8a70((int32_t)&v14); // 0x89ff
                g4 = v26;
                int32_t v27 = v15;
                int32_t v28 = g6;
                v16 = v28;
                v19 = v27;
                // branch -> 0x8a01
            }
            uint32_t v29 = *(int32_t *)(v19 + 16); // 0x8a01
            v22 = v19;
            if (v29 > v16) {
                int32_t v30 = function_8a70((int32_t)&v14); // 0x8a04
                v3 = v30;
                int32_t v31 = v15;
                v22 = v31;
                // branch -> 0x8a06
            }
            // 0x8a06
            v23 = (int32_t *)(v22 + 20);
            int32_t v32 = *v23; // 0x8a06
            v21 = v32 - 1;
            g4 = v21;
            *v23 = v21;
            int32_t v33; // 0x8a13
            int32_t result; // 0x8a13
            if (v21 == 0) {
                // 0x8a13
                v33 = g8;
                result = *(int32_t *)(v33 + (int32_t)&g15);
                v3 = result;
                return result;
            }
            // bb117
            v3 = function_8a42();
            // branch -> 0x8a13
            // 0x8a13
            v33 = g8;
            result = *(int32_t *)(v33 + (int32_t)&g15);
            v3 = result;
            return result;
        }
      lab_0x89fd:
        // 0x89fd
        v19 = v20;
        if (v13 == v20) {
            // bb115
            g4 = function_8a70((int32_t)&v14);
            v16 = g6;
            v19 = v15;
            // branch -> 0x8a01
        }
        // 0x8a01
        v22 = v19;
        if (*(int32_t *)(v19 + 16) > v16) {
            // bb116
            function_8a70((int32_t)&v14);
            v22 = v15;
            // branch -> 0x8a06
        }
        // 0x8a06
        v23 = (int32_t *)(v22 + 20);
        v21 = *v23 - 1;
        g4 = v21;
        *v23 = v21;
        if (v21 == 0) {
            // 0x8a13
            return *(int32_t *)(g8 + (int32_t)&g15);
        }
        // bb117
        function_8a42();
        // branch -> 0x8a13
        // 0x8a13
        return *(int32_t *)(g8 + (int32_t)&g15);
    }
}

// Address range: 0x8a30 - 0x8a31
int32_t function_8a30(int32_t a1) {
    // 0x8a30
    return g4;
}

// Address range: 0x8a42 - 0x8a49
int32_t function_8a42(void) {
    // 0x8a42
    return g4;
}

// Address range: 0x8a49 - 0x8a50
int32_t function_8a49(void) {
    // 0x8a49
    int32_t result;
    return result;
}

// Address range: 0x8a54 - 0x8a6e
int32_t function_8a54(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)-0x74a78a40; // 0x8a54
    *v1 = *v1 + 1;
    int32_t v2 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x8a5d
    g4 = v2;
    int32_t result = v2; // 0x8a6d
    if (v2 != 0) {
        // bb
        result = function_8aac();
        // branch -> 0x8a66
    }
    // 0x8a66
    return result;
}

// Address range: 0x8a70 - 0x8a8f
int32_t function_8a70(int32_t a1) {
    // 0x8a70
    return g4;
}

// Address range: 0x8aac - 0x8aad
int32_t function_8aac(void) {
    // 0x8aac
    return g4;
}

// Address range: 0x8ad0 - 0x8af2
// Demangled:     CKey::~CKey()
int32_t _ZN4CKeyD1Ev(int32_t a1) {
    // 0x8ad0
    return 0;
}

// Address range: 0x8b30 - 0x8b65
// Demangled:     boost::unique_lock<boost::mutex>::~unique_lock()
int32_t _ZN5boost11unique_lockINS_5mutexEED1Ev(int32_t * a1) {
    // 0x8b30
    if (*(char *)((int32_t)a1 + 4) != 0) {
        // 0x8b60
        return *a1;
    }
    // 0x8b4a
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x8b5a
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_8b92((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x8b57
    }
    // 0x8b57
    return result;
}

// Address range: 0x8b81 - 0x8b8e
int32_t function_8b81(void) {
    int32_t v1 = 0; // eax
    int32_t v2 = (v1 + 56) % 256 | v1 & -256; // 0x8b81
    int32_t v3 = v2 ^ *(int32_t *)v2; // 0x8b83
    g4 = v3 + 36 & 255 | v3 & -256;
    return function_e8008bb1();
}

// Address range: 0x8b92 - 0x8b93
int32_t function_8b92(int32_t a1) {
    // 0x8b92
    return g4;
}

// Address range: 0x8ba0 - 0x8be1
// Demangled:     boost::variant<boost::shared_ptr<void>, boost::signals2::detail::foreign_void_shared_ptr, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_>::~variant()
int32_t _ZN5boost7variantINS_10shared_ptrIvEENS_8signals26detail23foreign_void_shared_ptrENS_6detail7variant5void_ES8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_S8_ED1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0x8bb4
    int32_t v2 = v1 >> 31 ^ v1; // 0x8bbb
    g4 = v2;
    int32_t result = v2; // 0x8bda
    if (v2 < 20) {
        // bb
        result = function_8be8((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x8bc2
    }
    // 0x8bc2
    return result;
}

// Address range: 0x8be5 - 0x8be8
int32_t function_8be5(void) {
    // 0x8be5
    return 0;
}

// Address range: 0x8be8 - 0x8bef
int32_t function_8be8(int32_t a1) {
    // 0x8be8
    return g4;
}

// Address range: 0x8bf0 - 0x8c2d
int32_t function_8bf0(int32_t a1, int32_t a2) {
    // 0x8bf0
    g4 = function_8ca0();
    int32_t v1 = *(int32_t *)(g7 + 4); // 0x8c06
    g4 = v1;
    int32_t v2 = v1; // 0x8c1e2
    if (v1 == 0) {
        int32_t v3 = function_8c60(); // 0x8c0b
        g4 = v3;
        v2 = v3;
        // branch -> 0x8c0d
    }
    if ((a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
        // bb103
        v2 = function_8cba();
        // branch -> 0x8c1e
    }
    // 0x8c1e
    return *(int32_t *)(*(int32_t *)v2 + 4);
}

// Address range: 0x8c53 - 0x8c54
int32_t function_8c53(void) {
    // 0x8c53
    return 0;
}

// Address range: 0x8c60 - 0x8c72
int32_t function_8c60(void) {
    // 0x8c60
    int32_t v1;
    int32_t result; // 0x8c71
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_8cba();
        // branch -> 0x8c6d
    } else {
        // 0x8c60
        result = g4;
        // branch -> 0x8c6d
    }
    // 0x8c6d
    return result;
}

// Address range: 0x8c78 - 0x8c95
int32_t function_8c78(int32_t a1, int32_t a2) {
    // 0x8c78
    int32_t result; // 0x8c90
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_8cba();
        // branch -> 0x8c85
    } else {
        // 0x8c78
        result = g4;
        // branch -> 0x8c85
    }
    // 0x8c85
    return result;
}

// Address range: 0x8c98 - 0x8c9f
int32_t function_8c98(void) {
    // 0x8c98
    int32_t result; // 0x8c9d
    if (*(int32_t *)(g7 + 4) == 0) {
        // bb
        result = function_8c60();
        // branch -> 0x8c9f
    } else {
        // 0x8c98
        result = g4;
        // branch -> 0x8c9f
    }
    // 0x8c9f
    return result;
}

// Address range: 0x8ca0 - 0x8cba
int32_t function_8ca0(void) {
    uint32_t v1 = g4; // 0x8ca0
    int32_t v2 = *(int32_t *)(g5 - 0x74f78b40) + v1; // 0x8ca0
    int32_t v3 = g7; // 0x8ca6
    char * v4 = (char *)(v3 + 0x52ff2404); // 0x8ca6
    *v4 = (char)v3 + (char)(v2 < v1) + *v4;
    int32_t result = (v2 + 139 & (int32_t)(char)&g15 | v2 & -256) ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x8cb1
    return result;
}

// Address range: 0x8cba - 0x8cbb
int32_t function_8cba(void) {
    // 0x8cba
    return g4;
}

// Address range: 0x8d10 - 0x8d3e
// Demangled:     std::vector<unsigned char, secure_allocator<unsigned char> >::~vector()
int32_t _ZNSt6vectorIh16secure_allocatorIhEED1Ev(int32_t * a1) {
    int32_t result = (int32_t)a1;
    g4 = result;
    int32_t v1 = g6; // 0x8d17
    int32_t v2 = g10; // 0x8d28
    int32_t v3 = *a1; // 0x8d2c
    g6 = v3;
    g10 = *(int32_t *)(result + 8);
    if (v3 == 0) {
        // bb
        result = function_8d78((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", v1, v2);
        // branch -> 0x8d35
    }
    // 0x8d35
    return result;
}

// Address range: 0x8d78 - 0x8d91
int32_t function_8d78(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8d78
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x8d91
        return g4;
    }
    // 0x8d85
    g6 = a2;
    g10 = a3;
    return g4;
}

// Address range: 0x8da0 - 0x8e6c
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          constructor
int32_t _ZN5boost16exception_detail13get_bad_allocILi42EEENS_10shared_ptrIKNS0_10clone_baseEEEv(int32_t * a1) {
    // 0x8e49
    g4 = 0;
    function_8ec0((int32_t)&g67, 0, (int32_t)"boost::exception_ptr boost::exception_detail::get_bad_alloc() [with int Dummy = 42, boost::exception_ptr = boost::shared_ptr<const boost::exception_detail::clone_base>]", (int32_t)"/usr/include/boost/exception/detail/exception_ptr.hpp", 81, (int32_t)&g68, (int32_t)&g69, (int32_t)&g65, 0, 0, 0, -1, (int32_t)&g66, 0, (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0);
    *a1 = 0;
    *(int32_t *)((int32_t)a1 + 4) = (int32_t)&g70;
    *(int32_t *)&g71 = (int32_t)&g72;
    int32_t v1; // bp-52
    return &v1;
}

// Address range: 0x8e98 - 0x8ebc
int32_t function_8e98(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)-0x7017dbcc; // 0x8e98
    *v1 = *v1 - 1;
    int32_t result = g4; // 0x8eb9
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_8f8b();
        // branch -> 0x8eb4
    }
    // 0x8eb4
    return result;
}

// Address range: 0x8ec0 - 0x8ec7
int32_t function_8ec0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17) {
    // 0x8ec0
    return g4;
}

// Address range: 0x8f86 - 0x8f8b
int32_t function_8f86(void) {
    // 0x8f86
    return 0;
}

// Address range: 0x8f8b - 0x8f8c
int32_t function_8f8b(void) {
    // 0x8f8b
    return g4;
}

// Address range: 0x8fa6 - 0x8fa7
int32_t function_8fa6(void) {
    // 0x8fa6
    return 0;
}

// Address range: 0x8faf - 0x8fb0
int32_t function_8faf(void) {
    // 0x8faf
    return g4;
}

// Address range: 0x8fda - 0x8fe1
int32_t function_8fda(void) {
    int32_t * v1 = (int32_t *)-0x762f143d; // 0x8fda
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x8fe6 - 0x8fe8
int32_t function_8fe6(void) {
    // 0x8fe6
    return function_8faf();
}

// Address range: 0x8ff0 - 0x9025
// Demangled:     boost::unique_lock<AnnotatedMixin<boost::recursive_mutex> >::~unique_lock()
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(int32_t * a1) {
    int32_t result = (int32_t)a1;
    int32_t v1 = g6; // 0x8ff0
    if (*(char *)(result + 4) != 0) {
        // 0x9020
        g6 = *a1;
        return result;
    }
    // 0x900b
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    int32_t result2 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x901c
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result2 = function_9066((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x9018
    }
    // 0x9018
    g6 = v1;
    return result2;
}

// Address range: 0x903b - 0x903c
int32_t function_903b(void) {
    // 0x903b
    return g4;
}

// Address range: 0x9052 - 0x9066
int32_t function_9052(void) {
    // 0x9052
    *(char *)72 = 0;
    return function_903b();
}

// Address range: 0x9066 - 0x9067
int32_t function_9066(int32_t a1) {
    // 0x9066
    return g4;
}

// Address range: 0x90a0 - 0x9139
// Demangled:     std::_Rb_tree<CKeyID, std::pair<CKeyID const, CKey>, std::_Select1st<std::pair<CKeyID const, CKey> >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, CKey> > >::find(CKeyID const &) const
int32_t _ZNKSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE4findERS2_(int32_t * a1, int32_t a2) {
    int32_t v1 = g10; // 0x90a2
    int32_t v2 = g6; // 0x90a3
    int32_t v3 = (int32_t)a1; // ebp
    int32_t v4 = *(int32_t *)(a2 + 8); // 0x90c0
    g6 = v4;
    int32_t v5 = a2 + 4; // 0x90c3
    int32_t result; // 0x9122
    if (v4 != 0) {
        int32_t v6 = v5; // edi
        // branch -> 0x90e1
        while (true) {
            // 0x90e1
            int32_t v7;
            int32_t v8 = unknown_11450(v4 + (int32_t)&g13, v7); // 0x90eb
            int32_t v9 = g6; // 0x90d8
            int32_t v10; // 0x9101
            int32_t v11; // 0x90da
            if ((char)v8 == 0) {
                // 0x90d8
                v6 = v9;
                v11 = *(int32_t *)(v9 + 8);
                g6 = v11;
                if (v11 == 0) {
                    v10 = v9;
                    // 0x90fb
                    if (v5 != v10) {
                        // 0x9101
                        if ((char)unknown_11450(g10, v10 + (int32_t)&g13) == 0) {
                            // 0x9114
                            *(int32_t *)v3 = v6;
                            // branch -> 0x9117
                            // 0x9117
                            result = v3;
                            if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                                // 0x9139
                                return result;
                            }
                            // 0x9126
                            g6 = v2;
                            g10 = v1;
                            return result;
                        }
                    }
                    // 0x9130
                    *(int32_t *)v3 = v5;
                    // branch -> 0x9117
                    // 0x9117
                    result = v3;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                        // 0x9139
                        return result;
                    }
                    // 0x9126
                    g6 = v2;
                    g10 = v1;
                    return result;
                }
            } else {
                int32_t v12 = *(int32_t *)(v9 + (int32_t)&g37); // 0x90f4
                g6 = v12;
                if (v12 == 0) {
                    // 0x90f4
                    v10 = v6;
                    // branch -> 0x90fb
                    // 0x90fb
                    if (v5 != v10) {
                        // 0x9101
                        if ((char)unknown_11450(g10, v10 + (int32_t)&g13) == 0) {
                            // 0x9114
                            *(int32_t *)v3 = v6;
                            // branch -> 0x9117
                            // 0x9117
                            result = v3;
                            if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                                // 0x9139
                                return result;
                            }
                            // 0x9126
                            g6 = v2;
                            g10 = v1;
                            return result;
                        }
                    }
                    // 0x9130
                    *(int32_t *)v3 = v5;
                    // branch -> 0x9117
                    // 0x9117
                    result = v3;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                        // 0x9139
                        return result;
                    }
                    // 0x9126
                    g6 = v2;
                    g10 = v1;
                    return result;
                }
                v11 = v12;
            }
            // 0x90e1
            v7 = g10;
            v4 = v11;
            // branch -> 0x90e1
        }
    }
    // 0x9130
    *(int32_t *)v3 = v5;
    // branch -> 0x9117
    // 0x9117
    result = v3;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x9139
        return result;
    }
    // 0x9126
    g6 = v2;
    g10 = v1;
    return result;
}

// Address range: 0x9140 - 0x918a
// Demangled:     std::_Rb_tree<CKeyID, std::pair<CKeyID const, CKey>, std::_Select1st<std::pair<CKeyID const, CKey> >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, CKey> > >::_M_erase(std::_Rb_tree_node<std::pair<CKeyID const, CKey> > *)
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE8_M_eraseEPSt13_Rb_tree_nodeIS4_E(int32_t a1, int32_t a2) {
    // 0x9140
    g6 = a2;
    if (a2 != 0) {
        // 0x916a
        return unknown_12280(*(int32_t *)(a2 + (int32_t)&g37));
    }
    // 0x915f
    return function_91b3((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
}

// Address range: 0x91b3 - 0x91c8
int32_t function_91b3(int32_t a1) {
    int32_t result = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x91b7
    if (result != 0) {
        // 0x91c8
    }
    // 0x91c0
    return result;
}

// Address range: 0x91d0 - 0x920e
// Demangled:     std::_Rb_tree<CScriptID, std::pair<CScriptID const, CScript>, std::_Select1st<std::pair<CScriptID const, CScript> >, std::less<CScriptID>, std::allocator<std::pair<CScriptID const, CScript> > >::_M_erase(std::_Rb_tree_node<std::pair<CScriptID const, CScript> > *)
int32_t _ZNSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE8_M_eraseEPSt13_Rb_tree_nodeIS4_E(int32_t a1, int32_t a2) {
    // 0x91d0
    if (a2 == 0) {
        // 0x91ee
        return function_921f((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0, 0);
    }
    // 0x91f2
    unknown_123a0(a1, *(int32_t *)(a2 + (int32_t)&g37));
    int32_t v1 = *(int32_t *)(a2 + (int32_t)&g18); // 0x9201
    g4 = v1;
    int32_t result = v1; // 0x920b
    if (v1 == 0) {
        // bb
        result = function_9213();
        // branch -> 0x920b
    }
    // 0x920b
    return result;
}

// Address range: 0x9213 - 0x9216
int32_t function_9213(void) {
    // 0x9213
    return g4;
}

// Address range: 0x921f - 0x9233
int32_t function_921f(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x9223
    if (result != 0) {
        // 0x9233
    }
    // 0x922c
    return result;
}

// Address range: 0x9240 - 0x928a
// From class:    CBasicKeyStore
// Type:          constructor
// Demangled:     CBasicKeyStore::~CBasicKeyStore()
int32_t _ZN14CBasicKeyStoreD1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g43;
    unknown_12410(v1 + 112, *(int32_t *)(v1 + (int32_t)&g23));
    unknown_12380(v1 + (int32_t)&g20, *(int32_t *)(v1 + 96));
    *(int32_t *)v1 = (int32_t)&g42;
    return v1 + 4;
}

// Address range: 0x928e - 0x9295
int32_t function_928e(void) {
    // 0x928e
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x7cde8a40); // 0x928e
    *v2 = *v2 + 1;
    return 0;
}

// Address range: 0x929d - 0x92b4
int32_t function_929d(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x74e38a40; // 0x929d
    *v1 = *v1 + 1;
    int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x92a6
    if (result != 0) {
        // 0x92b9
    }
    // 0x92af
    return result;
}

// Address range: 0x92b4 - 0x92b9
int32_t function_92b4(void) {
    // 0x92b4
    return function_c7e6();
}

// Address range: 0x9300 - 0x934a
// From class:    CBasicKeyStore
// Type:          constructor
// Demangled:     CBasicKeyStore::~CBasicKeyStore()
int32_t _ZN14CBasicKeyStoreD0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g43;
    unknown_124d0(v1 + 112, *(int32_t *)(v1 + (int32_t)&g23));
    unknown_12440(v1 + (int32_t)&g20, *(int32_t *)(v1 + 96));
    *(int32_t *)v1 = (int32_t)&g42;
    return v1 + 4;
}

// Address range: 0x93d0 - 0x940e
// Demangled:     std::_Rb_tree<CKeyID, std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > >, std::_Select1st<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > > >::_M_erase(std::_Rb_tree_node<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > > *)
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE8_M_eraseEPSt13_Rb_tree_nodeIS8_E(int32_t a1, int32_t a2) {
    // 0x93d0
    if (a2 == 0) {
        // 0x93ee
        return function_941f((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0, 0);
    }
    // 0x93f2
    unknown_127a0(a1, *(int32_t *)(a2 + (int32_t)&g37));
    int32_t v1 = *(int32_t *)(a2 + 104); // 0x9401
    g4 = v1;
    int32_t result = v1; // 0x940b
    if (v1 == 0) {
        // bb
        result = function_9413();
        // branch -> 0x940b
    }
    // 0x940b
    return result;
}

// Address range: 0x9413 - 0x9416
int32_t function_9413(void) {
    // 0x9413
    return g4;
}

// Address range: 0x941f - 0x9433
int32_t function_941f(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x9423
    if (result != 0) {
        // 0x9433
    }
    // 0x942c
    return result;
}

// Address range: 0x9440 - 0x94d9
// Demangled:     std::_Rb_tree<CKeyID, std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > >, std::_Select1st<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > > >::find(CKeyID const &) const
int32_t _ZNKSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE4findERS2_(int32_t * a1, int32_t a2) {
    int32_t v1 = g8; // 0x9441
    int32_t v2 = g10; // 0x9442
    int32_t v3 = g6; // 0x9443
    int32_t v4 = (int32_t)a1; // ebp
    int32_t v5 = *(int32_t *)(a2 + 8); // 0x9460
    g6 = v5;
    int32_t v6 = a2 + 4; // 0x9463
    int32_t result; // 0x94c2
    if (v5 != 0) {
        // 0x946e
        g8 = v6;
        // branch -> 0x9481
        while (true) {
            // 0x9481
            int32_t v7;
            int32_t v8 = unknown_117f0(v5 + (int32_t)&g13, v7); // 0x948b
            int32_t v9 = g6; // 0x9478
            int32_t v10; // 0x94a1
            int32_t v11; // 0x947a
            if ((char)v8 == 0) {
                // 0x9478
                g8 = v9;
                v11 = *(int32_t *)(v9 + 8);
                g6 = v11;
                if (v11 == 0) {
                    v10 = v9;
                    // 0x949b
                    if (v6 != v10) {
                        // 0x94a1
                        if ((char)unknown_117f0(g10, v10 + (int32_t)&g13) == 0) {
                            // 0x94b4
                            *(int32_t *)v4 = g8;
                            // branch -> 0x94b7
                            // 0x94b7
                            result = v4;
                            if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                                // 0x94d9
                                return result;
                            }
                            // 0x94c6
                            g6 = v3;
                            g10 = v2;
                            g8 = v1;
                            return result;
                        }
                    }
                    // 0x94d0
                    *(int32_t *)v4 = v6;
                    // branch -> 0x94b7
                    // 0x94b7
                    result = v4;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                        // 0x94d9
                        return result;
                    }
                    // 0x94c6
                    g6 = v3;
                    g10 = v2;
                    g8 = v1;
                    return result;
                }
            } else {
                int32_t v12 = *(int32_t *)(v9 + (int32_t)&g37); // 0x9494
                g6 = v12;
                if (v12 == 0) {
                    // 0x9494
                    v10 = g8;
                    // branch -> 0x949b
                    // 0x949b
                    if (v6 != v10) {
                        // 0x94a1
                        if ((char)unknown_117f0(g10, v10 + (int32_t)&g13) == 0) {
                            // 0x94b4
                            *(int32_t *)v4 = g8;
                            // branch -> 0x94b7
                            // 0x94b7
                            result = v4;
                            if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                                // 0x94d9
                                return result;
                            }
                            // 0x94c6
                            g6 = v3;
                            g10 = v2;
                            g8 = v1;
                            return result;
                        }
                    }
                    // 0x94d0
                    *(int32_t *)v4 = v6;
                    // branch -> 0x94b7
                    // 0x94b7
                    result = v4;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                        // 0x94d9
                        return result;
                    }
                    // 0x94c6
                    g6 = v3;
                    g10 = v2;
                    g8 = v1;
                    return result;
                }
                v11 = v12;
            }
            // 0x9481
            v7 = g10;
            v5 = v11;
            // branch -> 0x9481
        }
    }
    // 0x94d0
    *(int32_t *)v4 = v6;
    // branch -> 0x94b7
    // 0x94b7
    result = v4;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x94d9
        return result;
    }
    // 0x94c6
    g6 = v3;
    g10 = v2;
    g8 = v1;
    return result;
}

// Address range: 0x94e0 - 0x94fc
// Demangled:     boost::exception_detail::error_info_injector<boost::bad_function_call>::error_info_injector(boost::exception_detail::error_info_injector<boost::bad_function_call> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_17bad_function_callEEC1ERKS3_(int32_t a1, int32_t a2) {
    // 0x94e0
    return a2 + 4;
}

// Address range: 0x9510 - 0x9562
int32_t function_9510(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x3c70c46); // 0x9510
    *v2 = *v2 - 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + *(char *)&g4;
    *(int32_t *)(v1 + 8) = (int32_t)&g47;
    *(int32_t *)(v1 + (int32_t)&g37) = v3;
    if (v3 != 0) {
        // 0x9528
        // branch -> 0x9530
    }
    int32_t v4 = 0; // esi
    int32_t v5 = *(int32_t *)(v4 + (int32_t)&g13); // 0x9530
    *(int32_t *)(v1 + 8) = (int32_t)&g58;
    *(int32_t *)(v1 + (int32_t)&g13) = v5;
    int32_t v6 = *(int32_t *)(v4 + (int32_t)&g14); // 0x953d
    *(int32_t *)(v1 + (int32_t)&g14) = v6;
    *(int32_t *)v1 = (int32_t)&g57;
    *(int32_t *)(v1 + 24) = *(int32_t *)(v4 + 24);
    int32_t result = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x9553
    if (result != 0) {
        // 0x9562
        return result;
    }
    // 0x955c
    return result;
}

// Address range: 0x9590 - 0x9597
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE7rethrowEv(a1 - (int32_t)&g15); // 0x9595
    return result;
}

// Address range: 0x95a0 - 0x95bc
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_function_call> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEE7rethrowEv(int32_t a1) {
    // 0x95a0
    return 0;
}

// Address range: 0x95c0 - 0x95c7
int32_t function_95c0(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb8c; // 0x95c0
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x9610 - 0x962c
// Demangled:     void boost::throw_exception<boost::bad_function_call>(boost::bad_function_call const &)
int32_t _ZN5boost15throw_exceptionINS_17bad_function_callEEEvRKT_(int32_t a1) {
    // 0x9610
    return 0;
}

// Address range: 0x96e3 - 0x96e4
int32_t function_96e3(void) {
    // 0x96e3
    return g4;
}

// Address range: 0x96f2 - 0x971e
int32_t function_96f2(void) {
    int32_t v1 = 0; // eax
    unsigned char v2 = (char)v1 - (char)&g13 + (char)false; // 0x96f5
    int32_t v3 = (int32_t)v2 | v1 & -256; // 0x96f5
    char * v4 = (char *)v3; // 0x96f7
    *v4 = *v4 + v2;
    function_d5f0(1);
    function_d5f0(0);
    g4 = v3;
    return function_96e3();
}

// Address range: 0x971e - 0x9720
int32_t function_971e(void) {
    // 0x971e
    return 0;
}

// Address range: 0x9720 - 0x97b9
// Demangled:     std::_Rb_tree<CScriptID, std::pair<CScriptID const, CScript>, std::_Select1st<std::pair<CScriptID const, CScript> >, std::less<CScriptID>, std::allocator<std::pair<CScriptID const, CScript> > >::find(CScriptID const &) const
int32_t _ZNKSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE4findERS2_(int32_t * a1, int32_t a2) {
    int32_t v1 = g8; // 0x9721
    int32_t v2 = g10; // 0x9722
    int32_t v3 = g6; // 0x9723
    int32_t v4 = (int32_t)a1; // ebp
    int32_t v5 = *(int32_t *)(a2 + 8); // 0x9740
    g6 = v5;
    int32_t v6 = a2 + 4; // 0x9743
    int32_t result; // 0x97a2
    if (v5 != 0) {
        // 0x974e
        g8 = v6;
        // branch -> 0x9761
        while (true) {
            // 0x9761
            int32_t v7;
            int32_t v8 = unknown_11ad0(v5 + (int32_t)&g13, v7); // 0x976b
            int32_t v9 = g6; // 0x9758
            int32_t v10; // 0x9781
            int32_t v11; // 0x975a
            if ((char)v8 == 0) {
                // 0x9758
                g8 = v9;
                v11 = *(int32_t *)(v9 + 8);
                g6 = v11;
                if (v11 == 0) {
                    v10 = v9;
                    // 0x977b
                    if (v6 != v10) {
                        // 0x9781
                        if ((char)unknown_11ad0(g10, v10 + (int32_t)&g13) == 0) {
                            // 0x9794
                            *(int32_t *)v4 = g8;
                            // branch -> 0x9797
                            // 0x9797
                            result = v4;
                            if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                                // 0x97b9
                                return result;
                            }
                            // 0x97a6
                            g6 = v3;
                            g10 = v2;
                            g8 = v1;
                            return result;
                        }
                    }
                    // 0x97b0
                    *(int32_t *)v4 = v6;
                    // branch -> 0x9797
                    // 0x9797
                    result = v4;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                        // 0x97b9
                        return result;
                    }
                    // 0x97a6
                    g6 = v3;
                    g10 = v2;
                    g8 = v1;
                    return result;
                }
            } else {
                int32_t v12 = *(int32_t *)(v9 + (int32_t)&g37); // 0x9774
                g6 = v12;
                if (v12 == 0) {
                    // 0x9774
                    v10 = g8;
                    // branch -> 0x977b
                    // 0x977b
                    if (v6 != v10) {
                        // 0x9781
                        if ((char)unknown_11ad0(g10, v10 + (int32_t)&g13) == 0) {
                            // 0x9794
                            *(int32_t *)v4 = g8;
                            // branch -> 0x9797
                            // 0x9797
                            result = v4;
                            if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                                // 0x97b9
                                return result;
                            }
                            // 0x97a6
                            g6 = v3;
                            g10 = v2;
                            g8 = v1;
                            return result;
                        }
                    }
                    // 0x97b0
                    *(int32_t *)v4 = v6;
                    // branch -> 0x9797
                    // 0x9797
                    result = v4;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                        // 0x97b9
                        return result;
                    }
                    // 0x97a6
                    g6 = v3;
                    g10 = v2;
                    g8 = v1;
                    return result;
                }
                v11 = v12;
            }
            // 0x9761
            v7 = g10;
            v5 = v11;
            // branch -> 0x9761
        }
    }
    // 0x97b0
    *(int32_t *)v4 = v6;
    // branch -> 0x9797
    // 0x9797
    result = v4;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // 0x97b9
        return result;
    }
    // 0x97a6
    g6 = v3;
    g10 = v2;
    g8 = v1;
    return result;
}

// Address range: 0x97c0 - 0x9803
int32_t _ZN5boost8signals26detail24slot_call_iterator_cacheINS1_9void_typeENS1_12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS6_EEENSB_IFvRKNS0_10connectionES6_EEENS0_5mutexEE12slot_invokerEED1Ev(int32_t a1) {
    // 0x97c0
    g6 = a1;
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g25); // 0x97d4
    g9 = v1;
    if (v1 == 0) {
        // bb
        function_9808((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        a1 = g6;
        // branch -> 0x97de
    }
    int32_t v2 = *(int32_t *)(a1 + (int32_t)&g24); // 0x97de
    g4 = v2;
    int32_t v3 = v2; // 0x97f36
    if (v2 < 10) {
        int32_t v4 = function_984d(); // 0x97e4
        g4 = v4;
        v3 = v4;
        a1 = g6;
        // branch -> 0x97e6
    }
    int32_t v5 = a1; // 0x97ed
    if (v1 == a1 + 4) {
        int32_t v6 = function_9848(); // 0x97eb
        g4 = v6;
        v3 = v6;
        v5 = g6;
        // branch -> 0x97ed
    }
    uint32_t v7 = *(int32_t *)(v5 + (int32_t)&g26); // 0x97ed
    g7 = v7;
    int32_t v8 = v3; // 0x97fb8
    if (v3 < v7) {
        // bb115
        v8 = function_984d();
        // branch -> 0x97f7
    }
    if (v7 != 0) {
        // bb116
        v8 = function_9828();
        // branch -> 0x97fb
    }
    int32_t result = v8; // 0x9800
    if (v8 < 11) {
        // bb118
        result = function_9808((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0x9800
    }
    // 0x9800
    return result;
}

// Address range: 0x9808 - 0x9822
int32_t function_9808(int32_t a1) {
    // 0x9808
    if (*(char *)&g6 != 0) {
        // 0x980d
        *(char *)g6 = 0;
        // branch -> 0x9810
    }
    int32_t v1 = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x9814
    g4 = v1;
    int32_t result = v1; // 0x9821
    if (v1 != 0) {
        // bb
        result = function_9852();
        // branch -> 0x981d
    }
    // 0x981d
    return result;
}

// Address range: 0x9828 - 0x9844
int32_t function_9828(void) {
    // 0x9828
    g4 = g6 + (int32_t)&g25;
    function_9940();
    return *(int32_t *)(g6 + (int32_t)&g24);
}

// Address range: 0x9848 - 0x984d
int32_t function_9848(void) {
    // 0x9848
    return g4;
}

// Address range: 0x984d - 0x9852
int32_t function_984d(void) {
    // 0x984d
    return function_ce9e();
}

// Address range: 0x9852 - 0x9853
int32_t function_9852(void) {
    // 0x9852
    return g4;
}

// Address range: 0x9870 - 0x9895
// Demangled:     boost::unique_lock<AnnotatedMixin<boost::recursive_mutex> >::lock()
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(int32_t * a1) {
    int32_t result = 0; // 0x9892
    if (*(char *)((int32_t)a1 + 4) != 0) {
        // bb
        result = function_9951((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0, 0);
        // branch -> 0x9890
    }
    // 0x9890
    return result;
}

// Address range: 0x98af - 0x98be
int32_t function_98af(void) {
    // 0x98af
    g9 = 1;
    if (g4 == *(int32_t *)(g6 + 76)) {
        // bb
        g4 = function_9910();
        // branch -> 0x98b9
    }
    // 0x98b9
    return function_98d4();
}

// Address range: 0x98c0 - 0x98c7
int32_t function_98c0(void) {
    // 0x98c0
    return g4;
}

// Address range: 0x98d4 - 0x98e0
int32_t function_98d4(void) {
    // 0x98d4
    if ((char)g9 != 0) {
        // bb
        g4 = function_98c0();
        // branch -> 0x98d8
    }
    int32_t * v1 = (int32_t *)(g6 + 80); // 0x98d8
    *v1 = *v1 + 1;
    *(char *)(g6 + 72) = 1;
    return g4;
}

// Address range: 0x98ef - 0x9910
int32_t function_98ef(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)-0x737af040; // 0x98ef
    *v1 = *v1 + 1;
    int32_t v2 = 0; // eax
    *(char *)v2 = (char)v2 + *(char *)&g4;
    char * v3 = (char *)0x651c2444; // 0x98f7
    *v3 = (char)0 + *v3;
    int32_t v4 = v2 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x98fd
    g4 = v4;
    *(char *)4 = 1;
    int32_t result; // 0x990f
    if (v4 != 0) {
        // bb
        result = function_996d();
        // branch -> 0x9909
    } else {
        // 0x98ef
        result = g4;
        // branch -> 0x9909
    }
    // 0x9909
    return result;
}

// Address range: 0x9910 - 0x9917
int32_t function_9910(void) {
    int32_t * v1 = (int32_t *)(g6 + 80); // 0x9910
    *v1 = *v1 + 1;
    return g4;
}

// Address range: 0x9920 - 0x9921
int32_t function_9920(void) {
    // 0x9920
    return g4;
}

// Address range: 0x9940 - 0x9947
int32_t function_9940(void) {
    // 0x9940
    return g4;
}

// Address range: 0x9951 - 0x996d
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_9951(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)&g46; // bp+20
    return unknown_11f50((int32_t)&v1);
}

// Address range: 0x996d - 0x996e
int32_t function_996d(void) {
    // 0x996d
    return g4;
}

// Address range: 0x997c - 0x997d
int32_t function_997c(void) {
    // 0x997c
    return g4;
}

// Address range: 0x99b2 - 0x99bb
int32_t function_99b2(void) {
    // 0x99b2
    if (g4 == 0) {
        // bb
        g4 = function_997c();
        // branch -> 0x99b6
    }
    // 0x99b6
    return function_9920();
}

// Address range: 0x99c0 - 0x99f3
// Demangled:     CMutexLock<AnnotatedMixin<boost::recursive_mutex> >::CMutexLock(AnnotatedMixin<boost::recursive_mutex> &, char const *, char const *, int, bool)
int32_t _ZN10CMutexLockI14AnnotatedMixinIN5boost15recursive_mutexEEEC1ERS3_PKcS7_ib(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g6; // 0x99c3
    g6 = (int32_t)a1;
    int32_t v2 = g10; // 0x99cb
    g10 = a2;
    *a1 = a2;
    *(char *)(g6 + 4) = 0;
    int32_t result; // 0x99ee
    if ((char)a3 == 0) {
        // bb
        result = function_9a58((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", v1, v2, g8);
        // branch -> 0x99f0
    } else {
        // 0x99c0
        result = 0;
        // branch -> 0x99f0
    }
    // 0x99f0
    return result;
}

// Address range: 0x9a07 - 0x9a08
int32_t function_9a07(void) {
    // 0x9a07
    return g4;
}

// Address range: 0x9a17 - 0x9a18
int32_t function_9a17(void) {
    // 0x9a17
    return g4;
}

// Address range: 0x9a28 - 0x9a45
int32_t function_9a28(void) {
    // 0x9a28
    int32_t v1;
    int32_t v2 = v1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x9a2c
    g4 = v2;
    int32_t result = v2; // 0x9a44
    if (v2 != 0) {
        // bb
        result = function_9a62();
        // branch -> 0x9a35
    }
    // 0x9a35
    return result;
}

// Address range: 0x9a4d - 0x9a56
int32_t function_9a4d(void) {
    // 0x9a4d
    int32_t v1;
    if (g4 == *(int32_t *)(v1 + 76)) {
        // bb
        g4 = function_9a07();
        // branch -> 0x9a52
    }
    // 0x9a52
    return function_9a17();
}

// Address range: 0x9a58 - 0x9a62
int32_t function_9a58(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x9a58
    unknown_13230(g6);
    return function_9a28();
}

// Address range: 0x9a62 - 0x9a63
int32_t function_9a62(void) {
    // 0x9a62
    return g4;
}

// Address range: 0x9a90 - 0x9b84
// From class:    CBasicKeyStore
// Type:          virtual member function
// Demangled:     CBasicKeyStore::GetKey(CKeyID const &, CKey &) const
int32_t _ZNK14CBasicKeyStore6GetKeyERK6CKeyIDR4CKey(int32_t a1, int32_t a2, int32_t * a3) {
    // 0x9a90
    int32_t v1; // bp-40
    int32_t v2 = &v1; // 0x9ab3
    int32_t v3 = (int32_t)a3; // ebx
    unknown_13450(v2, a1 + 4, (int32_t)"cs_KeyStore", (int32_t)"keystore.h", 76, 0);
    int32_t v4; // bp-48
    int32_t v5 = &v4; // 0x9aee
    unknown_12b30(v5, a1 + (int32_t)&g20);
    int32_t v6;
    int32_t result; // 0x9b82
    if (v6 == a1 + (int32_t)&g21) {
        // 0x9b78
        unknown_12a80(v2);
        result = 0;
        // branch -> 0x9b57
    } else {
        int32_t v7 = *(int32_t *)(v6 + (int32_t)&g18); // 0x9b13
        *(int32_t *)v3 = v7;
        *(int32_t *)(v3 + 4) = *(int32_t *)(v5 + 40);
        *(int32_t *)(v3 + 8) = *(int32_t *)(v5 + 44);
        int32_t v8 = *(int32_t *)(v5 + 48); // 0x9b24
        *(int32_t *)(v3 + (int32_t)&g37) = v8;
        int32_t v9 = *(int32_t *)(v5 + 52); // 0x9b2a
        *(int32_t *)(v3 + (int32_t)&g13) = v9;
        int32_t v10 = *(int32_t *)(v5 + 56); // 0x9b30
        *(int32_t *)(v3 + (int32_t)&g14) = v10;
        *(int32_t *)(v3 + 24) = *(int32_t *)(v5 + 60);
        int32_t v11 = *(int32_t *)(v5 + 64); // 0x9b3c
        *(int32_t *)(v3 + (int32_t)&g15) = v11;
        uint16_t v12 = *(int16_t *)(v5 + 68); // 0x9b42
        *(int16_t *)(v3 + (int32_t)&g16) = v12;
        unknown_12a80(v2);
        result = 1;
        // branch -> 0x9b57
    }
    // 0x9b57
    int32_t v13;
    if (v13 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x9b84
        return result;
    }
    // 0x9b64
    return result;
}

// Address range: 0x9b90 - 0x9c31
// From class:    CBasicKeyStore
// Type:          virtual member function
// Demangled:     CBasicKeyStore::HaveKey(CKeyID const &) const
int32_t _ZNK14CBasicKeyStore7HaveKeyERK6CKeyID(int32_t a1, int32_t a2) {
    // 0x9b90
    int32_t v1; // bp-24
    int32_t v2 = &v1; // 0x9bb3
    unknown_13550(v2, a1 + 4, (int32_t)"cs_KeyStore", (int32_t)"keystore.h", 55, 0);
    int32_t v3 = a1 + (int32_t)&g21; // 0x9be9
    int32_t v4; // bp-32
    unknown_12c30((int32_t)&v4);
    unknown_12b80(v2);
    int32_t v5;
    if (v5 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x9c31
    }
    // 0x9c21
    int32_t v6;
    return (int32_t)(v3 != v6) | v3 & -256;
}

// Address range: 0x9c40 - 0x9d5c
// Demangled:     CCryptoKeyStore::HaveKey(CKeyID const &) const
int32_t _ZNK15CCryptoKeyStore7HaveKeyERK6CKeyID(int32_t a1, int32_t a2) {
    // 0x9c40
    int32_t v1; // bp-48
    int32_t v2 = &v1; // 0x9c4f
    unknown_13600(v2, (int32_t)"cs_KeyStore", (int32_t)"keystore.h", (int32_t)"D$\f m", 0);
    int32_t result; // ebx
    int32_t v3; // bp-68
    if (*(char *)(a1 + 172) != 0) {
        int32_t v4 = a1 + 140; // 0x9d36
        unknown_13080((int32_t)&v3, a1 + (int32_t)&g28, a2);
        int32_t v5;
        result = (int32_t)(v4 != v5) | v4 & -256;
        // branch -> 0x9d03
    } else {
        // 0x9ca7
        int32_t v6; // bp-40
        int32_t v7 = &v6; // 0x9cab
        unknown_13600(v7, (int32_t)"cs_KeyStore", (int32_t)"keystore.h", 55, 0);
        int32_t v8 = a1 + (int32_t)&g21; // 0x9cda
        int32_t v9; // bp-64
        unknown_12ce0((int32_t)&v9, a1 + (int32_t)&g20, a2);
        result = (int32_t)(v8 != v3) | v8 & -256;
        unknown_12c30(v7);
        // branch -> 0x9d03
    }
    // 0x9d03
    unknown_12c30(v2);
    int32_t v10;
    if (v10 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // 0x9d5c
        return result;
    }
    // 0x9d1a
    return result;
}

// Address range: 0x9d62 - 0x9d63
int32_t function_9d62(void) {
    // 0x9d62
    return 0;
}

// Address range: 0x9d80 - 0x9db7
// Demangled:     std::_Rb_tree<CKeyID, CKeyID, std::_Identity<CKeyID>, std::less<CKeyID>, std::allocator<CKeyID> >::_M_erase(std::_Rb_tree_node<CKeyID> *)
int32_t _ZNSt8_Rb_treeI6CKeyIDS0_St9_IdentityIS0_ESt4lessIS0_ESaIS0_EE8_M_eraseEPSt13_Rb_tree_nodeIS0_E(int32_t a1, int32_t a2) {
    // 0x9d80
    if (a2 != 0) {
        // 0x9da2
        return unknown_13b00(a1, *(int32_t *)(a2 + (int32_t)&g37));
    }
    // 0x9d9e
    return function_9dc0((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0, 0);
}

// Address range: 0x9dc0 - 0x9dd4
int32_t function_9dc0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0x9dc4
    if (result != 0) {
        // 0x9dd4
    }
    // 0x9dcd
    return result;
}

// Address range: 0x9de0 - 0x9e32
// Demangled:     std::_Rb_tree<CKeyID, CKeyID, std::_Identity<CKeyID>, std::less<CKeyID>, std::allocator<CKeyID> >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, CKeyID const &)
int32_t _ZNSt8_Rb_treeI6CKeyIDS0_St9_IdentityIS0_ESt4lessIS0_ESaIS0_EE10_M_insert_EPKSt18_Rb_tree_node_baseS9_RKS0_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x9de0
    g6 = a5;
    int32_t v1 = a2 + 4; // 0x9e12
    g7 = v1;
    g5 = a4;
    int32_t result = a3; // 0x9e2b
    if (a3 == 0) {
        // bb
        result = function_9ea8(v1);
        // branch -> 0x9e27
    }
    // 0x9e27
    return result;
}

// Address range: 0x9e78 - 0x9ea8
int32_t function_9e78(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7ce7dbbc; // 0x9e78
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0x9e7f
    int32_t result = 0; // edi
    *(int32_t *)result = (v2 + 1 + (int32_t)false) % 256 | v2 & -256;
    g4 = result;
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_9ec7();
        // branch -> 0x9e92
    }
    // 0x9e92
    return result;
}

// Address range: 0x9ea8 - 0x9ec7
int32_t function_9ea8(int32_t a1) {
    // 0x9ea8
    return unknown_12190(g6, g5 + (int32_t)&g13);
}

// Address range: 0x9ec7 - 0x9ec8
int32_t function_9ec7(void) {
    // 0x9ec7
    return g4;
}

// Address range: 0x9ed0 - 0x9f6c
// Demangled:     std::_Rb_tree<CKeyID, CKeyID, std::_Identity<CKeyID>, std::less<CKeyID>, std::allocator<CKeyID> >::_M_insert_unique(CKeyID const &)
int32_t _ZNSt8_Rb_treeI6CKeyIDS0_St9_IdentityIS0_ESt4lessIS0_ESaIS0_EE16_M_insert_uniqueERKS0_(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x9ed0
    g8 = (int32_t)a1;
    g10 = a3;
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x9eef
    g6 = v1;
    int32_t result2; // 0x9f69
    if (v1 != 0) {
        while (true) {
            int32_t result = unknown_12280(a3); // 0x9f13
            int32_t v2 = g6; // 0x9f00
            int32_t v3; // 0x9f00
            if ((char)result != 0) {
                // 0x9f00
                v3 = *(int32_t *)(v2 + 8);
                if (v3 == 0) {
                    // 0x9f60
                    // branch -> 0x9f60
                    // 0x9f60
                    if (v2 != *(int32_t *)(a2 + (int32_t)&g37)) {
                        // 0x9f69
                        return result;
                    }
                    // bb124
                    result2 = function_9fab();
                    // branch -> 0x9f69
                    // 0x9f69
                    return result2;
                }
            } else {
                int32_t v4 = *(int32_t *)(v2 + (int32_t)&g37); // 0x9f1c
                if (v4 == 0) {
                    // 0x9f23
                    if ((char)unknown_12280(v2 + (int32_t)&g13) != 0) {
                        // bb
                        function_9f78();
                        // branch -> 0x9f3c
                    }
                    // 0x9f3c
                    *(int32_t *)g8 = v2;
                    *(char *)(g8 + 4) = 0;
                    int32_t result3 = g8; // 0x9f4d
                    g4 = result3;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                        // 0x9f51
                        return result3;
                    }
                    // bb121
                    // branch -> 0x9f51
                    // 0x9f51
                    return function_9fc1();
                }
                v3 = v4;
            }
            // 0x9f07
            g6 = v3;
            a3 = g10;
            // branch -> 0x9f09
        }
    }
    // 0x9f60
    result2 = 0;
    if (a2 + 4 == *(int32_t *)(a2 + (int32_t)&g37)) {
        // bb124
        result2 = function_9fab();
        // branch -> 0x9f69
    }
    // 0x9f69
    return result2;
}

// Address range: 0x9f71 - 0x9f75
int32_t function_9f71(void) {
    // 0x9f71
    return 0;
}

// Address range: 0x9f78 - 0x9fab
int32_t function_9f78(void) {
    // 0x9f78
    int32_t v1; // bp+44
    int32_t result = &v1; // 0x9f7c
    int32_t v2;
    unknown_13cb0(result, v2, 0, g6, g10);
    *(char *)(g8 + 4) = 1;
    *(int32_t *)g8 = result;
    return result;
}

// Address range: 0x9fab - 0x9fc1
int32_t function_9fab(void) {
    // 0x9fab
    int32_t v1; // bp+44
    return &v1;
}

// Address range: 0x9fc1 - 0x9fc2
int32_t function_9fc1(void) {
    // 0x9fc1
    return g4;
}

// Address range: 0x9fd0 - 0xa071
// From class:    CBasicKeyStore
// Type:          virtual member function
// Demangled:     CBasicKeyStore::GetKeys(std::set<CKeyID, std::less<CKeyID>, std::allocator<CKeyID> > &) const
int32_t _ZNK14CBasicKeyStore7GetKeysERSt3setI6CKeyIDSt4lessIS1_ESaIS1_EE(int32_t a1, int32_t a2) {
    // 0x9fd0
    unknown_13d50(a2, *(int32_t *)(a2 + 8));
    int32_t v1 = a2 + 4; // 0x9ffa
    *(int32_t *)(a2 + (int32_t)&g37) = v1;
    *(int32_t *)(a2 + (int32_t)&g13) = v1;
    *(int32_t *)(a2 + 8) = 0;
    *(int32_t *)(a2 + (int32_t)&g14) = 0;
    int32_t v2; // bp-40
    int32_t v3 = &v2; // 0xa018
    unknown_13990(v3, a1 + 4, (int32_t)"cs_KeyStore", (int32_t)"keystore.h", 64, 0);
    if (*(int32_t *)(a1 + 100) == a1 + (int32_t)&g21) {
        // bb
        function_a07c();
        // branch -> 0xa04e
    }
    // 0xa04e
    int32_t v4; // bp-52
    return unknown_13ea0((int32_t)&v4);
}

// Address range: 0xa079 - 0xa07a
int32_t function_a079(void) {
    // 0xa079
    return 0;
}

// Address range: 0xa07c - 0xa09d
int32_t function_a07c(void) {
    // 0xa07c
    int32_t v1; // bp+52
    unknown_12fc0((int32_t)&v1);
    int32_t v2;
    int32_t v3 = v2 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xa08c
    g4 = v3;
    int32_t result = v3; // 0xa09c
    if (v3 != 0) {
        // bb
        result = function_a0b3();
        // branch -> 0xa095
    }
    // 0xa095
    return result;
}

// Address range: 0xa09e - 0xa09f
int32_t function_a09e(void) {
    // 0xa09e
    return 0;
}

// Address range: 0xa0b3 - 0xa0b4
int32_t function_a0b3(void) {
    // 0xa0b3
    return g4;
}

// Address range: 0xa0c0 - 0xa139
// Demangled:     CCryptoKeyStore::GetKeys(std::set<CKeyID, std::less<CKeyID>, std::allocator<CKeyID> > &) const
int32_t _ZNK15CCryptoKeyStore7GetKeysERSt3setI6CKeyIDSt4lessIS1_ESaIS1_EE(int32_t a1, int32_t a2) {
    // 0xa0c0
    g10 = a1;
    g6 = a2;
    if (*(char *)(a1 + 172) == 0) {
        // bb
        function_a160((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        a2 = g6;
        // branch -> 0xa0e4
    }
    // 0xa0e4
    unknown_13e40(a2, *(int32_t *)(a2 + 8));
    int32_t v1 = g6; // 0xa0f3
    int32_t v2 = v1 + 4; // 0xa0f3
    *(int32_t *)(v1 + (int32_t)&g37) = v2;
    *(int32_t *)(g6 + 8) = 0;
    *(int32_t *)(g6 + (int32_t)&g13) = v2;
    int32_t v3 = g10; // 0xa103
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g29); // ebp
    *(int32_t *)(g6 + (int32_t)&g14) = 0;
    int32_t v5 = v4; // 0xa120
    if (v4 == v3 + 140) {
        // bb112
        function_a144();
        v5 = g5;
        // branch -> 0xa11a
    }
    int32_t v6 = v5 + (int32_t)&g13; // 0xa120
    int32_t v7; // bp-52
    return unknown_13f90((int32_t)&v7, g6, v6);
}

// Address range: 0xa144 - 0xa159
int32_t function_a144(void) {
    // 0xa144
    int32_t v1;
    int32_t v2 = v1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xa148
    g4 = v2;
    int32_t result = v2; // 0xa158
    if (v2 != 0) {
        // bb
        result = function_a181();
        // branch -> 0xa151
    }
    // 0xa151
    return result;
}

// Address range: 0xa160 - 0xa181
int32_t function_a160(int32_t a1) {
    int32_t v1 = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xa164
    g4 = v1;
    if (v1 != 0) {
        // bb
        g4 = function_a181();
        // branch -> 0xa16d
    }
    // 0xa16d
    return function_14090(g10, g6);
}

// Address range: 0xa181 - 0xa182
int32_t function_a181(void) {
    // 0xa181
    return g4;
}

// Address range: 0xa190 - 0xa1ab
int32_t _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE20disconnect_all_slotsEv(int32_t a1) {
    // 0xa190
    return 0;
}

// Address range: 0xa1cc - 0xa240
int32_t function_a1cc(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)-0x7aebdbbc; // 0xa1cc
    *v1 = *v1 - 1;
    int32_t v2 = g4; // 0xa1d7
    int32_t result2; // 0xa23f
    if (v2 == 0) {
        // 0xa23a
        result2 = function_d806();
        // branch -> 0xa23f
    } else {
        // branch -> 0xa20b
        while (true) {
            // 0xa20b
            int32_t v3;
            if (v2 == v3) {
                int32_t v4 = 0; // bp+24
                function_e660(&v4);
                int32_t result = a2 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xa21f
                if (result == 0) {
                    // 0xa228
                    return result;
                }
                // 0xa23f
                return result;
            }
            int32_t v5 = *(int32_t *)(v2 + 8); // 0xa1e0
            if (v5 != 0) {
                // 0xa1e7
                *(char *)(v5 + 4) = 0;
                g4 = (int32_t)a1;
                if (a1 == NULL) {
                    // 0xa22e
                    g4 = function_d79e(v5);
                    // branch -> 0xa235
                    // 0xa235
                    g4 = function_d7d2();
                    // branch -> 0xa23a
                    // 0xa23a
                    result2 = function_d806();
                    // branch -> 0xa23f
                    // 0xa23f
                    return result2;
                }
                int32_t v6 = *a1; // 0xa205
                g4 = v6;
                if (v6 == 0) {
                    // break -> 0xa23a
                    break;
                }
                v2 = *(int32_t *)v2;
                v3 = v6;
                // continue -> 0xa20b
                continue;
            }
            // 0xa235
            g4 = function_d7d2();
            // branch -> 0xa23a
            // 0xa23a
            result2 = function_d806();
            // branch -> 0xa23f
            // 0xa23f
            return result2;
        }
        // 0xa23a
        result2 = function_d806();
        // branch -> 0xa23f
    }
    // 0xa23f
    return result2;
}

// Address range: 0xa246 - 0xa247
int32_t function_a246(void) {
    // 0xa246
    return 0;
}

// Address range: 0xa260 - 0xa2b1
// From class:    N5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEE
// Type:          constructor
int32_t _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = *(int32_t *)(v1 + 4); // 0xa274
    g4 = v2;
    *a1 = (int32_t)&g54;
    int32_t result2; // 0xa2ac
    if (v2 == 0) {
        // 0xa2ac
        result2 = function_d90a((int32_t *)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0xa2b1
    } else {
        // 0xa281
        unknown_143f0(v2);
        int32_t v3 = v1 + 8; // 0xa289
        g4 = v3;
        function_e730(v3);
        int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // eax
        *(int32_t *)g6 = (int32_t)&g55;
        if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
            // 0xa2a7
            return result;
        }
        // 0xa281
        result2 = result;
        // branch -> 0xa2b1
    }
    // 0xa2b1
    return result2;
}

// Address range: 0xa2b6 - 0xa2b7
int32_t function_a2b6(void) {
    // 0xa2b6
    return g4;
}

// Address range: 0xa2c3 - 0xa2d9
int32_t function_a2c3(int32_t a1) {
    int32_t * v1 = (int32_t *)(g5 + 0x44890853); // 0xa2c3
    *v1 = *v1 - 1;
    g4 = 0;
    function_e730(0);
    g4 = a1;
    return function_a2b6();
}

// Address range: 0xa2e0 - 0xa32f
// From class:    N5boost8signals26signalIFvP15CCryptoKeyStoreENS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIS4_EENS9_IFvRKNS0_10connectionES3_EEENS0_5mutexEEE
// Type:          constructor
int32_t _ZN5boost8signals26signalIFvP15CCryptoKeyStoreENS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIS4_EENS9_IFvRKNS0_10connectionES3_EEENS0_5mutexEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g4 = *(int32_t *)(v1 + 4);
    *a1 = (int32_t)&g54;
    int32_t v2 = g4; // 0xa2fd
    int32_t v3 = v2; // 0xa301
    if (v2 == 0) {
        // bb
        v3 = function_a334((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0xa301
    }
    // 0xa301
    unknown_14470(v3);
    function_e7b0(v1 + 8);
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    *(int32_t *)v1 = (int32_t)&g55;
    int32_t result; // 0xa32e
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb105
        result = function_a339();
        // branch -> 0xa327
    } else {
        // 0xa301
        result = g4;
        // branch -> 0xa327
    }
    // 0xa327
    return result;
}

// Address range: 0xa334 - 0xa339
int32_t function_a334(int32_t a1) {
    // 0xa334
    return g4;
}

// Address range: 0xa339 - 0xa33a
int32_t function_a339(void) {
    // 0xa339
    return g4;
}

// Address range: 0xa33e - 0xa33f
int32_t function_a33e(void) {
    // 0xa33e
    return g4;
}

// Address range: 0xa34b - 0xa361
int32_t function_a34b(int32_t a1) {
    int32_t * v1 = (int32_t *)0x44890853; // 0xa34b
    *v1 = *v1 - 1;
    function_e7b0(0);
    g4 = a1;
    return function_a33e();
}

// Address range: 0xa370 - 0xa3bf
// From class:    N5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEE
// Type:          constructor
int32_t _ZN5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g4 = *(int32_t *)(v1 + 4);
    *a1 = (int32_t)&g54;
    int32_t v2 = g4; // 0xa38d
    int32_t v3 = v2; // 0xa391
    if (v2 == 0) {
        // bb
        v3 = function_a3c4((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0xa391
    }
    // 0xa391
    unknown_14500(v3);
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    *(int32_t *)v1 = (int32_t)&g55;
    int32_t result; // 0xa3be
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb105
        result = function_a3c9(v1 + 8);
        // branch -> 0xa3b7
    } else {
        // 0xa391
        result = g4;
        // branch -> 0xa3b7
    }
    // 0xa3b7
    return result;
}

// Address range: 0xa3c4 - 0xa3c9
int32_t function_a3c4(int32_t a1) {
    // 0xa3c4
    return function_da1a();
}

// Address range: 0xa3c9 - 0xa3ca
int32_t function_a3c9(int32_t a1) {
    // 0xa3c9
    return g4;
}

// Address range: 0xa3ce - 0xa3cf
int32_t function_a3ce(int32_t a1) {
    // 0xa3ce
    return g4;
}

// Address range: 0xa3db - 0xa3f1
int32_t function_a3db(int32_t a1) {
    int32_t * v1 = (int32_t *)0x44890853; // 0xa3db
    *v1 = *v1 - 1;
    g4 = a1;
    return function_a3ce(0);
}

// Address range: 0xa400 - 0xa451
// From class:    N5boost8signals26signalIFvP15CCryptoKeyStoreENS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIS4_EENS9_IFvRKNS0_10connectionES3_EEENS0_5mutexEEE
// Type:          constructor
int32_t _ZN5boost8signals26signalIFvP15CCryptoKeyStoreENS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIS4_EENS9_IFvRKNS0_10connectionES3_EEENS0_5mutexEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g6 = v1;
    int32_t v2 = *(int32_t *)(v1 + 4); // 0xa414
    g4 = v2;
    *a1 = (int32_t)&g54;
    int32_t result2; // 0xa44c
    if (v2 == 0) {
        // 0xa44c
        result2 = function_daaa((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        // branch -> 0xa451
    } else {
        // 0xa421
        unknown_14590(v2);
        int32_t v3 = g6 + 8; // 0xa429
        g4 = v3;
        function_e8d0(v3);
        int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // eax
        *(int32_t *)g6 = (int32_t)&g55;
        if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
            // 0xa447
            return result;
        }
        // 0xa421
        result2 = result;
        // branch -> 0xa451
    }
    // 0xa451
    return result2;
}

// Address range: 0xa456 - 0xa457
int32_t function_a456(void) {
    // 0xa456
    return g4;
}

// Address range: 0xa463 - 0xa479
int32_t function_a463(int32_t a1) {
    int32_t * v1 = (int32_t *)0x44890853; // 0xa463
    *v1 = *v1 - 1;
    g4 = 0;
    function_e8d0(g9);
    g4 = a1;
    return function_a456();
}

// Address range: 0xa480 - 0xa4ed
// From class:    N5boost8signals27signal1IvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS3_EEENS8_IFvRKNS0_10connectionES3_EEENS0_5mutexEEE
// Type:          constructor
// Demangled:     CCryptoKeyStore::~CCryptoKeyStore()
int32_t _ZN15CCryptoKeyStoreD1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g6 = v1;
    g4 = *(int32_t *)(v1 + (int32_t)&g33);
    *a1 = (int32_t)&g44;
    *(int32_t *)(g6 + (int32_t)&g32) = (int32_t)&g54;
    int32_t v2 = g4; // 0xa4ac
    int32_t v3 = v2; // 0xa4b4
    if (v2 == 0) {
        // bb
        v3 = function_a588((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0, g8);
        // branch -> 0xa4b4
    }
    // 0xa4b4
    unknown_14610(v3);
    int32_t v4 = function_e950(g6 + (int32_t)&g35); // eax
    int32_t v5 = g6; // 0xa4ca
    *(int32_t *)(v5 + (int32_t)&g32) = (int32_t)&g55;
    int32_t result; // 0xa4ea
    if (*(int32_t *)(v5 + 160) == 0) {
        // bb109
        result = function_a50e();
        // branch -> 0xa4e4
    } else {
        // 0xa4b4
        result = v4;
        // branch -> 0xa4e4
    }
    // 0xa4e4
    return result;
}

// Address range: 0xa50e - 0xa55c
// From class:    CBasicKeyStore
// Type:          constructor
int32_t function_a50e(void) {
    int32_t v1 = g6; // 0xa50e
    int32_t v2 = *(int32_t *)(v1 + (int32_t)"D$\f m"); // 0xa50e
    unknown_13850(v1 + (int32_t)&g28, v2);
    int32_t v3 = g6; // 0xa526
    *(int32_t *)v3 = (int32_t)&g43;
    unknown_13650(g6 + 112, *(int32_t *)(v3 + (int32_t)&g23));
    int32_t v4 = g6; // 0xa53e
    unknown_135c0(v4 + (int32_t)&g20, *(int32_t *)(v4 + 96));
    *(int32_t *)g6 = (int32_t)&g42;
    return g6 + 4;
}

// Address range: 0xa560 - 0xa567
int32_t function_a560(void) {
    // 0xa560
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x7c8f8a40); // 0xa560
    *v2 = *v2 + 1;
    return 0;
}

// Address range: 0xa56f - 0xa588
int32_t function_a56f(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)-0x74c28a40; // 0xa56f
    *v1 = *v1 + 1;
    int32_t v2 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xa578
    g4 = v2;
    int32_t result = v2; // 0xa587
    if (v2 != 0) {
        // bb
        result = function_a5ac();
        // branch -> 0xa581
    }
    // 0xa581
    return result;
}

// Address range: 0xa588 - 0xa5a7
int32_t function_a588(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xa588
    return g4;
}

// Address range: 0xa5ac - 0xa5ad
int32_t function_a5ac(void) {
    // 0xa5ac
    return g4;
}

// Address range: 0xa609 - 0xa60a
int32_t function_a609(void) {
    // 0xa609
    return g4;
}

// Address range: 0xa621 - 0xa622
int32_t function_a621(void) {
    // 0xa621
    return g4;
}

// Address range: 0xa649 - 0xa64d
int32_t function_a649(void) {
    // 0xa649
    return function_a621();
}

// Address range: 0xa65f - 0xa663
int32_t function_a65f(void) {
    // 0xa65f
    return function_a609();
}

// Address range: 0xa670 - 0xa6a1
// Demangled:     CCryptoKeyStore::~CCryptoKeyStore()
int32_t _ZN15CCryptoKeyStoreD0Ev(int32_t a1) {
    // 0xa670
    unknown_14af0(a1);
    g4 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    int32_t result = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xa6a0
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb
        result = function_a6a6();
        // branch -> 0xa699
    }
    // 0xa699
    return result;
}

// Address range: 0xa6a6 - 0xa6a7
int32_t function_a6a6(void) {
    // 0xa6a6
    return g4;
}

// Address range: 0xa6b0 - 0xa6fd
// Demangled:     std::_Rb_tree<unsigned int, std::pair<unsigned int const, int>, std::_Select1st<std::pair<unsigned int const, int> >, std::less<unsigned int>, std::allocator<std::pair<unsigned int const, int> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<unsigned int const, int> const &)
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE10_M_insert_EPKSt18_Rb_tree_node_baseSB_RKS2_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0xa6b0
    g4 = a3;
    g8 = a4;
    g5 = a5;
    int32_t result = a3; // 0xa6f6
    if (a3 == 0) {
        // bb
        result = function_a768(a2 + 4, 1);
        // branch -> 0xa6f6
    }
    // 0xa6f6
    return result;
}

// Address range: 0xa732 - 0xa762
int32_t function_a732(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7ce3dbbc; // 0xa732
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0xa739
    int32_t result = 0; // esi
    *(int32_t *)result = (v2 + 1 + (int32_t)false) % 256 | v2 & -256;
    g4 = result;
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_a780();
        // branch -> 0xa74c
    }
    // 0xa74c
    return result;
}

// Address range: 0xa768 - 0xa780
int32_t function_a768(int32_t a1, int32_t a2) {
    // 0xa768
    return g4;
}

// Address range: 0xa780 - 0xa781
int32_t function_a780(void) {
    // 0xa780
    return g4;
}

// Address range: 0xa790 - 0xa828
// Demangled:     std::_Rb_tree<unsigned int, std::pair<unsigned int const, int>, std::_Select1st<std::pair<unsigned int const, int> >, std::less<unsigned int>, std::allocator<std::pair<unsigned int const, int> > >::_M_insert_unique(std::pair<unsigned int const, int> const &)
int32_t _ZNSt8_Rb_treeIjSt4pairIKjiESt10_Select1stIS2_ESt4lessIjESaIS2_EE16_M_insert_uniqueERKS2_(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    g8 = a2;
    g6 = v1;
    int32_t result = *(int32_t *)(a2 + 8); // 0xa7af
    g10 = result;
    int32_t v2; // 0xa817
    if (result == 0) {
        // 0xa817
        v2 = a2 + 4;
        g10 = v2;
        // branch -> 0xa820
    } else {
        uint32_t v3 = *(int32_t *)a3; // 0xa7be
        // branch -> 0xa7d6
        while (true) {
            uint32_t v4 = *(int32_t *)(result + (int32_t)&g13); // 0xa7d6
            int32_t v5; // 0xa7f8
            int32_t result3; // 0xa809
            int32_t v6; // 0xa7f8
            int32_t v7; // 0xa7f6
            int32_t result4; // 0xa80b
            int32_t result2; // 0xa823
            int32_t v8; // 0xa7c8
            if (v4 > v3) {
                // 0xa7c8
                v8 = *(int32_t *)(result + 8);
                if (v8 == 0) {
                    // 0xa820
                    if (result != *(int32_t *)(a2 + (int32_t)&g37)) {
                        // 0xa825
                        return result;
                    }
                    // bb128
                    result2 = function_a840(v4);
                    // branch -> 0xa825
                    // 0xa825
                    return result2;
                    // 0xa7f2
                    v6 = v1;
                    v5 = result;
                    if (v4 < v3) {
                        // bb
                        v7 = function_a840(v4);
                        v6 = g6;
                        v5 = v7;
                        // branch -> 0xa7f8
                    }
                    // 0xa7f8
                    *(int32_t *)v6 = v5;
                    *(char *)(g6 + 4) = 0;
                    result3 = g6;
                    g4 = result3;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                        // 0xa80d
                        return result3;
                    }
                    // bb126
                    result4 = function_a873();
                    // branch -> 0xa80d
                    // 0xa80d
                    return result4;
                }
            } else {
                int32_t v9 = *(int32_t *)(result + (int32_t)&g37); // 0xa7dd
                if (v9 == 0) {
                    // 0xa7f2
                    v6 = v1;
                    v5 = result;
                    if (v4 < v3) {
                        // bb
                        v7 = function_a840(v4);
                        v6 = g6;
                        v5 = v7;
                        // branch -> 0xa7f8
                    }
                    // 0xa7f8
                    *(int32_t *)v6 = v5;
                    *(char *)(g6 + 4) = 0;
                    result3 = g6;
                    g4 = result3;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                        // 0xa80d
                        return result3;
                    }
                    // bb126
                    result4 = function_a873();
                    // branch -> 0xa80d
                    // 0xa80d
                    return result4;
                }
                v8 = v9;
            }
            // 0xa7d4
            g10 = v8;
            result = v8;
            // branch -> 0xa7d6
        }
    }
    int32_t result5 = 0; // 0xa825
    if (v2 == *(int32_t *)(a2 + (int32_t)&g37)) {
        // bb128
        int32_t v10;
        result5 = function_a840(v10);
        // branch -> 0xa825
    }
    // 0xa825
    return result5;
}

// Address range: 0xa840 - 0xa873
int32_t function_a840(int32_t result) {
    // 0xa840
    int32_t v1; // bp+44
    unknown_14e40((int32_t)&v1, g8, 0, g10, result);
    *(char *)(g6 + 4) = 1;
    *(int32_t *)g6 = result;
    return result;
}

// Address range: 0xa873 - 0xa878
int32_t function_a873(void) {
    // 0xa873
    return g4;
}

// Address range: 0xa880 - 0xa8ae
// Demangled:     LockedPageManagerBase<MemoryPageLocker>::LockRange(void *, unsigned int)
int32_t _ZN21LockedPageManagerBaseI16MemoryPageLockerE9LockRangeEPvj(int32_t a1, int32_t a2, int32_t a3) {
    // 0xa880
    return a1 + 4;
}

// Address range: 0xa8b2 - 0xa940
int32_t function_a8b2(int32_t result, char a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = 0; // ebp
    int32_t * v2 = (int32_t *)(v1 - 0x337af040); // 0xa8b2
    *v2 = *v2 + 1;
    int32_t v3 = 0; // eax
    *(char *)v3 = (char)v3 + *(char *)&g4;
    char * v4 = (char *)(v1 + 0x2444c6ff); // 0xa8ba
    *v4 = (char)v3 + *v4;
    char v5 = *(char *)&g7 - (char)v3; // 0xa8c0
    *(char *)0 = v5;
    if (v5 == 0) {
        // 0xa939
        return result;
    }
    int32_t v6 = g10; // 0xa8c4
    int32_t v7 = *(int32_t *)(v6 + (int32_t)&g16); // 0xa8c4
    int32_t v8 = v1 & v7; // 0xa8cd
    int32_t v9 = v8; // ebx
    int32_t v10 = v1 - 1 & v7; // 0xa8cf
    if (v8 > v10) {
        // 0xa939
        return result;
    }
    // branch -> 0xa8e0
  lab_0xa8e0:
    while (true) {
        int32_t v11 = *(int32_t *)(v6 + 44); // 0xa8e0
        int32_t v12 = v8;
        int32_t v13 = v11; // 0xa8f97
        int32_t v14 = v6; // 0xa8e7
        if (v11 == 0) {
            // bb
            v12 = v9;
            v13 = function_a950();
            v14 = g10;
            // branch -> 0xa8e7
        }
        // branch -> 0xa8f9
      lab_0xa8f9:
        while (true) {
            int32_t v15 = v13; // 0xa8f0
            // branch -> 0xa8f9
            while (true) {
                // 0xa8f9
                int32_t v16; // edx
                int32_t v17; // 0xa905
                if (*(int32_t *)(v15 + 16) >= v12) {
                    // 0xa8f0
                    v16 = v15;
                    int32_t v18 = *(int32_t *)(v15 + 8); // 0xa8f2
                    if (v18 == 0) {
                        v17 = v15;
                        // break (via goto) -> 0xa905
                        goto lab_0xa905;
                    }
                    v13 = v18;
                    // continue (via goto) -> 0xa8f9
                    goto lab_0xa8f9;
                } else {
                    int32_t v19 = *(int32_t *)(v15 + 12); // 0xa8fe
                    if (v19 == 0) {
                        // break -> 0xa905
                        break;
                    }
                    v15 = v19;
                    // continue -> 0xa8f9
                    continue;
                }
              lab_0xa905:;
                int32_t v20 = v17; // 0xa909
                if (v17 == v14 + 40) {
                    // bb124
                    function_a950();
                    v12 = v9;
                    v20 = v16;
                    // branch -> 0xa909
                }
                int32_t v21 = v20; // 0xa90e
                if (*(int32_t *)(v20 + 16) > v12) {
                    // bb125
                    function_a950();
                    v21 = v16;
                    // branch -> 0xa90e
                }
                int32_t * v22 = (int32_t *)(v21 + 20); // 0xa90e
                *v22 = *v22 + 1;
                int32_t v23 = g10; // 0xa912
                int32_t v24 = *(int32_t *)(v23 + (int32_t)&g15); // 0xa912
                int32_t v25 = v24 + v9; // 0xa912
                v9 = v25;
                if (v10 < v25) {
                    // break (via goto) -> 0xa919
                    goto lab_0xa919;
                }
                v8 = v25;
                v6 = v23;
                // continue (via goto) -> 0xa8e0
                goto lab_0xa8e0;
            }
          lab_0xa919:
            // 0xa919
            if (a2 != 0) {
                // 0xa939
                return result;
            }
            int32_t result2 = a3 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xa924
            g4 = result2;
            if (result2 == 0) {
                // 0xa931
                return result2;
            }
            // bb126
            // branch -> 0xa931
            // 0xa931
            return function_a9c7();
        }
    }
}

// Address range: 0xa950 - 0xa95a
int32_t function_a950(void) {
    // 0xa950
    return *(int32_t *)(g10 + (int32_t)&g15);
}

// Address range: 0xa95e - 0xa987
int32_t function_a95e(void) {
    int32_t * v1 = (int32_t *)-0x76d3dbbc; // 0xa95e
    *v1 = *v1 - 1;
    return unknown_15010((int32_t)&g18);
}

// Address range: 0xa9a0 - 0xa9a1
int32_t function_a9a0(void) {
    // 0xa9a0
    return 0;
}

// Address range: 0xa9c7 - 0xa9c8
int32_t function_a9c7(void) {
    // 0xa9c7
    return g4;
}

// Address range: 0xa9d0 - 0xaa8f
// Demangled:     std::vector<unsigned char, secure_allocator<unsigned char> >::operator=(std::vector<unsigned char, secure_allocator<unsigned char> > const &)
int32_t _ZNSt6vectorIh16secure_allocatorIhEEaSERKS2_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    g8 = v1;
    g5 = a2;
    int32_t v2; // 0xaa33
    int32_t result; // 0xaa42
    if (v1 == a2) {
        // 0xaa28
        v2 = g8;
        g4 = v2;
        result = v2;
        if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
            // bb122
            result = function_ab8f();
            // branch -> 0xaa3b
        }
        // 0xaa3b
        return result;
    }
    int32_t v3 = *a1; // 0xa9ef
    int32_t v4 = *(int32_t *)(a2 + 4); // 0xa9f1
    g10 = v4;
    int32_t v5 = *(int32_t *)a2; // 0xa9f4
    uint32_t result2 = *(int32_t *)(v1 + 8) - v3; // 0xa9fe
    uint32_t v6 = v4 - v5; // 0xaa04
    g9 = v6;
    if (v6 > result2) {
        // 0xaa88
        return result2;
    }
    int32_t v7 = *(int32_t *)(v1 + 4); // 0xaa0a
    g7 = v7;
    uint32_t v8 = v7 - v3; // 0xaa0f
    if (v6 > v8) {
        int32_t v9 = v8 + v5; // 0xaa48
        if (v8 != 0) {
            // bb124
            function_ab48(v9, v3, v8);
            v4 = g10;
            // branch -> 0xaa5a
        }
        // 0xaa5a
        g4 = v9;
        int32_t v10 = v9; // 0xaa6c5
        if (v4 == v9) {
            int32_t v11 = function_ab86(); // 0xaa62
            g4 = v11;
            v10 = v11;
            // branch -> 0xaa68
        }
        int32_t v12 = g7; // 0xaa6f
        // branch -> 0xaa68
        while (true) {
            int32_t v13 = 0; // 0xaa74
            int32_t v14 = v10; // 0xaa71
            if (v12 != 0) {
                // 0xaa6c
                *(char *)v12 = *(char *)v10;
                v13 = g7;
                v14 = g4;
                // branch -> 0xaa71
            }
            int32_t v15 = v14 + 1; // 0xaa71
            g4 = v15;
            int32_t v16 = v13 + 1; // 0xaa74
            g7 = v16;
            if (v15 == g10) {
                // break -> 0xaa7b
                break;
            }
            v10 = v15;
            v12 = v16;
            // continue -> 0xaa68
        }
        int32_t v17 = g8; // 0xaa7b
        *(int32_t *)(v17 + 4) = *(int32_t *)v17 + v6;
        // branch -> 0xaa28
    } else {
        if (v6 != 0) {
            // bb
            function_ab20(v3);
            v1 = g8;
            // branch -> 0xaa1f
        }
        // 0xaa1f
        *(int32_t *)(v1 + 4) = v3;
        // branch -> 0xaa28
    }
    // 0xaa28
    v2 = g8;
    g4 = v2;
    result = v2;
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        // bb122
        result = function_ab8f();
        // branch -> 0xaa3b
    }
    // 0xaa3b
    return result;
}

// Address range: 0xab0e - 0xab1a
int32_t function_ab0e(void) {
    int32_t v1 = 0; // ebp
    int32_t v2 = 0; // edi
    *(int32_t *)v2 = v1;
    *(int32_t *)(v2 + 8) = v1;
    return 0;
}

// Address range: 0xab20 - 0xab43
int32_t function_ab20(int32_t result) {
    // 0xab20
    return result;
}

// Address range: 0xab48 - 0xab86
int32_t function_ab48(int32_t a1, int32_t a2, int32_t a3) {
    // 0xab48
    g7 = *(int32_t *)(g8 + 4);
    g10 = *(int32_t *)(g5 + 4);
    return g5;
}

// Address range: 0xab86 - 0xab8f
int32_t function_ab86(void) {
    // 0xab86
    return g4;
}

// Address range: 0xab8f - 0xab90
int32_t function_ab8f(void) {
    // 0xab8f
    return g4;
}

// Address range: 0xaba0 - 0xabd2
int32_t _ZNSt10_List_baseIN5boost10shared_ptrINS0_8signals26detail15connection_bodyISt4pairINS3_15slot_meta_groupENS0_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS0_8functionIFvSC_EEEEENS2_5mutexEEEEESaISJ_EED1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0xabb6
    if (v1 != (int32_t)a1) {
        // 0xabc2
        return unknown_f070(v1 + (int32_t)&g37);
    }
    // 0xabbc
    return function_abdb((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0, 0);
}

// Address range: 0xabdb - 0xabef
int32_t function_abdb(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xabdf
    if (result != 0) {
        // 0xabef
    }
    // 0xabe8
    return result;
}

// Address range: 0xac00 - 0xac89
// Demangled:     std::_Rb_tree<CKeyID, std::pair<CKeyID const, CKey>, std::_Select1st<std::pair<CKeyID const, CKey> >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, CKey> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<CKeyID const, CKey> const &)
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE10_M_insert_EPKSt18_Rb_tree_node_baseSD_RKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5) {
    int32_t v1 = (int32_t)a5;
    g9 = a4;
    g6 = v1;
    int32_t * v2 = (int32_t *)24; // 0xac4b
    if (a3 == 0) {
        int32_t v3 = function_ad08(a1, a4, 1); // 0xac36
        v1 = g6;
        v2 = (int32_t *)(v3 + 24);
        // branch -> 0xac3c
    }
    // 0xac3c
    g13 = *(int32_t *)v1;
    g14 = (char *)*(int32_t *)(v1 + 4);
    *v2 = *(int32_t *)(v1 + 8);
    int32_t v4 = g6; // 0xac63
    g15 = *(int32_t *)(v4 + (int32_t)&g37);
    int32_t v5 = *(int32_t *)(v4 + (int32_t)&g13); // 0xac69
    g16 = (int16_t *)v5;
    char v6 = *(char *)(v4 + (int32_t)&g14); // 0xac6f
    *(char *)&g18 = v6;
    unsigned char result = *(char *)(v4 + 21); // 0xac76
    *(char *)&g19 = result;
    return result;
}

// Address range: 0xace4 - 0xad06
int32_t function_ace4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7cebdbbc; // 0xace4
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0xaceb
    int32_t v3 = (v2 + 1 + (int32_t)false) % 256 | v2 & -256; // 0xaceb
    g4 = v3;
    *(int32_t *)v3 = 0;
    int32_t result; // 0xad03
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_ad2d();
        // branch -> 0xacfc
    } else {
        // 0xace4
        result = g4;
        // branch -> 0xacfc
    }
    // 0xacfc
    return result;
}

// Address range: 0xad08 - 0xad2d
int32_t function_ad08(int32_t a1, int32_t a2, int32_t a3) {
    // 0xad08
    return unknown_12fb0(g6, g9 + (int32_t)&g13);
}

// Address range: 0xad2d - 0xad2e
int32_t function_ad2d(void) {
    // 0xad2d
    return g4;
}

// Address range: 0xad48 - 0xad49
int32_t function_ad48(void) {
    // 0xad48
    return 0;
}

// Address range: 0xad60 - 0xadfc
// Demangled:     std::_Rb_tree<CKeyID, std::pair<CKeyID const, CKey>, std::_Select1st<std::pair<CKeyID const, CKey> >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, CKey> > >::_M_insert_unique(std::pair<CKeyID const, CKey> const &)
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE16_M_insert_uniqueERKS4_(int32_t * a1, int32_t a2, int32_t a3) {
    // 0xad60
    g8 = (int32_t)a1;
    g10 = a3;
    int32_t v1 = *(int32_t *)(a2 + 8); // 0xad7f
    g6 = v1;
    int32_t result2; // 0xadf9
    if (v1 != 0) {
        while (true) {
            int32_t result = unknown_13110(a3, v1 + (int32_t)&g13); // 0xada3
            int32_t v2 = g6; // 0xad90
            int32_t v3; // 0xad90
            if ((char)result != 0) {
                // 0xad90
                v3 = *(int32_t *)(v2 + 8);
                if (v3 == 0) {
                    // 0xadf0
                    // branch -> 0xadf0
                    // 0xadf0
                    if (v2 != *(int32_t *)(a2 + (int32_t)&g37)) {
                        // 0xadf9
                        return result;
                    }
                    // bb124
                    result2 = function_ae3b();
                    // branch -> 0xadf9
                    // 0xadf9
                    return result2;
                }
            } else {
                int32_t v4 = *(int32_t *)(v2 + (int32_t)&g37); // 0xadac
                if (v4 == 0) {
                    // 0xadb3
                    if ((char)unknown_13110(v2 + (int32_t)&g13, g10) != 0) {
                        // bb
                        function_ae08();
                        // branch -> 0xadcc
                    }
                    // 0xadcc
                    *(int32_t *)g8 = v2;
                    *(char *)(g8 + 4) = 0;
                    int32_t result3 = g8; // 0xaddd
                    g4 = result3;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                        // 0xade1
                        return result3;
                    }
                    // bb121
                    // branch -> 0xade1
                    // 0xade1
                    return function_ae51();
                }
                v3 = v4;
            }
            // 0xad97
            g6 = v3;
            a3 = g10;
            v1 = v3;
            // branch -> 0xad99
        }
    }
    // 0xadf0
    result2 = 0;
    if (a2 + 4 == *(int32_t *)(a2 + (int32_t)&g37)) {
        // bb124
        result2 = function_ae3b();
        // branch -> 0xadf9
    }
    // 0xadf9
    return result2;
}

// Address range: 0xae01 - 0xae05
int32_t function_ae01(void) {
    // 0xae01
    return 0;
}

// Address range: 0xae08 - 0xae3b
int32_t function_ae08(void) {
    // 0xae08
    int32_t v1; // bp+44
    int32_t result = &v1; // 0xae0c
    int32_t v2;
    unknown_15960(result, v2, 0, g6, g10);
    *(char *)(g8 + 4) = 1;
    *(int32_t *)g8 = result;
    return result;
}

// Address range: 0xae3b - 0xae51
int32_t function_ae3b(void) {
    // 0xae3b
    int32_t v1; // bp+44
    return &v1;
}

// Address range: 0xae51 - 0xae52
int32_t function_ae51(void) {
    // 0xae51
    return g4;
}

// Address range: 0xae60 - 0xaec7
// Demangled:     std::_Rb_tree<CKeyID, std::pair<CKeyID const, CKey>, std::_Select1st<std::pair<CKeyID const, CKey> >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, CKey> > >::_M_insert_unique_(std::_Rb_tree_const_iterator<std::pair<CKeyID const, CKey> >, std::pair<CKeyID const, CKey> const &)
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_4CKeyESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS4_ERKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xae60
    g5 = a2;
    g6 = a3;
    g10 = a1;
    g8 = a4;
    int32_t v1 = a3; // 0xae9a
    if (a2 + 4 == a3) {
        // bb
        function_afb0((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        a4 = g8;
        v1 = g6;
        // branch -> 0xae9a
    }
    int32_t v2 = unknown_13210(a4); // 0xaea8
    g9 = v1 + (int32_t)&g13;
    if ((char)v2 == 0) {
        // bb115
        function_af40();
        // branch -> 0xaeb9
    }
    int32_t v3 = *(int32_t *)(g5 + (int32_t)&g37); // 0xaeb9
    g4 = v3;
    int32_t result = v3; // 0xaec4
    if (v3 == g6) {
        // bb116
        result = function_b036();
        // branch -> 0xaec4
    }
    // 0xaec4
    return result;
}

// Address range: 0xaecb - 0xaed4
int32_t function_aecb(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb84; // 0xaecb
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xaf13 - 0xaf3c
int32_t function_af13(void) {
    int32_t result = g10; // 0xaf1e
    g4 = result;
    int32_t v1;
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_b060();
        // branch -> 0xaf26
    }
    // 0xaf26
    return result;
}

// Address range: 0xaf40 - 0xaf62
int32_t function_af40(void) {
    // 0xaf40
    if ((char)unknown_13210(g9) == 0) {
        // bb
        function_aff8();
        // branch -> 0xaf54
    }
    int32_t v1 = *(int32_t *)(g5 + (int32_t)&g13); // 0xaf54
    g4 = v1;
    int32_t result = v1; // 0xaf5f
    if (v1 == g6) {
        // bb4
        result = function_b056();
        // branch -> 0xaf5f
    }
    // 0xaf5f
    return result;
}

// Address range: 0xaf66 - 0xafaf
int32_t function_af66(void) {
    int32_t * v1 = (int32_t *)-0x3d76dbc4; // 0xaf66
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0xaf73
    unknown_13210((int32_t)&g13);
    int32_t v3 = *(int32_t *)(int32_t)&g37; // 0xaf84
    g4 = v3;
    int32_t v4 = v2; // 0xaf93
    if (v3 == 0) {
        // bb
        function_b030(0);
        v4 = v2;
        // branch -> 0xaf93
    }
    // 0xaf93
    unknown_15a60(g10, v4, v4);
    return function_af13();
}

// Address range: 0xafb0 - 0xaff2
int32_t function_afb0(int32_t a1) {
    // 0xafb0
    int32_t v1; // bp+40
    if (*(int32_t *)(g5 + (int32_t)&g14) == 0) {
        // 0xafd0
        unknown_15bc0((int32_t)&v1, g8);
        *(int32_t *)g10 = a1;
        return function_af13();
    }
    int32_t v2 = *(int32_t *)(g5 + (int32_t)&g13); // 0xafb7
    g6 = v2;
    if ((char)unknown_13210(v2 + (int32_t)&g13) != 0) {
        // bb
        function_b000();
        // branch -> 0xafd0
    }
    // 0xafd0
    unknown_15bc0((int32_t)&v1, g8);
    *(int32_t *)g10 = a1;
    return function_af13();
}

// Address range: 0xaff8 - 0xafff
int32_t function_aff8(void) {
    // 0xaff8
    *(int32_t *)g10 = g6;
    return function_af13();
}

// Address range: 0xb000 - 0xb024
int32_t function_b000(void) {
    // 0xb000
    unknown_15a60(g10, 0, g6);
    return function_af13();
}

// Address range: 0xb028 - 0xb02e
int32_t function_b028(void) {
    // 0xb028
    return 0;
}

// Address range: 0xb030 - 0xb036
int32_t function_b030(int32_t a1) {
    // 0xb030
    return g4;
}

// Address range: 0xb036 - 0xb056
int32_t function_b036(void) {
    int32_t v1 = g4; // 0xb03a
    unknown_15a60(g10, v1, v1);
    return function_af13();
}

// Address range: 0xb056 - 0xb060
int32_t function_b056(void) {
    // 0xb056
    return g4;
}

// Address range: 0xb060 - 0xb061
int32_t function_b060(void) {
    // 0xb060
    return g4;
}

// Address range: 0xb070 - 0xb107
// Demangled:     std::map<CKeyID, CKey, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, CKey> > >::operator[](CKeyID const &)
int32_t _ZNSt3mapI6CKeyID4CKeySt4lessIS0_ESaISt4pairIKS0_S1_EEEixERS5_(int32_t a1) {
    // 0xb070
    g10 = a1;
    int32_t v1 = *(int32_t *)(a1 + 8); // 0xb094
    int32_t v2 = v1; // edi
    int32_t v3 = a1 + 4; // 0xb097
    g6 = v3;
    if (v1 == 0) {
        // 0xb0ee
        return 0;
    }
    int32_t v4;
    int32_t v5; // 0xb0bf
    while (true) {
        // 0xb0b1
        v5 = unknown_13420(v1 + (int32_t)&g13, v4);
        int32_t v6 = v2; // 0xb0a8
        if ((char)v5 == 0) {
            // 0xb0a8
            g6 = v6;
            int32_t v7 = *(int32_t *)(v6 + 8); // 0xb0aa
            v2 = v7;
            if (v7 == 0) {
                // break -> 0xb0cf
                break;
            }
            v1 = v7;
            // continue -> 0xb0b1
            continue;
        } else {
            int32_t v8 = *(int32_t *)(v6 + (int32_t)&g37); // 0xb0c8
            v2 = v8;
            if (v8 == 0) {
                // break -> 0xb0c8
                break;
            }
            v1 = v8;
            // continue -> 0xb0b1
            continue;
        }
    }
    int32_t v9 = g6; // 0xb0d7
    // branch -> 0xb0cf
    // 0xb0cf
    int32_t result; // 0xb103
    if (v9 != v3) {
        // 0xb0d3
        result = unknown_13420(v4, v9 + (int32_t)&g13);
        // branch -> 0xb0ee
    } else {
        result = v5;
    }
    // 0xb0ee
    return result;
}

// Address range: 0xb237 - 0xb238
int32_t function_b237(void) {
    // 0xb237
    return 0;
}

// Address range: 0xb238 - 0xb239
int32_t function_b238(void) {
    // 0xb238
    return g4;
}

// Address range: 0xb24b - 0xb25c
int32_t function_b24b(void) {
    int32_t * v1 = (int32_t *)0x24448dc3; // 0xb24b
    *v1 = *v1 - 1;
    g4 = unknown_13b40();
    return function_b238();
}

// Address range: 0xb260 - 0xb2ac
// Demangled:     std::_Rb_tree<CScriptID, std::pair<CScriptID const, CScript>, std::_Select1st<std::pair<CScriptID const, CScript> >, std::less<CScriptID>, std::allocator<std::pair<CScriptID const, CScript> > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<CScriptID const, CScript> const &)
int32_t _ZNSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE10_M_insert_EPKSt18_Rb_tree_node_baseSD_RKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0xb260
    g8 = a5;
    int32_t result = a3; // 0xb2a5
    if (a3 == 0) {
        // bb
        result = function_b388(a4, 1);
        // branch -> 0xb2a5
    }
    // 0xb2a5
    return result;
}

// Address range: 0xb2b5 - 0xb2b6
int32_t function_b2b5(void) {
    // 0xb2b5
    return 0;
}

// Address range: 0xb308 - 0xb309
int32_t function_b308(void) {
    // 0xb308
    return g4;
}

// Address range: 0xb353 - 0xb380
int32_t function_b353(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 + 0x144683e8); // 0xb353
    *v2 = *v2 - 1;
    int32_t v3 = 0; // ebx
    int32_t * v4 = (int32_t *)(v3 + 0x652c2454); // 0xb359
    *v4 = v1 + *v4;
    *(int32_t *)0 = v3;
    int32_t result; // 0xb37d
    if ((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" != 0) {
        // bb
        result = function_b3b1();
        // branch -> 0xb36a
    } else {
        // 0xb353
        result = g4;
        // branch -> 0xb36a
    }
    // 0xb36a
    return result;
}

// Address range: 0xb380 - 0xb384
int32_t function_b380(void) {
    // 0xb380
    g4 = 0;
    return function_b308();
}

// Address range: 0xb388 - 0xb3b1
int32_t function_b388(int32_t a1, int32_t a2) {
    // 0xb388
    return unknown_13610(g8, a1 + (int32_t)&g13);
}

// Address range: 0xb3b1 - 0xb3b2
int32_t function_b3b1(void) {
    // 0xb3b1
    return g4;
}

// Address range: 0xb3dd - 0xb3de
int32_t function_b3dd(void) {
    // 0xb3dd
    return 0;
}

// Address range: 0xb3f0 - 0xb48c
// Demangled:     std::_Rb_tree<CScriptID, std::pair<CScriptID const, CScript>, std::_Select1st<std::pair<CScriptID const, CScript> >, std::less<CScriptID>, std::allocator<std::pair<CScriptID const, CScript> > >::_M_insert_unique(std::pair<CScriptID const, CScript> const &)
int32_t _ZNSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE16_M_insert_uniqueERKS4_(int32_t * a1, int32_t a2, int32_t a3) {
    // 0xb3f0
    g8 = (int32_t)a1;
    g10 = a3;
    int32_t v1 = *(int32_t *)(a2 + 8); // 0xb40f
    g6 = v1;
    int32_t result2; // 0xb489
    if (v1 != 0) {
        while (true) {
            int32_t result = unknown_137a0(a3, v1 + (int32_t)&g13); // 0xb433
            int32_t v2 = g6; // 0xb420
            int32_t v3; // 0xb420
            if ((char)result != 0) {
                // 0xb420
                v3 = *(int32_t *)(v2 + 8);
                if (v3 == 0) {
                    // 0xb480
                    // branch -> 0xb480
                    // 0xb480
                    if (v2 != *(int32_t *)(a2 + (int32_t)&g37)) {
                        // 0xb489
                        return result;
                    }
                    // bb124
                    result2 = function_b4cb();
                    // branch -> 0xb489
                    // 0xb489
                    return result2;
                }
            } else {
                int32_t v4 = *(int32_t *)(v2 + (int32_t)&g37); // 0xb43c
                if (v4 == 0) {
                    // 0xb443
                    if ((char)unknown_137a0(v2 + (int32_t)&g13, g10) != 0) {
                        // bb
                        function_b498();
                        // branch -> 0xb45c
                    }
                    // 0xb45c
                    *(int32_t *)g8 = v2;
                    *(char *)(g8 + 4) = 0;
                    int32_t result3 = g8; // 0xb46d
                    g4 = result3;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                        // 0xb471
                        return result3;
                    }
                    // bb121
                    // branch -> 0xb471
                    // 0xb471
                    return function_b4e1();
                }
                v3 = v4;
            }
            // 0xb427
            g6 = v3;
            a3 = g10;
            v1 = v3;
            // branch -> 0xb429
        }
    }
    // 0xb480
    result2 = 0;
    if (a2 + 4 == *(int32_t *)(a2 + (int32_t)&g37)) {
        // bb124
        result2 = function_b4cb();
        // branch -> 0xb489
    }
    // 0xb489
    return result2;
}

// Address range: 0xb491 - 0xb495
int32_t function_b491(void) {
    // 0xb491
    return 0;
}

// Address range: 0xb498 - 0xb4cb
int32_t function_b498(void) {
    // 0xb498
    int32_t v1; // bp+44
    int32_t result = &v1; // 0xb49c
    int32_t v2;
    unknown_16650(result, v2, 0, g6, g10);
    *(char *)(g8 + 4) = 1;
    *(int32_t *)g8 = result;
    return result;
}

// Address range: 0xb4cb - 0xb4e1
int32_t function_b4cb(void) {
    // 0xb4cb
    int32_t v1; // bp+44
    return &v1;
}

// Address range: 0xb4e1 - 0xb4e2
int32_t function_b4e1(void) {
    // 0xb4e1
    return g4;
}

// Address range: 0xb4f0 - 0xb557
// Demangled:     std::_Rb_tree<CScriptID, std::pair<CScriptID const, CScript>, std::_Select1st<std::pair<CScriptID const, CScript> >, std::less<CScriptID>, std::allocator<std::pair<CScriptID const, CScript> > >::_M_insert_unique_(std::_Rb_tree_const_iterator<std::pair<CScriptID const, CScript> >, std::pair<CScriptID const, CScript> const &)
int32_t _ZNSt8_Rb_treeI9CScriptIDSt4pairIKS0_7CScriptESt10_Select1stIS4_ESt4lessIS0_ESaIS4_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS4_ERKS4_(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xb4f0
    g5 = a2;
    g6 = a3;
    g10 = a1;
    g8 = a4;
    int32_t v1 = a3; // 0xb52a
    if (a2 + 4 == a3) {
        // bb
        function_b640((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        a4 = g8;
        v1 = g6;
        // branch -> 0xb52a
    }
    int32_t v2 = unknown_138a0(a4); // 0xb538
    g9 = v1 + (int32_t)&g13;
    if ((char)v2 == 0) {
        // bb115
        function_b5d0();
        // branch -> 0xb549
    }
    int32_t v3 = *(int32_t *)(g5 + (int32_t)&g37); // 0xb549
    g4 = v3;
    int32_t result = v3; // 0xb554
    if (v3 == g6) {
        // bb116
        result = function_b6c6();
        // branch -> 0xb554
    }
    // 0xb554
    return result;
}

// Address range: 0xb55b - 0xb564
int32_t function_b55b(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb84; // 0xb55b
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xb5a3 - 0xb5cc
int32_t function_b5a3(void) {
    int32_t result = g10; // 0xb5ae
    g4 = result;
    int32_t v1;
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_b6f0();
        // branch -> 0xb5b6
    }
    // 0xb5b6
    return result;
}

// Address range: 0xb5d0 - 0xb5f2
int32_t function_b5d0(void) {
    // 0xb5d0
    if ((char)unknown_138a0(g9) == 0) {
        // bb
        function_b688();
        // branch -> 0xb5e4
    }
    int32_t v1 = *(int32_t *)(g5 + (int32_t)&g13); // 0xb5e4
    g4 = v1;
    int32_t result = v1; // 0xb5ef
    if (v1 == g6) {
        // bb4
        result = function_b6e6();
        // branch -> 0xb5ef
    }
    // 0xb5ef
    return result;
}

// Address range: 0xb5f6 - 0xb63f
int32_t function_b5f6(void) {
    int32_t * v1 = (int32_t *)-0x3d76dbc4; // 0xb5f6
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0xb603
    unknown_138a0((int32_t)&g13);
    int32_t v3 = *(int32_t *)(int32_t)&g37; // 0xb614
    g4 = v3;
    int32_t v4 = v2; // 0xb623
    if (v3 == 0) {
        // bb
        function_b6c0(0);
        v4 = v2;
        // branch -> 0xb623
    }
    // 0xb623
    unknown_16750(g10, v4, v4);
    return function_b5a3();
}

// Address range: 0xb640 - 0xb682
int32_t function_b640(int32_t a1) {
    // 0xb640
    int32_t v1; // bp+40
    if (*(int32_t *)(g5 + (int32_t)&g14) == 0) {
        // 0xb660
        unknown_168e0((int32_t)&v1, g8);
        *(int32_t *)g10 = a1;
        return function_b5a3();
    }
    int32_t v2 = *(int32_t *)(g5 + (int32_t)&g13); // 0xb647
    g6 = v2;
    if ((char)unknown_138a0(v2 + (int32_t)&g13) != 0) {
        // bb
        function_b690();
        // branch -> 0xb660
    }
    // 0xb660
    unknown_168e0((int32_t)&v1, g8);
    *(int32_t *)g10 = a1;
    return function_b5a3();
}

// Address range: 0xb688 - 0xb68f
int32_t function_b688(void) {
    // 0xb688
    *(int32_t *)g10 = g6;
    return function_b5a3();
}

// Address range: 0xb690 - 0xb6b4
int32_t function_b690(void) {
    // 0xb690
    unknown_16750(g10, 0, g6);
    return function_b5a3();
}

// Address range: 0xb6b8 - 0xb6be
int32_t function_b6b8(void) {
    // 0xb6b8
    return 0;
}

// Address range: 0xb6c0 - 0xb6c6
int32_t function_b6c0(int32_t a1) {
    // 0xb6c0
    return g4;
}

// Address range: 0xb6c6 - 0xb6e6
int32_t function_b6c6(void) {
    int32_t v1 = g4; // 0xb6ca
    unknown_16750(g10, v1, v1);
    return function_b5a3();
}

// Address range: 0xb6e6 - 0xb6f0
int32_t function_b6e6(void) {
    // 0xb6e6
    return g4;
}

// Address range: 0xb6f0 - 0xb6f1
int32_t function_b6f0(void) {
    // 0xb6f0
    return g4;
}

// Address range: 0xb700 - 0xb7f8
// Demangled:     std::map<CScriptID, CScript, std::less<CScriptID>, std::allocator<std::pair<CScriptID const, CScript> > >::operator[](CScriptID const &)
int32_t _ZNSt3mapI9CScriptID7CScriptSt4lessIS0_ESaISt4pairIKS0_S1_EEEixERS5_(int32_t a1) {
    // 0xb700
    g4 = 0;
    int32_t v1 = *(int32_t *)(a1 + 8); // 0xb71b
    g6 = v1;
    int32_t v2 = a1 + 4; // 0xb71e
    int32_t v3 = v1;
    if (v1 == 0) {
        // bb
        function_b825(v2);
        v3 = g6;
        // branch -> 0xb72d
    }
    // 0xb72d
    g8 = v2;
    // branch -> 0xb741
    while (true) {
        int32_t v4 = unknown_13ab0(v3 + (int32_t)&g13, g10); // 0xb74b
        int32_t v5 = g6; // 0xb738
        if ((char)v4 == 0) {
            // 0xb738
            g8 = v5;
            int32_t v6 = *(int32_t *)(v5 + 8); // 0xb73a
            g6 = v6;
            if (v6 == 0) {
                // break -> 0xb75b
                break;
            }
            v3 = v6;
            // continue -> 0xb741
            continue;
        } else {
            int32_t v7 = *(int32_t *)(v5 + (int32_t)&g37); // 0xb754
            g6 = v7;
            if (v7 == 0) {
                // break -> 0xb754
                break;
            }
            v3 = v7;
            // continue -> 0xb741
            continue;
        }
    }
    int32_t v8 = g8; // 0xb761
    // branch -> 0xb75b
    // 0xb75b
    if (v2 != v8) {
        // 0xb761
        if ((char)unknown_13ab0(g10, v8 + (int32_t)&g13) == 0) {
            // bb35
            function_b80d();
            // branch -> 0xb778
        }
    }
    int32_t v9 = g10; // 0xb778
    int32_t v10; // bp-64
    int32_t v11 = &v10; // 0xb77a
    v10 = *(int32_t *)v9;
    int32_t v12 = *(int32_t *)(v9 + (int32_t)&g13); // 0xb7c7
    int32_t v13; // bp-80
    unknown_16bf0((int32_t)&v13, g8, v11);
    g8 = v2;
    int32_t result = v12; // 0xb7f5
    if (v12 == 0) {
        // bb36
        result = function_b7fd();
        // branch -> 0xb7f5
    }
    // 0xb7f5
    return result;
}

// Address range: 0xb7fd - 0xb808
int32_t function_b7fd(void) {
    // 0xb7fd
    int32_t v1;
    int32_t result = v1; // 0xb805
    if (v1 == 0) {
        // bb
        result = function_b80d();
        // branch -> 0xb805
    }
    // 0xb805
    return result;
}

// Address range: 0xb80d - 0xb825
int32_t function_b80d(void) {
    int32_t result = g8 + (int32_t)&g18; // 0xb818
    g4 = result;
    int32_t v1;
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_b82e();
        // branch -> 0xb81d
    }
    // 0xb81d
    return result;
}

// Address range: 0xb825 - 0xb82e
int32_t function_b825(int32_t a1) {
    // 0xb825
    return g4;
}

// Address range: 0xb82e - 0xb82f
int32_t function_b82e(void) {
    // 0xb82e
    return g4;
}

// Address range: 0xb834 - 0xb835
int32_t function_b834(void) {
    // 0xb834
    return 0;
}

// Address range: 0xb860 - 0xb8a8
// Demangled:     std::_Rb_tree<CKeyID, std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > >, std::_Select1st<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > > >::_M_insert_(std::_Rb_tree_node_base const *, std::_Rb_tree_node_base const *, std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > const &)
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE10_M_insert_EPKSt18_Rb_tree_node_baseSH_RKS8_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = a4; // 0xb8a1
    if (a3 == 0) {
        // bb
        result = function_b990(a2, a1, a4, 1);
        // branch -> 0xb8a1
    }
    // 0xb8a1
    return result;
}

// Address range: 0xb8b1 - 0xb8b2
int32_t function_b8b1(void) {
    // 0xb8b1
    return 0;
}

// Address range: 0xb8e8 - 0xb8ea
int32_t function_b8e8(void) {
    // 0xb8e8
    return 0;
}

// Address range: 0xb905 - 0xb906
int32_t function_b905(int32_t a1) {
    // 0xb905
    return g4;
}

// Address range: 0xb919 - 0xb91c
int32_t function_b919(void) {
    // 0xb919
    return 0;
}

// Address range: 0xb956 - 0xb97c
int32_t function_b956(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 - 0x74efdbac); // 0xb956
    *v2 = *v2 - 1;
    g4 = 0;
    int32_t * v3 = (int32_t *)(int32_t)&g14; // 0xb95f
    *v3 = *v3 + 1;
    *(int32_t *)g4 = v1;
    int32_t result; // 0xb979
    if ((a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
        // bb
        result = function_b9bd();
        // branch -> 0xb972
    } else {
        // 0xb956
        result = g4;
        // branch -> 0xb972
    }
    // 0xb972
    return result;
}

// Address range: 0xb980 - 0xb98f
int32_t function_b980(void) {
    // 0xb980
    int32_t v1;
    return function_b905(v1);
}

// Address range: 0xb990 - 0xb9bd
int32_t function_b990(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xb990
    return unknown_13c10(a2 + (int32_t)&g13);
}

// Address range: 0xb9bd - 0xb9be
int32_t function_b9bd(void) {
    // 0xb9bd
    return g4;
}

// Address range: 0xb9d8 - 0xb9d9
int32_t function_b9d8(void) {
    // 0xb9d8
    return 0;
}

// Address range: 0xb9f0 - 0xba8c
// Demangled:     std::_Rb_tree<CKeyID, std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > >, std::_Select1st<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > > >::_M_insert_unique(std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > const &)
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE16_M_insert_uniqueERKS8_(int32_t * a1, int32_t a2, int32_t a3) {
    // 0xb9f0
    g8 = (int32_t)a1;
    g10 = a3;
    int32_t v1 = *(int32_t *)(a2 + 8); // 0xba0f
    g6 = v1;
    int32_t result2; // 0xba89
    if (v1 != 0) {
        while (true) {
            int32_t result = unknown_13da0(a3, v1 + (int32_t)&g13); // 0xba33
            int32_t v2 = g6; // 0xba20
            int32_t v3; // 0xba20
            if ((char)result != 0) {
                // 0xba20
                v3 = *(int32_t *)(v2 + 8);
                if (v3 == 0) {
                    // 0xba80
                    // branch -> 0xba80
                    // 0xba80
                    if (v2 != *(int32_t *)(a2 + (int32_t)&g37)) {
                        // 0xba89
                        return result;
                    }
                    // bb124
                    result2 = function_bacb();
                    // branch -> 0xba89
                    // 0xba89
                    return result2;
                }
            } else {
                int32_t v4 = *(int32_t *)(v2 + (int32_t)&g37); // 0xba3c
                if (v4 == 0) {
                    // 0xba43
                    if ((char)unknown_13da0(v2 + (int32_t)&g13, g10) != 0) {
                        // bb
                        function_ba98();
                        // branch -> 0xba5c
                    }
                    // 0xba5c
                    *(int32_t *)g8 = v2;
                    *(char *)(g8 + 4) = 0;
                    int32_t result3 = g8; // 0xba6d
                    g4 = result3;
                    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                        // 0xba71
                        return result3;
                    }
                    // bb121
                    // branch -> 0xba71
                    // 0xba71
                    return function_bae1();
                }
                v3 = v4;
            }
            // 0xba27
            g6 = v3;
            a3 = g10;
            v1 = v3;
            // branch -> 0xba29
        }
    }
    // 0xba80
    result2 = 0;
    if (a2 + 4 == *(int32_t *)(a2 + (int32_t)&g37)) {
        // bb124
        result2 = function_bacb();
        // branch -> 0xba89
    }
    // 0xba89
    return result2;
}

// Address range: 0xba91 - 0xba95
int32_t function_ba91(void) {
    // 0xba91
    return 0;
}

// Address range: 0xba98 - 0xbacb
int32_t function_ba98(void) {
    // 0xba98
    int32_t v1; // bp+44
    int32_t result = &v1; // 0xba9c
    int32_t v2;
    unknown_17250(result, v2, 0, g6, g10);
    *(char *)(g8 + 4) = 1;
    *(int32_t *)g8 = result;
    return result;
}

// Address range: 0xbacb - 0xbae1
int32_t function_bacb(void) {
    // 0xbacb
    int32_t v1; // bp+44
    return &v1;
}

// Address range: 0xbae1 - 0xbae2
int32_t function_bae1(void) {
    // 0xbae1
    return g4;
}

// Address range: 0xbaf0 - 0xbb57
// Demangled:     std::_Rb_tree<CKeyID, std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > >, std::_Select1st<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > > >::_M_insert_unique_(std::_Rb_tree_const_iterator<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > >, std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > const &)
int32_t _ZNSt8_Rb_treeI6CKeyIDSt4pairIKS0_S1_I7CPubKeySt6vectorIhSaIhEEEESt10_Select1stIS8_ESt4lessIS0_ESaIS8_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorIS8_ERKS8_(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xbaf0
    g5 = a2;
    g6 = a3;
    g10 = a1;
    g8 = a4;
    int32_t v1 = a3; // 0xbb2a
    if (a2 + 4 == a3) {
        // bb
        function_bc40((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        a4 = g8;
        v1 = g6;
        // branch -> 0xbb2a
    }
    int32_t v2 = unknown_13ea0(a4); // 0xbb38
    g9 = v1 + (int32_t)&g13;
    if ((char)v2 == 0) {
        // bb115
        function_bbd0();
        // branch -> 0xbb49
    }
    int32_t v3 = *(int32_t *)(g5 + (int32_t)&g37); // 0xbb49
    g4 = v3;
    int32_t result = v3; // 0xbb54
    if (v3 == g6) {
        // bb116
        result = function_bcc6();
        // branch -> 0xbb54
    }
    // 0xbb54
    return result;
}

// Address range: 0xbb5b - 0xbb64
int32_t function_bb5b(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb84; // 0xbb5b
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xbba3 - 0xbbcc
int32_t function_bba3(void) {
    int32_t result = g10; // 0xbbae
    g4 = result;
    int32_t v1;
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_bcf0();
        // branch -> 0xbbb6
    }
    // 0xbbb6
    return result;
}

// Address range: 0xbbd0 - 0xbbf2
int32_t function_bbd0(void) {
    // 0xbbd0
    if ((char)unknown_13ea0(g9) == 0) {
        // bb
        function_bc88();
        // branch -> 0xbbe4
    }
    int32_t v1 = *(int32_t *)(g5 + (int32_t)&g13); // 0xbbe4
    g4 = v1;
    int32_t result = v1; // 0xbbef
    if (v1 == g6) {
        // bb4
        result = function_bce6();
        // branch -> 0xbbef
    }
    // 0xbbef
    return result;
}

// Address range: 0xbbf6 - 0xbc3f
int32_t function_bbf6(void) {
    int32_t * v1 = (int32_t *)-0x3d76dbc4; // 0xbbf6
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0xbc03
    unknown_13ea0((int32_t)&g13);
    int32_t v3 = *(int32_t *)(int32_t)&g37; // 0xbc14
    g4 = v3;
    int32_t v4 = v2; // 0xbc23
    if (v3 == 0) {
        // bb
        function_bcc0(0);
        v4 = v2;
        // branch -> 0xbc23
    }
    // 0xbc23
    unknown_17350(g10, v4, v4);
    return function_bba3();
}

// Address range: 0xbc40 - 0xbc82
int32_t function_bc40(int32_t a1) {
    // 0xbc40
    int32_t v1; // bp+40
    if (*(int32_t *)(g5 + (int32_t)&g14) == 0) {
        // 0xbc60
        unknown_174e0((int32_t)&v1, g8);
        *(int32_t *)g10 = a1;
        return function_bba3();
    }
    int32_t v2 = *(int32_t *)(g5 + (int32_t)&g13); // 0xbc47
    g6 = v2;
    if ((char)unknown_13ea0(v2 + (int32_t)&g13) != 0) {
        // bb
        function_bc90();
        // branch -> 0xbc60
    }
    // 0xbc60
    unknown_174e0((int32_t)&v1, g8);
    *(int32_t *)g10 = a1;
    return function_bba3();
}

// Address range: 0xbc88 - 0xbc8f
int32_t function_bc88(void) {
    // 0xbc88
    *(int32_t *)g10 = g6;
    return function_bba3();
}

// Address range: 0xbc90 - 0xbcb4
int32_t function_bc90(void) {
    // 0xbc90
    unknown_17350(g10, 0, g6);
    return function_bba3();
}

// Address range: 0xbcb8 - 0xbcbe
int32_t function_bcb8(void) {
    // 0xbcb8
    return 0;
}

// Address range: 0xbcc0 - 0xbcc6
int32_t function_bcc0(int32_t a1) {
    // 0xbcc0
    return g4;
}

// Address range: 0xbcc6 - 0xbce6
int32_t function_bcc6(void) {
    int32_t v1 = g4; // 0xbcca
    unknown_17350(g10, v1, v1);
    return function_bba3();
}

// Address range: 0xbce6 - 0xbcf0
int32_t function_bce6(void) {
    // 0xbce6
    return g4;
}

// Address range: 0xbcf0 - 0xbcf1
int32_t function_bcf0(void) {
    // 0xbcf0
    return g4;
}

// Address range: 0xbd00 - 0xbe34
// Demangled:     std::map<CKeyID, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > >, std::less<CKeyID>, std::allocator<std::pair<CKeyID const, std::pair<CPubKey, std::vector<unsigned char, std::allocator<unsigned char> > > > > >::operator[](CKeyID const &)
int32_t _ZNSt3mapI6CKeyIDSt4pairI7CPubKeySt6vectorIhSaIhEEESt4lessIS0_ESaIS1_IKS0_S6_EEEixERS9_(int32_t a1, int32_t * a2) {
    // 0xbd00
    g4 = 0;
    g8 = (int32_t)a2;
    int32_t v1 = *(int32_t *)(a1 + 8); // 0xbd27
    int32_t v2 = v1; // esi
    int32_t v3 = a1 + 4; // 0xbd2a
    int32_t v4 = v1;
    if (v1 == 0) {
        // bb
        function_be6a(v3);
        v4 = v2;
        // branch -> 0xbd39
    }
    // 0xbd39
    g6 = v3;
    // branch -> 0xbd49
    while (true) {
        int32_t v5 = unknown_140b0(v4 + (int32_t)&g13, g8); // 0xbd53
        int32_t v6 = v2; // 0xbd40
        if ((char)v5 == 0) {
            // 0xbd40
            g6 = v6;
            int32_t v7 = *(int32_t *)(v6 + 8); // 0xbd42
            v2 = v7;
            if (v7 == 0) {
                // break -> 0xbd63
                break;
            }
            v4 = v7;
            // continue -> 0xbd49
            continue;
        } else {
            int32_t v8 = *(int32_t *)(v6 + (int32_t)&g37); // 0xbd5c
            v2 = v8;
            if (v8 == 0) {
                // break -> 0xbd5c
                break;
            }
            v4 = v8;
            // continue -> 0xbd49
            continue;
        }
    }
    int32_t v9 = g6; // 0xbd69
    // branch -> 0xbd63
    // 0xbd63
    if (v3 != v9) {
        // 0xbd69
        if ((char)unknown_140b0(g8, v9 + (int32_t)&g13) == 0) {
            // bb139
            function_be4c();
            // branch -> 0xbd80
        }
    }
    // 0xbd80
    int32_t v10; // bp-212
    int32_t v11 = &v10; // 0xbd99
    v10 = *(int32_t *)g8;
    int32_t v12 = &g74; // bp-112
    int32_t v13; // bp-192
    __asm_rep_movsd_memcpy((char *)&v13, (char *)&v12, (int32_t)&g13);
    int32_t v14; // bp-224
    unknown_177f0((int32_t)&v14, g6, v11);
    g6 = v3;
    int32_t v15;
    int32_t result = v15; // 0xbe31
    if (v15 == 0) {
        // bb142
        result = function_be39();
        // branch -> 0xbe31
    }
    // 0xbe31
    return result;
}

// Address range: 0xbe39 - 0xbe47
int32_t function_be39(void) {
    // 0xbe39
    int32_t v1;
    int32_t result = v1; // 0xbe44
    if (v1 == 0) {
        // bb
        result = function_be4c();
        // branch -> 0xbe44
    }
    // 0xbe44
    return result;
}

// Address range: 0xbe4c - 0xbe6a
int32_t function_be4c(void) {
    int32_t result = g6 + (int32_t)&g18; // 0xbe5a
    g4 = result;
    int32_t v1;
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_be73();
        // branch -> 0xbe5f
    }
    // 0xbe5f
    return result;
}

// Address range: 0xbe6a - 0xbe73
int32_t function_be6a(int32_t a1) {
    // 0xbe6a
    return g4;
}

// Address range: 0xbe73 - 0xbea0
int32_t function_be73(void) {
    // 0xbe73
    int32_t v1; // bp+128
    unknown_144d0((int32_t)&v1);
    int32_t v2; // bp+208
    return unknown_144d0((int32_t)&v2);
}

// Address range: 0xbea0 - 0xbee1
int32_t _ZNSt8_Rb_treeISt4pairIN5boost8signals26detail15slot_meta_groupENS1_8optionalIiEEES0_IKS7_St14_List_iteratorINS1_10shared_ptrINS3_15connection_bodyIS7_NS2_5slot1IvP15CCryptoKeyStoreNS1_8functionIFvSE_EEEEENS2_5mutexEEEEEEESt10_Select1stISN_ENS3_14group_key_lessIiSt4lessIiEEESaISN_EE8_M_eraseEPSt13_Rb_tree_nodeISN_E(int32_t a1, int32_t a2) {
    // 0xbea0
    if (a2 == 0) {
        // 0xbebe
        return function_beea((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0, 0);
    }
    int32_t result = unknown_17d40(a1, *(int32_t *)(a2 + (int32_t)&g37)); // 0xbecc
    char * v1 = (char *)(a2 + (int32_t)&g14); // 0xbed4
    if (*v1 != 0) {
        // 0xbeda
        *v1 = 0;
        // branch -> 0xbede
    }
    // 0xbede
    return result;
}

// Address range: 0xbeea - 0xbefe
int32_t function_beea(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xbeee
    if (result != 0) {
        // 0xbefe
    }
    // 0xbef7
    return result;
}

// Address range: 0xbf10 - 0xbf5a
// From class:    N5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEEE
// Type:          virtual member function
int32_t _ZN5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEE7disposeEv(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g37); // 0xbf26
    if (v1 == 0) {
        // bb
        function_bf80((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0, 0);
        // branch -> 0xbf2d
    }
    // 0xbf2d
    unknown_17db0(v1 + 8, *(int32_t *)(v1 + (int32_t)&g13));
    int32_t v2 = *(int32_t *)v1; // 0xbf3f
    if (v2 != v1) {
        // 0xbf4a
        return unknown_103e0(v2 + (int32_t)&g37);
    }
    // 0xbf45
    return function_bf63();
}

// Address range: 0xbf63 - 0xbf7a
int32_t function_bf63(void) {
    // 0xbf63
    int32_t v1;
    int32_t v2 = v1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xbf67
    g4 = v2;
    int32_t result = v2; // 0xbf79
    if (v2 != 0) {
        // bb
        result = function_bf94();
        // branch -> 0xbf70
    }
    // 0xbf70
    return result;
}

// Address range: 0xbf80 - 0xbf94
int32_t function_bf80(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xbf84
    g4 = v1;
    int32_t result = v1; // 0xbf93
    if (v1 != 0) {
        // bb
        result = function_bf94();
        // branch -> 0xbf8d
    }
    // 0xbf8d
    return result;
}

// Address range: 0xbf94 - 0xbf95
int32_t function_bf94(void) {
    // 0xbf94
    return g4;
}

// Address range: 0xbfa0 - 0xc000
int32_t _ZN5boost14checked_deleteINS_8signals26detail12signal1_implIvP15CCryptoKeyStoreNS1_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS5_EEENSA_IFvRKNS1_10connectionES5_EEENS1_5mutexEE16invocation_stateEEEvPT_(int32_t a1) {
    // 0xbfa0
    int32_t v1; // bp-60
    int32_t v2; // 0xbfe8
    int32_t result; // 0xbfec
    if (a1 == 0) {
        // 0xbfe8
        v2 = *(int32_t *)((int32_t)&v1 + 44);
        result = v2 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
        if (result == 0) {
            // 0xbff5
            return result;
        }
        // 0xbffa
        return result;
    }
    int32_t v3 = a1 + (int32_t)&g37; // 0xbfb8
    v1 = v3;
    unknown_10470(v3);
    int32_t v4 = a1 + 4; // 0xbfc3
    v1 = v4;
    unknown_10470(v4);
    if (((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
        int32_t result2 = (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xbffa
        // 0xbffa
        return result2;
    }
    // 0xbfdb
    // branch -> 0xbfe8
    // 0xbfe8
    int32_t v5;
    v2 = *(int32_t *)((int32_t)&v5 + 44);
    result = v2 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84";
    if (result == 0) {
        // 0xbff5
        return result;
    }
    // 0xbffa
    return result;
}

// Address range: 0xc006 - 0xc007
int32_t function_c006(void) {
    // 0xc006
    return 0;
}

// Address range: 0xc020 - 0xc06a
int32_t _ZN5boost14checked_deleteINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS2_15connection_bodyISt4pairINS2_15slot_meta_groupENS_8optionalIiEEENS1_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSF_EEEEENS1_5mutexEEEEEEEEEvPT_(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    if (a1 == NULL) {
        // bb
        function_c090((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84", 0, 0, 0);
        // branch -> 0xc03a
    }
    // 0xc03a
    unknown_17ec0(v1 + 8, *(int32_t *)(v1 + (int32_t)&g13));
    int32_t v2 = *a1; // 0xc04c
    if (v2 != v1) {
        // 0xc05a
        return unknown_104f0(v2 + (int32_t)&g37);
    }
    // 0xc052
    return function_c073();
}

// Address range: 0xc073 - 0xc08a
int32_t function_c073(void) {
    // 0xc073
    int32_t v1;
    int32_t v2 = v1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xc077
    g4 = v2;
    int32_t result = v2; // 0xc089
    if (v2 != 0) {
        // bb
        result = function_c0a4();
        // branch -> 0xc080
    }
    // 0xc080
    return result;
}

// Address range: 0xc090 - 0xc0a4
int32_t function_c090(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xc094
    g4 = v1;
    int32_t result = v1; // 0xc0a3
    if (v1 != 0) {
        // bb
        result = function_c0a4();
        // branch -> 0xc09d
    }
    // 0xc09d
    return result;
}

// Address range: 0xc0a4 - 0xc0a5
int32_t function_c0a4(void) {
    // 0xc0a4
    return g4;
}

// Address range: 0xc0b0 - 0xc0d6
int32_t _ZNSt8_Rb_treeISt4pairIN5boost8signals26detail15slot_meta_groupENS1_8optionalIiEEES0_IKS7_St14_List_iteratorINS1_10shared_ptrINS3_15connection_bodyIS7_NS2_5slot1IvP15CCryptoKeyStoreNS1_8functionIFvSE_EEEEENS2_5mutexEEEEEEESt10_Select1stISN_ENS3_14group_key_lessIiSt4lessIiEEESaISN_EE7_M_copyEPKSt13_Rb_tree_nodeISN_EPSX_(int32_t a1, int32_t a2, int32_t a3) {
    // 0xc0b0
    return 0;
}

// Address range: 0xc0da - 0xc159
int32_t function_c0da(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t * v2 = (int32_t *)(g6 + 0x4489f0f8); // 0xc0da
    *v2 = *v2 + 1;
    if (((char)0 & (char)&g15) != 0) {
        int32_t v3 = *(int32_t *)(g6 + (int32_t)&g13); // 0xc0e4
        g9 = v1;
        *(int32_t *)(v1 + (int32_t)&g13) = v3;
        *(char *)(g9 + (int32_t)&g14) = 0;
        int32_t v4 = g6; // 0xc0f2
        int32_t v5 = v4; // 0xc0fc
        if (*(char *)(v4 + (int32_t)&g14) != 0) {
            // bb
            function_c1d8();
            v5 = g6;
            // branch -> 0xc0fc
        }
        int32_t v6 = *(int32_t *)(v5 + (int32_t)&g15); // 0xc0fc
        *(int32_t *)(v1 + (int32_t)&g15) = v6;
        // branch -> 0xc106
    }
    int32_t * v7 = (int32_t *)(v1 + (int32_t)&g37); // 0xc10c
    *v7 = 0;
    *(int32_t *)v1 = g6;
    int32_t result = *(int32_t *)(g6 + (int32_t)&g37); // eax
    *(int32_t *)(v1 + 8) = 0;
    *(int32_t *)(v1 + 4) = 0;
    int32_t v8 = result; // 0xc122
    if (v8 != 0) {
        int32_t v9 = unknown_18160(v8, v1); // 0xc131
        result = v9;
        *v7 = v9;
        // branch -> 0xc13d
    }
    // 0xc13d
    if (*(int32_t *)(g6 + 8) != 0) {
        // 0xc152
        return result;
    }
    // 0xc148
    return function_c1be();
}

// Address range: 0xc162 - 0xc163
int32_t function_c162(void) {
    // 0xc162
    return 0;
}

// Address range: 0xc1be - 0xc1d7
int32_t function_c1be(void) {
    int32_t result;
    int32_t v1;
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_c1e7();
        // branch -> 0xc1cf
    }
    // 0xc1cf
    return result;
}

// Address range: 0xc1d8 - 0xc1e7
int32_t function_c1d8(void) {
    int32_t result = *(int32_t *)(g6 + 24); // eax
    *(char *)(g9 + (int32_t)&g14) = 1;
    *(int32_t *)(g9 + 24) = result;
    return result;
}

// Address range: 0xc1e7 - 0xc1e8
int32_t function_c1e7(void) {
    // 0xc1e7
    return g4;
}

// Address range: 0xc20a - 0xc20b
int32_t function_c20a(void) {
    // 0xc20a
    return 0;
}

// Address range: 0xc220 - 0xc252
int32_t _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE16invocation_stateC1ERKSJ_RKNS1_12grouped_listIiS8_NS_10shared_ptrINS1_15connection_bodyISt4pairINS1_15slot_meta_groupENS_8optionalIiEEENS0_5slot1IvS4_SB_EESH_EEEEEE(int32_t a1, int32_t a2, int32_t a3) {
    // 0xc220
    return 0;
}

// Address range: 0xc2a0 - 0xc36d
int32_t function_c2a0(void) {
    int32_t * v1 = (int32_t *)0x75df391b; // 0xc2a0
    *v1 = *v1 - 1;
    int32_t * v2 = (int32_t *)40; // 0xc2a7
    int32_t v3 = *v2; // 0xc2a7
    int32_t v4 = v3; // eax
    int32_t v5 = *v2; // ecx
    *(int32_t *)(v3 + 12) = 0;
    int32_t v6 = v4; // 0xc2b6
    *(int32_t *)(v6 + 16) = 0;
    *(int32_t *)(v4 + 28) = 0;
    int32_t v7 = v4 + 12; // 0xc2c9
    v4 = v7;
    *(int32_t *)(v5 + 20) = v7;
    int32_t v8 = v4; // 0xc2cf
    int32_t v9 = v8; // ebp
    *(int32_t *)(v5 + 24) = v8;
    *(int32_t *)(g11 + 32) = v4;
    int32_t v10 = *(int32_t *)(*(int32_t *)(g11 + 28) + 16); // 0xc2dc
    int32_t v11; // edi
    int32_t v12; // 0xc332
    int32_t v13; // 0xc350
    int32_t v14; // 0xc33d
    int32_t v15; // 0xc35a
    int32_t v16; // 0xc35e
    int32_t v17; // 0xc332
    int32_t v18; // 0xc336
    int32_t v19; // 0xc350
    if (v10 != 0) {
        // 0xc2e3
        *(int32_t *)(g11 + 8) = v9;
        *(int32_t *)(g11 + 4) = v10;
        *(int32_t *)g11 = v6 + 8;
        int32_t v20 = unknown_182d0(); // 0xc2ee
        v4 = v20;
        v9 = v20;
        *(int32_t *)(*(int32_t *)(g11 + 36) + 16) = v20;
        int32_t v21 = v9;
        int32_t v22 = *(int32_t *)(v21 + 8); // 0xc302115
        int32_t v23;
        int32_t v24; // 0xc321
        int32_t v25; // 0xc31a
        int32_t v26; // 0xc31a107
        int32_t v27; // 0xc31a110
        int32_t v28; // 0xc321
        if (v22 != 0) {
            v9 = v22;
            int32_t v29 = *(int32_t *)(v22 + 8); // 0xc302
            while (v29 != 0) {
                // 0xc300
                v22 = v29;
                v9 = v22;
                v29 = *(int32_t *)(v22 + 8);
                // continue -> 0xc300
            }
            // 0xc309
            *(int32_t *)(*(int32_t *)(g11 + 36) + 20) = v22;
            v23 = v4;
            v26 = *(int32_t *)(v23 + (int32_t)&g37);
            if (v26 == 0) {
                // 0xc321
                v24 = g11;
                v28 = *(int32_t *)(v24 + 36);
                *(int32_t *)(v28 + 24) = v23;
                *(int32_t *)(v28 + 28) = *(int32_t *)(*(int32_t *)(v24 + 28) + 28);
                // branch -> 0xc332
                // 0xc332
                v12 = g11;
                v17 = *(int32_t *)(v12 + (int32_t)&g15);
                v18 = *(int32_t *)(v12 + 36);
                g4 = v18;
                v11 = *(int32_t *)(v17 + (int32_t)&g14);
                v14 = v17 + 12;
                *(int32_t *)(v12 + 24) = v14;
                if (v11 == v14) {
                    // bb
                    g4 = function_c3a0();
                    // branch -> 0xc34a
                }
                // 0xc34a
                v13 = g11;
                v19 = v9;
                v16 = v19;
                v15 = v13;
                if (*(int32_t *)(v13 + 32) == v19) {
                    // bb104
                    g4 = function_c44c();
                    v16 = v9;
                    v15 = g11;
                    // branch -> 0xc35a
                }
                // 0xc35a
                *(int32_t *)(v16 + 28) = *(int32_t *)v18;
                if (v11 != *(int32_t *)(v15 + 24)) {
                    // 0xc367
                    // branch -> 0xc36a
                }
                // 0xc36a
                *(int32_t *)g11 = v11;
                return g4;
            }
            v27 = v26;
            v25 = *(int32_t *)(v27 + (int32_t)&g37);
            while (v25 != 0) {
                // 0xc318
                v27 = v25;
                v25 = *(int32_t *)(v27 + (int32_t)&g37);
                // continue -> 0xc318
            }
            // 0xc321
            v24 = g11;
            v28 = *(int32_t *)(v24 + 36);
            *(int32_t *)(v28 + 24) = v27;
            *(int32_t *)(v28 + 28) = *(int32_t *)(*(int32_t *)(v24 + 28) + 28);
            // branch -> 0xc332
            // 0xc332
            v12 = g11;
            v17 = *(int32_t *)(v12 + (int32_t)&g15);
            v18 = *(int32_t *)(v12 + 36);
            g4 = v18;
            v11 = *(int32_t *)(v17 + (int32_t)&g14);
            v14 = v17 + 12;
            *(int32_t *)(v12 + 24) = v14;
            if (v11 == v14) {
                // bb
                g4 = function_c3a0();
                // branch -> 0xc34a
            }
            // 0xc34a
            v13 = g11;
            v19 = v9;
            v16 = v19;
            v15 = v13;
            if (*(int32_t *)(v13 + 32) == v19) {
                // bb104
                g4 = function_c44c();
                v16 = v9;
                v15 = g11;
                // branch -> 0xc35a
            }
            // 0xc35a
            *(int32_t *)(v16 + 28) = *(int32_t *)v18;
            if (v11 != *(int32_t *)(v15 + 24)) {
                // 0xc367
                // branch -> 0xc36a
            }
            // 0xc36a
            *(int32_t *)g11 = v11;
            return g4;
        }
        // 0xc309
        *(int32_t *)(*(int32_t *)(g11 + 36) + 20) = v21;
        v23 = v4;
        v26 = *(int32_t *)(v23 + (int32_t)&g37);
        if (v26 != 0) {
            v27 = v26;
            v25 = *(int32_t *)(v27 + (int32_t)&g37);
            while (v25 != 0) {
                // 0xc318
                v27 = v25;
                v25 = *(int32_t *)(v27 + (int32_t)&g37);
                // continue -> 0xc318
            }
            // 0xc321
            v24 = g11;
            v28 = *(int32_t *)(v24 + 36);
            *(int32_t *)(v28 + 24) = v27;
            *(int32_t *)(v28 + 28) = *(int32_t *)(*(int32_t *)(v24 + 28) + 28);
            // branch -> 0xc332
            // 0xc332
            v12 = g11;
            v17 = *(int32_t *)(v12 + (int32_t)&g15);
            v18 = *(int32_t *)(v12 + 36);
            g4 = v18;
            v11 = *(int32_t *)(v17 + (int32_t)&g14);
            v14 = v17 + 12;
            *(int32_t *)(v12 + 24) = v14;
            if (v11 == v14) {
                // bb
                g4 = function_c3a0();
                // branch -> 0xc34a
            }
            // 0xc34a
            v13 = g11;
            v19 = v9;
            v16 = v19;
            v15 = v13;
            if (*(int32_t *)(v13 + 32) == v19) {
                // bb104
                g4 = function_c44c();
                v16 = v9;
                v15 = g11;
                // branch -> 0xc35a
            }
            // 0xc35a
            *(int32_t *)(v16 + 28) = *(int32_t *)v18;
            if (v11 != *(int32_t *)(v15 + 24)) {
                // 0xc367
                // branch -> 0xc36a
            }
            // 0xc36a
            *(int32_t *)g11 = v11;
            return g4;
        }
        // 0xc321
        v24 = g11;
        v28 = *(int32_t *)(v24 + 36);
        *(int32_t *)(v28 + 24) = v23;
        *(int32_t *)(v28 + 28) = *(int32_t *)(*(int32_t *)(v24 + 28) + 28);
        // branch -> 0xc332
    }
    // 0xc332
    v12 = g11;
    v17 = *(int32_t *)(v12 + (int32_t)&g15);
    v18 = *(int32_t *)(v12 + 36);
    g4 = v18;
    v11 = *(int32_t *)(v17 + (int32_t)&g14);
    v14 = v17 + 12;
    *(int32_t *)(v12 + 24) = v14;
    if (v11 == v14) {
        // bb
        g4 = function_c3a0();
        // branch -> 0xc34a
    }
    // 0xc34a
    v13 = g11;
    v19 = v9;
    v16 = v19;
    v15 = v13;
    if (*(int32_t *)(v13 + 32) == v19) {
        // bb104
        g4 = function_c44c();
        v16 = v9;
        v15 = g11;
        // branch -> 0xc35a
    }
    // 0xc35a
    *(int32_t *)(v16 + 28) = *(int32_t *)v18;
    if (v11 != *(int32_t *)(v15 + 24)) {
        // 0xc367
        // branch -> 0xc36a
    }
    // 0xc36a
    *(int32_t *)g11 = v11;
    return g4;
}

// Address range: 0xc372 - 0xc3a0
int32_t function_c372(int32_t a1, int32_t result) {
    int32_t v1 = 0; // 0xc372
    if (v1 != a1) {
        // 0xc37e
        result = *(int32_t *)(v1 + (int32_t)&g15);
        // branch -> 0xc38c
    }
    int32_t v2 = 0;
    if (v2 == result) {
        // 0xc390
        return result;
    }
    int32_t v3 = 0; // 0xc38a
    int32_t v4 = *(int32_t *)v2; // 0xc388
    // branch -> 0xc388
    while (v4 != result) {
        // 0xc388
        v3 = *(int32_t *)v3;
        v4 = *(int32_t *)v4;
        // continue -> 0xc388
    }
    // 0xc390
    return result;
}

// Address range: 0xc3a0 - 0xc3b8
int32_t function_c3a0(void) {
    // 0xc3a0
    int32_t v1;
    *(int32_t *)(v1 + 4) = 0;
    int32_t result = 0; // eax
    *(int32_t *)0 = result;
    return result;
}

// Address range: 0xc3bc - 0xc40c
// From class:    N5boost6detail17sp_counted_impl_pINS_8signals26detail12grouped_listIiSt4lessIiENS_10shared_ptrINS3_15connection_bodyISt4pairINS3_15slot_meta_groupENS_8optionalIiEEENS2_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSG_EEEEENS2_5mutexEEEEEEEEE
// Type:          constructor
int32_t function_c3bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t * v1 = (int32_t *)-0x74dbdbac; // 0xc3bc
    *v1 = *v1 - 1;
    int32_t v2 = 0; // 0xc3c3
    *(int32_t *)(v2 | 4) = 1;
    *(int32_t *)(v2 + 8) = 1;
    *(int32_t *)(v2 + 12) = 0;
    *(int32_t *)v2 = (int32_t)&g63;
    int32_t v3 = 0; // ecx
    *(int32_t *)(v3 + 4) = v2;
    *(int32_t *)(v3 + 8) = *(int32_t *)(a1 + 8);
    int32_t v4 = *(int32_t *)(a1 + (int32_t)&g37); // 0xc3e9
    g4 = v4;
    *(int32_t *)(v3 + (int32_t)&g37) = v4;
    if (v4 != 0) {
        int32_t * v5 = (int32_t *)(g4 + 4); // 0xc3f3
        *v5 = *v5 + 1;
        // branch -> 0xc3f7
    }
    // 0xc3f7
    int32_t result; // 0xc40b
    if ((a2 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
        // bb
        result = function_c42e();
        // branch -> 0xc404
    } else {
        // 0xc3f7
        result = g4;
        // branch -> 0xc404
    }
    // 0xc404
    return result;
}

// Address range: 0xc40d - 0xc40e
int32_t function_c40d(void) {
    // 0xc40d
    return 0;
}

// Address range: 0xc41a - 0xc421
int32_t function_c41a(void) {
    // 0xc41a
    int32_t result;
    return result;
}

// Address range: 0xc42e - 0xc42f
int32_t function_c42e(void) {
    // 0xc42e
    return g4;
}

// Address range: 0xc44c - 0xc480
int32_t function_c44c(void) {
    // 0xc44c
    int32_t v1;
    unknown_16dc0(v1, (int32_t)"/usr/include/boost/signals2/detail/slot_groups.hpp", 80, (int32_t)"boost::signals2::detail::grouped_list<Group, GroupCompare, ValueType>::grouped_list(const boost::signals2::detail::grouped_list<Group, GroupCompare, ValueType>&) [with Group = int, GroupCompare = std::less<int>, ValueType = boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, CCryptoKeyStore*, boost::function<void(CCryptoKeyStore*)> >, boost::signals2::mutex> >, boost::signals2::detail::grouped_list<Group, GroupCompare, ValueType> = boost::signals2::detail::grouped_list<int, std::less<int>, boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, CCryptoKeyStore*, boost::function<void(CCryptoKeyStore*)> >, boost::signals2::mutex> > >]");
    return function_c41a();
}

// Address range: 0xc481 - 0xc482
int32_t function_c481(void) {
    // 0xc481
    return 0;
}

// Address range: 0xc490 - 0xc51c
int32_t _ZNSt8_Rb_treeISt4pairIN5boost8signals26detail15slot_meta_groupENS1_8optionalIiEEES0_IKS7_St14_List_iteratorINS1_10shared_ptrINS3_15connection_bodyIS7_NS2_5slot1IvP15CCryptoKeyStoreNS1_8functionIFvSE_EEEEENS2_5mutexEEEEEEESt10_Select1stISN_ENS3_14group_key_lessIiSt4lessIiEEESaISN_EE10_M_insert_EPKSt18_Rb_tree_node_baseSY_RKSN_(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5) {
    // 0xc490
    g9 = 1;
    g4 = a3;
    g6 = (int32_t)a5;
    g5 = a4;
    int32_t result = a3; // 0xc4f2
    if (a3 == 0) {
        int32_t v1 = function_c560(a2 + 4); // 0xc4d1
        g4 = v1;
        result = v1;
        // branch -> 0xc4d7
    }
    // 0xc4d7
    if (result == -16) {
        // 0xc505
        return result;
    }
    // 0xc4f0
    *(char *)(result + (int32_t)&g14) = 0;
    *(int32_t *)(g4 + (int32_t)&g13) = *(int32_t *)g6;
    int32_t v2 = g6; // 0xc4f9
    int32_t v3; // 0xc4ff
    int32_t v4; // 0xc4fd
    if (*(char *)(v2 + 4) != 0) {
        // bb121
        v4 = function_c550((int32_t)(int16_t *)&g16);
        g4 = v4;
        v3 = g6;
        // branch -> 0xc4ff
    } else {
        // 0xc4f0
        v4 = g4;
        v3 = v2;
        // branch -> 0xc4ff
    }
    int32_t v5 = *(int32_t *)(v3 + (int32_t)&g37); // 0xc4ff
    *(int32_t *)(v4 + (int32_t)&g15) = v5;
    // branch -> 0xc505
    // 0xc505
    return g4;
}

// Address range: 0xc520 - 0xc550
int32_t function_c520(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * v1 = (int32_t *)-0x7ce3dbbc; // 0xc520
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    int32_t result = 0; // edi
    *(int32_t *)result = (v2 + 1 + (int32_t)false) % 256 | v2 & -256;
    return result;
}

// Address range: 0xc550 - 0xc55c
int32_t function_c550(int32_t a1) {
    // 0xc550
    *(char *)(g4 + (int32_t)&g14) = 1;
    *(int32_t *)(g4 + 24) = *(int32_t *)(g6 + 8);
    return g4;
}

// Address range: 0xc560 - 0xc5d0
int32_t function_c560(int32_t a1) {
    int32_t result = g6; // 0xc568
    if (result != *(int32_t *)(g5 + (int32_t)&g13)) {
        // 0xc56f
        // branch -> 0xc572
        // 0xc572
        g9 = g9 & -256 & (int32_t)&g74;
        return result;
    }
    // 0xc580
    g9 = 0;
    if (*(char *)(g5 + (int32_t)&g14) == 0) {
        // 0xc5ac
        return result;
    }
    // 0xc591
    if (*(char *)(result + 4) == 0) {
        // 0xc5a7
        // branch -> 0xc5ac
        // 0xc5ac
        return unknown_fbd6();
    }
    // 0xc597
    // branch -> 0xc572
    // 0xc572
    g9 = 0;
    return *(int32_t *)(g5 + 24);
}

// Address range: 0xc5d0 - 0xc5ef
int32_t _ZNSt8_Rb_treeISt4pairIN5boost8signals26detail15slot_meta_groupENS1_8optionalIiEEES0_IKS7_St14_List_iteratorINS1_10shared_ptrINS3_15connection_bodyIS7_NS2_5slot1IvP15CCryptoKeyStoreNS1_8functionIFvSE_EEEEENS2_5mutexEEEEEEESt10_Select1stISN_ENS3_14group_key_lessIiSt4lessIiEEESaISN_EE16_M_insert_uniqueERKSN_(int32_t a1, int32_t a2, int32_t a3) {
    // 0xc5d0
    return 0;
}

// Address range: 0xc5f0 - 0xc734
int32_t function_c5f0(int32_t a1) {
    // 0xc5f0
    if (!g78) {
        // 0xc5f2
        return g4;
    }
    int32_t v1 = g7; // 0xc5fa
    *(int32_t *)v1 = g4 + v1 + (int32_t)g1;
    int32_t v2 = g4; // 0xc5fc
    *(char *)v2 = (char)v2 + *(char *)&g4;
    int32_t v3 = g6; // 0xc5fe
    int32_t v4 = g8; // 0xc688
    // branch -> 0xc615
    while (true) {
        int32_t v5 = *(int32_t *)(v4 + (int32_t)&g13); // 0xc615
        int32_t v6 = v5; // edx
        int32_t v7 = v3 - v5; // 0xc618
        int32_t v8 = (int32_t)(v7 < 0 != ((v7 ^ v3) & (v5 ^ v3)) < 0) | v3 & -256; // 0xc61a
        int32_t v9; // 0xc60c
        int32_t v10; // 0xc626
        int32_t v11; // 0xc69210
        int32_t v12; // 0xc6929
        int32_t result; // 0xc72f
        if (v3 != v5) {
            v9 = v4;
            v11 = v3;
          lab_0xc608:;
            // 0xc608
            int32_t v13; // bp+44
            int32_t v14;
            int32_t v15; // 0xc652
            int32_t result2; // 0xc673
            int32_t v16; // 0xc6b0
            int32_t v17; // 0xc6b5
            int32_t v18; // 0xc6bb21
            int32_t v19; // 0xc6c4
            int32_t v20; // 0xc708
            int32_t v21; // 0xc659
            int32_t v22; // 0xc60c
            int32_t v23; // 0xc6c1
            int32_t v24; // 0xc6c4
            int32_t v25; // 0xc61a6
            int32_t v26; // 0xc65b
            int32_t v27; // 0xc6c4
            if ((char)v8 != 0) {
                // 0xc60c
                v22 = *(int32_t *)(v9 + 8);
                g4 = v22;
                if (v22 == 0) {
                    v17 = v11;
                    v20 = v9;
                    v15 = v8;
                    // 0xc62f
                    g4 = v15;
                    if ((char)v15 == 0) {
                        // 0xc708
                        g4 = v20;
                        v18 = v20;
                        v26 = v6;
                        v16 = v3;
                        // branch -> 0xc655
                        // 0xc655
                        if (v26 == v16) {
                            // 0xc6b0
                            if (v16 == 1) {
                                // 0xc6b5
                                v19 = v18;
                                if (*(char *)(v17 + 4) == 0) {
                                    // bb42
                                    v19 = function_c739();
                                    // branch -> 0xc6bb
                                }
                                // 0xc6bb
                                if (*(char *)(v19 + (int32_t)&g14) == 0) {
                                    // 0xc72f
                                    result = unknown_fd16();
                                    // branch -> 0xc734
                                    // 0xc734
                                    return result;
                                }
                                // 0xc6c1
                                v23 = *(int32_t *)(g6 + 8);
                                v24 = *(int32_t *)(v19 + 24);
                                v27 = v24 - v23;
                                if (v27 < 0 == ((v27 ^ v24) & (v24 ^ v23)) < 0) {
                                    // 0xc662
                                    *(int32_t *)g10 = v19;
                                    *(char *)(g10 + 4) = 0;
                                    // branch -> 0xc668
                                } else {
                                    // 0xc6d0
                                    // branch -> 0xc6e8
                                    // 0xc6e8
                                    unknown_18a60((int32_t)&v13, a1);
                                    *(char *)(g10 + 4) = 1;
                                    *(int32_t *)g10 = a1;
                                    // branch -> 0xc668
                                }
                                // 0xc668
                                result2 = g10;
                                if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                                    // 0xc67b
                                    return result2;
                                }
                                // 0xc734
                                return result2;
                            }
                        } else {
                            // 0xc659
                            v21 = v26 - v16;
                            if (v21 < 0 != ((v21 ^ v26) & (v16 ^ v26)) < 0) {
                                // 0xc6d0
                                // branch -> 0xc6e8
                                // 0xc6e8
                                unknown_18a60((int32_t)&v13, a1);
                                *(char *)(g10 + 4) = 1;
                                *(int32_t *)g10 = a1;
                                // branch -> 0xc668
                                // 0xc668
                                result2 = g10;
                                if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                                    // 0xc734
                                    return result2;
                                }
                                // 0xc67b
                                return result2;
                            }
                        }
                        // 0xc662
                        *(int32_t *)g10 = v18;
                        *(char *)(g10 + 4) = 0;
                        // branch -> 0xc668
                        // 0xc668
                        result2 = g10;
                        if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                            // 0xc734
                            return result2;
                        }
                        // 0xc67b
                        return result2;
                    }
                    // 0xc63b
                    if (v20 == *(int32_t *)(a1 + (int32_t)&g37)) {
                        // 0xc6e8
                        unknown_18a60((int32_t)&v13, a1);
                        *(char *)(g10 + 4) = 1;
                        *(int32_t *)g10 = a1;
                        // branch -> 0xc668
                    } else {
                        // 0xc648
                        v18 = v15;
                        v26 = *(int32_t *)(v15 + (int32_t)&g13);
                        v16 = v17;
                        // branch -> 0xc655
                        // 0xc655
                        if (v26 == v16) {
                            // 0xc6b0
                            if (v16 == 1) {
                                // 0xc6b5
                                v19 = v18;
                                if (*(char *)(v17 + 4) == 0) {
                                    // bb42
                                    v19 = function_c739();
                                    // branch -> 0xc6bb
                                }
                                // 0xc6bb
                                if (*(char *)(v19 + (int32_t)&g14) == 0) {
                                    // 0xc72f
                                    result = unknown_fd16();
                                    // branch -> 0xc734
                                    // 0xc734
                                    return result;
                                }
                                // 0xc6c1
                                v23 = *(int32_t *)(g6 + 8);
                                v24 = *(int32_t *)(v19 + 24);
                                v27 = v24 - v23;
                                if (v27 < 0 == ((v27 ^ v24) & (v24 ^ v23)) < 0) {
                                    // 0xc662
                                    *(int32_t *)g10 = v19;
                                    *(char *)(g10 + 4) = 0;
                                    // branch -> 0xc668
                                } else {
                                    // 0xc6d0
                                    // branch -> 0xc6e8
                                    // 0xc6e8
                                    unknown_18a60((int32_t)&v13, a1);
                                    *(char *)(g10 + 4) = 1;
                                    *(int32_t *)g10 = a1;
                                    // branch -> 0xc668
                                }
                                // 0xc668
                                result2 = g10;
                                if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                                    // 0xc67b
                                    return result2;
                                }
                                // 0xc734
                                return result2;
                            }
                        } else {
                            // 0xc659
                            v21 = v26 - v16;
                            if (v21 < 0 != ((v21 ^ v26) & (v16 ^ v26)) < 0) {
                                // 0xc6d0
                                // branch -> 0xc6e8
                                // 0xc6e8
                                unknown_18a60((int32_t)&v13, a1);
                                *(char *)(g10 + 4) = 1;
                                *(int32_t *)g10 = a1;
                                // branch -> 0xc668
                                // 0xc668
                                result2 = g10;
                                if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                                    // 0xc734
                                    return result2;
                                }
                                // 0xc67b
                                return result2;
                            }
                        }
                        // 0xc662
                        *(int32_t *)g10 = v18;
                        *(char *)(g10 + 4) = 0;
                        // branch -> 0xc668
                    }
                    // 0xc668
                    result2 = g10;
                    if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                        // 0xc734
                        return result2;
                    }
                    // 0xc67b
                    return result2;
                }
                v25 = v8;
              lab_0xc613_2:
                // 0xc613
                g8 = v22;
                v3 = v25;
                v4 = v22;
                // branch -> 0xc615
                continue;
            } else {
                v10 = v9;
                v12 = v11;
            }
          lab_0xc626:;
            int32_t v28 = *(int32_t *)(v10 + (int32_t)&g37); // 0xc626
            g4 = v28;
            if (v28 != 0) {
                v22 = v28;
                v25 = 0;
                goto lab_0xc613_2;
            }
            v17 = v12;
            v20 = v10;
            v15 = 0;
            // 0xc62f
            g4 = v15;
            if ((char)v15 == 0) {
                // 0xc708
                g4 = v20;
                v18 = v20;
                v26 = v6;
                v16 = v3;
                // branch -> 0xc655
                // 0xc655
                if (v26 == v16) {
                    // 0xc6b0
                    if (v16 == 1) {
                        // 0xc6b5
                        v19 = v18;
                        if (*(char *)(v17 + 4) == 0) {
                            // bb42
                            v19 = function_c739();
                            // branch -> 0xc6bb
                        }
                        // 0xc6bb
                        if (*(char *)(v19 + (int32_t)&g14) == 0) {
                            // 0xc72f
                            result = unknown_fd16();
                            // branch -> 0xc734
                            // 0xc734
                            return result;
                        }
                        // 0xc6c1
                        v23 = *(int32_t *)(g6 + 8);
                        v24 = *(int32_t *)(v19 + 24);
                        v27 = v24 - v23;
                        if (v27 < 0 == ((v27 ^ v24) & (v24 ^ v23)) < 0) {
                            // 0xc662
                            *(int32_t *)g10 = v19;
                            *(char *)(g10 + 4) = 0;
                            // branch -> 0xc668
                        } else {
                            // 0xc6d0
                            // branch -> 0xc6e8
                            // 0xc6e8
                            unknown_18a60((int32_t)&v13, a1);
                            *(char *)(g10 + 4) = 1;
                            *(int32_t *)g10 = a1;
                            // branch -> 0xc668
                        }
                        // 0xc668
                        result2 = g10;
                        if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                            // 0xc67b
                            return result2;
                        }
                        // 0xc734
                        return result2;
                    }
                } else {
                    // 0xc659
                    v21 = v26 - v16;
                    if (v21 < 0 != ((v21 ^ v26) & (v16 ^ v26)) < 0) {
                        // 0xc6d0
                        // branch -> 0xc6e8
                        // 0xc6e8
                        unknown_18a60((int32_t)&v13, a1);
                        *(char *)(g10 + 4) = 1;
                        *(int32_t *)g10 = a1;
                        // branch -> 0xc668
                        // 0xc668
                        result2 = g10;
                        if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                            // 0xc734
                            return result2;
                        }
                        // 0xc67b
                        return result2;
                    }
                }
                // 0xc662
                *(int32_t *)g10 = v18;
                *(char *)(g10 + 4) = 0;
                // branch -> 0xc668
                // 0xc668
                result2 = g10;
                if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                    // 0xc734
                    return result2;
                }
                // 0xc67b
                return result2;
            }
            // 0xc63b
            if (v20 == *(int32_t *)(a1 + (int32_t)&g37)) {
                // 0xc6e8
                unknown_18a60((int32_t)&v13, a1);
                *(char *)(g10 + 4) = 1;
                *(int32_t *)g10 = a1;
                // branch -> 0xc668
            } else {
                // 0xc648
                v18 = v15;
                v26 = *(int32_t *)(v15 + (int32_t)&g13);
                v16 = v17;
                // branch -> 0xc655
                // 0xc655
                if (v26 == v16) {
                    // 0xc6b0
                    if (v16 == 1) {
                        // 0xc6b5
                        v19 = v18;
                        if (*(char *)(v17 + 4) == 0) {
                            // bb42
                            v19 = function_c739();
                            // branch -> 0xc6bb
                        }
                        // 0xc6bb
                        if (*(char *)(v19 + (int32_t)&g14) == 0) {
                            // 0xc72f
                            result = unknown_fd16();
                            // branch -> 0xc734
                            // 0xc734
                            return result;
                        }
                        // 0xc6c1
                        v23 = *(int32_t *)(g6 + 8);
                        v24 = *(int32_t *)(v19 + 24);
                        v27 = v24 - v23;
                        if (v27 < 0 == ((v27 ^ v24) & (v24 ^ v23)) < 0) {
                            // 0xc662
                            *(int32_t *)g10 = v19;
                            *(char *)(g10 + 4) = 0;
                            // branch -> 0xc668
                        } else {
                            // 0xc6d0
                            // branch -> 0xc6e8
                            // 0xc6e8
                            unknown_18a60((int32_t)&v13, a1);
                            *(char *)(g10 + 4) = 1;
                            *(int32_t *)g10 = a1;
                            // branch -> 0xc668
                        }
                        // 0xc668
                        result2 = g10;
                        if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") == 0) {
                            // 0xc67b
                            return result2;
                        }
                        // 0xc734
                        return result2;
                    }
                } else {
                    // 0xc659
                    v21 = v26 - v16;
                    if (v21 < 0 != ((v21 ^ v26) & (v16 ^ v26)) < 0) {
                        // 0xc6d0
                        // branch -> 0xc6e8
                        // 0xc6e8
                        unknown_18a60((int32_t)&v13, a1);
                        *(char *)(g10 + 4) = 1;
                        *(int32_t *)g10 = a1;
                        // branch -> 0xc668
                        // 0xc668
                        result2 = g10;
                        if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                            // 0xc734
                            return result2;
                        }
                        // 0xc67b
                        return result2;
                    }
                }
                // 0xc662
                *(int32_t *)g10 = v18;
                *(char *)(g10 + 4) = 0;
                // branch -> 0xc668
            }
            // 0xc668
            result2 = g10;
            if ((v14 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") != 0) {
                // 0xc734
                return result2;
            }
            // 0xc67b
            return result2;
        }
        // 0xc621
        if (v3 != 1) {
            v10 = v4;
            v12 = v3;
            goto lab_0xc626;
        }
        if (*(char *)(v4 + (int32_t)&g14) == 0) {
            // bb
            function_c739();
            v3 = g6;
            // branch -> 0xc692
        }
        // 0xc692
        if (*(char *)(v3 + 4) == 0) {
            // 0xc72f
            result = unknown_fd16();
            // branch -> 0xc734
            // 0xc734
            return result;
        }
        int32_t v29 = g8; // 0xc69c
        int32_t v30 = *(int32_t *)(v29 + 24); // 0xc69c
        int32_t v31 = *(int32_t *)(v3 + 8); // 0xc69f
        int32_t v32 = v31 - v30; // 0xc69f
        v9 = v29;
        v8 = v8 & -256 | (int32_t)(v32 < 0 != ((v32 ^ v31) & (v31 ^ v30)) < 0);
        v11 = v3;
        // branch -> 0xc608
        goto lab_0xc608;
    }
}

// Address range: 0xc739 - 0xc758
int32_t function_c739(void) {
    // 0xc739
    return g4;
}

// Address range: 0xc760 - 0xc7c3
int32_t _ZNSt8_Rb_treeISt4pairIN5boost8signals26detail15slot_meta_groupENS1_8optionalIiEEES0_IKS7_St14_List_iteratorINS1_10shared_ptrINS3_15connection_bodyIS7_NS2_5slot1IvP15CCryptoKeyStoreNS1_8functionIFvSE_EEEEENS2_5mutexEEEEEEESt10_Select1stISN_ENS3_14group_key_lessIiSt4lessIiEEESaISN_EE17_M_insert_unique_ESt23_Rb_tree_const_iteratorISN_ERKSN_(int32_t a1, int32_t a2, int32_t a3, int32_t * a4) {
    int32_t v1 = (int32_t)a4;
    g8 = a2;
    g6 = a3;
    g10 = a1;
    g5 = v1;
    int32_t v2 = a3; // 0xc79d
    if (a2 + 4 == a3) {
        // bb
        function_c840((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        v2 = g6;
        v1 = g5;
        // branch -> 0xc79a
    }
    int32_t v3 = *(int32_t *)v1; // 0xc79a
    g9 = v3;
    int32_t v4 = *(int32_t *)(v2 + (int32_t)&g13); // 0xc79d
    g4 = v4;
    int32_t v5 = v3 - v4; // 0xc7a0
    int32_t result = v4; // 0xc7bf8
    bool v6 = ((v5 ^ v3) & (v4 ^ v3)) < 0; // 0xc7a8
    bool v7 = v5 < 0; // 0xc7a8
    if (v5 == 0) {
        int32_t v8 = function_c830(); // 0xc7a2
        g4 = v8;
        result = v8;
        v6 = g77;
        v7 = g79;
        // branch -> 0xc7a8
    }
    if (v7 == v6) {
        // bb118
        result = function_c910();
        // branch -> 0xc7b3
    }
    if (*(int32_t *)(g8 + (int32_t)&g37) == g6) {
        // bb119
        result = function_c900();
        // branch -> 0xc7bc
    }
    // 0xc7bc
    return result;
}

// Address range: 0xc7c7 - 0xc7d3
int32_t function_c7c7(int16_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 - 0x74dbdbac); // 0xc7c7
    *v2 = *v2 - 1;
    unsigned char v3 = (char)(v1 / 256) + *(char *)&g7; // 0xc7ce
    *(char *)0 = v3 + (char)false;
    return -1;
}

// Address range: 0xc7d3 - 0xc7de
int32_t function_c7d3(void) {
    char v1 = *(char *)&g4; // 0xc7d4
    int32_t result = 0; // eax
    *(char *)result = (char)result + v1;
    *(char *)0 = (char)0 + *(char *)&g7;
    int32_t v2 = 0; // edi
    *(int32_t *)v2 = v2 / 2 | 0x80000000 * v2;
    return result;
}

// Address range: 0xc7e6 - 0xc7ee
int32_t function_c7e6(void) {
    char * v1 = (char *)(g5 - 0x447bf037); // 0xc7e6
    *v1 = (char)g4 + *v1 + (char)g1;
    int32_t v2 = g4; // 0xc7ec
    *(char *)v2 = (char)v2 + *(char *)&g4;
    return g4;
}

// Address range: 0xc7ef - 0xc806
int32_t function_c7ef(void) {
    int32_t v1 = g6; // 0xc7ef
    return unknown_18bf0(g10, g8, v1, v1);
}

// Address range: 0xc806 - 0xc82f
int32_t function_c806(void) {
    // 0xc806
    int32_t v1;
    int32_t v2 = v1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xc80a
    g7 = v2;
    int32_t result = g10; // 0xc811
    g4 = result;
    if (v2 != 0) {
        // bb
        result = function_c9d1();
        // branch -> 0xc819
    }
    int32_t v3 = g11 + 92; // 0xc829
    g77 = (v3 & (g11 ^ -0x80000000)) < 0;
    g79 = v3 < 0;
    return result;
}

// Address range: 0xc830 - 0xc839
int32_t function_c830(void) {
    // 0xc830
    if (g9 == 1) {
        // bb
        function_c868();
        // branch -> 0xc835
    }
    // 0xc835
    *(int32_t *)g10 = g6;
    return function_c806();
}

// Address range: 0xc840 - 0xc866
int32_t function_c840(int32_t a1) {
    int32_t v1 = g8; // 0xc840
    int32_t v2 = v1; // 0xc852
    if (*(int32_t *)(v1 + (int32_t)&g14) != 0) {
        // bb
        function_c890();
        v2 = g8;
        // branch -> 0xc847
    }
    // 0xc847
    int32_t v3; // bp+40
    unknown_18d30((int32_t)&v3, v2);
    *(int32_t *)g10 = a1;
    return function_c806();
}

// Address range: 0xc868 - 0xc88a
int32_t function_c868(void) {
    // 0xc868
    if (*(char *)(g6 + (int32_t)&g14) == 0) {
        // bb
        g4 = function_c9fe();
        // branch -> 0xc872
    }
    // 0xc872
    int32_t result; // 0xc885
    if (*(char *)(g5 + 4) == 0) {
        // bb3
        result = function_c9f9();
        // branch -> 0xc87c
    } else {
        // 0xc872
        result = g4;
        // branch -> 0xc87c
    }
    // 0xc87c
    return result;
}

// Address range: 0xc890 - 0xc8ca
int32_t function_c890(void) {
    int32_t v1 = *(int32_t *)(g8 + (int32_t)&g13); // 0xc890
    g4 = v1;
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g13); // 0xc893
    g9 = v2;
    if (v2 == g5) {
        // bb
        v1 = function_c998();
        // branch -> 0xc89f
    }
    // 0xc89f
    unknown_18bf0(g10, g8, 0, v1);
    return function_c806();
}

// Address range: 0xc8d0 - 0xc8fb
int32_t function_c8d0(void) {
    // 0xc8d0
    int32_t v1;
    int32_t v2; // 0xc8e3
    if (*(char *)(v1 + 4) == 0) {
        // bb
        v2 = function_c9fe();
        // branch -> 0xc8e3
    } else {
        // 0xc8d0
        v2 = g4;
        // branch -> 0xc8e3
    }
    int32_t result = v2; // 0xc8f6
    if (*(char *)(v2 + (int32_t)&g14) == 0) {
        // bb99
        result = function_c9f9();
        // branch -> 0xc8ed
    }
    // 0xc8ed
    return result;
}

// Address range: 0xc900 - 0xc909
int32_t function_c900(void) {
    // 0xc900
    return function_c7ef();
}

// Address range: 0xc910 - 0xc935
int32_t function_c910(void) {
    int32_t v1 = g9; // 0xc910
    int32_t v2 = g4; // 0xc910
    int32_t v3 = v1; // 0xc918
    int32_t v4 = v2; // 0xc91a
    if (v1 == v2) {
        // bb
        v3 = g9;
        v4 = function_c9d6();
        // branch -> 0xc918
    }
    int32_t v5 = v4 - v3; // 0xc918
    int32_t result = (int32_t)(v5 < 0 != ((v5 ^ v4) & (v4 ^ v3)) < 0) | v4 & -256; // 0xc91a
    g4 = result;
    if (*(int32_t *)(g8 + (int32_t)&g13) == g6) {
        // bb5
        result = function_c9c4();
        // branch -> 0xc92e
    }
    // 0xc92e
    return result;
}

// Address range: 0xc939 - 0xc948
int32_t function_c939(void) {
    int32_t * v1 = (int32_t *)0x3b242454; // 0xc939
    *v1 = *v1 - 1;
    char * v2 = (char *)(int32_t)&g73; // 0xc940
    *v2 = (char)0 + *v2 + (char)false;
    return 0;
}

// Address range: 0xc948 - 0xc975
int32_t function_c948(void) {
    // 0xc948
    int32_t v1; // 0xc959
    if (*(int32_t *)(int32_t)&g37 == 0) {
        // bb
        v1 = function_c9bb();
        // branch -> 0xc959
    } else {
        // 0xc948
        v1 = g4;
        // branch -> 0xc959
    }
    // 0xc959
    unknown_18bf0(g10, 0, v1, v1);
    return function_c806();
}

// Address range: 0xc978 - 0xc998
int32_t function_c978(void) {
    int32_t v1 = g4; // 0xc981
    int32_t result = v1; // 0xc98d2
    if (*(char *)(v1 + (int32_t)&g14) == 0) {
        // bb
        result = function_c9fe();
        // branch -> 0xc987
    }
    if (*(char *)4 == 0) {
        // bb100
        result = function_c9f9();
        // branch -> 0xc98d
    }
    // 0xc98d
    return result;
}

// Address range: 0xc998 - 0xc9bb
int32_t function_c998(void) {
    // 0xc998
    int32_t v1; // 0xc9a7
    if (*(char *)(g5 + 4) == 0) {
        // bb
        v1 = function_c9fe();
        // branch -> 0xc9a7
    } else {
        // 0xc998
        v1 = g4;
        // branch -> 0xc9a7
    }
    int32_t result = v1; // 0xc9b6
    if (*(char *)(v1 + (int32_t)&g14) == 0) {
        // bb3
        result = function_c9f9();
        // branch -> 0xc9ad
    }
    int32_t v2 = *(int32_t *)(g5 + 8); // 0xc9ad
    int32_t v3 = *(int32_t *)(result + 24); // 0xc9b0
    int32_t v4 = v3 - v2; // 0xc9b0
    g77 = ((v4 ^ v3) & (v3 ^ v2)) < 0;
    g79 = v4 < 0;
    g9 = (int32_t)(v4 < 0 != ((v4 ^ v3) & (v3 ^ v2)) < 0) | v2 & -256;
    return result;
}

// Address range: 0xc9bb - 0xc9c4
int32_t function_c9bb(void) {
    // 0xc9bb
    return g4;
}

// Address range: 0xc9c4 - 0xc9d1
int32_t function_c9c4(void) {
    // 0xc9c4
    return g4;
}

// Address range: 0xc9d1 - 0xc9d2
int32_t function_c9d1(void) {
    // 0xc9d1
    return g4;
}

// Address range: 0xc9d6 - 0xc9f9
int32_t function_c9d6(void) {
    // 0xc9d6
    if (*(char *)(g5 + 4) == 0) {
        // bb
        g4 = function_c9fe();
        // branch -> 0xc9e5
    }
    int32_t v1 = g6; // 0xc9e5
    int32_t v2; // 0xc9ee
    int32_t v3; // 0xc9f1
    if (*(char *)(v1 + (int32_t)&g14) == 0) {
        // bb3
        v3 = function_c9f9();
        v2 = g6;
        // branch -> 0xc9eb
    } else {
        // 0xc9e5
        v3 = g4;
        v2 = v1;
        // branch -> 0xc9eb
    }
    int32_t v4 = *(int32_t *)(g5 + 8); // 0xc9eb
    int32_t v5 = *(int32_t *)(v2 + 24); // 0xc9ee
    int32_t v6 = v5 - v4; // 0xc9ee
    return (int32_t)(v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0) | v3 & -256;
}

// Address range: 0xc9f9 - 0xc9fe
int32_t function_c9f9(void) {
    // 0xc9f9
    return unknown_fea6();
}

// Address range: 0xc9fe - 0xca1d
int32_t function_c9fe(void) {
    // 0xc9fe
    return g4;
}

// Address range: 0xca30 - 0xcb20
int32_t _ZNK5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE31nolock_cleanup_connections_fromEbRKSt14_List_iteratorINS_10shared_ptrINS1_15connection_bodyISt4pairINS1_15slot_meta_groupENS_8optionalIiEEENS0_5slot1IvS4_SB_EESH_EEEEEj(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    g5 = v1;
    int32_t v2 = *(int32_t *)(v1 + 4); // 0xca59
    g4 = v2;
    int32_t v3 = v2; // 0xca74
    if (v2 == 0) {
        // bb
        v3 = function_cffc(a4);
        // branch -> 0xca74
    }
    int32_t v4 = *(int32_t *)(v3 + 4); // 0xca74
    g4 = v4;
    if (v4 != 1) {
        // bb134
        function_cffc(0x1000000 * a2 / 0x1000000);
        // branch -> 0xca80
    }
    int32_t v5 = *(int32_t *)g5; // 0xca80
    g6 = *(int32_t *)a3;
    int32_t v6 = v5; // 0xca8d
    if (v5 == 0) {
        // bb135
        v6 = function_cff2(0x1000000 * a2 / 0x1000000);
        // branch -> 0xca8d
    }
    int32_t v7 = *(int32_t *)v6; // 0xca8d
    g4 = v7;
    int32_t v8 = v7; // 0xca97
    if (v7 == 0) {
        int32_t v9 = function_cff7(0x1000000 * a2 / 0x1000000); // 0xca91
        g4 = v9;
        v8 = v9;
        // branch -> 0xca97
    }
    int32_t v10 = g6; // 0xca97
    int32_t v11 = v10; // 0xcaa5
    if (v10 == v8) {
        // bb137
        g4 = function_cb28(0x1000000 * a2 / 0x1000000);
        v11 = g6;
        // branch -> 0xca9f
    }
    int32_t v12 = *(int32_t *)(v11 + 8); // 0xcaa5
    g10 = v12;
    if (v12 == 0) {
        // bb138
        function_cbde((int32_t)(a4 == 0));
        v11 = g6;
        // branch -> 0xcab5
    }
    // 0xcab5
    g4 = *(int32_t *)v12;
    int32_t v13 = *(int32_t *)(v11 + 8); // 0xcac5
    g8 = v13;
    if ((char)a2 == 0) {
        // bb139
        function_cb80(v12);
        // branch -> 0xcad3
    }
    // 0xcad3
    if (v13 == 0) {
        // bb140
        function_cdd9((int32_t)(char *)v12);
        // branch -> 0xcadb
    }
    int32_t v14 = *(int32_t *)(v13 + (int32_t)&g13); // 0xcadb
    int32_t v15 = v14; // 0xcae7
    if (v14 == *(int32_t *)(v13 + (int32_t)&g14)) {
        // bb141
        v15 = function_cb88();
        // branch -> 0xcae7
    }
    int32_t v16 = *(int32_t *)v15; // 0xcaef
    int32_t v17 = v16 >> 31 ^ v16; // 0xcaf6
    g4 = v17;
    int32_t result = v17; // 0xcb19
    if (v17 < 20) {
        // bb143
        result = function_cc08(v15);
        // branch -> 0xcb01
    }
    // 0xcb01
    return result;
}

// Address range: 0xcb28 - 0xcb44
int32_t function_cb28(int32_t a1) {
    int32_t v1 = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xcb2c
    g4 = v1;
    *(int32_t *)(g5 + 8) = g6;
    int32_t result; // 0xcb43
    if (v1 != 0) {
        // bb
        result = function_d020();
        // branch -> 0xcb3c
    } else {
        // 0xcb28
        result = g4;
        // branch -> 0xcb3c
    }
    // 0xcb3c
    return result;
}

// Address range: 0xcb5b - 0xcb5c
int32_t function_cb5b(void) {
    // 0xcb5b
    return g4;
}

// Address range: 0xcb63 - 0xcb64
int32_t function_cb63(int32_t a1) {
    // 0xcb63
    return g4;
}

// Address range: 0xcb7d - 0xcb7e
int32_t function_cb7d(void) {
    // 0xcb7d
    return g4;
}

// Address range: 0xcb80 - 0xcb88
int32_t function_cb80(int32_t a1) {
    // 0xcb80
    return g4;
}

// Address range: 0xcb88 - 0xcbde
int32_t function_cb88(void) {
    int32_t v1 = g10; // 0xcb8c
    if (*(char *)(g8 + 4) == 0) {
        // bb
        function_cc18(v1);
        // branch -> 0xcb9a
    }
    int32_t v2 = g5; // 0xcba7
    if (g5 == 0) {
        // bb9
        function_cff2(v1);
        v2 = g5;
        // branch -> 0xcba7
    }
    int32_t v3 = v2; // 0xcbb1
    if (v2 == 0) {
        // bb10
        v3 = function_cff7(v1);
        // branch -> 0xcbb1
    }
    int32_t result = v3; // 0xcbd84
    if (v3 == g6) {
        // bb11
        result = function_cb28(v1);
        // branch -> 0xcbb9
    }
    // 0xcbb9
    int32_t v4;
    uint32_t v5 = v4 + 1; // 0xcbb9
    uint32_t v6;
    if (v6 > v5) {
        // 0xcbd3
        return result;
    }
    char v7;
    if (v7 == 0) {
        // bb12
        result = function_cb28(v5);
        // branch -> 0xcbd3
    }
    // 0xcbd3
    return result;
}

// Address range: 0xcbde - 0xcbfd
int32_t function_cbde(int32_t a1) {
    // 0xcbde
    return g4;
}

// Address range: 0xcc08 - 0xcc0f
int32_t function_cc08(int32_t a1) {
    // 0xcc08
    return g4;
}

// Address range: 0xcc18 - 0xcce2
int32_t function_cc18(int32_t a1) {
    int32_t v1 = *(int32_t *)(g6 + 8); // 0xcc18
    if (v1 == 0) {
        // bb
        function_cdd9(0);
        // branch -> 0xcc27
    }
    int32_t v2 = v1 + 68; // 0xcc2e
    int32_t v3 = g5; // 0xcc51
    if (g5 == 0) {
        // bb33
        function_cff2(v2);
        v3 = g5;
        // branch -> 0xcc3d
    }
    // 0xcc3d
    g4 = v3;
    if (v3 == 0) {
        // bb34
        g4 = function_cff7(0);
        // branch -> 0xcc4b
    }
    // 0xcc4b
    if (g6 == v3) {
        // bb35
        function_d084(v3);
        // branch -> 0xcc5b
    }
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g13); // 0xcc5f
    g10 = v4;
    g8 = v3 + (int32_t)&g37;
    int32_t v5 = *(int32_t *)v2; // 0xcc77
    g9 = v5;
    g4 = v4;
    // branch -> 0xcc90
  lab_0xcc90_2:
    while (true) {
        int32_t v6 = v4; // 0xcc89
        // branch -> 0xcc90
        int32_t v7;
        int32_t v8; // 0xcc9c
        int32_t v9; // 0xccb7
        int32_t v10; // 0xccb9
        int32_t v11; // 0xccb2
        int32_t v12; // 0xccaf
        int32_t result; // 0xccdb
        int32_t result2; // 0xccdb17
        int32_t v13; // 0xccb4
        while (true) {
            int32_t v14 = *(int32_t *)(v6 + (int32_t)&g13); // 0xcc90
            g7 = v14;
            int32_t v15; // 0xcc9e
            if (v14 != v5) {
                int32_t v16 = v14 - v5; // 0xcc80
                g7 = (int32_t)(v16 < 0 != ((v16 ^ v14) & (v14 ^ v5)) < 0) | v14 & -256;
                if (v16 < 0 == ((v16 ^ v14) & (v14 ^ v5)) < 0) {
                    // 0xcc9c
                    v7 = v5;
                    v8 = v6;
                    // branch -> 0xcc9c
                  lab_0xcc9c_2:
                    // 0xcc9c
                    g8 = v8;
                    v15 = *(int32_t *)(v8 + 8);
                    g4 = v15;
                    if (v15 == 0) {
                        // break (via goto) -> 0xcc9c
                        goto lab_0xcc9c_4;
                    }
                    v5 = v7;
                    v4 = v15;
                    // continue (via goto) -> 0xcc90
                    goto lab_0xcc90_2;
                } else {
                    int32_t v17 = *(int32_t *)(v6 + (int32_t)&g37); // 0xcc89
                    g4 = v17;
                    if (v17 == 0) {
                        // break -> 0xcca5
                        break;
                    }
                    v6 = v17;
                    // continue -> 0xcc90
                    continue;
                }
                // 0xcca5
                int32_t v18; // 0xccaf
                v12 = *(int32_t *)(v18 + (int32_t)&g13);
                g4 = v12;
                v11 = v12 - v9;
                int32_t v19; // 0xccb4
                v13 = (int32_t)(v11 < 0 != ((v11 ^ v12) & (v12 ^ v9)) < 0) | v19 & -256;
                g7 = v13;
                result2 = v12;
                if (v12 == v9) {
                    // bb39
                    v10 = function_cd18();
                    g4 = v10;
                    int32_t v20 = g7;
                    result2 = v10;
                    v13 = v20;
                    // branch -> 0xccbb
                }
                // 0xccbb
                result = result2;
                if ((char)v13 != 0) {
                    // 0xccc3
                    return result;
                }
                // bb40
                result = function_cf31();
                // branch -> 0xccc3
                // 0xccc3
                return result;
            }
            // 0xcc97
            if (v5 != 1) {
                v7 = v5;
                v8 = v6;
                goto lab_0xcc9c_2;
            }
            // bb38
            v7 = g9;
            v8 = function_cce8();
            // branch -> 0xcc9c
            goto lab_0xcc9c_2;
            // 0xcc9c
            g8 = v8;
            v15 = *(int32_t *)(v8 + 8);
            g4 = v15;
            if (v15 == 0) {
                // break (via goto) -> 0xcc9c
                goto lab_0xcc9c_4;
            }
            v5 = v7;
            v4 = v15;
            // continue (via goto) -> 0xcc90
            goto lab_0xcc90_2;
        }
      lab_0xcc9c_4:
        // 0xcc9c
        v9 = v7;
        // branch -> 0xcca5
        // 0xcca5
        v12 = *(int32_t *)(v8 + (int32_t)&g13);
        g4 = v12;
        v11 = v12 - v9;
        v13 = (int32_t)(v11 < 0 != ((v11 ^ v12) & (v12 ^ v9)) < 0) | g7 & -256;
        g7 = v13;
        result2 = v12;
        if (v12 == v9) {
            // bb39
            v10 = function_cd18();
            g4 = v10;
            result2 = v10;
            v13 = g7;
            // branch -> 0xccbb
        }
        // 0xccbb
        if ((char)v13 != 0) {
            // 0xccc3
            return result2;
        }
        // bb40
        result = function_cf31();
        // branch -> 0xccc3
        // 0xccc3
        return result;
    }
}

// Address range: 0xcce8 - 0xcd12
int32_t function_cce8(void) {
    // 0xcce8
    int32_t v1;
    int32_t v2; // 0xccf6
    if (*(char *)(v1 + 4) == 0) {
        // bb
        v2 = function_d025();
        // branch -> 0xccf6
    } else {
        // 0xcce8
        v2 = g4;
        // branch -> 0xccf6
    }
    int32_t result = v2; // 0xcd0d
    if (*(char *)(v2 + (int32_t)&g14) == 0) {
        // bb3
        result = function_d049();
        // branch -> 0xcd00
    }
    int32_t v3 = *(int32_t *)(v1 + 8); // 0xcd04
    int32_t v4 = *(int32_t *)(result + 24); // 0xcd07
    int32_t v5 = v4 - v3; // 0xcd07
    g7 = (int32_t)(v5 < 0 != ((v5 ^ v4) & (v4 ^ v3)) < 0) | v3 & -256;
    return result;
}

// Address range: 0xcd18 - 0xcd2d
int32_t function_cd18(void) {
    // 0xcd18
    int32_t v1; // 0xcd1b
    if (g9 == 1) {
        // bb
        v1 = function_ce08();
        g4 = v1;
        // branch -> 0xcd21
    } else {
        // 0xcd18
        v1 = g4;
        // branch -> 0xcd21
    }
    int32_t result = v1; // 0xcd2b4
    if (v1 == 1) {
        // bb6
        result = function_cd73();
        // branch -> 0xcd26
    }
    if (g6 == *(int32_t *)(g8 + (int32_t)&g15)) {
        // bb7
        result = function_cda2();
        // branch -> 0xcd2b
    }
    // 0xcd2b
    return result;
}

// Address range: 0xcd2d - 0xcd30
int32_t function_cd2d(void) {
    // 0xcd2d
    return g4;
}

// Address range: 0xcd4a - 0xcd4f
int32_t function_cd4a(void) {
    // 0xcd4a
    return 0;
}

// Address range: 0xcd4f - 0xcd73
int32_t function_cd4f(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 4); // 0xcd5b
    g4 = v1;
    int32_t v2 = v1; // 0xcd66
    if (v1 == 0) {
        int32_t v3 = function_cf6d(); // 0xcd60
        g4 = v3;
        v2 = v3;
        // branch -> 0xcd66
    }
    // 0xcd66
    return function_cb63(v2);
}

// Address range: 0xcd73 - 0xcda2
int32_t function_cd73(void) {
    // 0xcd73
    if (*(char *)(g8 + (int32_t)&g14) == 0) {
        // bb
        function_d025();
        // branch -> 0xcd7d
    }
    // 0xcd7d
    int32_t v1;
    if (*(char *)(v1 + 72) == 0) {
        // bb1
        function_d049();
        // branch -> 0xcd8b
    }
    int32_t v2 = *(int32_t *)(g8 + 24); // 0xcd8f
    int32_t v3 = *(int32_t *)(v1 + 76); // 0xcd92
    int32_t v4 = v3 - v2; // 0xcd92
    return (int32_t)(v4 < 0 != ((v4 ^ v3) & (v3 ^ v2)) < 0) | v2 & -256;
}

// Address range: 0xcda2 - 0xcdd9
int32_t function_cda2(void) {
    // 0xcda2
    g7 = g6;
    int32_t v1 = g10; // 0xcdb0
    g4 = v1;
    // branch -> 0xcdca
    while (true) {
      lab_0xcdca:;
        int32_t v2 = g9; // 0xcdca
        int32_t v3 = *(int32_t *)(v1 + (int32_t)&g13); // 0xcdca
        int32_t v4 = v2 - v3; // 0xcdca
        int32_t v5;
        int32_t v6; // 0xcdd4
        if (v4 != 0) {
            // 0xcdb8
            g7 = g7 & -256 | (int32_t)(v4 < 0 != ((v4 ^ v2) & (v3 ^ v2)) < 0);
            if (v4 < 0 != ((v4 ^ v2) & (v3 ^ v2)) < 0) {
                // 0xcdbf
                v5 = v1 + 8;
                // branch -> 0xcdc6
              lab_0xcdc6_2:;
                int32_t v7 = *(int32_t *)v5;
                g4 = v7;
                if (v7 == 0) {
                    // break -> bb
                    break;
                }
                v1 = v7;
                // continue -> 0xcdca
                continue;
            } else {
                v6 = v1;
            }
          lab_0xcdd4_2:
            // 0xcdd4
            v5 = v6 + (int32_t)&g37;
            // branch -> 0xcdc6
            goto lab_0xcdc6_2;
        } else {
            // 0xcdcf
            if (v2 != 1) {
                v6 = v1;
                goto lab_0xcdd4_2;
            }
            // bb8
            v6 = function_cde0();
            // branch -> 0xcdd4
            goto lab_0xcdd4_2;
        }
        int32_t v8 = v6 + (int32_t)&g37; // 0xcdd4
        v5 = v8;
        // branch -> 0xcdc6
        goto lab_0xcdc6_2;
    }
    int32_t v9 = function_ce38(); // 0xcdc8
    g4 = v9;
    v1 = v9;
    // branch -> 0xcdca
    goto lab_0xcdca;
}

// Address range: 0xcdd9 - 0xcde0
int32_t function_cdd9(int32_t a1) {
    // 0xcdd9
    return unknown_10072();
}

// Address range: 0xcde0 - 0xce07
int32_t function_cde0(void) {
    int32_t v1 = g4; // 0xcde0
    int32_t result = v1; // 0xcdfc2
    if (*(char *)(v1 + (int32_t)&g14) == 0) {
        // bb
        result = function_d025();
        // branch -> 0xcdea
    }
    int32_t v2;
    if (*(char *)(v2 + 4) == 0) {
        // bb3
        result = function_d049();
        // branch -> 0xcdf8
    }
    int32_t v3 = *(int32_t *)(result + 24); // 0xcdfc
    int32_t v4 = *(int32_t *)(v2 + 8); // 0xcdff
    int32_t v5 = v4 - v3; // 0xcdff
    g7 = (int32_t)(v5 < 0 != ((v5 ^ v4) & (v4 ^ v3)) < 0) | v3 & -256;
    return result;
}

// Address range: 0xce08 - 0xce32
int32_t function_ce08(void) {
    // 0xce08
    int32_t v1;
    if (*(char *)(v1 + 72) == 0) {
        // bb
        g4 = function_d025();
        // branch -> 0xce16
    }
    int32_t v2 = g8; // 0xce16
    int32_t v3; // 0xce27
    int32_t result; // 0xce2d
    if (*(char *)(v2 + (int32_t)&g14) == 0) {
        // bb3
        result = function_d049();
        v3 = g8;
        // branch -> 0xce20
    } else {
        // 0xce16
        result = g4;
        v3 = v2;
        // branch -> 0xce20
    }
    int32_t v4 = *(int32_t *)(v1 + 76); // 0xce24
    int32_t v5 = *(int32_t *)(v3 + 24); // 0xce27
    int32_t v6 = v5 - v4; // 0xce27
    g7 = (int32_t)(v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0) | v4 & -256;
    return result;
}

// Address range: 0xce38 - 0xce9c
int32_t function_ce38(void) {
    int32_t v1;
    int32_t v2;
    int32_t v3;
    if (v2 != v3) {
        // 0xce46
        v1 = *(int32_t *)(v2 + (int32_t)&g15);
        // branch -> 0xce51
    }
    // 0xce51
    g4 = v1;
    int32_t v4;
    if (v4 == v1) {
        // bb
        function_cfc7();
        // branch -> 0xce63
    }
    int32_t v5 = g9;
    int32_t v6 = g10; // 0xce8c
    // branch -> 0xce80
    while (true) {
        int32_t result = *(int32_t *)(v6 + (int32_t)&g13); // 0xce80
        if (result == v5) {
            // 0xce87
            if (v5 != 1) {
                goto lab_0xce8c;
            }
            // 0xce98
            return result;
        }
        int32_t v7 = result - v5; // 0xce70
        int32_t v8;
        if (v7 < 0 != ((v7 ^ result) & (result ^ v5)) < 0) {
            // 0xce79
            v8 = v6 + (int32_t)&g37;
            // branch -> 0xce7c
          lab_0xce7c_2:;
            int32_t v9 = *(int32_t *)v8;
            g10 = v9;
            v6 = v9;
            // branch -> 0xce80
            continue;
        }
      lab_0xce8c:
        // 0xce8c
        g7 = v6;
        v8 = v6 + 8;
        // branch -> 0xce7c
        goto lab_0xce7c_2;
    }
}

// Address range: 0xce9e - 0xcf31
int32_t function_ce9e(void) {
    int32_t v1 = g7; // 0xce9e
    *(int32_t *)v1 = v1;
    int32_t v2 = g4; // 0xcea1
    char * v3 = (char *)(v2 + 0xf00147e); // 0xcea1
    *v3 = *v3 + (char)v2;
    g8++;
    *(char *)g7 = *(char *)&g7 | (char)(g6 / 256);
    char * v4 = (char *)g8; // 0xceb1
    unsigned char v5 = *v4; // 0xceb1
    unsigned char v6 = (char)g7; // 0xceb1
    bool v7 = false; // 0xceb1
    char v8 = v7; // 0xceb1
    char v9 = v5 - v6; // 0xceb1
    char v10 = v9 + v8; // 0xceb1
    unsigned char v11 = v9 - v8; // 0xceb1
    bool v12 = v7 ? v6 != -1 | v5 < v11 : v5 < v6; // 0xceb1
    bool v13 = llvm_ctpop_i8(v10) % 2 == 0; // pf
    *v4 = v10;
    int32_t v14 = v13 ? 4 : 0; // 0xceb3
    int32_t v15 = v5 % 16 - v6 % 16 + v8 > 15 ? 16 : 0; // 0xceb3
    int32_t v16 = v10 == 0 ? 64 : 0; // 0xceb3
    int32_t v17 = v10 < 0 ? 128 : 0; // 0xceb3
    int32_t v18 = g80 ? 256 : 0; // 0xceb3
    int32_t v19 = g75 ? 512 : 0; // 0xceb3
    int32_t v20 = g3 ? 1024 : 0; // 0xceb3
    int32_t v21 = ((v11 ^ v5) & (v6 ^ v5)) < 0 ? 2048 : 0; // 0xceb3
    int32_t v22 = (int32_t)v12 | v14 | v15 | v16 | v17 | v18 | v19 | v20 | v21 | (int32_t)g76 << (int32_t)&g39 | 2; // 0xceb3
    g6 &= -256;
    uint32_t v23 = g7; // 0xceb8
    uint32_t v24;
    int32_t v25; // 0xcf25
    if (v23 - v24 != 0) {
        uint32_t v26 = g9; // 0xcebe
        uint32_t v27 = *(int32_t *)(v23 + (int32_t)&g13); // 0xcebe
        int32_t v28 = v26 - v27; // 0xcebe
        bool v29; // 0xcec7
        bool v30; // 0xcec7
        int32_t v31; // 0xcec7
        if (v28 == 0) {
            // bb
            v31 = function_cf98(v22);
            v30 = g77;
            v29 = g79;
            // branch -> 0xcec7
        } else {
            // 0xcebe
            v31 = g4;
            v30 = ((v28 ^ v26) & (v27 ^ v26)) < 0;
            v29 = v28 < 0;
            // branch -> 0xcec7
        }
        // 0xcec7
        g4 = (int32_t)(v29 != v30) | v31 & -256;
        if (v29 == v30) {
            // 0xcec7
            // branch -> 0xcf25
            // 0xcf25
            v25 = *(int32_t *)(g11 + 56);
            g9 = v25;
            *(int32_t *)(g7 + (int32_t)&g15) = v25;
            return function_cd2d();
        }
    }
    int32_t v32 = g9; // bp+72
    int32_t v33;
    if (*(char *)(v33 + 72) != 0) {
        // 0xcee5
        // branch -> 0xcef1
    }
    // 0xcef1
    uint32_t v34;
    int32_t v35 = v34 + 8; // 0xcf09
    int32_t v36; // bp+56
    g4 = unknown_19190((int32_t)&v36, v35, g7, (int32_t)&v32);
    g10 = *(int32_t *)g6;
    // branch -> 0xcf25
    // 0xcf25
    int32_t v37; // bp-8
    v25 = *(int32_t *)((int32_t)&v37 + 56);
    g9 = v25;
    int32_t v38;
    *(int32_t *)(v38 + (int32_t)&g15) = v25;
    return function_cd2d();
}

// Address range: 0xcf31 - 0xcf41
int32_t function_cf31(void) {
    int32_t v1 = g9; // 0xcf31
    int32_t v2 = g4; // 0xcf31
    int32_t v3 = v1 - v2; // 0xcf31
    return (int32_t)(v3 < 0 != ((v3 ^ v1) & (v2 ^ v1)) < 0) | v2 & -256;
}

// Address range: 0xcf41 - 0xcf5c
int32_t function_cf41(int32_t a1) {
    int32_t v1 = *(int32_t *)(*(int32_t *)(a1 + 4) + 4); // 0xcf48
    g4 = v1;
    if (v1 != 0) {
        // bb
        g4 = function_cb5b();
        // branch -> 0xcf53
    }
    // 0xcf53
    *(char *)4 = 0;
    return function_cb7d();
}

// Address range: 0xcf5c - 0xcf6d
int32_t function_cf5c(void) {
    // 0xcf5c
    int32_t v1;
    return *(int32_t *)*(int32_t *)(v1 + 4);
}

// Address range: 0xcf6d - 0xcf8c
int32_t function_cf6d(void) {
    // 0xcf6d
    return g4;
}

// Address range: 0xcf98 - 0xcfc7
int32_t function_cf98(int32_t a1) {
    // 0xcf98
    if (*(char *)(g7 + (int32_t)&g14) == 0) {
        // bb
        function_d025();
        // branch -> 0xcfa7
    }
    // 0xcfa7
    g10 = a1;
    if (*(char *)(a1 + 72) == 0) {
        // bb3
        function_d049();
        // branch -> 0xcfb5
    }
    int32_t v1 = *(int32_t *)(g7 + 24); // 0xcfb9
    int32_t v2 = *(int32_t *)(a1 + 76); // 0xcfbc
    int32_t v3 = v2 - v1; // 0xcfbc
    g77 = ((v3 ^ v2) & (v2 ^ v1)) < 0;
    g79 = v3 < 0;
    return (int32_t)(v3 < 0 != ((v3 ^ v2) & (v2 ^ v1)) < 0) | a1 & -256;
}

// Address range: 0xcfc7 - 0xcfce
int32_t function_cfc7(void) {
    // 0xcfc7
    return g4;
}

// Address range: 0xcfe4 - 0xcff2
int32_t function_cfe4(void) {
    int32_t * v1 = (int32_t *)-0x7cebdb8c; // 0xcfe4
    *v1 = *v1 - 1;
    __asm_outsb((int16_t)0, *(char *)&g10);
    int32_t v2 = 0; // eax
    return v2 + 255 + (int32_t)false & 255 | v2 & -256;
}

// Address range: 0xcff2 - 0xcff7
int32_t function_cff2(int32_t a1) {
    // 0xcff2
    return unknown_1003e();
}

// Address range: 0xcff7 - 0xcffc
int32_t function_cff7(int32_t a1) {
    // 0xcff7
    return unknown_100a6();
}

// Address range: 0xcffc - 0xd020
int32_t function_cffc(int32_t a1) {
    // 0xcffc
    return g4;
}

// Address range: 0xd020 - 0xd021
int32_t function_d020(void) {
    // 0xd020
    return g4;
}

// Address range: 0xd025 - 0xd044
int32_t function_d025(void) {
    // 0xd025
    return g4;
}

// Address range: 0xd049 - 0xd07f
int32_t function_d049(void) {
    // 0xd049
    g6 = unknown_10176();
    return g10;
}

// Address range: 0xd084 - 0xd0a8
int32_t function_d084(int32_t a1) {
    // 0xd084
    return g4;
}

// Address range: 0xd100 - 0xd12d
int32_t _ZNK5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEE25force_cleanup_connectionsEPKNS1_12grouped_listIiS8_NS_10shared_ptrINS1_15connection_bodyISt4pairINS1_15slot_meta_groupENS_8optionalIiEEENS0_5slot1IvS4_SB_EESH_EEEEEE(int32_t a1, int32_t a2) {
    // 0xd100
    return 0;
}

// Address range: 0xd14a - 0xd14b
int32_t function_d14a(void) {
    // 0xd14a
    return g4;
}

// Address range: 0xd151 - 0xd177
int32_t function_d151(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x652c2454; // 0xd151
    *v1 = *v1 - 1;
    int32_t result; // 0xd176
    if ((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84" != 0) {
        // bb
        result = function_d259();
        // branch -> 0xd163
    } else {
        // 0xd151
        result = g4;
        // branch -> 0xd163
    }
    // 0xd163
    return result;
}

// Address range: 0xd196 - 0xd259
int32_t function_d196(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 - 0x76e3dbbc); // 0xd196
    int32_t v3 = *v2; // 0xd196
    *v2 = v3 - 1;
    int32_t v4; // ebx
    if (v3 >= 1) {
        char * v5 = (char *)(v1 - 0x76fbdb8c); // 0xd19e
        *v5 = *v5 | (char)v1;
        int32_t result = unknown_19320(); // 0xd1a6
        if (a1 == 0) {
            // 0xd1bf
            return result;
        }
        // 0xd1b3
        g4 = a1;
        int32_t result2 = a1; // 0xd1b9
        if (v4 == a1) {
            // bb
            result2 = function_d25e();
            // branch -> 0xd1bf
        }
        // 0xd1bf
        return result2;
    }
    int32_t v6 = 0; // 0xd1c2
    unsigned char v7 = (char)v6 + 57 + (char)false & (char)&g18; // 0xd1c5
    int32_t v8 = (int32_t)v7 | v6 & -256; // 0xd1c5
    int32_t v9 = v8; // eax
    char * v10 = (char *)v8; // 0xd1c7
    *v10 = *v10 + v7;
    char * v11 = (char *)v9; // 0xd1c9
    *v11 = *v11 + (char)v9;
    *(int32_t *)v9 = (int32_t)&g64;
    *(int32_t *)(v9 + 4) = 1;
    *(int32_t *)(v9 + 8) = 1;
    *(int32_t *)(v9 + (int32_t)&g37) = a2;
    v4 = 0;
    *(int32_t *)v4 = v9;
    int32_t * v12 = (int32_t *)(v4 + 4); // 0xd1fe
    *v12 = v9;
    int32_t v13; // bp+37
    int32_t v14 = &v13; // 0xd204
    v13 = *v12;
    unknown_115d0(v14);
    if (v4 == 0) {
        // 0xd254
        return unknown_1070e();
    }
    int32_t v15 = v4; // bp+41
    g4 = unknown_19b30(v4, 0, (int32_t)&v15, 0);
    return function_d14a();
}

// Address range: 0xd259 - 0xd25a
int32_t function_d259(void) {
    // 0xd259
    return g4;
}

// Address range: 0xd25e - 0xd27d
int32_t function_d25e(void) {
    // 0xd25e
    return g4;
}

// Address range: 0xd29c - 0xd29d
int32_t function_d29c(void) {
    // 0xd29c
    return 0;
}

// Address range: 0xd29d - 0xd29e
int32_t function_d29d(void) {
    // 0xd29d
    return g4;
}

// Address range: 0xd2ae - 0xd2af
int32_t function_d2ae(void) {
    // 0xd2ae
    return 0;
}

// Address range: 0xd2bb - 0xd2bd
int32_t function_d2bb(void) {
    // 0xd2bb
    return function_d29d();
}

// Address range: 0xd2be - 0xd2bf
int32_t function_d2be(void) {
    // 0xd2be
    return 0;
}

// Address range: 0xd2c4 - 0xd2c6
int32_t function_d2c4(void) {
    // 0xd2c4
    return function_d29d();
}

// Address range: 0xd2d0 - 0xd316
int32_t _ZN5boost8signals26detail11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ES9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_S9_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISA_EE18move_to_new_bufferEjRKNS_17integral_constantIbLb0EEE(int32_t a1, int32_t a2) {
    // 0xd2d0
    g5 = a2;
    g6 = a1;
    g4 = 0;
    int32_t v1 = a2; // 0xd300
    if (a2 < 11) {
        // bb
        g4 = function_d31f(a1);
        v1 = g5;
        // branch -> 0xd300
    }
    // 0xd300
    int32_t v2; // 0xd30c
    if (v1 >= 0x15555556) {
        // bb112
        function_d415();
        v2 = g5;
        // branch -> 0xd30c
    } else {
        v2 = v1;
    }
    // 0xd30c
    return 12 * v2;
}

// Address range: 0xd31f - 0xd36b
int32_t function_d31f(int32_t a1) {
    int32_t v1 = g6; // 0xd31f
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g24); // 0xd325
    g10 = v2;
    int32_t v3 = 12 * *(int32_t *)(v1 + (int32_t)&g25); // 0xd32b
    int32_t v4 = v2 + v3; // 0xd32b
    g4 = v4;
    if (v3 == 0) {
        // bb
        g4 = function_d39c(v4);
        // branch -> 0xd336
    }
    // 0xd336
    g8 = a1;
    if (a1 == 0) {
        // bb15
        function_d390();
        // branch -> 0xd33e
    }
    int32_t v5 = *(int32_t *)g10; // 0xd33e
    int32_t v6 = v5 >> 31 ^ v5; // 0xd345
    g4 = v6;
    int32_t result = v6; // 0xd364
    if (v6 < 20) {
        // bb17
        result = function_d3c8();
        // branch -> 0xd34c
    }
    // 0xd34c
    return result;
}

// Address range: 0xd377 - 0xd378
int32_t function_d377(void) {
    // 0xd377
    return g4;
}

// Address range: 0xd382 - 0xd383
int32_t function_d382(void) {
    // 0xd382
    return g4;
}

// Address range: 0xd385 - 0xd388
int32_t function_d385(void) {
    // 0xd385
    return 0;
}

// Address range: 0xd390 - 0xd39c
int32_t function_d390(void) {
    // 0xd390
    g10 += (int32_t)&g37;
    g8 += (int32_t)&g37;
    return g4;
}

// Address range: 0xd39c - 0xd3c1
int32_t function_d39c(int32_t result) {
    // 0xd39c
    g4 = result;
    int32_t v1;
    if (v1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_d410();
        // branch -> 0xd3ad
    }
    // 0xd3ad
    return result;
}

// Address range: 0xd3c8 - 0xd3cf
int32_t function_d3c8(void) {
    // 0xd3c8
    return g4;
}

// Address range: 0xd3d0 - 0xd410
int32_t function_d3d0(void) {
    // 0xd3d0
    function_d390();
    int32_t v1 = *(int32_t *)(g10 + 4); // 0xd3da
    int32_t * v2; // 0xd3ef
    // 0xd3e2
    *(int32_t *)(g8 + 4) = v1;
    int32_t v3 = *(int32_t *)(g10 + 8); // 0xd3e5
    g4 = v3;
    *(int32_t *)(g8 + 8) = v3;
    if (v3 == 0) {
        // bb
        g4 = function_d382();
        // branch -> 0xd3ef
    }
    // 0xd3ef
    v2 = (int32_t *)(g4 + 4);
    *v2 = *v2 + 1;
    return function_d382();
}

// Address range: 0xd410 - 0xd411
int32_t function_d410(void) {
    // 0xd410
    return g4;
}

// Address range: 0xd415 - 0xd416
int32_t function_d415(void) {
    // 0xd415
    return g4;
}

// Address range: 0xd41a - 0xd437
int32_t function_d41a(int32_t a1) {
    // branch -> 0xd426
    while (0 != a1) {
        // 0xd426
        // 0xd42a
        unknown_15e70(a1);
        a1 += (int32_t)&g37;
        // branch -> 0xd426
    }
    // 0xd437
    return 0;
}

// Address range: 0xd4b0 - 0xd520
int32_t _ZNK5boost8signals26detail15connection_bodyISt4pairINS1_15slot_meta_groupENS_8optionalIiEEENS0_5slot1IvP15CCryptoKeyStoreNS_8functionIFvSA_EEEEENS0_5mutexEE27nolock_grab_tracked_objectsISt20back_insert_iteratorINS1_11auto_bufferINS_7variantINS_10shared_ptrIvEENS1_23foreign_void_shared_ptrENS_6detail7variant5void_ESQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_SQ_EENS1_15store_n_objectsILj10EEENS1_19default_grow_policyESaISR_EEEEEEvT_(int32_t a1, int32_t a2) {
    // 0xd4b0
    g4 = 0;
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g13); // 0xd4e2
    int32_t v2 = v1; // 0xd4f1
    if (v1 == *(int32_t *)(a1 + (int32_t)&g14)) {
        // bb
        function_d548((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84");
        v2 = g10;
        // branch -> 0xd4f1
    }
    int32_t v3 = *(int32_t *)v2; // 0xd4f3
    int32_t v4 = v3 >> 31 ^ v3; // 0xd4fa
    g4 = v4;
    int32_t result = v4; // 0xd519
    if (v4 < 20) {
        // bb119
        result = function_d580();
        // branch -> 0xd501
    }
    // 0xd501
    return result;
}

// Address range: 0xd525 - 0xd526
int32_t function_d525(void) {
    // 0xd525
    return g4;
}

// Address range: 0xd548 - 0xd579
int32_t function_d548(int32_t a1) {
    // 0xd548
    int32_t result; // 0xd578
    if (a1 != (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84") {
        // bb
        result = function_ddc0();
        // branch -> 0xd559
    } else {
        // 0xd548
        result = g4;
        // branch -> 0xd559
    }
    // 0xd559
    return result;
}

// Address range: 0xd580 - 0xd587
int32_t function_d580(void) {
    // 0xd580
    return g4;
}

// Address range: 0xd5b0 - 0xd5b1
int32_t function_d5b0(void) {
    // 0xd5b0
    return g4;
}

// Address range: 0xd5c7 - 0xd5ca
int32_t function_d5c7(void) {
    // 0xd5c7
    return 0;
}

// Address range: 0xd5f0 - 0xd604
int32_t function_d5f0(int32_t a1) {
    // 0xd5f0
    int32_t v1; // bp+72
    return unknown_11980((int32_t)&v1);
}

// Address range: 0xd604 - 0xd635
int32_t function_d604(int32_t a1) {
    int32_t v1 = g8; // 0xd604
    int32_t v2 = v1 >> 31 ^ v1; // 0xd60b
    g4 = v2;
    int32_t result = v2; // 0xd62e
    if (v2 < 20) {
        // bb
        result = function_d7a8();
        // branch -> 0xd616
    }
    // 0xd616
    return result;
}

// Address range: 0xd630 - 0xd631
int32_t function_d630(int32_t a1, int32_t a2) {
    // 0xd630
    return g4;
}

// Address range: 0xd639 - 0xd697
int32_t function_d639(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = 0; // ebp
    int32_t * v3 = (int32_t *)(v2 + (int32_t)&g34); // 0xd639
    *v3 = *v3 - 1;
    char * v4 = (char *)(v2 + 0x4478bd2); // 0xd63f
    *v4 = (char)g4 + *v4;
    if (g4 == 0) {
        // bb
        function_deef();
        // branch -> 0xd653
    }
    int32_t v5 = v1; // 0xd68a
    if (a1 == NULL) {
        // bb107
        v5 = function_d604(v1);
        // branch -> 0xd68a
    }
    // 0xd68a
    return function_d604(v5);
}

// Address range: 0xd79e - 0xd79f
int32_t function_d79e(int32_t a1) {
    // 0xd79e
    return g4;
}

// Address range: 0xd7a8 - 0xd7af
int32_t function_d7a8(void) {
    // 0xd7a8
    return g4;
}

// Address range: 0xd7bd - 0xd7c0
int32_t function_d7bd(void) {
    // 0xd7bd
    return 0;
}

// Address range: 0xd7d2 - 0xd7d3
int32_t function_d7d2(void) {
    // 0xd7d2
    return g4;
}

// Address range: 0xd800 - 0xd801
int32_t function_d800(void) {
    // 0xd800
    return g4;
}

// Address range: 0xd801 - 0xd803
int32_t function_d801(void) {
    // 0xd801
    return function_d800();
}

// Address range: 0xd806 - 0xd808
int32_t function_d806(void) {
    // 0xd806
    return g4;
}

// Address range: 0xd809 - 0xd8b6
int32_t function_d809(int32_t a1) {
    int32_t v1 = 0; // ebp
    int32_t * v2 = (int32_t *)(v1 + 0x4478bd2); // 0xd809
    int32_t v3 = *v2 + 1; // 0xd809
    *v2 = v3;
    int32_t v4; // 0xd80f
    if (v3 < 0) {
        // bb
        v4 = function_dca5();
        g4 = v4;
        // branch -> 0xd815
    } else {
        // 0xd809
        v4 = g4;
        // branch -> 0xd815
    }
    int32_t v5 = v4; // 0xd81d
    if (v4 == 0) {
        // bb117
        v5 = function_df13();
        // branch -> 0xd81d
    }
    // branch -> 0xd82d
    while (true) {
        // 0xd82d
        if ((char)v5 != 0) {
            // bb118
            function_ddc5();
            // branch -> 0xd835
        }
        int32_t v6 = *(int32_t *)(v1 + (int32_t)&g25); // 0xd835
        int32_t v7 = *(int32_t *)(v1 + (int32_t)&g24); // 0xd84a
        int32_t v8 = a1; // 0xd857
        int32_t v9 = v8 >> 31 ^ v8; // 0xd868
        g4 = v9;
        if (v9 < 20) {
            // bb120
            function_d9a8((int32_t)&a1, v7 + 12 * v6);
            // branch -> 0xd873
        }
        // 0xd873
        if (v8 < 0) {
            // bb121
            function_dc90((int32_t)"false", (int32_t)"/usr/include/boost/variant/detail/visitation_impl.hpp", (int32_t)&g38, (int32_t)"typename Visitor::result_type boost::detail::variant::visitation_impl(int, int, Visitor&, VPCV, mpl_::true_, NBF, W*, S*) [with W = mpl_::int_<20>, S = boost::detail::variant::visitation_impl_step<boost::mpl::l_iter<boost::mpl::l_end>, boost::mpl::l_iter<boost::mpl::l_end> >, Visitor = boost::detail::variant::copy_into, VPCV = const void*, NBF = boost::variant<boost::shared_ptr<void>, boost::signals2::detail::foreign_void_shared_ptr>::has_fallback_type_, typename Visitor::result_type = void, mpl_::true_ = mpl_::bool_<true>]");
            // branch -> 0xd8a0
        }
        int32_t v10 = *(int32_t *)(g8 + 8); // 0xd8a0
        int32_t v11 = 0; // 0xd8ae
        if (v10 != 0) {
            // 0xd8a9
            v11 = *(int32_t *)(v10 + 4);
            // branch -> 0xd8ac
        }
        // 0xd8ac
        v5 = (int32_t)(v11 == 0) | v11 & -256;
        // branch -> 0xd82d
    }
}

// Address range: 0xd8b6 - 0xd8dd
int32_t function_d8b6(int32_t a1) {
    // 0xd8b6
    int32_t * v1;
    function_d5f0((int32_t)&v1);
    return function_d5f0(0);
}

// Address range: 0xd906 - 0xd909
int32_t function_d906(void) {
    // 0xd906
    return 0;
}

// Address range: 0xd90a - 0xd9a8
int32_t function_d90a(int32_t * a1) {
    int32_t v1 = g4; // 0xd90c
    int32_t v2; // bp+80
    if ((v1 + 117 & 255 || v1 & -256) == 0) {
        // 0xd98e
        v2 = 0;
        // branch -> 0xd929
    } else {
        int32_t * v3 = (int32_t *)(g7 & -256 | 85); // 0xd925
        *v3 = *v3 + 1;
        // branch -> 0xd929
    }
    int32_t v4 = &v2; // 0xd929
    unknown_11980(v4);
    return function_d604(v4);
}

// Address range: 0xd9a8 - 0xd9af
int32_t function_d9a8(int32_t a1, int32_t a2) {
    // 0xd9a8
    return g4;
}

// Address range: 0xd9bd - 0xd9c0
int32_t function_d9bd(void) {
    // 0xd9bd
    return 0;
}

// Address range: 0xda1a - 0xda7c
int32_t function_da1a(void) {
    int32_t v1 = g4; // 0xda1a
    int32_t v2 = g9; // 0xda1c
    char * v3 = (char *)v2; // bp-4
    *(int32_t *)(v2 + 4) = (v1 & (int32_t)&g74 | 136) & (int32_t)(char)&g18 | v1 & -256;
    int32_t v4;
    int32_t * v5 = (int32_t *)v4; // 0xda2d
    int32_t v6 = *v5; // 0xda2d
    int32_t v7;
    *(int32_t *)v7 = v6 >> 31 ^ v6;
    int32_t * v8 = (int32_t *)(g5 + (int32_t)&g25); // 0xda38
    *v8 = *v8 + 1;
    int32_t v9 = *v5; // 0xda4b
    int32_t v10 = v9 >> 31 ^ v9; // 0xda52
    g4 = v10;
    int32_t result = v10; // 0xda75
    if (v10 < 20) {
        char * v11 = (char *)&v3; // 0xda57
        result = function_dbcd((int32_t)v11, (int32_t)v3);
        // branch -> 0xda5d
    }
    // 0xda5d
    return result;
}

// Address range: 0xda80 - 0xdaa5
int32_t function_da80(int32_t a1, int32_t result) {
    int32_t * v1 = (int32_t *)0x24448bd2; // 0xda80
    int32_t v2 = *v1 + 1; // 0xda80
    *v1 = v2;
    int32_t v3; // 0xda91
    if (v2 < 0) {
        // bb
        v3 = function_de1a();
        // branch -> 0xda8d
    } else {
        // 0xda80
        v3 = g4;
        // branch -> 0xda8d
    }
    // 0xda8d
    *(int32_t *)(a1 + 4) = v3;
    *(int32_t *)(a1 + 8) = result;
    int32_t * v4 = (int32_t *)(result + 4); // 0xda9f
    *v4 = *v4 + 1;
    return result;
}

// Address range: 0xda9f - 0xdaa0
int32_t function_da9f(void) {
    // 0xda9f
    return g4;
}

// Address range: 0xdaaa - 0xdb31
int32_t function_daaa(int32_t a1) {
    int32_t v1 = g4; // 0xdab0
    int32_t v2 = v1; // 0xdab9
    if (v1 < 10) {
        // bb
        v2 = function_df58();
        // branch -> 0xdab9
    }
    int32_t v3 = v2 + 1; // 0xdab9
    int32_t v4 = v3; // 0xdacd
    int32_t v5 = v2; // 0xdac8
    if (v2 == -1) {
        // bb24
        v4 = v3;
        v5 = function_df53(v3);
        // branch -> 0xdac8
    }
    uint32_t v6 = 4 * v5; // 0xdac8
    int32_t v7; // bp+95
    int32_t v8 = unknown_1a780(v6 < v4 ? v4 : v6, (int32_t)&v7); // 0xdaef
    int32_t v9 = *(int32_t *)(g5 + (int32_t)&g24); // 0xdaf4
    int32_t v10 = g5; // 0xdaff
    if (v9 == 0) {
        // bb25
        function_db36(v8);
        v10 = g5;
        // branch -> 0xdaff
    }
    int32_t v11 = *(int32_t *)(v10 + (int32_t)&g23); // 0xdaff
    g4 = v11;
    int32_t v12 = v11; // 0xdb199
    if (v11 < 10) {
        int32_t v13 = function_de3f(); // 0xdb05
        g4 = v13;
        v12 = v13;
        v10 = g5;
        // branch -> 0xdb0b
    }
    int32_t v14 = v10; // 0xdb13
    if (v9 == v10) {
        // bb28
        v12 = function_de36();
        v14 = g5;
        // branch -> 0xdb13
    }
    uint32_t v15 = *(int32_t *)(v14 + (int32_t)&g25); // 0xdb13
    int32_t v16 = v12; // 0xdb2911
    if (v12 < v15) {
        // bb29
        v16 = function_de3f();
        // branch -> 0xdb21
    }
    if (v15 != 0) {
        // bb30
        v16 = function_dd97();
        // branch -> 0xdb29
    }
    int32_t result = v16; // 0xdb2e
    if (v16 < 11) {
        // bb32
        result = function_db36(v8);
        // branch -> 0xdb2e
    }
    // 0xdb2e
    return result;
}

// Address range: 0xdb36 - 0xdbcd
int32_t function_db36(uint32_t a1) {
    // 0xdb36
    g4 = *(int32_t *)(g5 + (int32_t)&g25);
    int32_t v1 = 0; // edx
    *(int32_t *)(g5 + (int32_t)&g23) = v1;
    int32_t v2 = g4; // 0xdb4a
    int32_t v3 = v2; // 0xdb605
    if (v2 > v1) {
        int32_t v4 = function_dfda(); // 0xdb4c
        g4 = v4;
        v3 = v4;
        // branch -> 0xdb52
    }
    uint32_t v5;
    if (v5 < a1) {
        // bb21
        v3 = function_dfb6();
        // branch -> 0xdb60
    }
    int32_t v6 = v3; // 0xdb6a
    if (v3 == v5) {
        // bb22
        int32_t * v7;
        v6 = function_df53((int32_t)&v7);
        // branch -> 0xdb6a
    }
    // 0xdb6a
    if (*(int32_t *)(g5 + (int32_t)&g24) == -12 * v6) {
        // bb23
        function_dd8d(0);
        // branch -> 0xdb7d
    }
    // 0xdb7d
    int32_t v8; // bp+96
    int32_t v9 = v8; // 0xdb85
    int32_t v10 = v9 >> 31 ^ v9; // 0xdb8e
    g4 = v10;
    int32_t result = v10; // 0xdbc8
    if (v10 < 20) {
        // bb25
        result = function_dcc4((int32_t)&v8);
        // branch -> 0xdb99
    }
    // 0xdb99
    return result;
}

// Address range: 0xdbcd - 0xdbd4
int32_t function_dbcd(int32_t a1, int32_t a2) {
    // 0xdbcd
    return g4;
}

// Address range: 0xdbd4 - 0xdc5e
int32_t function_dbd4(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    function_d5b0();
    g4 = v1;
    // 0xdc41
    if (v1 != 0) {
        // branch -> 0xdc4d
    } else {
        int32_t v2;
        v1 = v2;
    }
    // 0xdc4d
    return function_d548(v1);
}

// Address range: 0xdc89 - 0xdc8b
int32_t function_dc89(void) {
    // 0xdc89
    return 0;
}

// Address range: 0xdc90 - 0xdca5
int32_t function_dc90(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xdc90
    return 0;
}

// Address range: 0xdca5 - 0xdcc4
int32_t function_dca5(void) {
    // 0xdca5
    if (g4 == 0) {
        // bb
        function_df92();
        // branch -> 0xdcaf
    }
    // 0xdcaf
    int32_t v1; // bp+96
    return &v1;
}

// Address range: 0xdcc4 - 0xdccb
int32_t function_dcc4(int32_t a1) {
    // 0xdcc4
    return g4;
}

// Address range: 0xdd45 - 0xdd46
int32_t function_dd45(void) {
    // 0xdd45
    return g4;
}

// Address range: 0xdd50 - 0xdd53
int32_t function_dd50(void) {
    // 0xdd50
    return 0;
}

// Address range: 0xdd58 - 0xdd64
int32_t function_dd58(int32_t a1) {
    int32_t * v1 = (int32_t *)(g5 + (int32_t)&g25); // 0xdd58
    *v1 = *v1 + 1;
    return g4;
}

// Address range: 0xdd64 - 0xdd88
int32_t function_dd64(int32_t a1, int32_t a2, int32_t a3) {
    // 0xdd64
    g4 = a2;
    // 0xdd70
    *(int32_t *)(a1 + 4) = a2;
    g4 = a3;
    *(int32_t *)(a1 + 8) = a3;
    int32_t v1; // 0xdd80
    if (a3 == 0) {
        // bb101
        v1 = function_dd45();
        g4 = v1;
        // branch -> 0xdd82
    } else {
        // 0xdd70
        v1 = g4;
        // branch -> 0xdd82
    }
    int32_t * v2 = (int32_t *)(v1 + 4); // 0xdd82
    *v2 = *v2 + 1;
    return function_dd45();
}

// Address range: 0xdd8d - 0xdd97
int32_t function_dd8d(int32_t a1) {
    // 0xdd8d
    int32_t v1; // bp+96
    int32_t v2 = &v1; // 0xdd8d
    g4 = v2;
    return function_dd58(v2);
}

// Address range: 0xdd97 - 0xddc0
int32_t function_dd97(void) {
    int32_t v1 = g5 + (int32_t)&g24; // 0xdd97
    g4 = v1;
    int32_t v2; // bp+96
    function_d630(v1, (int32_t)&v2);
    return *(int32_t *)(g5 + (int32_t)&g23);
}

// Address range: 0xddc0 - 0xddc1
int32_t function_ddc0(void) {
    // 0xddc0
    return g4;
}

// Address range: 0xddc5 - 0xde1a
int32_t function_ddc5(void) {
    // 0xddc5
    *(char *)(g6 + 4) = 0;
    int32_t result = 0; // eax
    if ((result >> 31 ^ result) < 20) {
        // 0xde13
        return result;
    }
    int32_t result2 = *(int32_t *)result; // 0xddfd
    int32_t v1;
    *(int32_t *)(v1 + 4) = result2;
    return result2;
}

// Address range: 0xde1a - 0xde36
int32_t function_de1a(void) {
    int32_t v1 = g4; // 0xde1a
    int32_t v2 = *(int32_t *)(v1 + 4); // 0xde1c
    g4 = v2;
    int32_t v3;
    *(int32_t *)(v3 + 4) = v1;
    *(int32_t *)8 = g4;
    int32_t result; // 0xde31
    if (v2 != 0) {
        // bb
        result = function_da9f();
        // branch -> 0xde31
    } else {
        // 0xde1a
        result = g4;
        // branch -> 0xde31
    }
    // 0xde31
    return result;
}

// Address range: 0xde36 - 0xde3f
int32_t function_de36(void) {
    // 0xde36
    return g4;
}

// Address range: 0xde3f - 0xde5a
int32_t function_de3f(void) {
    int32_t v1 = unknown_10b8e(); // 0xde40
    int32_t v2;
    int32_t result; // 0xde57
    if (v2 != 0) {
        // 0xde4f
        result = *(int32_t *)v2;
        // branch -> 0xde57
    } else {
        result = v1;
    }
    // 0xde57
    return result;
}

// Address range: 0xde5e - 0xde65
int32_t function_de5e(void) {
    int32_t * v1 = (int32_t *)-0x76a7dbac; // 0xde5e
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xde9c - 0xdea3
int32_t function_de9c(void) {
    int32_t * v1 = (int32_t *)-0x76dfdbac; // 0xde9c
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0xdeb2 - 0xdec4
int32_t function_deb2(void) {
    // 0xdeb2
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x7697dbbc); // 0xdeb2
    *v2 = *v2 - 1;
    int32_t * v3;
    return unknown_11980((int32_t)&v3);
}

// Address range: 0xdec4 - 0xdee5
int32_t function_dec4(void) {
    int32_t result = g4; // 0xdec4
    if (result != 0) {
        // 0xded2
        // branch -> 0xdee2
    } else {
        result = 0;
    }
    // 0xdee2
    return result;
}

// Address range: 0xdeea - 0xdeef
int32_t function_deea(void) {
    // 0xdeea
    return 0;
}

// Address range: 0xdeef - 0xdf0e
int32_t function_deef(void) {
    // 0xdeef
    return g4;
}

// Address range: 0xdf13 - 0xdf32
int32_t function_df13(void) {
    // 0xdf13
    return g4;
}

// Address range: 0xdf37 - 0xdf53
int32_t function_df37(void) {
    int32_t v1 = g4; // 0xdf37
    int32_t v2 = *(int32_t *)(v1 + 4); // 0xdf39
    g4 = v2;
    int32_t v3;
    *(int32_t *)(v3 + 4) = v1;
    *(int32_t *)8 = v2;
    return function_dd45();
}

// Address range: 0xdf53 - 0xdf58
int32_t function_df53(int32_t a1) {
    // 0xdf53
    return unknown_10bc2();
}

// Address range: 0xdf58 - 0xdf77
int32_t function_df58(void) {
    // 0xdf58
    return g4;
}

// Address range: 0xdf7b - 0xdf92
int32_t function_df7b(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x76ef7500; // 0xdf7b
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    int32_t v3 = v2 + (int32_t)(char)&g18 & 255 | v2 & -256; // 0xdf81
    g4 = v3;
    *(int32_t *)(a1 + 4) = v3;
    return function_dd45();
}

// Address range: 0xdf92 - 0xdfb6
int32_t function_df92(void) {
    // 0xdf92
    return g4;
}

// Address range: 0xdfb6 - 0xdfd5
int32_t function_dfb6(void) {
    // 0xdfb6
    return g4;
}

// Address range: 0xdfda - 0xdff9
int32_t function_dfda(void) {
    // 0xdfda
    return g4;
}

// Address range: 0xdffe - 0xe07b
int32_t function_dffe(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    g4 = function_d5b0();
    int32_t v2 = function_d5b0(); // 0xe055
    g4 = v2;
    if (v2 < 0) {
        // bb
        function_d525();
        // branch -> 0xe062
    }
    // 0xe062
    g4 = v1;
    if (a1 == NULL) {
        // bb101
        int32_t * v3;
        int32_t v4 = function_d548((int32_t)&v3); // 0xe068
        g4 = v4;
        v1 = v4;
        // branch -> 0xe06e
    }
    // 0xe06e
    return function_d548(v1);
}

// Address range: 0xe07b - 0xe07c
int32_t function_e07b(void) {
    // 0xe07b
    return 0;
}

// Address range: 0xe0a1 - 0xe0a6
int32_t function_e0a1(void) {
    // 0xe0a1
    int32_t * v1;
    return function_d548((int32_t)&v1);
}

// Address range: 0xe0a6 - 0xe0bc
int32_t function_e0a6(void) {
    // 0xe0a6
    function_d5b0();
    int32_t v1; // bp+104
    int32_t v2 = &v1; // 0xe0ab
    g4 = unknown_11980(v2);
    return function_d548(v2);
}

// Address range: 0xe2a0 - 0xe348
int32_t _ZNK5boost8signals26detail20slot_call_iterator_tINS1_12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS5_EEENSA_IFvRKNS0_10connectionES5_EEENS0_5mutexEE12slot_invokerESt14_List_iteratorINS_10shared_ptrINS1_15connection_bodyISt4pairINS1_15slot_meta_groupENS_8optionalIiEEENS0_5slot1IvS5_SC_EESI_EEEEESV_E18lock_next_callableEv(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g10 = v1;
    int32_t v2 = *a1; // 0xe2b7
    g4 = v2;
    int32_t v3 = v1; // 0xe2c2
    int32_t v4 = v2; // 0xe2c2
    if (v2 == *(int32_t *)(v1 + (int32_t)&g37)) {
        int32_t v5 = function_e3d0((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"); // 0xe2bc
        g4 = v5;
        v3 = g10;
        v4 = v5;
        // branch -> 0xe2c2
    }
    int32_t v6 = v4; // 0xe2cb
    if (v4 == *(int32_t *)(v3 + 4)) {
        int32_t v7 = function_e3c8((int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"); // 0xe2c5
        g4 = v7;
        v6 = v7;
        // branch -> 0xe2cb
    }
    int32_t v8 = *(int32_t *)(v6 + 8); // 0xe2cb
    g8 = v8;
    if (v8 == 0) {
        // bb125
        function_e4c5();
        // branch -> 0xe2d6
    }
    int32_t v9 = *(int32_t *)(g10 + 8); // 0xe2de
    int32_t v10 = *(int32_t *)(v9 + (int32_t)&g26); // 0xe2e1
    if (v10 == 0) {
        // bb126
        function_e368(v8);
        v9 = g9;
        // branch -> 0xe2ef
    }
    int32_t v11 = *(int32_t *)(v9 + (int32_t)&g25); // 0xe2ef
    int32_t v12 = 12 * v10; // 0xe2fd
    int32_t v13 = v11 + 4 * (v10 - 3 + 2 * v10); // 0xe300
    uint32_t v14 = v13 - v12; // 0xe305
    int32_t v15 = v13; // 0xe30f
    if (v12 == 0 || v13 < v14) {
        // bb127
        v15 = function_e350(v14);
        // branch -> 0xe30f
    }
    int32_t v16 = *(int32_t *)v15; // 0xe317
    int32_t v17 = v16 >> 31 ^ v16; // 0xe31e
    g4 = v17;
    int32_t result = v17; // 0xe341
    if (v17 < 20) {
        // bb129
        result = function_e418(v15);
        // branch -> 0xe329
    }
    // 0xe329
    return result;
}

// Address range: 0xe350 - 0xe368
int32_t function_e350(int32_t a1) {
    // 0xe350
    *(int32_t *)(a1 + (int32_t)&g26) = 0;
    return 0;
}

// Address range: 0xe368 - 0xe3c8
int32_t function_e368(int32_t a1) {
    int32_t v1 = *(int32_t *)(g10 + 8); // 0xe36e
    int32_t v2 = v1; // 0xe380
    if (v1 == 0) {
        // bb
        v2 = function_e4bd();
        // branch -> 0xe37c
    }
    // 0xe37c
    unknown_1b750(v2, a1 + 4);
    int32_t v3 = *(int32_t *)(g10 + 8); // 0xe38a
    int32_t v4 = v3; // 0xe395
    if (v3 == 0) {
        // bb10
        v4 = function_e4bd();
        // branch -> 0xe395
    }
    int32_t v5 = v4; // 0xe39e
    if (*(char *)(v4 + 4) == 0) {
        // bb11
        v5 = function_e3f0();
        // branch -> 0xe39b
    }
    int32_t v6 = *(int32_t *)(g10 + 8); // 0xe39b
    g9 = v6;
    int32_t v7 = *(int32_t *)(v5 + (int32_t)&g37); // 0xe39e
    int32_t * v8 = (int32_t *)(v6 + 140); // 0xe3a1
    *v8 = *v8 + 1;
    if (v7 != 0) {
        // 0xe3ac
        if (*(int32_t *)(v7 + 4) != 0) {
            // bb12
            function_e3fa();
            // branch -> 0xe3b3
        }
    }
    int32_t v9 = g10; // 0xe3b3
    *(int32_t *)(v9 + (int32_t)&g37) = v9;
    int32_t v10 = g10; // 0xe3c0
    int32_t v11 = *(int32_t *)(v10 + 4); // 0xe3c0
    g4 = v11;
    int32_t result = v11; // 0xe3c7
    if (v10 != v11) {
        // bb13
        result = function_e3d0(g8);
        // branch -> 0xe3c7
    }
    // 0xe3c7
    return result;
}

// Address range: 0xe3c8 - 0xe3d0
int32_t function_e3c8(int32_t a1) {
    int32_t v1 = g10; // 0xe3c8
    int32_t result = *(int32_t *)(v1 + 4); // 0xe3c8
    *(int32_t *)(v1 + (int32_t)&g37) = result;
    return result;
}

// Address range: 0xe3d0 - 0xe3e9
int32_t function_e3d0(int32_t a1) {
    int32_t v1 = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xe3d4
    g9 = v1;
    int32_t result; // 0xe3e8
    if (v1 != 0) {
        // bb
        result = function_e4e9();
        // branch -> 0xe3e1
    } else {
        // 0xe3d0
        result = g4;
        // branch -> 0xe3e1
    }
    // 0xe3e1
    return result;
}

// Address range: 0xe3f0 - 0xe3fa
int32_t function_e3f0(void) {
    int32_t result = *(int32_t *)(g10 + 8); // 0xe3f0
    int32_t * v1 = (int32_t *)(result + (int32_t)"D$\f m"); // 0xe3f3
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0xe3fa - 0xe413
int32_t function_e3fa(void) {
    int32_t v1 = g10; // 0xe402
    *(int32_t *)v1 = v1;
    return function_e3c8(g8);
}

// Address range: 0xe418 - 0xe41f
int32_t function_e418(int32_t a1) {
    // 0xe418
    return g4;
}

// Address range: 0xe448 - 0xe449
int32_t function_e448(int32_t a1) {
    // 0xe448
    return g4;
}

// Address range: 0xe44f - 0xe477
int32_t function_e44f(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0xc18246c; // 0xe44f
    *v1 = *v1 + 1;
    return *(int32_t *)(a1 + (int32_t)&g26);
}

// Address range: 0xe478 - 0xe4bd
int32_t function_e478(int32_t a1) {
    // 0xe47c
    return *(int32_t *)(a1 + 4);
    int32_t v1 = *(int32_t *)*(int32_t *)(a1 + 4); // 0xe4ad
    g4 = v1;
    int32_t v2 = v1; // 0xe4b3
    if (v1 == 0) {
        // bb
        int32_t v3;
        int32_t v4 = function_e448(v3); // 0xe4b1
        g4 = v4;
        v2 = v4;
        // branch -> 0xe4b3
    }
    // 0xe4b3
    return function_e448(v2);
}

// Address range: 0xe4bd - 0xe4c5
int32_t function_e4bd(void) {
    // 0xe4bd
    return unknown_118e2();
}

// Address range: 0xe4c5 - 0xe4e4
int32_t function_e4c5(void) {
    // 0xe4c5
    return g4;
}

// Address range: 0xe4e9 - 0xe4ea
int32_t function_e4e9(void) {
    // 0xe4e9
    return g4;
}

// Address range: 0xe4ef - 0xe4f0
int32_t function_e4ef(void) {
    // 0xe4ef
    return 0;
}

// Address range: 0xe550 - 0xe59a
int32_t _ZN5boost8signals26detail12signal1_implIvP15CCryptoKeyStoreNS0_19optional_last_valueIvEEiSt4lessIiENS_8functionIFvS4_EEENS9_IFvRKNS0_10connectionES4_EEENS0_5mutexEEclES4_(int32_t a1, int32_t result) {
    // 0xe550
    return result;
}

// Address range: 0xe5c8 - 0xe5d4
int32_t function_e5c8(int32_t a1, int32_t result) {
    int32_t * v1 = (int32_t *)(g4 + 4); // 0xe5c8
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0xe5d4 - 0xe5fb
int32_t function_e5d4(void) {
    // 0xe5d4
    int32_t v1; // bp+112
    return unknown_12a20((int32_t)&v1);
}

// Address range: 0xe660 - 0xe6cd
int32_t function_e660(int32_t * a1) {
    char * v1 = (char *)(g7 + 0xf242444); // 0xe660
    unsigned char v2 = *v1; // 0xe660
    *v1 = v2 / 16 | 16 * v2;
    int32_t v3 = unknown_8b000004((int32_t)g2) & -115; // 0xe66e
    int32_t v4 = v3; // eax
    *(int16_t *)(4 * g7 + v3) = g12;
    char * v5 = (char *)v4; // 0xe673
    *v5 = *v5 + (char)v4;
    char * v6 = (char *)(g5 - 0x76abdbbc); // 0xe675
    *v6 = (char)g7 + *v6;
    unknown_1c7f0(v4 & ((int32_t)(char)&g21 | -256));
    int32_t v7 = (int32_t)a1; // 0xe69e
    if (a1 == NULL) {
        // bb
        v7 = function_eaea();
        // branch -> 0xe69e
    }
    // 0xe69e
    int32_t v8; // bp+67
    int32_t v9 = &v8; // 0xe6b2
    v8 = *(int32_t *)*(int32_t *)v7;
    return unknown_1c7f0(v9);
}

// Address range: 0xe6d0 - 0xe700
int32_t function_e6d0(void) {
    int32_t v1 = g4; // 0xe6d0
    int32_t v2 = v1; // 0xe6d9
    if (v1 == 0) {
        int32_t v3 = function_eaea(); // 0xe6d3
        g4 = v3;
        v2 = v3;
        // branch -> 0xe6d9
    }
    // 0xe6d9
    if (*(int32_t *)(v2 + 8) == 0) {
        // bb9
        function_eb0f();
        // branch -> 0xe6e4
    }
    // 0xe6e4
    int32_t result;
    return result;
}

// Address range: 0xe700 - 0xe72c
int32_t function_e700(void) {
    // 0xe700
    int32_t v1;
    if (v1 == g10) {
        // bb
        g4 = function_e9f8();
        // branch -> 0xe70a
    }
    // 0xe70a
    if (*(char *)&g8 == 0) {
        // bb5
        g4 = function_e888();
        // branch -> 0xe713
    }
    // 0xe713
    int32_t v2;
    int32_t result; // 0xe72a
    if (v2 == g10) {
        // bb6
        result = function_eaa0();
        // branch -> 0xe727
    } else {
        // 0xe713
        result = g4;
        // branch -> 0xe727
    }
    // 0xe727
    return result;
}

// Address range: 0xe730 - 0xe7a8
int32_t function_e730(int32_t a1) {
    int32_t v1 = g4; // 0xe730
    *(char *)v1 = (char)v1 + *(char *)&g4;
    int32_t v2 = *(int32_t *)(g8 + (int32_t)&g26); // 0xe742
    if (v2 == 0) {
        // bb
        function_e7b8(0);
        // branch -> 0xe750
    }
    int32_t v3 = *(int32_t *)(g8 + (int32_t)&g25); // 0xe750
    g6 = v3;
    int32_t v4 = 12 * v2; // 0xe75d
    int32_t v5 = v3 + 4 * (v2 - 3 + 2 * v2); // 0xe760
    uint32_t v6 = v5 - v4; // 0xe765
    int32_t v7 = v5; // 0xe76f
    if (v4 == 0 || v5 < v6) {
        // bb20
        v7 = function_e7b0(v6);
        // branch -> 0xe76f
    }
    int32_t v8 = *(int32_t *)v7; // 0xe777
    int32_t v9 = v8 >> 31 ^ v8; // 0xe77e
    g4 = v9;
    int32_t result = v9; // 0xe7a1
    if (v9 < 20) {
        // bb22
        result = function_e878(v7);
        // branch -> 0xe789
    }
    // 0xe789
    return result;
}

// Address range: 0xe7b0 - 0xe7b8
int32_t function_e7b0(int32_t a1) {
    // 0xe7b0
    *(int32_t *)(g8 + (int32_t)&g26) = 0;
    return 0;
}

// Address range: 0xe7b8 - 0xe86e
int32_t function_e7b8(int32_t a1) {
    int32_t v1 = *(int32_t *)(g10 + 8); // 0xe7b8
    int32_t v2 = v1; // 0xe7c7
    if (v1 == 0) {
        // bb
        v2 = function_eb00();
        // branch -> 0xe7c3
    }
    // 0xe7c3
    int32_t v3;
    unknown_1ba00(v2, v3);
    int32_t v4 = *(int32_t *)(g10 + 8); // 0xe7d3
    int32_t v5 = v4; // 0xe7e4
    if (v4 == 0) {
        // bb20
        v5 = function_eb00();
        // branch -> 0xe7de
    }
    // 0xe7de
    int32_t v6; // 0xe82f
    int32_t result; // 0xe867
    if (*(char *)(v5 + 4) == 0) {
        int32_t * v7 = (int32_t *)(g8 + (int32_t)"D$\f m"); // 0xe828
        *v7 = *v7 + 1;
        // branch -> 0xe82f
        // 0xe82f
        v6 = g5;
        g4 = v6;
        result = v6;
        if (g10 == a1) {
            // bb24
            result = function_eaa0();
            // branch -> 0xe844
        }
        // 0xe844
        return result;
    }
    int32_t v8 = *(int32_t *)(v5 + (int32_t)&g37); // 0xe7e4
    int32_t * v9 = (int32_t *)(g8 + 140); // 0xe7e7
    *v9 = *v9 + 1;
    if (v8 != 0) {
        // 0xe7f2
        if (*(int32_t *)(v8 + 4) != 0) {
            // 0xe82f
            v6 = g5;
            g4 = v6;
            result = v6;
            if (g10 == a1) {
                // bb24
                result = function_eaa0();
                // branch -> 0xe844
            }
            // 0xe844
            return result;
        }
    }
    // 0xe7f9
    g4 = g5;
    if (g10 == a1) {
        // bb21
        g4 = function_eaa0();
        // branch -> 0xe80c
    }
    // 0xe80c
    if (*(char *)&g8 == 0) {
        // bb22
        g4 = function_e700();
        // branch -> 0xe819
    }
    // 0xe819
    *(char *)g8 = 0;
    return function_e700();
}

// Address range: 0xe878 - 0xe87f
int32_t function_e878(int32_t a1) {
    // 0xe878
    return g4;
}

// Address range: 0xe881 - 0xe882
int32_t function_e881(int16_t a1) {
    // 0xe881
    return 0;
}

// Address range: 0xe888 - 0xe8c7
int32_t function_e888(void) {
    int32_t v1 = *(int32_t *)(g10 + 8); // 0xe890
    g4 = v1;
    int32_t v2 = v1; // 0xe89b
    if (v1 == 0) {
        int32_t v3 = function_eb00(); // 0xe895
        g4 = v3;
        v2 = v3;
        // branch -> 0xe89b
    }
    int32_t v4 = v2; // 0xe8a6
    if (*(int32_t *)(v2 + (int32_t)&g15) == 0) {
        // bb7
        v4 = function_eb57();
        // branch -> 0xe8a6
    }
    // 0xe8a6
    *(char *)g8 = 1;
    return v4 + (int32_t)&g16;
}

// Address range: 0xe8d0 - 0xe950
int32_t function_e8d0(int32_t a1) {
    int32_t v1 = g4; // 0xe8d1
    char * v2 = (char *)(g6 - 0x38dfdbac); // 0xe8d3
    *v2 = (char)g7 + *v2;
    int32_t v3 = 2 * v1 & 254 | v1 & -256; // 0xe8da
    unsigned char v4 = (char)v3 & (char)&g24; // 0xe8da
    int32_t v5 = (int32_t)v4 | v3 & -256; // 0xe8da
    char * v6 = (char *)v5; // 0xe8dc
    *v6 = *v6 + v4;
    char * v7 = (char *)v5; // 0xe8de
    *v7 = *v7 + (char)v5;
    int32_t v8 = g9; // 0xe8e0
    int32_t v9 = v8; // 0xe8ea
    if (v8 == 0) {
        // bb
        function_eaea();
        v9 = g9;
        // branch -> 0xe8ea
    }
    // 0xe8ea
    g4 = v9;
    int32_t v10;
    int32_t * v11 = (int32_t *)(v10 + 8); // 0xe8f8
    if (v9 == *v11) {
        // bb13
        function_ea92();
        // branch -> 0xe901
    }
    int32_t v12 = *v11; // bp+129
    unknown_1af80(v10, 0, (int32_t)&v12, 1);
    int32_t v13 = *(int32_t *)(v10 + 4); // 0xe934
    g4 = v13;
    if (v13 != 0) {
        // bb14
        function_e5c8(*(int32_t *)v10, v13);
        // branch -> 0xe949
    }
    // 0xe949
    return function_e5d4();
}

// Address range: 0xe950 - 0xe98d
int32_t function_e950(int32_t a1) {
    // 0xe950
    if (g9 < 0) {
        // bb
        function_e9d6();
        // branch -> 0xe958
    }
    // 0xe958
    int32_t v1;
    if (*(int32_t *)(v1 + 4) != 0) {
        // 0xe963
        // branch -> 0xe96b
    }
    // 0xe96b
    return *(int32_t *)(g8 + (int32_t)&g26) - a1;
}

// Address range: 0xe9aa - 0xe9ad
int32_t function_e9aa(int32_t a1) {
    // 0xe9aa
    return g4;
}

// Address range: 0xe9b2 - 0xe9b4
int32_t function_e9b2(void) {
    // 0xe9b2
    return 0;
}

// Address range: 0xe9b8 - 0xe9c5
int32_t function_e9b8(int32_t * a1) {
    // 0xe9b8
    return function_e5d4();
}

// Address range: 0xe9c5 - 0xe9d6
int32_t function_e9c5(int32_t a1) {
    // 0xe9c5
    return unknown_12a20(a1 + 8);
}

// Address range: 0xe9d6 - 0xe9f1
int32_t function_e9d6(void) {
    // 0xe9d6
    int32_t v1;
    int32_t v2 = *(int32_t *)(v1 + 4); // 0xe9da
    g6 = v2;
    int32_t v3 = *(int32_t *)v2; // 0xe9e1
    g4 = v3;
    int32_t v4 = v3; // 0xe9e7
    if (v3 == 0) {
        // bb
        int32_t * v5;
        int32_t v6 = function_e9aa((int32_t)&v5); // 0xe9e5
        g4 = v6;
        v4 = v6;
        // branch -> 0xe9e7
    }
    // 0xe9e7
    return function_e9aa(v4);
}

// Address range: 0xe9f8 - 0xea50
int32_t function_e9f8(void) {
    // 0xe9f8
    uint32_t v1;
    uint32_t v2;
    if (v1 > v2) {
        // bb
        function_eaab();
        // branch -> 0xea0c
    }
    // 0xea0c
    int32_t v3;
    int32_t v4 = v3; // 0xea272
    if (v3 == 0) {
        int32_t v5 = function_ea55(); // 0xea15
        g4 = v5;
        v4 = v5;
        // branch -> 0xea17
    }
    uint32_t v6;
    if (v6 < 10) {
        int32_t v7 = function_eaf8(); // 0xea21
        g4 = v7;
        v4 = v7;
        // branch -> 0xea27
    }
    int32_t result = v4; // 0xea4d6
    int32_t v8;
    if (v4 == v8) {
        // bb17
        result = function_eaef();
        // branch -> 0xea31
    }
    uint32_t v9;
    if (g9 < v9) {
        // bb18
        result = function_eaf8();
        // branch -> 0xea40
    }
    if (v9 != 0) {
        // bb19
        result = function_eac4();
        // branch -> 0xea48
    }
    if (g9 < 11) {
        // bb21
        result = function_ea55();
        // branch -> 0xea4d
    }
    // 0xea4d
    return result;
}

// Address range: 0xea55 - 0xea92
int32_t function_ea55(void) {
    // 0xea55
    int32_t v1; // bp+104
    unknown_12a20((int32_t)&v1);
    int32_t v2;
    int32_t v3 = v2 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xea7a
    g4 = v3;
    int32_t result = v3; // 0xea91
    if (v3 != 0) {
        // bb
        result = function_eb0a();
        // branch -> 0xea87
    }
    // 0xea87
    return result;
}

// Address range: 0xea92 - 0xea9d
int32_t function_ea92(void) {
    // 0xea92
    return g4;
}

// Address range: 0xeaa0 - 0xeaab
int32_t function_eaa0(void) {
    // 0xeaa0
    return g4;
}

// Address range: 0xeaab - 0xeac4
int32_t function_eaab(void) {
    // 0xeaab
    int32_t v1;
    int32_t v2;
    return unknown_1b650(v1, v2);
}

// Address range: 0xeac4 - 0xeaea
int32_t function_eac4(void) {
    // 0xeac4
    int32_t result; // bp+264
    g4 = &result;
    function_e6d0();
    return result;
}

// Address range: 0xeaea - 0xeaef
int32_t function_eaea(void) {
    // 0xeaea
    return unknown_11b5e();
}

// Address range: 0xeaef - 0xeaf8
int32_t function_eaef(void) {
    // 0xeaef
    return g4;
}

// Address range: 0xeaf8 - 0xeb00
int32_t function_eaf8(void) {
    // 0xeaf8
    return unknown_11c2e();
}

// Address range: 0xeb00 - 0xeb0a
int32_t function_eb00(void) {
    // 0xeb00
    unknown_11b92();
    return unknown_11bc6();
}

// Address range: 0xeb0a - 0xeb0b
int32_t function_eb0a(void) {
    // 0xeb0a
    return g4;
}

// Address range: 0xeb0f - 0xeb2e
int32_t function_eb0f(void) {
    // 0xeb0f
    return g4;
}

// Address range: 0xeb57 - 0xeb74
int32_t function_eb57(void) {
    // 0xeb57
    return g4;
}

// Address range: 0xebc7 - 0xebc8
int32_t function_ebc7(void) {
    // 0xebc7
    return g4;
}

// Address range: 0xebc8 - 0xebd4
int32_t function_ebc8(void) {
    int32_t * v1 = (int32_t *)-125; // 0xebc9
    return function_894b7401();
}

// Address range: 0xebf1 - 0xebf7
int32_t function_ebf1(int32_t a1, int16_t a2) {
    // 0xebf1
    return 0;
}

// Address range: 0xebf7 - 0xebf8
int32_t function_ebf7(void) {
    // 0xebf7
    return g4;
}

// Address range: 0xec08 - 0xec09
int32_t function_ec08(void) {
    // 0xec08
    return g4;
}

// Address range: 0xec29 - 0xec2e
int32_t function_ec29(void) {
    // 0xec29
    return 0;
}

// Address range: 0xec71 - 0xec7c
int32_t function_ec71(int32_t a1) {
    // 0xec71
    return function_ebc7();
}

// Address range: 0xec7c - 0xec81
int32_t function_ec7c(void) {
    // 0xec7c
    return 0;
}

// Address range: 0xec8b - 0xec90
int32_t function_ec8b(void) {
    // 0xec8b
    return function_ec08();
}

// Address range: 0xec90 - 0xeca0
int32_t function_ec90(void) {
    // 0xec90
    int32_t result;
    return result;
}

// Address range: 0xeca0 - 0xeca5
int32_t function_eca0(void) {
    // 0xeca0
    return function_ebc7();
}

// Address range: 0xeca5 - 0xecc1
int32_t function_eca5(char a1) {
    // 0xeca5
    return function_ec08();
}

// Address range: 0xecc1 - 0xecc8
int32_t function_ecc1(void) {
    // 0xecc1
    return function_ebf7();
}

// Address range: 0xecd3 - 0xecde
int32_t function_ecd3(int32_t a1) {
    // 0xecd3
    int32_t result;
    return result;
}

// Address range: 0xed30 - 0xed46
int32_t _GLOBAL__sub_I__ZNK9CKeyStore9GetPubKeyERK6CKeyIDR7CPubKey(void) {
    // 0xed30
    return 0;
}

// Address range: 0xeda4 - 0xedaa
int32_t function_eda4(void) {
    // 0xeda4
    return 0;
}

// Address range: 0xedae - 0xedb4
int32_t function_edae(void) {
    // 0xedae
    return 0;
}

// Address range: 0xedb8 - 0xedbe
int32_t function_edb8(void) {
    // 0xedb8
    return 0;
}

// Address range: 0xedbe - 0xedcf
int32_t function_edbe(int32_t a1) {
    int32_t result = a1 ^ (int32_t)"\x89\x44\x24\x5c\x31\xc0\x89\x74\x24\x70\x8b\xb4\x24\x84"; // 0xedc2
    if (result != 0) {
        // 0xedcf
    }
    // 0xedcb
    return result;
}

// Address range: 0x14090 - 0x14091
int32_t function_14090(int32_t a1, int32_t a2) {
    // 0x14090
    return g4;
}

// Address range: 0x894b7401 - 0x894b7402
int32_t function_894b7401(void) {
    // 0x894b7401
    return g4;
}

// Address range: 0xe8008bb1 - 0xe8008bb2
int32_t function_e8008bb1(void) {
    // 0xe8008bb1
    return g4;
}

// Address range: 0xf302b277 - 0xf302b278
int32_t function_f302b277(void) {
    // 0xf302b277
    return g4;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected language: C++
// Detected functions: 811
// Decompilation date: 2018-06-10 00:06:08
