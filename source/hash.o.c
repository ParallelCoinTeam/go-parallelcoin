//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

void __static_initialization_and_destruction_0(int32_t __initialize_p, int32_t __priority);
void _GLOBAL__sub_I__Z11MurmurHash3jRKSt6vectorIhSaIhEE(void);
int32_t _Z11MurmurHash3jRKSt6vectorIhSaIhEE(void);
int32_t _Z6ROTL32ja(uint32_t a1, unsigned char a2);
int32_t _ZNKSt6vectorIhSaIhEE4sizeEv(int32_t * a1);
int32_t _ZNKSt6vectorIhSaIhEEixEj(int32_t * a1, int32_t a2);
int32_t function_1e0(void);
int32_t function_237(int32_t a1, int32_t a2);
int32_t function_248(void);
int32_t function_280(void);
int32_t function_2c(void);
int32_t function_2ea(void);
int32_t function_364(int32_t a1, int32_t a2);
int32_t function_ffffffc1(void);

// --------------------- Global Variables ---------------------

int32_t CADDR_TIME_VERSION = -0x5e9a3fbb;
int32_t NOBLKS_VERSION_START = 20;
int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0x45c7f045;
int32_t g4;

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x3
// Demangled:     MurmurHash3(unsigned int, std::vector<unsigned char, std::allocator<unsigned char> > const &)
int32_t _Z11MurmurHash3jRKSt6vectorIhSaIhEE(void) {
    // 0x0
    return 0;
}

// Address range: 0x2c - 0x1db
int32_t function_2c(void) {
    int32_t v1 = -1;
    int32_t v2;
    if (v1 == 0 || false) {
        // 0x2c
        v2 = g1;
        // branch -> 0x2e
    } else {
        // bb
        v2 = function_ffffffc1();
        // branch -> 0x2e
    }
    int32_t v3 = v2 ^ 0x458b1b87; // eax
    char * v4 = (char *)(v1 - 0x4b17dbfc); // bp+33
    unsigned char v5 = *v4; // bp+33
    *v4 = v5 / 4 | 64 * v5;
    char * v6 = (char *)v3;
    *v6 = *v6 + (char)v3;
    *(int32_t *)(g2 - 28) = v3 / 4;
    int32_t v7 = _ZNKSt6vectorIhSaIhEEixEj((int32_t *)*(int32_t *)(g2 - 64), 0); // bp+50
    *(int32_t *)(g2 - 24) = 4 * *(int32_t *)(g2 - 28) + v7;
    *(int32_t *)(g2 - 44) = -*(int32_t *)(g2 - 28);
    int32_t * v8 = (int32_t *)(g2 - 44); // 0xd8107
    int32_t v9; // bp+127
    int32_t v10; // bp+139
    int32_t v11;
    int32_t v12; // bp+185
    int32_t v13;
    int32_t v14;
    int32_t v15; // bp+113
    int32_t v16;
    int32_t v17; // bp+151
    unsigned char v18;
    int32_t v19; // bp+133
    int32_t * v20; // bp+136
    int32_t v21; // bp+145
    int32_t * v22; // bp+148
    int32_t * v23; // bp+154
    int32_t * v24; // bp+157
    int32_t * v25; // bp+179
    int32_t * v26; // bp+188
    int32_t v27; // bp+191
    int32_t * v28; // bp+196
    int32_t * v29; // bp+199
    int32_t * v30;
    int32_t * v31;
    int32_t * v32;
    int32_t * v33;
    int32_t result;
    int32_t v34;
    int32_t v35;
    int32_t v36;
    if (*v8 == 0) {
        // 0xe3
        v36 = _ZNKSt6vectorIhSaIhEEixEj((int32_t *)*(int32_t *)(g2 - 64), 0);
        v14 = g2;
        *(int32_t *)(v14 - 16) = 4 * *(int32_t *)(v14 - 28) + v36;
        *(int32_t *)(g2 - 40) = 0;
        v15 = _ZNKSt6vectorIhSaIhEE4sizeEv((int32_t *)*(int32_t *)(g2 - 64)) % 4;
        if (v15 == 2) {
            // 0x139
            v10 = g2;
            v16 = *(int32_t *)(v10 - 16) + 1;
            v21 = 256 * ((int32_t)*(char *)v16 & (int32_t)&g3);
            v22 = (int32_t *)(v10 - 40);
            *v22 = v21 ^ *v22;
            // branch -> 0x14b
            // 0x14b
            v11 = g2;
            v34 = *(int32_t *)(v11 - 16);
            v17 = (int32_t)*(char *)v34 & (int32_t)&g3;
            v23 = (int32_t *)(v11 - 40);
            *v23 = *v23 ^ v17;
            v24 = (int32_t *)(g2 - 40);
            *v24 = -0x3361d2af * *v24;
            *(int32_t *)(g2 - 40) = _Z6ROTL32ja(*(int32_t *)(g2 - 40), 15);
            v25 = (int32_t *)(g2 - 40);
            *v25 = 0x1b873593 * *v25;
            v12 = g2;
            v26 = (int32_t *)(v12 - 48);
            *v26 = *v26 ^ *(int32_t *)(v12 - 40);
            // branch -> 0x18b
            // 0x18b
            v27 = _ZNKSt6vectorIhSaIhEE4sizeEv((int32_t *)*(int32_t *)(g2 - 64));
            v28 = (int32_t *)(g2 - 48);
            *v28 = *v28 ^ v27;
            v29 = (int32_t *)(g2 - 48);
            *v29 = *v29 ^ *v29 >> (int32_t)&CADDR_TIME_VERSION;
            v30 = (int32_t *)(g2 - 48);
            *v30 = -0x7a143595 * *v30;
            v31 = (int32_t *)(g2 - 48);
            *v31 = *v31 ^ *v31 / 0x2000;
            v32 = (int32_t *)(g2 - 48);
            *v32 = -0x3d4d51cb * *v32;
            v33 = (int32_t *)(g2 - 48);
            *v33 = *v33 ^ *v33 >> (int32_t)&CADDR_TIME_VERSION;
            v13 = g2;
            v35 = *(int32_t *)(v13 - 48);
            g1 = v35;
            result = v35;
            if (*(int32_t *)(v13 - 12) == 20) {
                // bb104
                result = function_1e0();
                // branch -> 0x1db
            }
            // 0x1db
            return result;
        }
        // 0x11b
        if (v15 == 3) {
            // 0x127
            v9 = g2;
            v18 = *(char *)(*(int32_t *)(v9 - 16) + 2);
            v19 = ((int32_t)v18 & (int32_t)&g3) << (int32_t)&CADDR_TIME_VERSION;
            v20 = (int32_t *)(v9 - 40);
            *v20 = v19 ^ *v20;
            // branch -> 0x139
            // 0x139
            v10 = g2;
            v16 = *(int32_t *)(v10 - 16) + 1;
            v21 = 256 * ((int32_t)*(char *)v16 & (int32_t)&g3);
            v22 = (int32_t *)(v10 - 40);
            *v22 = v21 ^ *v22;
            // branch -> 0x14b
        } else {
            // 0x120
            if (v15 != 1) {
                // 0x18b
                v27 = _ZNKSt6vectorIhSaIhEE4sizeEv((int32_t *)*(int32_t *)(g2 - 64));
                v28 = (int32_t *)(g2 - 48);
                *v28 = *v28 ^ v27;
                v29 = (int32_t *)(g2 - 48);
                *v29 = *v29 ^ *v29 >> (int32_t)&CADDR_TIME_VERSION;
                v30 = (int32_t *)(g2 - 48);
                *v30 = -0x7a143595 * *v30;
                v31 = (int32_t *)(g2 - 48);
                *v31 = *v31 ^ *v31 / 0x2000;
                v32 = (int32_t *)(g2 - 48);
                *v32 = -0x3d4d51cb * *v32;
                v33 = (int32_t *)(g2 - 48);
                *v33 = *v33 ^ *v33 >> (int32_t)&CADDR_TIME_VERSION;
                v13 = g2;
                v35 = *(int32_t *)(v13 - 48);
                g1 = v35;
                result = v35;
                if (*(int32_t *)(v13 - 12) == 20) {
                    // bb104
                    result = function_1e0();
                    // branch -> 0x1db
                }
                // 0x1db
                return result;
            }
        }
        // 0x14b
        v11 = g2;
        v34 = *(int32_t *)(v11 - 16);
        v17 = (int32_t)*(char *)v34 & (int32_t)&g3;
        v23 = (int32_t *)(v11 - 40);
        *v23 = *v23 ^ v17;
        v24 = (int32_t *)(g2 - 40);
        *v24 = -0x3361d2af * *v24;
        *(int32_t *)(g2 - 40) = _Z6ROTL32ja(*(int32_t *)(g2 - 40), 15);
        v25 = (int32_t *)(g2 - 40);
        *v25 = 0x1b873593 * *v25;
        v12 = g2;
        v26 = (int32_t *)(v12 - 48);
        *v26 = *v26 ^ *(int32_t *)(v12 - 40);
        // branch -> 0x18b
        // 0x18b
        v27 = _ZNKSt6vectorIhSaIhEE4sizeEv((int32_t *)*(int32_t *)(g2 - 64));
        v28 = (int32_t *)(g2 - 48);
        *v28 = *v28 ^ v27;
        v29 = (int32_t *)(g2 - 48);
        *v29 = *v29 ^ *v29 >> (int32_t)&CADDR_TIME_VERSION;
        v30 = (int32_t *)(g2 - 48);
        *v30 = -0x7a143595 * *v30;
        v31 = (int32_t *)(g2 - 48);
        *v31 = *v31 ^ *v31 / 0x2000;
        v32 = (int32_t *)(g2 - 48);
        *v32 = -0x3d4d51cb * *v32;
        v33 = (int32_t *)(g2 - 48);
        *v33 = *v33 ^ *v33 >> (int32_t)&CADDR_TIME_VERSION;
        v13 = g2;
        v35 = *(int32_t *)(v13 - 48);
        g1 = v35;
        result = v35;
        if (*(int32_t *)(v13 - 12) == 20) {
            // bb104
            result = function_1e0();
            // branch -> 0x1db
        }
        // 0x1db
        return result;
    }
    int32_t v37 = g2; // 0xd8117
    int32_t v38 = *(int32_t *)(v37 - 24) + 4 * *v8; // bp+70
    *(int32_t *)(v37 - 20) = *(int32_t *)v38;
    int32_t * v39 = (int32_t *)(g2 - 20); // bp+78
    *v39 = -0x3361d2af * *v39;
    *(int32_t *)(g2 - 20) = _Z6ROTL32ja(*(int32_t *)(g2 - 20), 15);
    int32_t * v40 = (int32_t *)(g2 - 20);
    *v40 = 0x1b873593 * *v40;
    int32_t * v41 = (int32_t *)(g2 - 48);
    *v41 = *v41 ^ *(int32_t *)(g2 - 20);
    *(int32_t *)(g2 - 48) = _Z6ROTL32ja(*(int32_t *)(g2 - 48), 13);
    int32_t * v42 = (int32_t *)(g2 - 48);
    *v42 = 5 * *v42 - 0x19ab949c;
    int32_t * v43 = (int32_t *)(g2 - 44);
    *v43 = *v43 + 1;
    while (*(int32_t *)(g2 - 44) != 0) {
        // 0x6a
        v37 = g2;
        v38 = *(int32_t *)(v37 - 24) + 4 * *(int32_t *)(g2 - 44);
        *(int32_t *)(v37 - 20) = *(int32_t *)v38;
        v39 = (int32_t *)(g2 - 20);
        *v39 = -0x3361d2af * *v39;
        *(int32_t *)(g2 - 20) = _Z6ROTL32ja(*(int32_t *)(g2 - 20), 15);
        v40 = (int32_t *)(g2 - 20);
        *v40 = 0x1b873593 * *v40;
        v41 = (int32_t *)(g2 - 48);
        *v41 = *v41 ^ *(int32_t *)(g2 - 20);
        *(int32_t *)(g2 - 48) = _Z6ROTL32ja(*(int32_t *)(g2 - 48), 13);
        v42 = (int32_t *)(g2 - 48);
        *v42 = 5 * *v42 - 0x19ab949c;
        v43 = (int32_t *)(g2 - 44);
        *v43 = *v43 + 1;
        // continue -> 0x6a
    }
    // 0xe3
    v36 = _ZNKSt6vectorIhSaIhEEixEj((int32_t *)*(int32_t *)(g2 - 64), 0);
    v14 = g2;
    *(int32_t *)(v14 - 16) = 4 * *(int32_t *)(v14 - 28) + v36;
    *(int32_t *)(g2 - 40) = 0;
    v15 = _ZNKSt6vectorIhSaIhEE4sizeEv((int32_t *)*(int32_t *)(g2 - 64)) % 4;
    if (v15 == 2) {
        // 0x139
        v10 = g2;
        v16 = *(int32_t *)(v10 - 16) + 1;
        v21 = 256 * ((int32_t)*(char *)v16 & (int32_t)&g3);
        v22 = (int32_t *)(v10 - 40);
        *v22 = v21 ^ *v22;
        // branch -> 0x14b
        // 0x14b
        v11 = g2;
        v34 = *(int32_t *)(v11 - 16);
        v17 = (int32_t)*(char *)v34 & (int32_t)&g3;
        v23 = (int32_t *)(v11 - 40);
        *v23 = *v23 ^ v17;
        v24 = (int32_t *)(g2 - 40);
        *v24 = -0x3361d2af * *v24;
        *(int32_t *)(g2 - 40) = _Z6ROTL32ja(*(int32_t *)(g2 - 40), 15);
        v25 = (int32_t *)(g2 - 40);
        *v25 = 0x1b873593 * *v25;
        v12 = g2;
        v26 = (int32_t *)(v12 - 48);
        *v26 = *v26 ^ *(int32_t *)(v12 - 40);
        // branch -> 0x18b
        // 0x18b
        v27 = _ZNKSt6vectorIhSaIhEE4sizeEv((int32_t *)*(int32_t *)(g2 - 64));
        v28 = (int32_t *)(g2 - 48);
        *v28 = *v28 ^ v27;
        v29 = (int32_t *)(g2 - 48);
        *v29 = *v29 ^ *v29 >> (int32_t)&CADDR_TIME_VERSION;
        v30 = (int32_t *)(g2 - 48);
        *v30 = -0x7a143595 * *v30;
        v31 = (int32_t *)(g2 - 48);
        *v31 = *v31 ^ *v31 / 0x2000;
        v32 = (int32_t *)(g2 - 48);
        *v32 = -0x3d4d51cb * *v32;
        v33 = (int32_t *)(g2 - 48);
        *v33 = *v33 ^ *v33 >> (int32_t)&CADDR_TIME_VERSION;
        v13 = g2;
        v35 = *(int32_t *)(v13 - 48);
        g1 = v35;
        result = v35;
        if (*(int32_t *)(v13 - 12) == 20) {
            // bb104
            result = function_1e0();
            // branch -> 0x1db
        }
        // 0x1db
        return result;
    }
    // 0x11b
    if (v15 == 3) {
        // 0x127
        v9 = g2;
        v18 = *(char *)(*(int32_t *)(v9 - 16) + 2);
        v19 = ((int32_t)v18 & (int32_t)&g3) << (int32_t)&CADDR_TIME_VERSION;
        v20 = (int32_t *)(v9 - 40);
        *v20 = v19 ^ *v20;
        // branch -> 0x139
        // 0x139
        v10 = g2;
        v16 = *(int32_t *)(v10 - 16) + 1;
        v21 = 256 * ((int32_t)*(char *)v16 & (int32_t)&g3);
        v22 = (int32_t *)(v10 - 40);
        *v22 = v21 ^ *v22;
        // branch -> 0x14b
    } else {
        // 0x120
        if (v15 != 1) {
            // 0x18b
            v27 = _ZNKSt6vectorIhSaIhEE4sizeEv((int32_t *)*(int32_t *)(g2 - 64));
            v28 = (int32_t *)(g2 - 48);
            *v28 = *v28 ^ v27;
            v29 = (int32_t *)(g2 - 48);
            *v29 = *v29 ^ *v29 >> (int32_t)&CADDR_TIME_VERSION;
            v30 = (int32_t *)(g2 - 48);
            *v30 = -0x7a143595 * *v30;
            v31 = (int32_t *)(g2 - 48);
            *v31 = *v31 ^ *v31 / 0x2000;
            v32 = (int32_t *)(g2 - 48);
            *v32 = -0x3d4d51cb * *v32;
            v33 = (int32_t *)(g2 - 48);
            *v33 = *v33 ^ *v33 >> (int32_t)&CADDR_TIME_VERSION;
            v13 = g2;
            v35 = *(int32_t *)(v13 - 48);
            g1 = v35;
            result = v35;
            if (*(int32_t *)(v13 - 12) == 20) {
                // bb104
                result = function_1e0();
                // branch -> 0x1db
            }
            // 0x1db
            return result;
        }
    }
    // 0x14b
    v11 = g2;
    v34 = *(int32_t *)(v11 - 16);
    v17 = (int32_t)*(char *)v34 & (int32_t)&g3;
    v23 = (int32_t *)(v11 - 40);
    *v23 = *v23 ^ v17;
    v24 = (int32_t *)(g2 - 40);
    *v24 = -0x3361d2af * *v24;
    *(int32_t *)(g2 - 40) = _Z6ROTL32ja(*(int32_t *)(g2 - 40), 15);
    v25 = (int32_t *)(g2 - 40);
    *v25 = 0x1b873593 * *v25;
    v12 = g2;
    v26 = (int32_t *)(v12 - 48);
    *v26 = *v26 ^ *(int32_t *)(v12 - 40);
    // branch -> 0x18b
    // 0x18b
    v27 = _ZNKSt6vectorIhSaIhEE4sizeEv((int32_t *)*(int32_t *)(g2 - 64));
    v28 = (int32_t *)(g2 - 48);
    *v28 = *v28 ^ v27;
    v29 = (int32_t *)(g2 - 48);
    *v29 = *v29 ^ *v29 >> (int32_t)&CADDR_TIME_VERSION;
    v30 = (int32_t *)(g2 - 48);
    *v30 = -0x7a143595 * *v30;
    v31 = (int32_t *)(g2 - 48);
    *v31 = *v31 ^ *v31 / 0x2000;
    v32 = (int32_t *)(g2 - 48);
    *v32 = -0x3d4d51cb * *v32;
    v33 = (int32_t *)(g2 - 48);
    *v33 = *v33 ^ *v33 >> (int32_t)&CADDR_TIME_VERSION;
    v13 = g2;
    v35 = *(int32_t *)(v13 - 48);
    g1 = v35;
    result = v35;
    if (*(int32_t *)(v13 - 12) == 20) {
        // bb104
        result = function_1e0();
        // branch -> 0x1db
    }
    // 0x1db
    return result;
}

// Address range: 0x1e0 - 0x1e2
int32_t function_1e0(void) {
    // 0x1e0
    return g1;
}

// Address range: 0x1e2 - 0x215
// Line range:    0 - 58
void __static_initialization_and_destruction_0(int32_t __initialize_p, int32_t __priority) {
    // 0x1e2
    if (__initialize_p != 1) {
        // bb
        function_237(__priority, __initialize_p);
        // branch -> 0x205
    }
    // 0x205
    if (__priority != 0xffff) {
        // bb9
        function_237((int32_t)&NOBLKS_VERSION_START, (int32_t)&g4);
        // branch -> 0x20e
    }
}

// Address range: 0x237 - 0x243
int32_t function_237(int32_t a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(g2 - 12) ^ 20;
    g1 = v1;
    int32_t result = v1; // bp+241
    if (v1 == 0) {
        // bb
        result = function_248();
        // branch -> 0x243
    }
    // 0x243
    return result;
}

// Address range: 0x248 - 0x24a
int32_t function_248(void) {
    // 0x248
    return g1;
}

// Address range: 0x24a - 0x27b
// Line range:    0 - 58
void _GLOBAL__sub_I__Z11MurmurHash3jRKSt6vectorIhSaIhEE(void) {
    // 0x24a
    __static_initialization_and_destruction_0(1, 0xffff);
    g1 = (int32_t)&NOBLKS_VERSION_START ^ 20;
    if (((int32_t)&NOBLKS_VERSION_START ^ 20) == 0) {
        // bb
        function_280();
        // branch -> 0x27b
    }
}

// Address range: 0x280 - 0x282
int32_t function_280(void) {
    // 0x280
    return g1;
}

// Address range: 0x2ac - 0x2e5
// Demangled:     ROTL32(unsigned int, signed char)
int32_t _Z6ROTL32ja(uint32_t a1, unsigned char a2) {
    uint32_t v1 = (int32_t)a2 & (int32_t)&g3 & 31;
    int32_t result = a1;
    if (v1 != 0) {
        // bb
        result = a1 >> 32 - v1 | a1 << v1;
        // branch -> bb11
    }
    // bb11
    g1 = result;
    if (((int32_t)&NOBLKS_VERSION_START ^ 20) == 0) {
        // bb12
        result = function_2ea();
        // branch -> 0x2e5
    }
    // 0x2e5
    return result;
}

// Address range: 0x2ea - 0x2f0
int32_t function_2ea(void) {
    // 0x2ea
    return g1;
}

// Address range: 0x2f0 - 0x32d
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::size() const
int32_t _ZNKSt6vectorIhSaIhEE4sizeEv(int32_t * a1) {
    // 0x2f0
    return *(int32_t *)((int32_t)a1 + 4) - *a1;
}

// Address range: 0x32e - 0x35f
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::operator[](unsigned int) const
int32_t _ZNKSt6vectorIhSaIhEEixEj(int32_t * a1, int32_t a2) {
    int32_t result = *a1 + a2; // bp+350
    g1 = result;
    if (((int32_t)&NOBLKS_VERSION_START ^ 20) == 0) {
        // bb
        result = function_364(a2, (int32_t)a1);
        // branch -> 0x35f
    }
    // 0x35f
    return result;
}

// Address range: 0x364 - 0x366
int32_t function_364(int32_t a1, int32_t a2) {
    // 0x364
    return g1;
}

// Address range: 0xffffffc1 - 0xffffffc2
int32_t function_ffffffc1(void) {
    // 0xffffffc1
    return g1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected language: C++
// Detected functions: 14
// Decompilation date: 2018-06-10 00:05:19
