//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct CService {
    int16_t e0;
};

struct CService_3 {
    int16_t e0;
};

struct vtable_8480_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t);
};

struct vtable_8498_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_84b0_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_84d8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_8518_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

struct vtable_8598_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_85b8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
};

struct vtable_85f8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)();
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t);
};

struct vtable_8678_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
};

struct vtable_86b8_type {
    int32_t (*e0)(int32_t *);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t);
    int32_t (*e3)(int32_t);
};

// ------------------------- Classes --------------------------

// N5boost10lock_errorE (base classes: N5boost16thread_exceptionE)
// N5boost16exception_detail10bad_alloc_E
// N5boost16exception_detail10clone_baseE
// N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE (base classes: N5boost16exception_detail10bad_alloc_E, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE (base classes: N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE (base classes: N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEE, N5boost16exception_detail10clone_baseE)
// N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE (base classes: N5boost10lock_errorE, N5boost9exceptionE)
// N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEE (base classes: N5boost21thread_resource_errorE, N5boost9exceptionE)
// N5boost16thread_exceptionE
// N5boost21thread_resource_errorE (base classes: N5boost16thread_exceptionE)
// N5boost6detail15sp_counted_baseE
// N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE (base classes: N5boost6detail15sp_counted_baseE)
// N5boost6system12system_errorE
// N5boost9exceptionE

// ------------------- Function Prototypes --------------------

void _7e_clone_impl(int32_t this, int32_t __in_chrg);
void _7e_pthread_mutex_scoped_lock(int32_t this, int32_t __in_chrg);
int32_t _GLOBAL__sub_I_nConnectTimeout(void);
bool _Z10LookupHostPKcRSt6vectorI8CNetAddrSaIS2_EEjb(char * pszName, int32_t vIP, int32_t nMaxSolutions, bool fAllowLookup);
bool _Z12GetNameProxyRSt4pairI8CServiceiE(int32_t nameproxyInfoOut);
int32_t _Z12ParseNetworkSs(int32_t net);
bool _Z12SetNameProxy8CServicei(struct CService addrProxy, int32_t nSocksVersion);
bool _Z13ConnectSocketRK8CServiceRji(struct CService addrDest, int32_t hSocketRet, int32_t nTimeout);
bool _Z13HaveNameProxyv(void);
bool _Z13LookupNumericPKcR8CServicei(char * pszName, int32_t addr, int32_t portDefault);
int32_t _Z13myclosesocketRj(int32_t * a1);
void _Z13SplitHostPortSsRiRSs(int32_t in, int32_t portOut, int32_t hostOut);
bool _Z17LookupHostNumericPKcRSt6vectorI8CNetAddrSaIS2_EEj(char * pszName, int32_t vIP, int32_t nMaxSolutions);
bool _Z19ConnectSocketByNameR8CServiceRjPKcii(struct CService addr, int32_t hSocketRet, char * pszDest, int32_t portDefault, int32_t nTimeout);
bool _Z6LookupPKcR8CServiceib(char * pszName, int32_t addr, int32_t portDefault, bool fAllowLookup);
bool _Z6LookupPKcRSt6vectorI8CServiceSaIS2_EEibj(char * pszName, int32_t vAddr, int32_t portDefault, bool fAllowLookup, int32_t nMaxSolutions);
bool _Z7IsProxyRK8CNetAddr(int32_t addr);
bool _Z8GetProxy7NetworkRSt4pairI8CServiceiE(uint32_t net, int32_t proxyInfoOut);
bool _Z8SetProxy7Network8CServicei(uint32_t net, struct CService_3 addrProxy, int32_t nSocksVersion);
bool _ZeqRK8CNetAddrS1_(uint32_t a, int32_t b);
bool _ZeqRK8CServiceS1_(int32_t a, int32_t b);
bool _ZltRK8CNetAddrS1_(uint32_t a, int32_t b);
bool _ZltRK8CServiceS1_(int32_t a, int32_t b);
int32_t _ZN14AnnotatedMixinIN5boost15recursive_mutexEED1Ev(int32_t a1);
int32_t _ZN5boost10lock_errorD0Ev(int32_t * a1);
int32_t _ZN5boost10lock_errorD1Ev(int32_t * a1);
int32_t _ZN5boost10shared_ptrIKNS_16exception_detail10clone_baseEED1Ev(int32_t a1);
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(int32_t * a1);
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(int32_t * a1);
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED2Ev_part_104(void);
int32_t _ZN5boost15recursive_mutexC1Ev(int32_t a1);
int32_t _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(int32_t a1);
int32_t _ZN5boost15throw_exceptionINS_21thread_resource_errorEEEvRKT_(int32_t a1);
int32_t _ZN5boost16exception_detail10bad_alloc_D0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10bad_alloc_D1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail13get_bad_allocILi42EEENS_10shared_ptrIKNS0_10clone_baseEEEv(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEEC1ERKS3_(int32_t * a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEC1ERKS3_(int32_t * a1, int32_t a2);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED1Ev(int32_t * a1);
int32_t _ZN5boost16exception_detail20copy_boost_exceptionEPNS_9exceptionEPKS1_(int32_t a1, int32_t a2);
int32_t _ZN5boost16thread_exceptionD0Ev(int32_t * a1);
int32_t _ZN5boost16thread_exceptionD1Ev(int32_t * a1);
int32_t _ZN5boost21thread_resource_errorD0Ev(int32_t * a1);
int32_t _ZN5boost21thread_resource_errorD1Ev(int32_t * a1);
int32_t _ZN5boost6detail15sp_counted_base7destroyEv(int32_t * a1);
int32_t _ZN5boost6detail15sp_counted_baseD0Ev(int32_t * a1);
int32_t _ZN5boost6detail15sp_counted_baseD1Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE11get_deleterERKSt9type_info(void);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE7disposeEv(int32_t a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED0Ev(int32_t * a1);
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED1Ev(int32_t * a1);
int32_t _ZN5boost6system12system_errorD0Ev(int32_t * a1);
int32_t _ZN5boost6system12system_errorD1Ev(int32_t * a1);
int32_t _ZN5boost6system14error_categoryD0Ev(int32_t * a1);
int32_t _ZN5boost6system14error_categoryD1Ev(int32_t * a1);
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockC2EP15pthread_mutex_t_part_20(void);
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockD2Ev_part_21(void);
int32_t _ZN5boost9exceptionD0Ev(int32_t a1);
int32_t _ZN5boost9exceptionD1Ev(int32_t * a1);
void _ZN8CNetAddr10SetSpecialERKSs(int32_t this, int32_t strName);
void _ZN8CNetAddr4InitEv(int32_t this);
void _ZN8CNetAddr5SetIPERKS_(int32_t this, int32_t ipIn);
void _ZN8CService11SetSockAddrEPK8sockaddr(int32_t this, int32_t paddr);
void _ZN8CService4InitEv(int32_t this);
void _ZN8CService7SetPortEt(int32_t this, int16_t portIn);
bool _ZneRK8CNetAddrS1_(uint32_t a, int32_t b);
bool _ZneRK8CServiceS1_(int32_t a, int32_t b);
int32_t _ZNK5boost10lock_error4whatEv(void);
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1);
void _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t this);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv(int32_t a1);
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZNK5boost21thread_resource_error4whatEv(void);
int32_t _ZNK5boost6system12system_error4whatEv(int32_t a1);
int32_t _ZNK5boost6system14error_category10equivalentEiRKNS0_15error_conditionE(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNK5boost6system14error_category10equivalentERKNS0_10error_codeEi(int32_t a1, int32_t * a2, int32_t a3);
int32_t _ZNK5boost6system14error_category23default_error_conditionEi(int32_t * a1, int32_t a2, int32_t a3);
void _ZNK8CNetAddr10GetIn6AddrEP8in6_addr(int32_t this, int32_t pipv6Addr);
void _ZNK8CNetAddr10GetNetworkEv(int32_t this);
void _ZNK8CNetAddr10IsRoutableEv(int32_t this);
void _ZNK8CNetAddr10ToStringIPEv(int32_t this);
void _ZNK8CNetAddr11IsMulticastEv(int32_t this);
void _ZNK8CNetAddr19GetReachabilityFromEPKS_(int32_t this, int32_t paddrPartner);
void _ZNK8CNetAddr5IsTorEv(int32_t this);
void _ZNK8CNetAddr5printEv(int32_t this);
void _ZNK8CNetAddr6IsIPv4Ev(int32_t this);
void _ZNK8CNetAddr6IsIPv6Ev(int32_t this);
void _ZNK8CNetAddr7GetByteEi(int32_t this, int32_t n);
void _ZNK8CNetAddr7GetHashEv(int32_t this);
void _ZNK8CNetAddr7IsLocalEv(int32_t this);
void _ZNK8CNetAddr7IsValidEv(int32_t this);
void _ZNK8CNetAddr8GetGroupEv(int32_t this);
void _ZNK8CNetAddr8ToStringEv(int32_t this);
void _ZNK8CNetAddr9GetInAddrEP7in_addr(int32_t this, int32_t pipv4Addr);
void _ZNK8CNetAddr9IsRFC1918Ev(int32_t this);
void _ZNK8CNetAddr9IsRFC3849Ev(int32_t this);
void _ZNK8CNetAddr9IsRFC3927Ev(int32_t this);
void _ZNK8CNetAddr9IsRFC3964Ev(int32_t this);
void _ZNK8CNetAddr9IsRFC4193Ev(int32_t this);
void _ZNK8CNetAddr9IsRFC4380Ev(int32_t this);
void _ZNK8CNetAddr9IsRFC4843Ev(int32_t this);
void _ZNK8CNetAddr9IsRFC4862Ev(int32_t this);
void _ZNK8CNetAddr9IsRFC6052Ev(int32_t this);
void _ZNK8CNetAddr9IsRFC6145Ev(int32_t this);
void _ZNK8CService11GetSockAddrEP8sockaddrPj(int32_t this, int32_t paddr, int32_t * addrlen);
void _ZNK8CService12ToStringPortEv(int32_t this);
void _ZNK8CService14ToStringIPPortEv(int32_t this);
void _ZNK8CService5printEv(int32_t this);
void _ZNK8CService6GetKeyEv(struct CService * this);
void _ZNK8CService7GetPortEv(int32_t this);
void _ZNK8CService8ToStringEv(int32_t this);
int32_t _ZNSt6vectorI8CNetAddrSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_(int32_t * a1, int32_t a2);
int32_t _ZNSt6vectorI8CServiceSaIS0_EE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPS0_S2_EEjRKS0_(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t _ZNSt6vectorIhSaIhEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPhS1_EERKh(int32_t * a1, int32_t a2, int32_t a3);
int32_t _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(int32_t a1, int32_t a2, uint32_t a3, char * a4);
int32_t _ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_S8_(int32_t result, int32_t a2, int32_t a3);
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D0Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D1Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1);
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1);
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1);
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1);
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1);
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t a1);
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv(int32_t a1);
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev(int32_t a1);
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED1Ev(int32_t a1);
void CNetAddr(int32_t this);
void CNetAddr2(int32_t this, int32_t ipv4Addr);
void CNetAddr3(int32_t this, int32_t ipv6Addr);
void CNetAddr4(int32_t this, int32_t strIp, bool fAllowLookup);
void CNetAddr5(int32_t this, char * pszIp, bool fAllowLookup);
bool ConnectSocketDirectly(int32_t addrConnect, int32_t hSocketRet, int32_t nTimeout);
void CService(int32_t this);
void CService10(int32_t this, char * pszIpPort, bool fAllowLookup);
void CService2(int32_t this, int32_t cip, int16_t portIn);
void CService3(int32_t this, int32_t ipv4Addr, int16_t portIn);
void CService4(int32_t this, int32_t ipv6Addr, int16_t portIn);
void CService5(int32_t this, int32_t addr);
void CService6(int32_t this, int32_t addr);
void CService7(int32_t this, int32_t strIpPort, int32_t portDefault, bool fAllowLookup);
void CService8(int32_t this, int32_t strIpPort, bool fAllowLookup);
void CService9(int32_t this, char * pszIpPort, int32_t portDefault, bool fAllowLookup);
int32_t fNameLookup(void);
int32_t function_107a(int32_t a1);
int32_t function_110a(int32_t a1);
int32_t function_11ba(int32_t a1);
int32_t function_1297(void);
int32_t function_129f(void);
int32_t function_1392(void);
int32_t function_13a8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_13d1(void);
int32_t function_1414(void);
int32_t function_1420(void);
int32_t function_1445(void);
int32_t function_147(void);
int32_t function_161a(int32_t a1);
int32_t function_166a(int32_t a1);
int32_t function_16ba(void);
int32_t function_171(void);
int32_t function_1853(int32_t a1, int32_t a2);
int32_t function_199(void);
int32_t function_1bed(void);
int32_t function_1c7d(void);
int32_t function_1e1d(void);
int32_t function_1eb1(void);
int32_t function_2231(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2278(void);
int32_t function_22d(int32_t result);
int32_t function_2387(void);
int32_t function_2390(void);
int32_t function_2430(void);
int32_t function_2438(void);
int32_t function_2470(void);
int32_t function_2478(int32_t a1, int32_t a2);
int32_t function_2488(int32_t a1);
int32_t function_248e(void);
int32_t function_2497(void);
int32_t function_24a7(void);
int32_t function_2581(void);
int32_t function_2583(int32_t a1, int32_t a2);
int32_t function_25a0(void);
int32_t function_26f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2730(void);
int32_t function_276(int32_t a1, int32_t result);
int32_t function_280f(void);
int32_t function_2814(int32_t a1);
int32_t function_2819(int32_t a1);
int32_t function_281a(void);
int32_t function_2823(void);
int32_t function_282b(void);
int32_t function_2833(void);
int32_t function_283d(void);
int32_t function_2842(void);
int32_t function_2847(void);
int32_t function_2848(void);
int32_t function_2859(void);
int32_t function_2862(void);
int32_t function_286e(void);
int32_t function_2871(void);
int32_t function_2872(int32_t a1);
int32_t function_287a(void);
int32_t function_287c(void);
int32_t function_2888(void);
int32_t function_292a(void);
int32_t function_2961(void);
int32_t function_2963(void);
int32_t function_2980(void);
int32_t function_2a83(void);
int32_t function_2b12(void);
int32_t function_2b42(void);
int32_t function_2b56(void);
int32_t function_2c0a(int16_t a1);
int32_t function_2c31(void);
int32_t function_2c6d(void);
int32_t function_2c78(void);
int32_t function_2cae(void);
int32_t function_2cb5(void);
int32_t function_2cdf(void);
int32_t function_2ce6(int32_t a1, int32_t a2);
int32_t function_2cec(void);
int32_t function_2df0(void);
int32_t function_2e04(void);
int32_t function_2e0f(void);
int32_t function_2e20(int32_t a1);
int32_t function_2fca(void);
int32_t function_2fee(void);
int32_t function_2ff4(void);
int32_t function_3118(int32_t a1, int32_t a2);
int32_t function_3139(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3158(int32_t a1, int32_t a2, int32_t a3);
int32_t function_315c(void);
int32_t function_316d(void);
int32_t function_3189(void);
int32_t function_31b(int32_t result);
int32_t function_3259(void);
int32_t function_3324(void);
int32_t function_35c(void);
int32_t function_368(int32_t a1);
int32_t function_373(void);
int32_t function_3765(int32_t * a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_38ae(void);
int32_t function_38ba(void);
int32_t function_38c0(int32_t a1, int32_t a2);
int32_t function_38f8(int32_t a1);
int32_t function_3909(void);
int32_t function_390a(void);
int32_t function_390b(void);
int32_t function_391e(void);
int32_t function_3931(void);
int32_t function_3933(void);
int32_t function_39af(void);
int32_t function_39c8(void);
int32_t function_39ed(void);
int32_t function_39f1(void);
int32_t function_3b3(void);
int32_t function_3bf(void);
int32_t function_3c9(void);
int32_t function_3d01(void);
int32_t function_3e2(void);
int32_t function_3ebb(void);
int32_t function_3ed1(void);
int32_t function_3ee(void);
int32_t function_3ee0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_3ee8(void);
int32_t function_3eee(void);
int32_t function_3efb(void);
int32_t function_3f0d(void);
int32_t function_3fcd(void);
int32_t function_3fe3(void);
int32_t function_3ff6(void);
int32_t function_4006(void);
int32_t function_40ee(void);
int32_t function_4104(void);
int32_t function_4116(void);
int32_t function_411c(void);
int32_t function_41ad(void);
int32_t function_41c4(void);
int32_t function_41d6(void);
int32_t function_42fd(void);
int32_t function_4314(void);
int32_t function_432e(void);
int32_t function_4333(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4362(void);
int32_t function_437(void);
int32_t function_444(void);
int32_t function_4490(int32_t result);
int32_t function_4496(void);
int32_t function_44a8(void);
int32_t function_44e2(void);
int32_t function_457(void);
int32_t function_45a2(void);
int32_t function_45a8(void);
int32_t function_45c1(void);
int32_t function_45d0(void);
int32_t function_45e9(void);
int32_t function_45f(void);
int32_t function_45f5(void);
int32_t function_4664(void);
int32_t function_4669(void);
int32_t function_4671(void);
int32_t function_46a3(void);
int32_t function_46d7(void);
int32_t function_46dc(void);
int32_t function_46e5(void);
int32_t function_46f7(void);
int32_t function_4722(void);
int32_t function_4727(void);
int32_t function_4729(void);
int32_t function_4822(void);
int32_t function_486c(int16_t a1);
int32_t function_48a8(void);
int32_t function_48a9(void);
int32_t function_48b(void);
int32_t function_48b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_48d8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, uint16_t a8);
int32_t function_4985(int32_t * a1, int32_t a2);
int32_t function_49a3(int32_t a1);
int32_t function_49a9(void);
int32_t function_49b4(void);
int32_t function_49b5(void);
int32_t function_49b6(void);
int32_t function_49c6(void);
int32_t function_49cc(void);
int32_t function_49da(void);
int32_t function_4b8d(void);
int32_t function_4b9c(void);
int32_t function_4ba1(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4bb(void);
int32_t function_4bcb(void);
int32_t function_4c8b(void);
int32_t function_4fa(void);
int32_t function_521(void);
int32_t function_5363(int32_t a1);
int32_t function_53a3(int32_t a1);
int32_t function_53e3(int32_t a1);
int32_t function_5423(int32_t a1);
int32_t function_5463(int32_t a1);
int32_t function_54a2(void);
int32_t function_57e(int32_t a1);
int32_t function_58d(void);
int32_t function_5a9(void);
int32_t function_5bf(void);
int32_t function_5c2b(void);
int32_t function_5c3a(int32_t a1);
int32_t function_5c4(void);
int32_t function_5c75(void);
int32_t function_5cc1(int32_t a1);
int32_t function_5d73(int32_t a1);
int32_t function_5e1(void);
int32_t function_5e90(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5f2(void);
int32_t function_5f30(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5ff0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_603(void);
int32_t function_608(void);
int32_t function_60dd(void);
int32_t function_60ff(void);
int32_t function_6130(void);
int32_t function_6150(void);
int32_t function_6152(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_6163(void);
int32_t function_6174(void);
int32_t function_617a(void);
int32_t function_6180(void);
int32_t function_6183(void);
int32_t function_625(void);
int32_t function_62a5(void);
int32_t function_62a7(int32_t a1);
int32_t function_62ac(void);
int32_t function_6317(void);
int32_t function_636(void);
int32_t function_636b(int32_t a1);
int32_t function_63b(int32_t a1, int32_t result);
int32_t function_63ec(void);
int32_t function_645c(void);
int32_t function_64c2(int32_t a1);
int32_t function_656(int32_t a1);
int32_t function_65ab(int32_t a1);
int32_t function_665b(int32_t a1);
int32_t function_66d3(void);
int32_t function_66e(void);
int32_t function_67b4(int32_t a1);
int32_t function_67f(int32_t a1, int32_t result);
int32_t function_68bb(int32_t a1);
int32_t function_68f6(void);
int32_t function_692b(int32_t a1);
int32_t function_69a(int32_t a1, int32_t result);
int32_t function_6b5(int32_t a1, int32_t result);
int32_t function_6efa(void);
int32_t function_6f03(void);
int32_t function_6f17(void);
int32_t function_7070(void);
int32_t function_70e1(void);
int32_t function_7100(int32_t a1);
int32_t function_715e(int32_t a1);
int32_t function_71d4(void);
int32_t function_71eb(void);
int32_t function_720a(void);
int32_t function_72d0(void);
int32_t function_732(int16_t a1);
int32_t function_736a(void);
int32_t function_73d1(void);
int32_t function_73f0(int32_t a1);
int32_t function_744(void);
int32_t function_750(void);
int32_t function_7508(int32_t a1, int32_t a2, int32_t a3, int32_t result, int32_t a5, int32_t a6, char * a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_7530(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17);
int32_t function_75f6(void);
int32_t function_75fb(void);
int32_t function_7616(void);
int32_t function_761f(void);
int32_t function_764a(void);
int32_t function_7656(void);
int32_t function_777(void);
int32_t function_784(void);
int32_t function_78ae(void);
int32_t function_78c3(int32_t a1);
int32_t function_78d7(void);
int32_t function_7908(void);
int32_t function_7980(void);
int32_t function_7986(int32_t a1);
int32_t function_798b(int32_t a1);
int32_t function_799(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_7ae3(void);
int32_t function_7af3(void);
int32_t function_7af8(int32_t a1);
int32_t function_7c6(void);
int32_t function_7db6(void);
int32_t function_7dd0(void);
int32_t function_7e08(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint16_t a5, int32_t a6);
int32_t function_7ee3(void);
int32_t function_7ef2(void);
int32_t function_7ef7(void);
int32_t function_7f0(void);
int32_t function_7f03(int32_t a1);
int32_t function_7f4f(void);
int32_t function_7f60(void);
int32_t function_7f74(void);
int32_t function_7f94(int32_t a1);
int32_t function_7fac(void);
int32_t function_7ff1(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_800(void);
int32_t function_802e(void);
int32_t function_807(void);
int32_t function_80d(void);
int32_t function_80f8(void);
int32_t function_8143(int32_t a1);
int32_t function_816(void);
int32_t function_817e(int32_t a1, int32_t a2, int32_t a3);
int32_t function_81a5(void);
int32_t function_81b5(void);
int32_t function_81c1(int32_t a1);
int32_t function_81e8(void);
int32_t function_8208(int32_t a1);
int32_t function_8240(int32_t a1);
int32_t function_8257(int32_t a1);
int32_t function_826(void);
int32_t function_8270(void);
int32_t function_827f(void);
int32_t function_8290(void);
int32_t function_82b0(int32_t a1);
int32_t function_82c3(void);
int32_t function_82c8(void);
int32_t function_82d4(void);
int32_t function_8325(void);
int32_t function_8338(void);
int32_t function_8342(void);
int32_t function_8358(void);
int32_t function_839f(int32_t a1);
int32_t function_83e2(void);
int32_t function_83e7(void);
int32_t function_877(void);
int32_t function_87a(void);
int32_t function_892(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8e1(void);
int32_t function_912(void);
int32_t function_996(void);
int32_t function_a29(void);
int32_t function_a30(void);
int32_t function_a5d(void);
int32_t function_a71(void);
int32_t function_a83(void);
int32_t function_ae(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_b7104826(void);
int32_t function_c4d(void);
int32_t function_c60(void);
int32_t function_c600(int32_t a1);
int32_t function_c670(int32_t a1);
int32_t function_c70(void);
int32_t function_c730(int32_t a1);
int32_t function_c750(int32_t a1);
int32_t function_c810(int32_t a1);
int32_t function_c900(int32_t a1);
int32_t function_c9f(int32_t a1);
int32_t function_ca4(int32_t a1);
int32_t function_cc3(void);
int32_t function_cce0(int32_t a1);
int32_t function_cd4(void);
int32_t function_cfa0(int32_t a1);
int32_t function_e2a(int32_t a1);
int32_t function_f1d(void);
int32_t function_f8c1f889(void);
int32_t function_fad(void);
int32_t function_fda(int32_t a1);
int32_t GetExtNetwork(int32_t addr);
void LookupIntern(char * pszName, int32_t vIP, int32_t nMaxSolutions, bool fAllowLookup);
int32_t unknown_2454a1e0(void);
int32_t unknown_c660(int32_t a1);
int32_t unknown_c6d0(int32_t a1);
int32_t unknown_c8a0(int32_t a1);
int32_t unknown_c940(int32_t a1);
int32_t unknown_c9a0(int32_t a1);
int32_t unknown_ca10(int32_t a1);
int32_t unknown_caa0(int32_t a1);
int32_t unknown_cb00(int32_t a1);
int32_t unknown_cb80(int32_t a1);
int32_t unknown_d3d0(void);
int32_t unknown_d480(void);
int32_t unknown_d4e8(void);
int32_t unknown_d730(void);
int32_t unknown_dab4(void);
int32_t unknown_dc90(int32_t a1);
int32_t unknown_ded0(int32_t a1, int32_t a2);
int32_t unknown_e150(int32_t a1);
int32_t unknown_f230(int32_t a1);

// --------------------- Global Variables ---------------------

bool g1 = false; // df
int32_t g2 = 0; // eax
int32_t g3 = 0; // ebp
int32_t g4 = 0; // ebx
int32_t g5 = 0; // ecx
int32_t g6 = 0; // edi
int32_t g7 = 0; // edx
int32_t g8 = 0; // esi
int32_t g9 = 0; // esp
int16_t * g10 = (int16_t *)0x14a1;
char * g11 = "\x14";
int32_t g12 = 0x24848900;
int32_t g13 = 332;
int32_t g14 = -0x4b726f01;
int32_t g15 = 0x38bc031;
int16_t * g16 = (int16_t *)364;
int32_t g17 = -0x53762877;
char g18 = 103;
int32_t g19 = 20;
int32_t g20 = 0x203a0029;
int32_t g21 = 0x434f5300;
int32_t g22 = -0x78f10000;
int32_t g25 = 0x5c249c89;
int32_t g23 = -0x38ffffc0;
char g24 = -57;
int32_t g26 = 0;
int32_t g27 = 0x5140;
int32_t g31 = 0;
int32_t g33 = 0x6400;
int32_t g34 = 0;
int32_t g36 = 0x6670;
int32_t g37 = 0x5f00;
int32_t g40 = 0x6390;
int32_t g42 = 0x67d0;
int32_t g43 = 0x5fc0;
int32_t g45 = 0x6330;
int32_t g47 = 0x6480;
int32_t g48 = 0x5e60;
int32_t g49 = 0x50b0;
int32_t g50 = 8;
char (*g51)[33] = "N5boost6detail15sp_counted_baseE";
char * g52 = "\x5c\x01";
int32_t g53 = 0x65c38900;
int32_t g54 = -0x5e9a3c77;
struct vtable_8480_type g28 = {
    .e0 = _ZN5boost6system12system_errorD1Ev,
    .e1 = _ZN5boost6system12system_errorD0Ev,
    .e2 = _ZNK5boost6system12system_error4whatEv
};
struct vtable_8498_type g29 = {
    .e0 = _ZN5boost16thread_exceptionD1Ev,
    .e1 = _ZN5boost16thread_exceptionD0Ev,
    .e2 = fNameLookup
};
struct vtable_84b0_type g30 = {
    .e0 = _ZN5boost10lock_errorD1Ev,
    .e1 = _ZN5boost10lock_errorD0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv
};
struct vtable_84d8_type g32 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv
};
struct vtable_8518_type g35 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev,
    .e2 = _ZNK5boost10lock_error4whatEv,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv
};
struct vtable_8598_type g38 = {
    .e0 = _ZN5boost21thread_resource_errorD1Ev,
    .e1 = _ZN5boost21thread_resource_errorD0Ev,
    .e2 = _ZNK5boost21thread_resource_error4whatEv
};
struct vtable_85b8_type g39 = {
    .e0 = _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED1Ev,
    .e1 = _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev,
    .e2 = _ZNK5boost21thread_resource_error4whatEv
};
struct vtable_85f8_type g41 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev,
    .e2 = _ZNK5boost21thread_resource_error4whatEv,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv,
    .e4 = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv
};
struct vtable_8678_type g44 = {
    .e0 = _ZN5boost16exception_detail10bad_alloc_D1Ev,
    .e1 = _ZN5boost16exception_detail10bad_alloc_D0Ev
};
struct vtable_86b8_type g46 = {
    .e0 = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev,
    .e1 = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev,
    .e2 = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv,
    .e3 = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv
};

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x1
// From class:    N5boost16thread_exceptionE
// Type:          virtual member function
int32_t fNameLookup(void) {
    // 0x0
    return 0;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x10 - 0x11
// Line range:    411 - 215
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::clone() const
void _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t this) {
    // 0x10
    return;
}

// From module:   /usr/include/boost/exception/exception.hpp
// Address range: 0x20 - 0x27
// Line range:    404 - 67
void _7e_clone_impl(int32_t this, int32_t __in_chrg) {
    // 0x20
    return;
}

// From module:   /usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp
// Address range: 0x34 - 0x38
// Line range:    34 - 311
void _7e_pthread_mutex_scoped_lock(int32_t this, int32_t __in_chrg) {
    int32_t v1 = 0; // bp+34
    int32_t * v2 = (int32_t *)v1; // bp+36
    *v2 = *v2 + v1;
}

// Address range: 0xae - 0xe6
int32_t function_ae(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x14c2494;
    *v1 = *v1 - 1;
    int32_t v2 = g2;
    *(char *)v2 = (char)v2 + *(char *)&g2;
    int32_t result;
    // bb
    result = function_45f();
    // branch -> 0xc3
    // 0xc3
    return result;
}

// Address range: 0x147 - 0x14c
int32_t function_147(void) {
    // 0x147
    return 0;
}

// Address range: 0x171 - 0x176
int32_t function_171(void) {
    // 0x171
    return 0;
}

// Address range: 0x199 - 0x19e
int32_t function_199(void) {
    // 0x199
    return 0;
}

// Address range: 0x22d - 0x235
int32_t function_22d(int32_t result) {
    // 0x22d
    *(char *)0 = 3;
    return result;
}

// Address range: 0x276 - 0x28f
int32_t function_276(int32_t a1, int32_t result) {
    int32_t v1 = a1 - 255; // bp+276
    char v2 = v1 == 0 | v1 < 0 != (254 - a1 & a1) < 0 ? (char)a1 : -1; // bp+288
    *(char *)0 = v2;
    return result;
}

// Address range: 0x31b - 0x324
int32_t function_31b(int32_t result) {
    // 0x31b
    int32_t v1;
    *(char *)0 = (char)v1;
    return result;
}

// Address range: 0x35c - 0x35d
int32_t function_35c(void) {
    // 0x35c
    return g2;
}

// Address range: 0x368 - 0x369
int32_t function_368(int32_t a1) {
    // 0x368
    return g2;
}

// Address range: 0x373 - 0x37e
int32_t function_373(void) {
    // 0x373
    int32_t v1;
    *(int32_t *)v1 = v1 - 1;
    return 0;
}

// Address range: 0x3b3 - 0x3b4
int32_t function_3b3(void) {
    // 0x3b3
    return g2;
}

// Address range: 0x3bf - 0x3c1
int32_t function_3bf(void) {
    // 0x3bf
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x3c9 - 0x3d1
int32_t function_3c9(void) {
    // 0x3c9
    int32_t v1;
    *(int32_t *)v1 = -1;
    return function_35c();
}

// Address range: 0x3e2 - 0x3e3
int32_t function_3e2(void) {
    // 0x3e2
    return g2;
}

// Address range: 0x3ee - 0x3f3
int32_t function_3ee(void) {
    // 0x3ee
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x437 - 0x43c
int32_t function_437(void) {
    // 0x437
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x444 - 0x44f
int32_t function_444(void) {
    // 0x444
    int32_t v1;
    *(int32_t *)v1 = -1;
    return function_3b3();
}

// Address range: 0x457 - 0x45f
int32_t function_457(void) {
    // 0x457
    int32_t v1;
    *(int32_t *)v1 = -1;
    return function_3e2();
}

// Address range: 0x45f - 0x460
int32_t function_45f(void) {
    // 0x45f
    return g2;
}

// Address range: 0x48b - 0x490
int32_t function_48b(void) {
    // 0x48b
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x4bb - 0x4bc
int32_t function_4bb(void) {
    // 0x4bb
    return g2;
}

// Address range: 0x4fa - 0x4ff
int32_t function_4fa(void) {
    // 0x4fa
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x521 - 0x52c
int32_t function_521(void) {
    // 0x521
    g2 = true;
    return function_4bb();
}

// Address range: 0x57e - 0x58d
int32_t function_57e(int32_t a1) {
    // 0x57e
    g2 = 0 != a1;
    return function_4bb();
}

// Address range: 0x58d - 0x597
int32_t function_58d(void) {
    // 0x58d
    return 0;
}

// Address range: 0x5a9 - 0x5b3
int32_t function_5a9(void) {
    // 0x5a9
    g2 = 1;
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x5bf - 0x5c4
int32_t function_5bf(void) {
    // 0x5bf
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x5c4 - 0x5d5
int32_t function_5c4(void) {
    // 0x5c4
    return function_368((int32_t)"Proxy error: TTL expired");
}

// Address range: 0x5e1 - 0x5e6
int32_t function_5e1(void) {
    // 0x5e1
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x5f2 - 0x5f7
int32_t function_5f2(void) {
    // 0x5f2
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x603 - 0x608
int32_t function_603(void) {
    // 0x603
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x608 - 0x619
int32_t function_608(void) {
    // 0x608
    return function_368((int32_t)"Proxy error: connection not allowed");
}

// Address range: 0x625 - 0x62a
int32_t function_625(void) {
    // 0x625
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x636 - 0x63b
int32_t function_636(void) {
    // 0x636
    int32_t * v1;
    return function_368((int32_t)&v1);
}

// Address range: 0x63b - 0x656
int32_t function_63b(int32_t a1, int32_t result) {
    int32_t v1 = 0; // eax
    *(int32_t *)(v1 - 4) = 0;
    *(int32_t *)(v1 - 12) = a1;
    *(char *)(a1 + v1) = 0;
    return result;
}

// Address range: 0x656 - 0x66d
int32_t function_656(int32_t a1) {
    int32_t result = 0; // eax
    *(int32_t *)(result - 4) = 0;
    *(int32_t *)(result - 12) = a1;
    *(char *)(a1 + result) = 0;
    return result;
}

// Address range: 0x66e - 0x66f
int32_t function_66e(void) {
    // 0x66e
    return 0;
}

// Address range: 0x67f - 0x69a
int32_t function_67f(int32_t a1, int32_t result) {
    int32_t v1 = 0; // eax
    *(int32_t *)(v1 - 4) = 0;
    *(int32_t *)(v1 - 12) = a1;
    *(char *)(a1 + v1) = 0;
    return result;
}

// Address range: 0x69a - 0x6b5
int32_t function_69a(int32_t a1, int32_t result) {
    int32_t v1 = 0; // eax
    *(int32_t *)(v1 - 4) = 0;
    *(int32_t *)(v1 - 12) = a1;
    *(char *)(a1 + v1) = 0;
    return result;
}

// Address range: 0x6b5 - 0x6d0
int32_t function_6b5(int32_t a1, int32_t result) {
    int32_t v1 = 0; // eax
    *(int32_t *)(v1 - 4) = 0;
    *(int32_t *)(v1 - 12) = a1;
    *(char *)(a1 + v1) = 0;
    return result;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x6d0 - 0x6f7
// Line range:    29 - 30
// Demangled:     ParseNetwork(std::string)
int32_t _Z12ParseNetworkSs(int32_t net) {
    // 0x6d0
    return net;
}

// Address range: 0x732 - 0x735
int32_t function_732(int16_t a1) {
    // 0x732
    return 0;
}

// Address range: 0x744 - 0x745
int32_t function_744(void) {
    // 0x744
    return g2;
}

// Address range: 0x750 - 0x752
int32_t function_750(void) {
    // 0x750
    return function_7c6();
}

// Address range: 0x777 - 0x778
int32_t function_777(void) {
    // 0x777
    return 0;
}

// Address range: 0x784 - 0x790
int32_t function_784(void) {
    int32_t * v1 = (int32_t *)-0x38e3dbbc; // bp+784
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x799 - 0x7c4
int32_t function_799(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t result = 0;
    if (result != 0) {
        // 0x7c0
        return result;
    }
    // 0x7a2
    g2 = 1;
    int32_t result2 = 1;
    if (a2 != 0x24848900) {
        // bb
        result2 = function_807();
        // branch -> 0x7b1
    }
    // 0x7b1
    return result2;
}

// Address range: 0x7c6 - 0x7c8
int32_t function_7c6(void) {
    // 0x7c6
    return g2 & -252;
}

// Address range: 0x7f0 - 0x7fb
int32_t function_7f0(void) {
    int32_t * v1 = (int32_t *)-0x2de6fe08;
    *v1 = *v1 + 1;
    return 0;
}

// Address range: 0x800 - 0x807
int32_t function_800(void) {
    // 0x800
    return function_744();
}

// Address range: 0x807 - 0x808
int32_t function_807(void) {
    // 0x807
    return g2;
}

// Address range: 0x80d - 0x80e
int32_t function_80d(void) {
    // 0x80d
    return 0;
}

// Address range: 0x816 - 0x817
int32_t function_816(void) {
    // 0x816
    return g2;
}

// Address range: 0x826 - 0x82a
int32_t function_826(void) {
    // 0x826
    return function_816();
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x830 - 0x86e
// Line range:    37 - 53
// Demangled:     SplitHostPort(std::string, int &, std::string &)
void _Z13SplitHostPortSsRiRSs(int32_t in, int32_t portOut, int32_t hostOut) {
    // 0x830
    return;
}

// Address range: 0x877 - 0x87a
int32_t function_877(void) {
    // 0x877
    return 0;
}

// Address range: 0x87a - 0x87b
int32_t function_87a(void) {
    // 0x87a
    return g2;
}

// Address range: 0x892 - 0x8b8
int32_t function_892(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x652c2444; // bp+892
    *v1 = *v1 - 1;
    int32_t v2 = 0x24848900; // bp+898
    g2 = v2;
    int32_t result = v2;
    if (v2 != 0) {
        // bb
        result = function_a71();
        // branch -> 0x8a4
    }
    // 0x8a4
    return result;
}

// Address range: 0x8e1 - 0x8e2
int32_t function_8e1(void) {
    // 0x8e1
    return g2;
}

// Address range: 0x912 - 0x913
int32_t function_912(void) {
    // 0x912
    return g2;
}

// Address range: 0x996 - 0x9ab
int32_t function_996(void) {
    // 0x996
    int32_t v1;
    int32_t v2 = v1 - 1; // bp+996
    g2 = v2;
    int32_t v3;
    if (v2 >= 0xffff) {
        // bb
        g2 = function_87a();
        v3 = 0;
        // branch -> 0x9a4
    } else {
        v3 = v1;
    }
    // 0x9a4
    *(int32_t *)0 = v3;
    return function_87a();
}

// Address range: 0xa29 - 0xa2e
int32_t function_a29(void) {
    // 0xa29
    return 0;
}

// Address range: 0xa30 - 0xa45
int32_t function_a30(void) {
    // 0xa30
    if (g2 != -1) {
        // bb
        g2 = function_87a();
        // branch -> 0xa39
    }
    // 0xa39
    return function_912();
}

// Address range: 0xa5d - 0xa71
int32_t function_a5d(void) {
    int32_t * v1 = (int32_t *)0x24548b03;
    *v1 = *v1 - 1;
    int32_t v2 = g2;
    char * v3 = (char *)(v2 + 0x5dff107c);
    *v3 = (char)false + *v3 - (char)v2;
    return function_8e1();
}

// Address range: 0xa71 - 0xa72
int32_t function_a71(void) {
    // 0xa71
    return g2;
}

// Address range: 0xa83 - 0xa84
int32_t function_a83(void) {
    // 0xa83
    return 0;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xab0 - 0xaf0
// Line range:    540 - 543
// Demangled:     CNetAddr::Init()
void _ZN8CNetAddr4InitEv(int32_t this) {
    // 0xab0
    *(int32_t *)this = 0;
    *(int32_t *)(this + 4) = 0;
    *(int32_t *)(this + 8) = 0;
    *(int32_t *)(this + (int32_t)&g53) = 0;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xb00 - 0xb3f
// Line range:    545 - 548
// Demangled:     CNetAddr::SetIP(CNetAddr const &)
void _ZN8CNetAddr5SetIPERKS_(int32_t this, int32_t ipIn) {
    // 0xb00
    *(int32_t *)this = *(int32_t *)ipIn;
    *(int32_t *)(this + 4) = *(int32_t *)(ipIn + 4);
    *(int32_t *)(this + 8) = *(int32_t *)(ipIn + 8);
    int32_t v1 = *(int32_t *)(ipIn + (int32_t)&g53);
    *(int32_t *)(this + (int32_t)&g53) = v1;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xb50 - 0xbca
// Line range:    552 - 563
// Demangled:     CNetAddr::SetSpecial(std::string const &)
void _ZN8CNetAddr10SetSpecialERKSs(int32_t this, int32_t strName) {
    int32_t v1 = g4;
    g4 = strName;
    int32_t v2 = g8;
    g8 = this;
    uint32_t v3 = *(int32_t *)(*(int32_t *)strName - 12);
    int32_t v4 = v3 - 6;
    if (v3 < 6 || v4 == 0) {
        // 0xb83
        g4 = v1;
        g8 = v2;
        return;
    }
    // 0xba8
    g2 = v4;
    if (v3 <= 5) {
        // bb
        function_ca4(0x24848900);
        // branch -> 0xbb3
    }
    // 0xbb3
    int32_t v5; // bp-40
    g6 = &v5;
}

// Address range: 0xc4d - 0xc4e
int32_t function_c4d(void) {
    // 0xc4d
    return g2;
}

// Address range: 0xc60 - 0xc6b
int32_t function_c60(void) {
    // 0xc60
    int32_t v1;
    *(int32_t *)v1 = v1 - 1;
    return 0;
}

// Address range: 0xc70 - 0xc9f
int32_t function_c70(void) {
    // 0xc70
    int32_t v1;
    *(int32_t *)v1 = 0x7ed887fd;
    int32_t v2 = 0; // esi
    *(int16_t *)(v2 + 4) = 0x43eb;
    int32_t v3 = 0;
    char v4 = *(char *)v3;
    *(char *)(v3 + (int32_t)&g25 + v2) = v4;
    int32_t v5 = 0;
    int32_t v6 = v5 + 1;
    // branch -> 0xc88
    while (v5 != 9) {
        // 0xc88
        v3 = v6;
        v4 = *(char *)v3;
        *(char *)(v3 + (int32_t)&g25 + v2) = v4;
        v5 = v6;
        v6 = v5 + 1;
        // continue -> 0xc88
    }
    // 0xc98
    g2 = 1;
    return function_c4d();
}

// Address range: 0xc9f - 0xca0
int32_t function_c9f(int32_t a1) {
    // 0xc9f
    return g2;
}

// Address range: 0xca4 - 0xcab
int32_t function_ca4(int32_t a1) {
    // 0xca4
    return g2;
}

// Address range: 0xcc3 - 0xcc4
int32_t function_cc3(void) {
    // 0xcc3
    return 0;
}

// Address range: 0xcd4 - 0xcdb
int32_t function_cd4(void) {
    // 0xcd4
    return 0;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xce0 - 0xd0d
// Line range:    566 - 568
void CNetAddr(int32_t this) {
    // 0xce0
    _ZN8CNetAddr4InitEv(0x24848900);
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xd20 - 0xd68
// Line range:    571 - 575
void CNetAddr2(int32_t this, int32_t ipv4Addr) {
    // 0xd20
    *(int32_t *)this = 0;
    *(int32_t *)(this + 4) = 0;
    *(int32_t *)(this + 8) = -0x10000;
    *(int32_t *)(this + (int32_t)&g53) = *(int32_t *)ipv4Addr;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xd70 - 0xdaf
// Line range:    578 - 581
void CNetAddr3(int32_t this, int32_t ipv6Addr) {
    // 0xd70
    *(int32_t *)this = *(int32_t *)ipv6Addr;
    *(int32_t *)(this + 4) = *(int32_t *)(ipv6Addr + 4);
    *(int32_t *)(this + 8) = *(int32_t *)(ipv6Addr + 8);
    int32_t v1 = *(int32_t *)(ipv6Addr + (int32_t)&g53);
    *(int32_t *)(this + (int32_t)&g53) = v1;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xdc0 - 0xded
// Line range:    600 - 603
// Demangled:     CNetAddr::GetByte(int) const
void _ZNK8CNetAddr7GetByteEi(int32_t this, int32_t n) {
    // 0xdc0
    return;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xe00 - 0xe26
// Line range:    605 - 608
// Demangled:     CNetAddr::IsIPv4() const
void _ZNK8CNetAddr6IsIPv4Ev(int32_t this) {
    // 0xe00
    return;
}

// Address range: 0xe2a - 0xe41
int32_t function_e2a(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x3f6bf040;
    *v1 = *v1 + 1;
    if (a1 != 0x24848900) {
        // 0xe41
        return 0;
    }
    // 0xe3d
    int32_t result; // eax
    return result;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xe50 - 0xec1
// Line range:    615 - 621
// Demangled:     CNetAddr::IsRFC1918() const
void _ZNK8CNetAddr9IsRFC1918Ev(int32_t this) {
    // 0xe50
    _ZNK8CNetAddr6IsIPv4Ev(this);
    int32_t * v1;
    if ((char)&v1 == 0) {
        // 0xe90
        return;
    }
    char v2 = *(char *)(this + (int32_t)&g53);
    if (v2 == 10) {
        // 0xe90
        return;
    }
    // 0xe7f
    if (v2 == -64) {
        // 0xeb8
        // branch -> 0xe90
    } else {
        // 0xe83
        if (v2 == -84) {
            // 0xea8
            if (*(char *)(this + (int32_t)&g54) >= 16) {
                // 0xeb0
                // branch -> 0xe90
            }
            // 0xe90
            return;
        }
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xed0 - 0xf19
// Line range:    623 - 626
// Demangled:     CNetAddr::IsRFC3927() const
void _ZNK8CNetAddr9IsRFC3927Ev(int32_t this) {
    // 0xed0
    _ZNK8CNetAddr6IsIPv4Ev(this);
    int32_t * v1;
    if ((char)&v1 == 0) {
        // 0xef8
        return;
    }
    // 0xef2
    if (*(char *)(this + (int32_t)&g53) == -87) {
        // 0xf10
        // branch -> 0xef8
    }
}

// Address range: 0xf1d - 0xf20
int32_t function_f1d(void) {
    // 0xf1d
    return 0;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xf20 - 0xf65
// Line range:    628 - 631
// Demangled:     CNetAddr::IsRFC3849() const
void _ZNK8CNetAddr9IsRFC3849Ev(int32_t this) {
    // 0xf20
    if (*(char *)this != 32 || *(char *)(this + 1) != 1) {
        // 0xf38
        return;
    }
    // 0xf56
    if (*(char *)(this + (int32_t)&g16) == 13) {
        // 0xf5c
        // branch -> 0xf38
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xf70 - 0xfa9
// Line range:    633 - 636
// Demangled:     CNetAddr::IsRFC3964() const
void _ZNK8CNetAddr9IsRFC3964Ev(int32_t this) {
    // 0xf70
    if (*(char *)this == 32) {
        // 0xfa0
        // branch -> 0xf88
    }
}

// Address range: 0xfad - 0xfb0
int32_t function_fad(void) {
    // 0xfad
    return 0;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0xfb0 - 0xfd6
// Line range:    638 - 642
// Demangled:     CNetAddr::IsRFC6052() const
void _ZNK8CNetAddr9IsRFC6052Ev(int32_t this) {
    // 0xfb0
    return;
}

// Address range: 0xfda - 0xff1
int32_t function_fda(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x3f6bf040;
    *v1 = *v1 + 1;
    if (a1 != 0x24848900) {
        // 0xff1
        return 0;
    }
    // 0xfed
    int32_t result; // eax
    return result;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1000 - 0x1045
// Line range:    644 - 647
// Demangled:     CNetAddr::IsRFC4380() const
void _ZNK8CNetAddr9IsRFC4380Ev(int32_t this) {
    // 0x1000
    if (*(char *)this != 32 || *(char *)(this + 1) != 1) {
        // 0x1018
        return;
    }
    // 0x1036
    if (*(char *)(this + (int32_t)&g16) == 0) {
        // 0x103c
        // branch -> 0x1018
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1050 - 0x1076
// Line range:    649 - 653
// Demangled:     CNetAddr::IsRFC4862() const
void _ZNK8CNetAddr9IsRFC4862Ev(int32_t this) {
    // 0x1050
    return;
}

// Address range: 0x107a - 0x1091
int32_t function_107a(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x3f6bf040; // 0x107a
    *v1 = *v1 + 1;
    if (a1 != 0x24848900) {
        // 0x1091
        return 0;
    }
    // 0x108d
    int32_t result; // eax
    return result;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x10a0 - 0x10d4
// Line range:    655 - 658
// Demangled:     CNetAddr::IsRFC4193() const
void _ZNK8CNetAddr9IsRFC4193Ev(int32_t this) {
    // 0x10a0
    return;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x10e0 - 0x1106
// Line range:    660 - 664
// Demangled:     CNetAddr::IsRFC6145() const
void _ZNK8CNetAddr9IsRFC6145Ev(int32_t this) {
    // 0x10e0
    return;
}

// Address range: 0x110a - 0x1121
int32_t function_110a(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x3f6bf040; // 0x110a
    *v1 = *v1 + 1;
    if (a1 != 0x24848900) {
        // 0x1121
        return 0;
    }
    // 0x111d
    int32_t result; // eax
    return result;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1130 - 0x117d
// Line range:    666 - 669
// Demangled:     CNetAddr::IsRFC4843() const
void _ZNK8CNetAddr9IsRFC4843Ev(int32_t this) {
    // 0x1130
    if (*(char *)this != 32 || *(char *)(this + 1) != 1) {
        // 0x1148
        return;
    }
    // 0x1166
    if (*(char *)(this + (int32_t)&g16) == 0) {
        // 0x116c
        // branch -> 0x1148
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1190 - 0x11b6
// Line range:    671 - 674
// Demangled:     CNetAddr::IsTor() const
void _ZNK8CNetAddr5IsTorEv(int32_t this) {
    // 0x1190
    return;
}

// Address range: 0x11ba - 0x11d1
int32_t function_11ba(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x3f6bf040; // 0x11ba
    *v1 = *v1 + 1;
    if (a1 != 0x24848900) {
        // 0x11d1
        return 0;
    }
    // 0x11cd
    int32_t result; // eax
    return result;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x11e0 - 0x1223
// Line range:    610 - 613
// Demangled:     CNetAddr::IsIPv6() const
void _ZNK8CNetAddr6IsIPv6Ev(int32_t this) {
    // 0x11e0
    _ZNK8CNetAddr6IsIPv4Ev(this);
    int32_t * v1;
    if ((char)&v1 != 0) {
        // 0x1202
        _ZNK8CNetAddr5IsTorEv(this);
        // branch -> 0x120f
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1230 - 0x1293
// Line range:    676 - 688
// Demangled:     CNetAddr::IsLocal() const
void _ZNK8CNetAddr7IsLocalEv(int32_t this) {
    int32_t v1 = g4; // 0x1230
    g4 = this;
    _ZNK8CNetAddr6IsIPv4Ev(this);
    int32_t * v2;
    if (((char)&v2 & (char)&v2) == 0) {
        // 0x1280
        return;
    }
    char v3 = *(char *)(g4 + (int32_t)&g53); // 0x1250
    if (v3 == 127) {
        // 0x1268
        g4 = v1;
        return;
    }
    // 0x125e
    if (v3 != 0) {
        // 0x1280
        return;
    }
    // 0x1268
    g4 = v1;
}

// Address range: 0x1297 - 0x129f
int32_t function_1297(void) {
    // 0x1297
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x3f6bf040); // 0x1297
    *v2 = *v2 + 1;
    return 0;
}

// Address range: 0x129f - 0x12a0
int32_t function_129f(void) {
    // 0x129f
    return g2;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x12b0 - 0x12ff
// Line range:    690 - 694
// Demangled:     CNetAddr::IsMulticast() const
void _ZNK8CNetAddr11IsMulticastEv(int32_t this) {
    // 0x12b0
    _ZNK8CNetAddr6IsIPv4Ev(this);
    int32_t * v1;
    if (((char)&v1 & (char)&v1) == 0) {
        // 0x12e7
        // branch -> 0x12ed
        // 0x12ed
        return;
    }
    // 0x12d0
    if ((*(char *)(this + (int32_t)&g53) & -16) != -32) {
        // 0x12e7
        // branch -> 0x12ed
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1310 - 0x1380
// Line range:    696 - 730
// Demangled:     CNetAddr::IsValid() const
void _ZNK8CNetAddr7IsValidEv(int32_t this) {
    // 0x1310
    g8 = 0;
    function_13a8(this, (int32_t)&g26, (int32_t)&g52);
}

// Address range: 0x1392 - 0x1393
int32_t function_1392(void) {
    // 0x1392
    return g2;
}

// Address range: 0x13a8 - 0x13cb
int32_t function_13a8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x13a8
    g2 = g8;
    int32_t result = g8; // 0x13ca
    if (a1 != 0x24848900) {
        // bb
        result = function_1445();
        // branch -> 0x13bb
    }
    // 0x13bb
    g4 = a2;
    g8 = a3;
    return result;
}

// Address range: 0x13d1 - 0x13d2
int32_t function_13d1(void) {
    // 0x13d1
    return 0;
}

// Address range: 0x1414 - 0x141e
int32_t function_1414(void) {
    // 0x1414
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x3d6af040); // 0x1414
    *v2 = *v2 + 1;
    g8 = 0;
    int32_t * v3;
    int32_t result = function_13a8((int32_t)&v3, (int32_t)&v3, (int32_t)&v3); // 0x141c
    return result;
}

// Address range: 0x1420 - 0x1445
int32_t function_1420(void) {
    int32_t v1 = 0; // ebx
    int32_t v2 = v1; // 0x142a
    if (*(char *)(v1 + 1) != 1) {
        // bb
        g2 = function_1392();
        v2 = v1;
        // branch -> 0x142a
    }
    int32_t v3 = v2; // 0x1434
    if (*(char *)(v2 + (int32_t)&g16) != 13) {
        // bb100
        g2 = function_1392();
        v3 = v1;
        // branch -> 0x1434
    }
    // 0x1434
    if (*(char *)(v3 + 3) != -72) {
        // bb101
        function_1392();
        // branch -> 0x143e
    }
    // 0x143e
    int32_t * v4;
    int32_t result = function_13a8((int32_t)&v4, (int32_t)&v4, (int32_t)&v4); // 0x1440
    return result;
}

// Address range: 0x1445 - 0x1446
int32_t function_1445(void) {
    // 0x1445
    return g2;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1450 - 0x151d
// Line range:    732 - 735
// Demangled:     CNetAddr::IsRoutable() const
void _ZNK8CNetAddr10IsRoutableEv(int32_t this) {
    // 0x1450
    _ZNK8CNetAddr7IsValidEv(this);
    int32_t * v1;
    if (((char)&v1 & (char)&v1) != 0) {
        // 0x1479
        _ZNK8CNetAddr9IsRFC1918Ev(g4);
        // branch -> 0x1485
    }
    // 0x1485
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1530 - 0x1586
// Line range:    737 - 749
// Demangled:     CNetAddr::GetNetwork() const
void _ZNK8CNetAddr10GetNetworkEv(int32_t this) {
    int32_t v1 = g4; // 0x1530
    g4 = this;
    _ZNK8CNetAddr10IsRoutableEv(this);
    int32_t * v2;
    if ((char)&v2 == 0) {
        // 0x1572
        g4 = v1;
        return;
    }
    // 0x1552
    _ZNK8CNetAddr6IsIPv4Ev(g4);
    if (((char)&v2 & (char)&v2) != 0) {
        // 0x1563
        _ZNK8CNetAddr5IsTorEv(g4);
        // branch -> 0x1572
    }
    // 0x1572
    g4 = v1;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x1590 - 0x15e0
// Line range:    899 - 906
int32_t GetExtNetwork(int32_t addr) {
    int32_t v1 = g2; // 0x1593
    int32_t result; // 0x15c4
    if (v1 != 0) {
        // 0x15ac
        _ZNK8CNetAddr10GetNetworkEv(v1);
        int32_t * v2;
        result = (int32_t)&v2;
        // branch -> 0x15b4
    } else {
        result = 4;
    }
    // 0x15b4
    return result;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x15f0 - 0x1616
// Line range:    782 - 785
bool _ZeqRK8CNetAddrS1_(uint32_t a, int32_t b) {
    // 0x15f0
    return a % 2 != 0;
}

// Address range: 0x161a - 0x1631
int32_t function_161a(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x3f6bf040; // 0x161a
    *v1 = *v1 + 1;
    if (a1 != 0x24848900) {
        // 0x1631
        return 0;
    }
    // 0x162d
    int32_t result; // eax
    return result;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x1640 - 0x1666
// Line range:    787 - 790
bool _ZneRK8CNetAddrS1_(uint32_t a, int32_t b) {
    // 0x1640
    return a % 2 != 0;
}

// Address range: 0x166a - 0x1681
int32_t function_166a(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x3f6af040; // 0x166a
    *v1 = *v1 + 1;
    if (a1 != 0x24848900) {
        // 0x1681
        return 0;
    }
    // 0x167d
    int32_t result; // eax
    return result;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x1690 - 0x16b6
// Line range:    792 - 795
bool _ZltRK8CNetAddrS1_(uint32_t a, int32_t b) {
    // 0x1690
    return a % 2 != 0;
}

// Address range: 0x16ba - 0x16e0
int32_t function_16ba(void) {
    int32_t v1 = unknown_2454a1e0(); // 0x16bc
    int32_t result = (v1 - (int32_t)(char)&g24 + (int32_t)false) % 256 | v1 & -256; // 0x16c1
    // 0x16cf
    return result;
    // 0x16cb
    return result;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x16e0 - 0x1732
// Line range:    797 - 803
// Demangled:     CNetAddr::GetInAddr(in_addr *) const
void _ZNK8CNetAddr9GetInAddrEP7in_addr(int32_t this, int32_t pipv4Addr) {
    // 0x16e0
    _ZNK8CNetAddr6IsIPv4Ev(this);
    int32_t * v1;
    if ((char)&v1 != 0) {
        // 0x170d
        *(int32_t *)pipv4Addr = *(int32_t *)(this + (int32_t)&g53);
        // branch -> 0x1717
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1740 - 0x1784
// Line range:    806 - 810
// Demangled:     CNetAddr::GetIn6Addr(in6_addr *) const
void _ZNK8CNetAddr10GetIn6AddrEP8in6_addr(int32_t this, int32_t pipv6Addr) {
    // 0x1740
    *(int32_t *)pipv6Addr = *(int32_t *)this;
    *(int32_t *)(pipv6Addr + 4) = *(int32_t *)(this + 4);
    *(int32_t *)(pipv6Addr + 8) = *(int32_t *)(this + 8);
    int32_t v1 = *(int32_t *)(this + (int32_t)&g53); // 0x1768
    *(int32_t *)(pipv6Addr + (int32_t)&g53) = v1;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1790 - 0x17f7
// Line range:    882 - 888
// Demangled:     CNetAddr::GetHash() const
void _ZNK8CNetAddr7GetHashEv(int32_t this) {
    // 0x1790
    return;
}

// Address range: 0x1853 - 0x186e
int32_t function_1853(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)-0x74e3dbbc; // 0x1853
    *v1 = *v1 - 1;
    int32_t result = 0; // 0x185a
    // 0x186e
    return result;
    // 0x1869
    return result;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1880 - 0x19e8
// Line range:    909 - 965
// Demangled:     CNetAddr::GetReachabilityFrom(CNetAddr const *) const
void _ZNK8CNetAddr19GetReachabilityFromEPKS_(int32_t this, int32_t paddrPartner) {
    // 0x1880
    g4 = this;
    g8 = paddrPartner;
    _ZNK8CNetAddr10IsRoutableEv(this);
    int32_t * v1;
    if ((char)&v1 == 0) {
        // 0x1928
        return;
    }
    // 0x18b1
    g2 = g4;
    g6 = GetExtNetwork(this);
    g2 = g8;
    int32_t v2 = GetExtNetwork(this); // 0x18bc
    int16_t * v3;
    int32_t v4;
    int32_t v5; // 0x1906
    int32_t v6; // 0x1958
    int32_t v7; // 0x195f
    if (*(char *)g4 == 32) {
        // 0x1980
        if (*(char *)(g4 + 1) == 2) {
            // 0x18dd
            if (v2 == 2) {
                // 0x195f
                v7 = g6;
                if (v7 == 2) {
                    // 0x19d8
                    // branch -> 0x1928
                } else {
                    // 0x1964
                    if (v7 != 5) {
                        // 0x196e
                        // branch -> 0x1928
                    }
                }
                // 0x1928
                return;
            }
            v5 = v2;
            // 0x18e2
            if (v4 <= (int32_t)v3) {
                // 0x18e4
                if (v5 != 1) {
                    // 0x190f
                    if (g6 < 6) {
                        // 0x191c
                        // branch -> 0x1928
                    }
                }
                // 0x1928
                return;
            }
            // 0x18f8
            if (v5 == 3) {
                // 0x1998
                if (g6 < 4) {
                    // 0x19a5
                    // branch -> 0x1928
                }
                // 0x1928
                return;
            }
            // 0x1906
            if (v5 == 5) {
                // 0x19b8
                if (g6 < 6) {
                    // 0x19c9
                    // branch -> 0x1928
                }
            } else {
                // 0x190f
                if (g6 < 6) {
                    // 0x191c
                    // branch -> 0x1928
                }
            }
            // 0x1928
            return;
        }
        // 0x18cc
        _ZNK8CNetAddr9IsRFC6052Ev(g4);
        if (((char)&v1 & (char)&v1) == 0) {
            // 0x1950
            _ZNK8CNetAddr9IsRFC6145Ev(g4);
            v6 = v2;
            if (v6 != 2) {
                v5 = v6;
                // 0x18e2
                if (v6 <= (int32_t)(int16_t *)&g16) {
                    // 0x18e4
                    if (v5 != 1) {
                        // 0x190f
                        if (g6 < 6) {
                            // 0x191c
                            // branch -> 0x1928
                        }
                    }
                    // 0x1928
                    return;
                }
                // 0x18f8
                if (v5 == 3) {
                    // 0x1998
                    if (g6 < 4) {
                        // 0x19a5
                        // branch -> 0x1928
                    }
                    // 0x1928
                    return;
                }
                // 0x1906
                if (v5 == 5) {
                    // 0x19b8
                    if (g6 < 6) {
                        // 0x19c9
                        // branch -> 0x1928
                    }
                } else {
                    // 0x190f
                    if (g6 < 6) {
                        // 0x191c
                        // branch -> 0x1928
                    }
                }
                // 0x1928
                return;
            }
        } else {
            // 0x18cc
            // branch -> 0x18dd
            // 0x18dd
            if (v2 != 2) {
                v5 = v2;
                // 0x18e2
                if (v4 <= (int32_t)v3) {
                    // 0x18e4
                    if (v5 != 1) {
                        // 0x190f
                        if (g6 < 6) {
                            // 0x191c
                            // branch -> 0x1928
                        }
                    }
                    // 0x1928
                    return;
                }
                // 0x18f8
                if (v5 == 3) {
                    // 0x1998
                    if (g6 < 4) {
                        // 0x19a5
                        // branch -> 0x1928
                    }
                    // 0x1928
                    return;
                }
                // 0x1906
                if (v5 == 5) {
                    // 0x19b8
                    if (g6 < 6) {
                        // 0x19c9
                        // branch -> 0x1928
                    }
                } else {
                    // 0x190f
                    if (g6 < 6) {
                        // 0x191c
                        // branch -> 0x1928
                    }
                }
                // 0x1928
                return;
            }
        }
        // 0x195f
        v7 = g6;
        if (v7 == 2) {
            // 0x19d8
            // branch -> 0x1928
        } else {
            // 0x1964
            if (v7 != 5) {
                // 0x196e
                // branch -> 0x1928
            }
        }
        // 0x1928
        return;
    }
    // 0x18cc
    _ZNK8CNetAddr9IsRFC6052Ev(g4);
    if (((char)&v1 & (char)&v1) != 0) {
        // 0x18cc
        // branch -> 0x18dd
        // 0x18dd
        if (v2 == 2) {
            // 0x195f
            v7 = g6;
            if (v7 == 2) {
                // 0x19d8
                // branch -> 0x1928
            } else {
                // 0x1964
                if (v7 != 5) {
                    // 0x196e
                    // branch -> 0x1928
                }
            }
            // 0x1928
            return;
        }
        v5 = v2;
        // 0x18e2
        if (v4 <= (int32_t)v3) {
            // 0x18e4
            if (v5 != 1) {
                // 0x190f
                if (g6 < 6) {
                    // 0x191c
                    // branch -> 0x1928
                }
            }
            // 0x1928
            return;
        }
        // 0x18f8
        if (v5 == 3) {
            // 0x1998
            if (g6 < 4) {
                // 0x19a5
                // branch -> 0x1928
            }
            // 0x1928
            return;
        }
        // 0x1906
        if (v5 == 5) {
            // 0x19b8
            if (g6 < 6) {
                // 0x19c9
                // branch -> 0x1928
            }
        } else {
            // 0x190f
            if (g6 < 6) {
                // 0x191c
                // branch -> 0x1928
            }
        }
        // 0x1928
        return;
    }
    // 0x1950
    _ZNK8CNetAddr9IsRFC6145Ev(g4);
    v6 = v2;
    if (v6 != 2) {
        v5 = v6;
        // 0x18e2
        if (v6 <= (int32_t)(int16_t *)&g16) {
            // 0x18e4
            if (v5 != 1) {
                // 0x190f
                if (g6 < 6) {
                    // 0x191c
                    // branch -> 0x1928
                }
            }
            // 0x1928
            return;
        }
        // 0x18f8
        if (v5 == 3) {
            // 0x1998
            if (g6 < 4) {
                // 0x19a5
                // branch -> 0x1928
            }
            // 0x1928
            return;
        }
        // 0x1906
        if (v5 == 5) {
            // 0x19b8
            if (g6 < 6) {
                // 0x19c9
                // branch -> 0x1928
            }
        } else {
            // 0x190f
            if (g6 < 6) {
                // 0x191c
                // branch -> 0x1928
            }
        }
        // 0x1928
        return;
    }
    // 0x195f
    v7 = g6;
    if (v7 == 2) {
        // 0x19d8
        // branch -> 0x1928
    } else {
        // 0x1964
        if (v7 != 5) {
            // 0x196e
            // branch -> 0x1928
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x19f0 - 0x1a1a
// Line range:    967 - 970
// Demangled:     CService::Init()
void _ZN8CService4InitEv(int32_t this) {
    // 0x19f0
    *(int16_t *)(this + (int32_t)&g10) = 0;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1a20 - 0x1a54
// Line range:    972 - 975
void CService(int32_t this) {
    // 0x1a4f
    _ZN8CNetAddr4InitEv(this);
    *(int16_t *)(this + (int32_t)&g10) = 0;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1a60 - 0x1aa7
// Line range:    977 - 979
void CService2(int32_t this, int32_t cip, int16_t portIn) {
    // 0x1a60
    *(int32_t *)this = *(int32_t *)cip;
    *(int32_t *)(this + 4) = *(int32_t *)(cip + 4);
    *(int32_t *)(this + 8) = *(int32_t *)(cip + 8);
    int32_t v1 = *(int32_t *)(cip + (int32_t)&g53); // 0x1a88
    *(int32_t *)(this + (int32_t)&g53) = v1;
    *(int16_t *)(this + (int32_t)&g10) = portIn;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1ab0 - 0x1afc
// Line range:    981 - 983
void CService3(int32_t this, int32_t ipv4Addr, int16_t portIn) {
    // 0x1af0
    CNetAddr2(this, ipv4Addr);
    *(int16_t *)(this + (int32_t)&g10) = portIn;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1b10 - 0x1b5c
// Line range:    986 - 988
void CService4(int32_t this, int32_t ipv6Addr, int16_t portIn) {
    // 0x1b50
    CNetAddr3(this, ipv6Addr);
    *(int16_t *)(this + (int32_t)&g10) = portIn;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1b70 - 0x1be8
// Line range:    991 - 994
void CService5(int32_t this, int32_t addr) {
    int32_t v1 = g4; // 0x1b73
    g4 = addr;
    CNetAddr2(this, addr + 4);
    int16_t v2 = llvm_bswap_i16(*(int16_t *)(g4 + (int32_t)&g16)); // 0x1ba2
    *(int16_t *)(this + (int32_t)&g10) = v2;
    if (*(int16_t *)g4 != 2) {
        // 0x1bc9
        return;
    }
    // 0x1bb0
    g4 = v1;
}

// Address range: 0x1bed - 0x1bee
int32_t function_1bed(void) {
    // 0x1bed
    return g2;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1c00 - 0x1c78
// Line range:    997 - 1000
void CService6(int32_t this, int32_t addr) {
    int32_t v1 = g4; // 0x1c03
    g4 = addr;
    CNetAddr3(this, addr + 8);
    int16_t v2 = llvm_bswap_i16(*(int16_t *)(g4 + (int32_t)&g16)); // 0x1c32
    *(int16_t *)(this + (int32_t)&g10) = v2;
    if (*(int16_t *)g4 != 10) {
        // 0x1c59
        return;
    }
    // 0x1c40
    g4 = v1;
}

// Address range: 0x1c7d - 0x1c7e
int32_t function_1c7d(void) {
    // 0x1c7d
    return g2;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1c90 - 0x1d4e
// Line range:    1003 - 1017
// Demangled:     CService::SetSockAddr(sockaddr const *)
void _ZN8CService11SetSockAddrEPK8sockaddr(int32_t this, int32_t paddr) {
    // 0x1c90
    g4 = this;
    int16_t v1 = *(int16_t *)paddr; // 0x1ca8
    if (v1 == 2) {
        // 0x1cd0
        int32_t v2; // bp-52
        CService5((int32_t)&v2, paddr);
        *(int32_t *)g4 = v2;
        // branch -> 0x1cb9
        // 0x1cb9
        return;
    }
    // 0x1cb1
    if (v1 == 10) {
        // 0x1d10
        int32_t v3; // bp-34
        CService6((int32_t)&v3, paddr);
        *(int32_t *)g4 = v3;
        // branch -> 0x1cb9
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x1d60 - 0x1d88
// Line range:    1051 - 1054
// Demangled:     CService::GetPort() const
void _ZNK8CService7GetPortEv(int32_t this) {
    // 0x1d60
    return;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x1d90 - 0x1e19
// Line range:    1056 - 1059
bool _ZeqRK8CServiceS1_(int32_t a, int32_t b) {
    int32_t v1 = *(int32_t *)b; // bp-32
    int32_t v2 = *(int32_t *)a; // bp-48
    bool result; // 0x1e04
    if (_ZeqRK8CNetAddrS1_((int32_t)&v2, (int32_t)&v1)) {
        uint16_t v3 = *(int16_t *)(b + (int32_t)&g10); // 0x1df9
        int16_t v4 = *(int16_t *)(a + (int32_t)&g10); // 0x1dfd
        result = ((int32_t)(v4 == v3) | (int32_t)v3 & 0xff00) % 2 != 0;
        // branch -> 0x1e04
    } else {
        result = false;
    }
    // 0x1e04
    return result;
}

// Address range: 0x1e1d - 0x1e20
int32_t function_1e1d(void) {
    // 0x1e1d
    return 0;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x1e20 - 0x1eac
// Line range:    1061 - 1064
bool _ZneRK8CServiceS1_(int32_t a, int32_t b) {
    int32_t v1 = *(int32_t *)b; // bp-32
    int32_t v2 = *(int32_t *)a; // bp-48
    bool v3 = _ZneRK8CNetAddrS1_((int32_t)&v2, (int32_t)&v1); // 0x1e7e
    bool result; // 0x1e97
    if (!v3) {
        uint16_t v4 = *(int16_t *)(b + (int32_t)&g10); // 0x1e8c
        int16_t v5 = *(int16_t *)(a + (int32_t)&g10); // 0x1e90
        result = ((int32_t)(v5 != v4) | (int32_t)v4 & 0xff00) % 2 != 0;
        // branch -> 0x1e97
    } else {
        result = true;
    }
    // 0x1e97
    return result;
}

// Address range: 0x1eb1 - 0x1eb3
int32_t function_1eb1(void) {
    // 0x1eb1
    int32_t * v1;
    return _ZltRK8CServiceS1_((int32_t)&v1, (int32_t)&v1);
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x1ec0 - 0x1ffd
// Line range:    1066 - 1069
bool _ZltRK8CServiceS1_(int32_t a, int32_t b) {
    int32_t v1 = *(int32_t *)b; // 0x1eff
    int32_t v2 = *(int32_t *)a; // 0x1f0f
    if (_ZltRK8CNetAddrS1_((int32_t)&v2, (int32_t)&v1)) {
        // 0x1fb9
        return true;
    }
    bool v3 = _ZeqRK8CNetAddrS1_((int32_t)&v2, (int32_t)&v1); // 0x1fae
    bool result = false; // 0x1fc4
    if (v3) {
        uint16_t v4 = *(int16_t *)(a + (int32_t)&g10); // 0x1ff4
        result = v4 < *(int16_t *)(b + (int32_t)&g10);
        // branch -> 0x1fb9
    }
    // 0x1fb9
    return result;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x2010 - 0x2198
// Line range:    1071 - 1100
// Demangled:     CService::GetSockAddr(sockaddr *, unsigned int *) const
void _ZNK8CService11GetSockAddrEP8sockaddrPj(int32_t this, int32_t paddr, int32_t * addrlen) {
    int32_t v1 = g4; // 0x2013
    g4 = this;
    int32_t v2 = g8; // 0x201f
    g8 = paddr;
    _ZNK8CNetAddr6IsIPv4Ev(this);
    int32_t * v3;
    if (((char)&v3 & (char)&v3) == 0) {
        // 0x2088
        _ZNK8CNetAddr6IsIPv6Ev(g4);
        // branch -> 0x205c
        // 0x205c
        g4 = v1;
        g8 = v2;
        return;
    }
    // 0x204d
    if (*addrlen < 16) {
        // 0x205c
        g4 = v1;
        g8 = v2;
        return;
    }
    // 0x2128
    *addrlen = (int32_t)&g10;
    *(int32_t *)g8 = 0;
    *(int32_t *)(g8 + 4) = 0;
    *(int32_t *)(g8 + 8) = 0;
    *(int32_t *)(g8 + (int32_t)&g53) = 0;
    _ZNK8CNetAddr9GetInAddrEP7in_addr(g4, g8 + 4);
    if (((char)&v3 & (char)&v3) != 0) {
        int16_t v4 = *(int16_t *)(g4 + (int32_t)&g10); // 0x2160
        int32_t v5 = llvm_bswap_i16(v4); // eax
        *(int16_t *)g8 = (int16_t)&g16;
        *(int16_t *)(g8 + (int32_t)&g16) = (int16_t)v5;
        // branch -> 0x205c
    }
    // 0x205c
    g4 = v1;
    g8 = v2;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x21a0 - 0x2205
// Line range:    751 - 754
// Demangled:     CNetAddr::ToStringIP() const
void _ZNK8CNetAddr10ToStringIPEv(int32_t this) {
    // 0x21a0
    g8 = this;
    int32_t v1;
    _ZNK8CNetAddr5IsTorEv(v1);
    int32_t * v2;
    if (((char)&v2 & (char)&v2) == 0) {
        // bb
        function_2278();
        // branch -> 0x21ef
    }
    // 0x21ef
    g4 += (int32_t)&g25;
}

// Address range: 0x2231 - 0x2274
int32_t function_2231(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = 0; // esi
    g2 = result;
    if (a1 != 0x24848900) {
        // bb
        result = function_2488(0);
        // branch -> 0x224f
    }
    // 0x224f
    return result;
}

// Address range: 0x2278 - 0x2382
int32_t function_2278(void) {
    int32_t v1 = 128; // bp+64
    int32_t v2 = g4; // bp+200
    int32_t v3; // bp+72
    _ZNK8CService11GetSockAddrEP8sockaddrPj((int32_t)&v2, (int32_t)&v3, &v1);
    int32_t * v4;
    if (((char)&v4 & (char)&v4) == 0) {
        // 0x22d8
        function_2390();
        _ZNK8CNetAddr6IsIPv4Ev(g4);
        function_2438();
        // branch -> 0x22e8
    } else {
        // 0x22e8
        _ZNK8CNetAddr6IsIPv4Ev(g4);
        // branch -> 0x22e8
    }
    // 0x22e8
    return (int32_t)*(char *)(g4 + 1) | 256 * (g4 % 256);
}

// Address range: 0x2387 - 0x238f
int32_t function_2387(void) {
    // 0x2387
    return 0;
}

// Address range: 0x2390 - 0x240f
int32_t function_2390(void) {
    // 0x2390
    int32_t v1; // bp+224
    __asm_rep_stosd_memset((char *)&v1, 0, (int32_t)&g18 >> (int32_t)&g16);
    int32_t v2 = g1 ? -4 * ((int32_t)&g18 >> (int32_t)&g16) : 4 * ((int32_t)&g18 >> (int32_t)&g16); // 0x23c5
    int32_t v3 = v2 + (int32_t)&v1; // 0x23c5
    int32_t v4 = v3; // 0x23d6
    if (((int32_t)&g18 & 2) != 0) {
        // 0x23c9
        *(int16_t *)v3 = 0;
        v4 = v3 + 2;
        // branch -> 0x23d1
    }
    // 0x23d1
    if ((int32_t)&g18 % 2 != 0) {
        // 0x23d6
        *(char *)v4 = 0;
        // branch -> 0x23d9
    }
    // 0x23d9
    int32_t result;
    return result;
}

// Address range: 0x2430 - 0x2435
int32_t function_2430(void) {
    // 0x2430
    return 0;
}

// Address range: 0x2438 - 0x246b
int32_t function_2438(void) {
    // 0x2438
    return (int32_t)*(char *)(g4 + (int32_t)&g53);
}

// Address range: 0x2470 - 0x2478
int32_t function_2470(void) {
    // 0x2470
    return 0;
}

// Address range: 0x2478 - 0x2488
int32_t function_2478(int32_t a1, int32_t a2) {
    // 0x2478
    *(int16_t *)g6 = 0;
    return g2;
}

// Address range: 0x2488 - 0x2489
int32_t function_2488(int32_t a1) {
    // 0x2488
    return g2;
}

// Address range: 0x248e - 0x248f
int32_t function_248e(void) {
    // 0x248e
    return 0;
}

// Address range: 0x2497 - 0x2498
int32_t function_2497(void) {
    // 0x2497
    return g2;
}

// Address range: 0x24a7 - 0x24ab
int32_t function_24a7(void) {
    // 0x24a7
    return function_2497();
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x24b0 - 0x24ed
// Line range:    777 - 780
// Demangled:     CNetAddr::ToString() const
void _ZNK8CNetAddr8ToStringEv(int32_t this) {
    // 0x24b0
    _ZNK8CNetAddr10ToStringIPEv(this);
    int32_t v1;
    if (v1 != 0x24848900) {
        // 0x24ed
        return;
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x2500 - 0x255c
// Line range:    890 - 67
// Demangled:     CNetAddr::print() const
void _ZNK8CNetAddr5printEv(int32_t this) {
    // 0x2500
    int32_t v1; // bp-24
    _ZNK8CNetAddr10ToStringIPEv((int32_t)&v1);
    int32_t v2;
    if (v2 != 12) {
        // 0x255c
        return;
    }
    // 0x254a
    int32_t v3;
    int32_t v4 = v3 ^ 0x24848900; // 0x254e
    g2 = v4;
    if (v4 != 0) {
        // bb
        function_2583((int32_t)"CNetAddr(%s)\n", v2);
        // branch -> 0x2557
    }
}

// Address range: 0x2581 - 0x2583
int32_t function_2581(void) {
    // 0x2581
    return 0;
}

// Address range: 0x2583 - 0x258f
int32_t function_2583(int32_t a1, int32_t a2) {
    // 0x2583
    return g2;
}

// Address range: 0x25a0 - 0x25ab
int32_t function_25a0(void) {
    int32_t result = 0; // eax
    int32_t * v1 = (int32_t *)(result - 4); // 0x25a0
    *v1 = *v1 - 1;
    return result;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x25b0 - 0x2610
// Line range:    1112 - 1115
// Demangled:     CService::ToStringPort() const
void _ZNK8CService12ToStringPortEv(int32_t this) {
    // 0x25b0
    int32_t v1;
    if (v1 != 0x24848900) {
        // 0x2601
        return;
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x2610 - 0x263c
// Line range:    1136 - 1139
// Demangled:     CService::SetPort(unsigned short)
void _ZN8CService7SetPortEt(int32_t this, int16_t portIn) {
    // 0x2610
    *(int16_t *)(this + (int32_t)&g10) = portIn;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x2650 - 0x26b8
// Line range:    1117 - 1122
// Demangled:     CService::ToStringIPPort() const
void _ZNK8CService14ToStringIPPortEv(int32_t this) {
    // 0x2650
    g4 = this;
    int32_t v1;
    _ZNK8CNetAddr6IsIPv4Ev(v1);
    int32_t * v2;
    if (((char)&v2 & (char)&v2) == 0) {
        // bb
        function_2730();
        // branch -> 0x2687
    }
    // 0x2687
    int32_t v3; // bp-52
    _ZNK8CService12ToStringPortEv((int32_t)&v3);
    int32_t v4; // bp-64
    _ZNK8CNetAddr10ToStringIPEv((int32_t)&v4);
}

// Address range: 0x26f0 - 0x2729
int32_t function_26f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = 0; // ebx
    g2 = result;
    if (a1 != 0x24848900) {
        // bb
        result = function_2814(0);
        // branch -> 0x2713
    }
    // 0x2713
    return result;
}

// Address range: 0x2730 - 0x279b
int32_t function_2730(void) {
    // 0x2730
    _ZNK8CNetAddr5IsTorEv(g8);
    int32_t v1; // bp+40
    _ZNK8CService12ToStringPortEv((int32_t)&v1);
    int32_t v2; // bp+24
    _ZNK8CNetAddr10ToStringIPEv((int32_t)&v2);
    v2 = &g53;
    int32_t v3;
    return *(int32_t *)(v3 - 12) + 1;
}

// Address range: 0x280f - 0x2814
int32_t function_280f(void) {
    // 0x280f
    return 0;
}

// Address range: 0x2814 - 0x2815
int32_t function_2814(int32_t a1) {
    // 0x2814
    return g2;
}

// Address range: 0x2819 - 0x281a
int32_t function_2819(int32_t a1) {
    // 0x2819
    return g2;
}

// Address range: 0x281a - 0x281b
int32_t function_281a(void) {
    // 0x281a
    return 0;
}

// Address range: 0x2823 - 0x2824
int32_t function_2823(void) {
    // 0x2823
    return g2;
}

// Address range: 0x282b - 0x282c
int32_t function_282b(void) {
    // 0x282b
    return g2;
}

// Address range: 0x2833 - 0x283d
int32_t function_2833(void) {
    // 0x2833
    return function_2819(0);
}

// Address range: 0x283d - 0x2842
int32_t function_283d(void) {
    // 0x283d
    return function_2823();
}

// Address range: 0x2842 - 0x2846
int32_t function_2842(void) {
    // 0x2842
    return function_282b();
}

// Address range: 0x2847 - 0x2848
int32_t function_2847(void) {
    // 0x2847
    return 0;
}

// Address range: 0x2848 - 0x2849
int32_t function_2848(void) {
    // 0x2848
    return g2;
}

// Address range: 0x2859 - 0x285a
int32_t function_2859(void) {
    // 0x2859
    return 0;
}

// Address range: 0x2862 - 0x2863
int32_t function_2862(void) {
    // 0x2862
    return g2;
}

// Address range: 0x286e - 0x2870
int32_t function_286e(void) {
    // 0x286e
    return function_2848();
}

// Address range: 0x2871 - 0x2872
int32_t function_2871(void) {
    // 0x2871
    return 0;
}

// Address range: 0x2872 - 0x2873
int32_t function_2872(int32_t a1) {
    // 0x2872
    return g2;
}

// Address range: 0x287a - 0x287c
int32_t function_287a(void) {
    // 0x287a
    return function_2862();
}

// Address range: 0x287c - 0x2888
int32_t function_287c(void) {
    // 0x287c
    return function_2872(g8);
}

// Address range: 0x2888 - 0x288a
int32_t function_2888(void) {
    // 0x2888
    return function_287c();
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x2890 - 0x28cd
// Line range:    1126 - 1129
// Demangled:     CService::ToString() const
void _ZNK8CService8ToStringEv(int32_t this) {
    // 0x2890
    _ZNK8CService14ToStringIPPortEv(this);
    int32_t v1;
    if (v1 != 0x24848900) {
        // 0x28cd
        return;
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x28e0 - 0x2916
// Line range:    1131 - 67
// Demangled:     CService::print() const
void _ZNK8CService5printEv(int32_t this) {
    // 0x28e0
    int32_t v1; // bp-24
    _ZNK8CService14ToStringIPPortEv((int32_t)&v1);
}

// Address range: 0x292a - 0x293c
int32_t function_292a(void) {
    // 0x292a
    int32_t v1;
    int32_t v2 = v1 ^ 0x24848900; // 0x292e
    g2 = v2;
    int32_t result = v2; // 0x293b
    if (v2 != 0) {
        // bb
        result = function_2963();
        // branch -> 0x2937
    }
    // 0x2937
    return result;
}

// Address range: 0x2961 - 0x2963
int32_t function_2961(void) {
    // 0x2961
    return function_292a();
}

// Address range: 0x2963 - 0x2980
int32_t function_2963(void) {
    // 0x2963
    return g2;
}

// Address range: 0x2980 - 0x298b
int32_t function_2980(void) {
    int32_t result = 0; // eax
    int32_t * v1 = (int32_t *)(result - 4); // 0x2980
    *v1 = *v1 - 1;
    return result;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x2990 - 0x2a78
// Line range:    312 - 323
bool ConnectSocketDirectly(int32_t addrConnect, int32_t hSocketRet, int32_t nTimeout) {
    // 0x2990
    g4 = g2;
    int32_t v1 = g7; // 0x29a6
    g8 = v1;
    *(int32_t *)v1 = -1;
    int32_t v2 = 128; // bp-304
    int32_t v3; // bp-288
    _ZNK8CService11GetSockAddrEP8sockaddrPj(g4, (int32_t)&v3, &v2);
    int32_t * v4;
    if (((char)&v4 & (char)&v4) == 0) {
        // 0x2a60
        return v3 % 2 != 0;
    }
    // 0x29f1
    int32_t v5; // bp-300
    int32_t v6 = &v5; // 0x29f1
    _ZNK8CService14ToStringIPPortEv(v6);
    g2 = 0;
    bool result = false; // 0x2a5a
    int32_t v7;
    if (v7 != 0x24848900) {
        // bb
        result = function_2ce6(v6, v2) % 2 != 0;
        // branch -> 0x2a38
    }
    // 0x2a38
    return result;
}

// Address range: 0x2a83 - 0x2a84
int32_t function_2a83(void) {
    // 0x2a83
    return 0;
}

// Address range: 0x2b12 - 0x2b28
int32_t function_2b12(void) {
    int32_t * v1 = (int32_t *)-0x7bf00008; // 0x2b12
    *v1 = *v1 + 1;
    return 0;
}

// Address range: 0x2b42 - 0x2b4e
int32_t function_2b42(void) {
    // 0x2b42
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + (int32_t)&g23); // 0x2b42
    uint32_t v3 = *v2; // 0x2b42
    uint32_t v4 = 0; // 0x2b42
    if (v4 == 0) {
        // 0x2b42
        // branch -> bb97
    } else {
        // bb
        *v2 = v3 << 32 - v4 | v3 >> v4;
        // branch -> bb97
    }
    // bb97
    return function_f8c1f889();
}

// Address range: 0x2b56 - 0x2b59
int32_t function_2b56(void) {
    // 0x2b56
    return 0;
}

// Address range: 0x2c0a - 0x2c16
int32_t function_2c0a(int16_t a1) {
    char v1 = *(char *)&g2; // 0x2c0a
    int32_t result = 0; // eax
    *(char *)result = (char)result + v1;
    char * v2 = (char *)-0x7abbdbbc; // 0x2c0c
    *v2 = (char)0 + *v2;
    unsigned char v3 = *(char *)&g6; // 0x2c12
    *(char *)0 = v3 / 16 | 16 * v3;
    return result;
}

// Address range: 0x2c31 - 0x2c40
int32_t function_2c31(void) {
    // 0x2c31
    return 0;
}

// Address range: 0x2c6d - 0x2c78
int32_t function_2c6d(void) {
    // 0x2c6d
    int32_t v1;
    *(int32_t *)v1 = v1 - 1;
    return 0;
}

// Address range: 0x2c78 - 0x2c93
int32_t function_2c78(void) {
    // 0x2c78
    return 0;
}

// Address range: 0x2cae - 0x2cb5
int32_t function_2cae(void) {
    // 0x2cae
    return 0;
}

// Address range: 0x2cb5 - 0x2cd7
int32_t function_2cb5(void) {
    // 0x2cb5
    return 0;
}

// Address range: 0x2cdf - 0x2ce6
int32_t function_2cdf(void) {
    // 0x2cdf
    return 0;
}

// Address range: 0x2ce6 - 0x2ce7
int32_t function_2ce6(int32_t a1, int32_t a2) {
    // 0x2ce6
    return g2;
}

// Address range: 0x2cec - 0x2ced
int32_t function_2cec(void) {
    // 0x2cec
    return 0;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x2d00 - 0x2dd7
// Line range:    58 - 64
void LookupIntern(char * pszName, int32_t vIP, int32_t nMaxSolutions, bool fAllowLookup) {
    // 0x2d00
    g8 = g5;
    int32_t v1 = g7; // 0x2d06
    g4 = v1;
    int32_t v2; // bp-80
    int32_t v3 = &v2; // 0x2d1a
    g3 = v3;
    int32_t v4; // bp-92
    int32_t v5 = &v4; // 0x2d2b
    g6 = v5;
    *(int32_t *)(v1 + 4) = 0;
    _ZN8CNetAddr4InitEv(v3);
    _ZN8CNetAddr10SetSpecialERKSs(v3, v5);
    g7 = 0;
    int32_t v6 = 0; // 0x2d7f
    int32_t * v7;
    if ((char)&v7 == 0) {
        // bb
        function_2e20(v5);
        v6 = g7;
        // branch -> 0x2d7f
    }
    *(int32_t *)(v6 + 32 + g9) = 0;
    int32_t v8 = g7 + 4; // 0x2d87
    g7 = v8;
    while (v8 < 32) {
        // 0x2d7f
        *(int32_t *)(v8 + 32 + g9) = 0;
        v8 = g7 + 4;
        g7 = v8;
        // continue -> 0x2d7f
    }
}

// Address range: 0x2df0 - 0x2df1
int32_t function_2df0(void) {
    // 0x2df0
    return g2;
}

// Address range: 0x2e04 - 0x2e05
int32_t function_2e04(void) {
    // 0x2e04
    return g2;
}

// Address range: 0x2e0f - 0x2e1f
int32_t function_2e0f(void) {
    int32_t * v1 = (int32_t *)0x32b0443; // 0x2e0f
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    return (int32_t)(v2 >= 16) | v2 / 16 & -256;
}

// Address range: 0x2e20 - 0x2fc5
int32_t function_2e20(int32_t a1) {
    int32_t v1 = g4; // 0x2e20
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x2e20
    if (v2 == *(int32_t *)(v1 + 8)) {
        // 0x2f8c
        _ZNSt6vectorI8CNetAddrSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_((int32_t *)v1, v2);
        g2 = 1;
        // branch -> 0x2e60
    } else {
        // 0x2e2c
        int32_t * v3;
        if (v2 == 0) {
            v3 = &g7;
            // branch -> 0x2e4e
        } else {
            // 0x2e30
            *(int32_t *)v2 = a1;
            v3 = (int32_t *)(g4 + 4);
            // branch -> 0x2e4e
        }
        // 0x2e4e
        g2 = 1;
        *(int32_t *)(g4 + 4) = *v3 + (int32_t)&g10;
        // branch -> 0x2e60
    }
    // 0x2e60
    int32_t v4;
    int32_t v5 = v4 ^ 0x24848900; // 0x2e64
    g7 = v5;
    int32_t result; // 0x2e7b
    if (v5 != 0) {
        // bb
        result = function_2fee();
        // branch -> 0x2e71
    } else {
        // 0x2e60
        result = g2;
        // branch -> 0x2e71
    }
    // 0x2e71
    return result;
}

// Address range: 0x2fca - 0x2fe9
int32_t function_2fca(void) {
    // 0x2fca
    return g2;
}

// Address range: 0x2fee - 0x2fef
int32_t function_2fee(void) {
    // 0x2fee
    return g2;
}

// Address range: 0x2ff4 - 0x2ff5
int32_t function_2ff4(void) {
    // 0x2ff4
    return 0;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x3010 - 0x30bf
// Line range:    115 - 319
// Demangled:     LookupHost(char const *, std::vector<CNetAddr, std::allocator<CNetAddr> > &, unsigned int, bool)
bool _Z10LookupHostPKcRSt6vectorI8CNetAddrSaIS2_EEjb(char * pszName, int32_t vIP, int32_t nMaxSolutions, bool fAllowLookup) {
    // 0x3010
    bool result; // bp-52
    int32_t v1 = &result; // 0x3033
    g3 = nMaxSolutions;
    g6 = fAllowLookup;
    bool v2;
    int32_t v3 = *(int32_t *)((int32_t)v2 - 12); // 0x3054
    g2 = v3;
    if (v3 == 0) {
        // bb
        int32_t v4; // bp-33
        function_3158(v1, (int32_t)pszName, (int32_t)&v4);
        v2 = result;
        // branch -> 0x305f
    }
    int32_t v5 = v2; // 0x306f
    int32_t v6 = *(int32_t *)(v5 - 12); // 0x3073
    int32_t v7 = v5; // 0x3096
    if (v6 == 0) {
        // bb33
        int32_t v8; // bp-44
        v7 = function_3118((int32_t)&v8, v1);
        // branch -> 0x3096
    }
    // 0x3096
    if (*(char *)v7 != 91) {
        // bb35
        function_3118(v6, v5);
        // branch -> 0x309b
    }
    // 0x309b
    int32_t v9; // bp-40
    g4 = &v9;
    return result;
}

// Address range: 0x3118 - 0x3135
int32_t function_3118(int32_t a1, int32_t a2) {
    // 0x3118
    g7 = a1;
    g5 = g3;
    g2 = a2;
    int32_t * v1;
    LookupIntern((char *)(g6 % 256), (int32_t)&v1, (int32_t)&v1, (bool)&v1);
    return (int32_t)&v1;
}

// Address range: 0x3139 - 0x3151
int32_t function_3139(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x24548bd8; // 0x3139
    *v1 = *v1 - 1;
    int32_t result = g2; // 0x3150
    // bb
    result = function_315c();
    // branch -> 0x3149
    // 0x3149
    return result;
}

// Address range: 0x3158 - 0x315c
int32_t function_3158(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3158
    return g2;
}

// Address range: 0x315c - 0x3168
int32_t function_315c(void) {
    // 0x315c
    return g2;
}

// Address range: 0x316d - 0x316e
int32_t function_316d(void) {
    // 0x316d
    return g2;
}

// Address range: 0x3189 - 0x318d
int32_t function_3189(void) {
    // 0x3189
    return function_316d();
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x3190 - 0x3254
// Line range:    592 - 98
void CNetAddr4(int32_t this, int32_t strIp, bool fAllowLookup) {
    // 0x3190
    _ZN8CNetAddr4InitEv(this);
    int32_t v1 = *(int32_t *)strIp; // 0x31d9
    int32_t v2 = 0; // bp-28
    bool v3 = _Z10LookupHostPKcRSt6vectorI8CNetAddrSaIS2_EEjb((char *)v1, (int32_t)&v2, 1, (int32_t)fAllowLookup % 2 != 0); // 0x31f6
    if (v3) {
        // 0x3203
        *(int32_t *)g4 = *(int32_t *)v2;
        *(int32_t *)(g4 + 4) = *(int32_t *)(v2 + 4);
        *(int32_t *)(g4 + 8) = *(int32_t *)(v2 + 8);
        *(int32_t *)(g4 + (int32_t)&g53) = 0x65c38900;
        // branch -> 0x3219
    }
    // 0x3219
    if (v2 != 0) {
        // 0x321d
        // branch -> 0x3225
    }
}

// Address range: 0x3259 - 0x325c
int32_t function_3259(void) {
    // 0x3259
    return g2;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x3270 - 0x3320
// Line range:    584 - 98
void CNetAddr5(int32_t this, char * pszIp, bool fAllowLookup) {
    // 0x3270
    _ZN8CNetAddr4InitEv(this);
    int32_t v1 = 0; // bp-28
    bool v2 = _Z10LookupHostPKcRSt6vectorI8CNetAddrSaIS2_EEjb(pszIp, (int32_t)&v1, 1, (int32_t)fAllowLookup % 2 != 0); // 0x32d4
    if (v2) {
        // 0x32e1
        *(int32_t *)g4 = *(int32_t *)v1;
        *(int32_t *)(g4 + 4) = *(int32_t *)(v1 + 4);
        *(int32_t *)(g4 + 8) = *(int32_t *)(v1 + 8);
        *(int32_t *)(g4 + (int32_t)&g53) = 0x65c38900;
        // branch -> 0x32f7
    }
    // 0x32f7
    if (v1 != 0) {
        // 0x32fb
        // branch -> 0x3303
    }
}

// Address range: 0x3324 - 0x332b
int32_t function_3324(void) {
    int32_t * v1 = (int32_t *)-0x76efdbac; // 0x3324
    *v1 = *v1 - 1;
    return 0;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x3340 - 0x3390
// Line range:    128 - 131
// Demangled:     LookupHostNumeric(char const *, std::vector<CNetAddr, std::allocator<CNetAddr> > &, unsigned int)
bool _Z17LookupHostNumericPKcRSt6vectorI8CNetAddrSaIS2_EEj(char * pszName, int32_t vIP, int32_t nMaxSolutions) {
    // 0x3340
    return _Z10LookupHostPKcRSt6vectorI8CNetAddrSaIS2_EEjb(pszName, vIP, nMaxSolutions, false);
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x3390 - 0x36a0
// Line range:    815 - 880
// Demangled:     CNetAddr::GetGroup() const
void _ZNK8CNetAddr8GetGroupEv(int32_t this) {
    // 0x3390
    g4 = this;
    char * v1;
    g3 = (int32_t)v1;
    *(int32_t *)this = 0;
    *(int32_t *)(g4 + 4) = 0;
    *(int32_t *)(g4 + 8) = 0;
    _ZNK8CNetAddr7IsLocalEv(0x24848900);
    int32_t * v2;
    _ZNK8CNetAddr10IsRoutableEv((int32_t)((char)&v2 == 0) + 255);
    char v3; // 0x340d
    if (((char)&v2 & (char)&v2) == 0) {
        // 0x3548
        g6 = 0;
        g8 = 0;
        v3 = 0;
        // branch -> 0x3409
    } else {
        // 0x33ef
        g8 = &g53;
        _ZNK8CNetAddr6IsIPv4Ev(g3);
        v3 = 1;
        // branch -> 0x3409
    }
    char v4 = v3; // bp-35
    _ZNSt6vectorIhSaIhEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPhS1_EERKh((int32_t *)g4, 0, (int32_t)&v4);
    int32_t v5 = g6; // 0x3425
    uint32_t v6 = v5; // 0x3491
    char v7; // bp-33
    int32_t v8; // 0x3493
    char v9; // 0x3498
    int32_t v10; // 0x34b4
    int32_t v11; // 0x34b7
    int32_t v12; // 0x34ba
    int32_t v13; // 0x3493
    uint32_t v14; // 0x3496
    char v15; // 0x349b
    if (v5 <= 7) {
        // 0x3488
        if (v6 == 0) {
            // 0x34bd
            return;
        }
        // 0x348c
        v8 = g4;
        v13 = *(int32_t *)(v8 + 4);
        v14 = v6 % 32;
        v9 = 0;
        if (v14 != 0) {
            // bb
            v9 = (1 << v14) + 255;
            // branch -> bb143
        }
        // bb143
        v15 = *(char *)(g8 + g3) | v9;
        v7 = v15;
        if (v13 == *(int32_t *)(v8 + 8)) {
            // 0x3620
            _ZNSt6vectorIhSaIhEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPhS1_EERKh((int32_t *)v8, v13, (int32_t)&v7);
            // branch -> 0x34bd
        } else {
            // 0x34ac
            if (v13 != 0) {
                // 0x34b2
                *(char *)v13 = v15;
                v10 = g4;
                v12 = v10;
                v11 = *(int32_t *)(v10 + 4) + 1;
                // branch -> 0x34b7
            } else {
                v12 = v8;
                v11 = 1;
            }
            // 0x34b7
            *(int32_t *)(v12 + 4) = v11;
            // branch -> 0x34bd
        }
        // 0x34bd
        return;
    }
    uint32_t v16 = v5 % 8; // 0x342c
    char v17; // bp-34
    int32_t v18 = &v17; // 0x3466
    // branch -> 0x3455
    while (true) {
        char v19 = *(char *)(g8 + g3); // 0x3455
        int32_t v20 = g4; // 0x345a
        int32_t v21 = *(int32_t *)(v20 + 4); // 0x345a
        char * v22 = (char *)v21; // 0x345a
        v17 = v19;
        if (v21 != *(int32_t *)(v20 + 8)) {
            int32_t v23 = v20; // 0x3450
            int32_t v24 = 0; // 0x3443
            if (v21 != 0) {
                // 0x343e
                *v22 = v19;
                int32_t v25 = g4; // 0x3440
                v23 = v25;
                v24 = *(int32_t *)(v25 + 4);
                // branch -> 0x3443
            }
            // 0x3443
            g8++;
            int32_t v26 = g6 - 8; // 0x3449
            g6 = v26;
            *(int32_t *)(v23 + 4) = v24 + 1;
            if (v26 == v16) {
                // break -> 0x3443
                break;
            }
            // continue -> 0x3455
            continue;
        } else {
            // 0x3466
            _ZNSt6vectorIhSaIhEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPhS1_EERKh((int32_t *)v20, v21, v18);
            g8++;
            int32_t v27 = g6 - 8; // 0x347d
            g6 = v27;
            if (v27 == v16) {
                v6 = v27;
                // break -> 0x3488
                break;
            }
            // continue -> 0x3455
            continue;
        }
    }
    // 0x3488
    if (v6 == 0) {
        // 0x34bd
        return;
    }
    // 0x348c
    v8 = g4;
    v13 = *(int32_t *)(v8 + 4);
    v14 = v6 % 32;
    v9 = 0;
    if (v14 != 0) {
        // bb
        v9 = (1 << v14) + 255;
        // branch -> bb143
    }
    // bb143
    v15 = *(char *)(g8 + g3) | v9;
    v7 = v15;
    if (v13 == *(int32_t *)(v8 + 8)) {
        // 0x3620
        _ZNSt6vectorIhSaIhEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPhS1_EERKh((int32_t *)v8, v13, (int32_t)&v7);
        // branch -> 0x34bd
    } else {
        // 0x34ac
        if (v13 != 0) {
            // 0x34b2
            *(char *)v13 = v15;
            v10 = g4;
            v12 = v10;
            v11 = *(int32_t *)(v10 + 4) + 1;
            // branch -> 0x34b7
        } else {
            v12 = v8;
            v11 = 1;
        }
        // 0x34b7
        *(int32_t *)(v12 + 4) = v11;
        // branch -> 0x34bd
    }
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x36a0 - 0x373b
// Line range:    133 - 98
// Demangled:     Lookup(char const *, std::vector<CService, std::allocator<CService> > &, int, bool, unsigned int)
bool _Z6LookupPKcRSt6vectorI8CServiceSaIS2_EEibj(char * pszName, int32_t vAddr, int32_t portDefault, bool fAllowLookup, int32_t nMaxSolutions) {
    // 0x36a0
    if (*pszName != 0) {
        // 0x3708
        int32_t v1; // bp-92
        g4 = &v1;
    }
    // 0x36e7
    return false;
}

// Address range: 0x3765 - 0x38a9
int32_t function_3765(int32_t * a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t * v1 = (int32_t *)-0x76c3dbbc; // 0x3765
    *v1 = *v1 - 1;
    int32_t v2; // bp+44
    g7 = &v2;
    v2 = 0;
    int32_t * v3;
    LookupIntern((char *)0, (int32_t)&v3, (int32_t)&v3, (bool)&v3);
    char * v4;
    int32_t result; // 0x389a
    if (((char)&v3 & (char)&v3) == 0) {
        // 0x3890
        v4 = (char *)v2;
        // branch -> 0x389a
        // 0x389a
        result = (int32_t)v4;
        g2 = result;
        if (v4 == NULL) {
            // bb130
            function_38ae();
            // branch -> 0x38a2
        }
        // 0x38a2
        return result;
    }
    // 0x3798
    CService((int32_t)&a3);
    int32_t v5 = v2; // 0x37a4
    char * v6 = (char *)v5; // 0x37ac
    int32_t v7 = -v5 / 16; // 0x37b6
    g2 = v7;
    int32_t * v8 = (int32_t *)((int32_t)a1 + 4); // 0x37e7
    int32_t v9 = *v8; // 0x37e7
    g4 = v9;
    int32_t v10 = *a1; // 0x37ea
    g5 = v10;
    int32_t v11 = 0x38e38e39 * (v9 - v10) / 2; // 0x37f2
    g7 = v11;
    int32_t v12 = v11; // 0x3800
    if (v7 > v11) {
        // bb
        function_38c0(v5, v7);
        v12 = g7;
        // branch -> 0x3800
    }
    // 0x3800
    if (v7 < v12) {
        // 0x3806
        *v8 = g5 + 18 * v7;
        // branch -> 0x3817
    }
    // 0x3817
    if (-v5 >= 16) {
        int32_t v13 = 0; // 0x3843
        int32_t v14 = 0; // 0x383c
        // branch -> 0x3838
        while (true) {
            int32_t v15 = *a1 + v14; // 0x3841
            int32_t v16 = v15; // eax
            int32_t v17 = v13 + 1; // 0x3848
            int32_t v18 = 16 * v13 + v5; // 0x384b
            int32_t v19 = *(int32_t *)(v18 + (int32_t)&g53); // 0x385b
            *(int32_t *)(v15 + 12) = v19;
            *(int32_t *)v16 = *(int32_t *)v18;
            *(int32_t *)(v16 + 4) = *(int32_t *)(v18 + 4);
            *(int32_t *)(v16 + 8) = *(int32_t *)(v18 + 8);
            *(int16_t *)(v16 + 16) = (int16_t)(a2 % 0x10000);
            if (v17 == v7) {
                // 0x3884
                v4 = v6;
                // branch -> 0x389a
                // 0x389a
                result = (int32_t)v4;
                g2 = result;
                if (v4 != NULL) {
                    // 0x38a2
                    return result;
                }
                // bb130
                function_38ae();
                // branch -> 0x38a2
                // 0x38a2
                return result;
            }
            // 0x3838
            v13 = v17;
            v14 += 18;
            // branch -> 0x3838
        }
    } else {
        v4 = v6;
    }
    // 0x389a
    result = (int32_t)v4;
    g2 = result;
    if (v4 == NULL) {
        // bb130
        function_38ae();
        // branch -> 0x38a2
    }
    // 0x38a2
    return result;
}

// Address range: 0x38ae - 0x38b5
int32_t function_38ae(void) {
    // 0x38ae
    return g2;
}

// Address range: 0x38ba - 0x38bf
int32_t function_38ba(void) {
    // 0x38ba
    return 0;
}

// Address range: 0x38c0 - 0x38f8
int32_t function_38c0(int32_t a1, int32_t a2) {
    // 0x38c0
    int32_t v1; // bp+106
    int32_t v2 = &v1; // 0x38ca
    g5 = v2;
    _ZNSt6vectorI8CServiceSaIS0_EE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPS0_S2_EEjRKS0_((int32_t *)a1, g4, g2 - g7, v2);
    g7 = a2;
    int32_t v3;
    return (v3 - a2) / 16;
}

// Address range: 0x38f8 - 0x38f9
int32_t function_38f8(int32_t a1) {
    // 0x38f8
    return g2;
}

// Address range: 0x3909 - 0x390a
int32_t function_3909(void) {
    // 0x3909
    return g2;
}

// Address range: 0x390a - 0x390b
int32_t function_390a(void) {
    // 0x390a
    return 0;
}

// Address range: 0x390b - 0x390c
int32_t function_390b(void) {
    // 0x390b
    return g2;
}

// Address range: 0x391e - 0x3925
int32_t function_391e(void) {
    int32_t * v1 = (int32_t *)-0x76d3dbac; // 0x391e
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x3931 - 0x3933
int32_t function_3931(void) {
    // 0x3931
    return function_390b();
}

// Address range: 0x3933 - 0x3935
int32_t function_3933(void) {
    // 0x3933
    return function_3909();
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x3940 - 0x39aa
// Line range:    151 - 98
// Demangled:     Lookup(char const *, CService &, int, bool)
bool _Z6LookupPKcR8CServiceib(char * pszName, int32_t addr, int32_t portDefault, bool fAllowLookup) {
    // 0x3940
    g4 = addr;
    int32_t v1 = 0; // bp-28
    bool v2 = _Z6LookupPKcRSt6vectorI8CServiceSaIS2_EEibj(pszName, (int32_t)&v1, portDefault, fAllowLookup, 1); // 0x3994
    g7 = v1;
    int32_t v3 = v2; // 0x39a77
    if (v2) {
        // bb
        v3 = function_39c8();
        // branch -> 0x39a1
    }
    // 0x39a1
    g4 = 0;
    if (v1 == 0) {
        // bb26
        v3 = function_39af();
        // branch -> 0x39a7
    }
    // 0x39a7
    return v3 % 2 != 0;
}

// Address range: 0x39af - 0x39c3
int32_t function_39af(void) {
    // 0x39af
    g2 = g4;
    int32_t result = g4; // 0x39c2
    int32_t v1;
    if (v1 != 0x24848900) {
        // bb
        result = function_39ed();
        // branch -> 0x39be
    }
    // 0x39be
    return result;
}

// Address range: 0x39c8 - 0x39ed
int32_t function_39c8(void) {
    // 0x39c8
    *(int32_t *)g4 = g7;
    *(int32_t *)(g4 + 4) = *(int32_t *)(g7 + 4);
    *(int32_t *)(g4 + 8) = *(int32_t *)(g7 + 8);
    int32_t v1 = *(int32_t *)(g7 + (int32_t)&g53); // 0x39d8
    *(int32_t *)(g4 + (int32_t)&g53) = v1;
    uint16_t result = *(int16_t *)(g7 + (int32_t)&g10); // 0x39de
    *(int16_t *)(g4 + (int32_t)&g10) = result;
    return result;
}

// Address range: 0x39ed - 0x39ee
int32_t function_39ed(void) {
    // 0x39ed
    return g2;
}

// Address range: 0x39f1 - 0x39f8
int32_t function_39f1(void) {
    int32_t * v1 = (int32_t *)-0x76dfdbac; // 0x39f1
    *v1 = *v1 - 1;
    return 0;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x3a10 - 0x3ac2
// Line range:    1043 - 1049
void CService7(int32_t this, int32_t strIpPort, int32_t portDefault, bool fAllowLookup) {
    // 0x3a10
    g4 = this;
    int32_t v1; // bp-50
    int32_t v2 = &v1; // 0x3a24
    g8 = v2;
    g6 = strIpPort;
    g3 = portDefault;
    _ZN8CNetAddr4InitEv(this);
    *(int16_t *)(g4 + (int32_t)&g10) = 0;
    CService(v2);
    int32_t v3 = *(int32_t *)g6; // 0x3a6f
    int32_t * v4;
    bool v5 = _Z6LookupPKcR8CServiceib((char *)v3, v2, (int32_t)fAllowLookup, (bool)&v4); // 0x3a74
    if (v5) {
        // 0x3a7d
        *(int32_t *)g4 = v1;
        // branch -> 0x3aa1
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x3ad0 - 0x3b7e
// Line range:    1035 - 1041
void CService8(int32_t this, int32_t strIpPort, bool fAllowLookup) {
    // 0x3ad0
    g4 = this;
    g3 = fAllowLookup;
    g6 = strIpPort;
    int32_t v1; // bp-50
    int32_t v2 = &v1; // 0x3afc
    g8 = v2;
    _ZN8CNetAddr4InitEv(this);
    *(int16_t *)(g4 + (int32_t)&g10) = 0;
    CService(v2);
    if (_Z6LookupPKcR8CServiceib((char *)*(int32_t *)g6, v2, 0, g3 % 2 != 0)) {
        // 0x3b39
        *(int32_t *)g4 = v1;
        // branch -> 0x3b5d
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x3b90 - 0x3c40
// Line range:    1027 - 1033
void CService9(int32_t this, char * pszIpPort, int32_t portDefault, bool fAllowLookup) {
    // 0x3b90
    g4 = this;
    int32_t v1; // bp-50
    int32_t v2 = &v1; // 0x3ba4
    g8 = v2;
    g6 = (int32_t)pszIpPort;
    g3 = portDefault;
    _ZN8CNetAddr4InitEv(this);
    *(int16_t *)(g4 + (int32_t)&g10) = 0;
    CService(v2);
    int32_t * v3;
    bool v4 = _Z6LookupPKcR8CServiceib((char *)g6, v2, (int32_t)fAllowLookup, (bool)&v3); // 0x3bf2
    if (v4) {
        // 0x3bfb
        *(int32_t *)g4 = v1;
        // branch -> 0x3c1f
    }
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x3c50 - 0x3cfc
// Line range:    1019 - 1025
void CService10(int32_t this, char * pszIpPort, bool fAllowLookup) {
    int32_t v1 = g4; // 0x3c53
    g4 = this;
    int32_t v2 = g3; // 0x3c5b
    g3 = fAllowLookup;
    int32_t v3 = g6; // 0x3c64
    g6 = (int32_t)pszIpPort;
    int32_t v4 = g8; // 0x3c78
    int32_t v5; // bp-50
    int32_t v6 = &v5; // 0x3c7c
    g8 = v6;
    _ZN8CNetAddr4InitEv(this);
    *(int16_t *)(g4 + (int32_t)&g10) = 0;
    CService(v6);
    if (_Z6LookupPKcR8CServiceib((char *)g6, v6, 0, g3 % 2 != 0)) {
        // 0x3cb7
        *(int32_t *)g4 = v5;
        // branch -> 0x3cdb
    }
    // 0x3cdb
    g4 = v1;
    g8 = v4;
    g6 = v3;
    g3 = v2;
}

// Address range: 0x3d01 - 0x3d03
int32_t function_3d01(void) {
    // 0x3d01
    int32_t * v1;
    bool result = _Z13LookupNumericPKcR8CServicei((char *)&v1, (int32_t)&v1, (int32_t)&v1); // 0x3d01
    return result;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x3d10 - 0x3d54
// Line range:    161 - 164
// Demangled:     LookupNumeric(char const *, CService &, int)
bool _Z13LookupNumericPKcR8CServicei(char * pszName, int32_t addr, int32_t portDefault) {
    // 0x3d10
    return _Z6LookupPKcR8CServiceib(pszName, addr, portDefault, false);
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x3d60 - 0x3ea5
// Line range:    441 - 147
// Demangled:     SetNameProxy(CService, int)
bool _Z12SetNameProxy8CServicei(struct CService addrProxy, int32_t nSocksVersion) {
    int32_t v1 = addrProxy.e0;
    int32_t v2 = v1; // bp-96
    int32_t v3; // bp-68
    int16_t v4;
    int32_t v5;
    if (v5 != 5) {
        // 0x3e08
        if (v5 != 0) {
            // bb
            int32_t v6;
            int32_t v7;
            function_3ee0(v1, nSocksVersion, v7, v6, (int32_t)v4);
            // branch -> 0x3e10
        }
        // 0x3e10
        g8 = &v3;
        v3 = &g19;
        _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(&v3);
        *(int32_t *)"ecting %s\n" = (int32_t)v4;
        g20 = v2;
        g21 = nSocksVersion;
        // branch -> 0x3de0
        // 0x3de0
        return true;
    }
    // 0x3dc5
    if (v5 == 0) {
        // 0x3e10
        g8 = &v3;
        v3 = &g19;
        _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(&v3);
        *(int32_t *)"ecting %s\n" = (int32_t)v4;
        g20 = v2;
        g21 = nSocksVersion;
        // branch -> 0x3de0
        // 0x3de0
        return true;
    }
    // 0x3dc9
    _ZNK8CNetAddr7IsValidEv((int32_t)&v2);
    int32_t * v8;
    if ((char)&v8 != 0) {
        // 0x3de0
        return false;
    }
    // 0x3e10
    g8 = &v3;
    v3 = &g19;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(&v3);
    *(int32_t *)"ecting %s\n" = (int32_t)v4;
    g20 = v2;
    g21 = nSocksVersion;
    // branch -> 0x3de0
    // 0x3de0
    return true;
}

// Address range: 0x3ebb - 0x3ebc
int32_t function_3ebb(void) {
    // 0x3ebb
    return g2;
}

// Address range: 0x3ed1 - 0x3ee0
int32_t function_3ed1(void) {
    // 0x3ed1
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x47c98a40); // 0x3ed1
    *v2 = *v2 + 1;
    int32_t result = 0; // eax
    *(int32_t *)result = 2 * result;
    char v3 = *(char *)&g2; // 0x3ed9
    *(char *)result = (char)result + v3;
    return result;
}

// Address range: 0x3ee0 - 0x3ee7
int32_t function_3ee0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x3ee0
    return 0;
}

// Address range: 0x3ee8 - 0x3eee
int32_t function_3ee8(void) {
    // 0x3ee8
    *(char *)72 = 0;
    return function_3ebb();
}

// Address range: 0x3eee - 0x3ef0
int32_t function_3eee(void) {
    // 0x3eee
    return g2;
}

// Address range: 0x3efb - 0x3efc
int32_t function_3efb(void) {
    // 0x3efb
    return 0;
}

// Address range: 0x3f0d - 0x3f15
int32_t function_3f0d(void) {
    int32_t v1 = 0; // 0x3f0d
    unsigned char v2 = (char)0 + (char)false + (char)v1; // 0x3f10
    return (int32_t)v2 | v1 & -256;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x3f20 - 0x3fb7
// Line range:    451 - 128
// Demangled:     GetNameProxy(std::pair<CService, int> &)
bool _Z12GetNameProxyRSt4pairI8CServiceiE(int32_t nameproxyInfoOut) {
    // 0x3f8d
    int32_t v1; // bp-24
    g8 = &v1;
    g4 = nameproxyInfoOut;
    v1 = &g19;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(&v1);
    return false;
}

// Address range: 0x3fcd - 0x3fce
int32_t function_3fcd(void) {
    // 0x3fcd
    return g2;
}

// Address range: 0x3fe3 - 0x3ff6
int32_t function_3fe3(void) {
    // 0x3fe3
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x17538b40); // 0x3fe3
    *v2 = *v2 + 1;
    int32_t v3 = g2; // 0x3feb
    *(char *)v3 = (char)v3 + *(char *)&g2;
    *(char *)((int32_t)&g14 + 72) = 0;
    return function_3fcd();
}

// Address range: 0x3ff6 - 0x3ff7
int32_t function_3ff6(void) {
    // 0x3ff6
    return g2;
}

// Address range: 0x4006 - 0x4007
int32_t function_4006(void) {
    // 0x4006
    return 0;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x4020 - 0x40d8
// Line range:    464 - 26
// Demangled:     IsProxy(CNetAddr const &)
bool _Z7IsProxyRK8CNetAddr(int32_t addr) {
    // 0x4020
    int32_t v1; // bp-40
    g8 = &v1;
    g4 = addr;
    v1 = &g19;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(&v1);
    int32_t v2 = 0; // esi
    int32_t v3; // bp-32
    int32_t v4 = &v3; // 0x4051
    int32_t v5 = 0; // 0x4084
    // branch -> 0x4055
    while (true) {
        int32_t v6 = v5; // 0x40c0
        int32_t v7; // 0x40c0
        if (*(int32_t *)(v5 + (int32_t)"ad_mutex_destroy(&m)") != 0) {
            // 0x405f
            v3 = *(int32_t *)(v5 + (int32_t)"tex_unlock(m)");
            if (_ZeqRK8CNetAddrS1_(g4, v4)) {
                // 0x4097
                // branch -> 0x40a3
                // 0x40a3
                return true;
            }
            // 0x405f
            v6 = v2;
            // branch -> 0x40c0
            // 0x40c0
            v7 = v6 + (int32_t)&g13;
            v2 = v7;
            if (v6 == 96 - (int32_t)&g13) {
                // break -> 0x40c8
                break;
            }
            v5 = v7;
            // continue -> 0x4055
            continue;
        }
        // 0x40c0
        v7 = v6 + (int32_t)&g13;
        v2 = v7;
        if (v6 == 96 - (int32_t)&g13) {
            // break -> 0x40c8
            break;
        }
        v5 = v7;
        // continue -> 0x4055
    }
    // 0x40c8
    // branch -> 0x40a3
    // 0x40a3
    return false;
}

// Address range: 0x40ee - 0x40ef
int32_t function_40ee(void) {
    // 0x40ee
    return g2;
}

// Address range: 0x4104 - 0x4116
int32_t function_4104(void) {
    // 0x4104
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x17658b40); // 0x4104
    *v2 = *v2 + 1;
    int32_t v3 = 0; // eax
    uint32_t v4 = 0; // 0x410a
    char v5 = (char)v4 - (char)v3; // 0x410b
    g2 = (int32_t)((char)false + v5) | v4 & -256;
    char * v6 = (char *)(v3 - 112); // 0x410d
    *v6 = *v6 + (char)(v4 / 256);
    *(char *)72 = 0;
    return function_40ee();
}

// Address range: 0x4116 - 0x4117
int32_t function_4116(void) {
    // 0x4116
    return g2;
}

// Address range: 0x411c - 0x4122
int32_t function_411c(void) {
    // 0x411c
    return -0x76ffffe6;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x4140 - 0x4197
// Line range:    459 - 128
// Demangled:     HaveNameProxy()
bool _Z13HaveNameProxyv(void) {
    // 0x4140
    int32_t v1; // bp-24
    g4 = &v1;
    v1 = &g19;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(&v1);
    return false;
}

// Address range: 0x41ad - 0x41ae
int32_t function_41ad(void) {
    // 0x41ad
    return g2;
}

// Address range: 0x41c4 - 0x41d6
int32_t function_41c4(void) {
    // 0x41c4
    g2 = _ZN5boost7pthread25pthread_mutex_scoped_lockD2Ev_part_21();
    *(char *)72 = 0;
    return function_41ad();
}

// Address range: 0x41d6 - 0x41d7
int32_t function_41d6(void) {
    // 0x41d6
    return g2;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x4220 - 0x42e7
// Line range:    432 - 128
// Demangled:     GetProxy(Network, std::pair<CService, int> &)
bool _Z8GetProxy7NetworkRSt4pairI8CServiceiE(uint32_t net, int32_t proxyInfoOut) {
    int32_t v1 = g4; // 0x4223
    g4 = net;
    g2 = 0;
    int32_t v2 = g8; // 0x4237
    g8 = proxyInfoOut;
    int32_t v3 = g6; // 0x423f
    if (net >= 4) {
        // bb
        function_4333(0x24848900, v1, v2, v3);
        // branch -> 0x424c
    }
    // 0x424c
    int32_t v4; // bp-24
    g6 = &v4;
    v4 = &g19;
    _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(&v4);
    int32_t v5 = g4 * 8 * ((int32_t)&g16 + 1); // 0x426a
    bool result; // 0x4289
    if (*(int32_t *)(v5 + (int32_t)"ad_mutex_destroy(&m)") != 0) {
        int32_t v6 = v5 + (int32_t)"tex_unlock(m)"; // 0x42a8
        *(int32_t *)g8 = *(int32_t *)v6;
        *(int32_t *)(g8 + 4) = *(int32_t *)(v6 + 4);
        *(int32_t *)(g8 + 8) = *(int32_t *)(v6 + 8);
        int32_t v7 = *(int32_t *)(v6 + (int32_t)&g53); // 0x42cc
        *(int32_t *)(g8 + (int32_t)&g53) = v7;
        int32_t v8 = *(int32_t *)(v6 + (int32_t)&g10); // 0x42d2
        *(int32_t *)(g8 + (int32_t)&g10) = v8;
        int32_t v9 = *(int32_t *)(v6 + (int32_t)&g12); // 0x42d8
        *(int32_t *)(g8 + (int32_t)&g12) = v9;
        result = true;
        // branch -> 0x427e
    } else {
        // 0x4277
        result = false;
        // branch -> 0x427e
    }
    // 0x427e
    g4 = v1;
    g8 = v2;
    g6 = v3;
    return result;
}

// Address range: 0x42fd - 0x42fe
int32_t function_42fd(void) {
    // 0x42fd
    return g2;
}

// Address range: 0x4314 - 0x432e
int32_t function_4314(void) {
    // 0x4314
    g2 = _ZN5boost7pthread25pthread_mutex_scoped_lockD2Ev_part_21();
    *(char *)72 = 0;
    return function_42fd();
}

// Address range: 0x432e - 0x432f
int32_t function_432e(void) {
    // 0x432e
    return g2;
}

// Address range: 0x4333 - 0x4352
int32_t function_4333(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4333
    return g2;
}

// Address range: 0x4362 - 0x4363
int32_t function_4362(void) {
    // 0x4362
    return 0;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x4380 - 0x448b
// Line range:    473 - 67
// Demangled:     ConnectSocket(CService const &, unsigned int &, int)
bool _Z13ConnectSocketRK8CServiceRji(struct CService addrDest, int32_t hSocketRet, int32_t nTimeout) {
    // 0x4380
    g8 = addrDest.e0;
    int32_t v1; // bp-96
    int32_t v2 = &v1; // 0x4398
    g4 = v2;
    g3 = nTimeout;
    CService(v2);
    _ZNK8CNetAddr10GetNetworkEv(g8);
    int32_t * v3;
    bool v4 = _Z8GetProxy7NetworkRSt4pairI8CServiceiE((int32_t)&v3, v2); // 0x43e3
    g5 = g3;
    bool result;
    int32_t v5;
    if (!v4) {
        // 0x4450
        g7 = g6;
        g2 = g8;
        int32_t v6;
        result = (int32_t)ConnectSocketDirectly(v6, v5, (int32_t)&v3) % 2 != 0;
        // branch -> 0x4419
    } else {
        // 0x43ec
        g2 = v2;
        int32_t v7; // bp-120
        g7 = &v7;
        v7 = -1;
        if (ConnectSocketDirectly(-1, v5, (int32_t)&v3)) {
            // 0x4405
            // branch -> 0x4417
        }
        // 0x4417
        result = false;
        // branch -> 0x4419
    }
    // 0x4419
    return result;
}

// Address range: 0x4490 - 0x44a6
int32_t function_4490(int32_t result) {
    // 0x4490
    int32_t v1;
    *(int32_t *)v1 = result;
    return result;
}

// Address range: 0x4496 - 0x4497
int32_t function_4496(void) {
    // 0x4496
    return g2;
}

// Address range: 0x44a8 - 0x44ca
int32_t function_44a8(void) {
    // 0x44a8
    int32_t v1; // bp+36
    _ZNK8CService14ToStringIPPortEv((int32_t)&v1);
    int32_t result;
    return result;
}

// Address range: 0x44e2 - 0x4573
int32_t function_44e2(void) {
    // 0x44e2
    _ZNK8CNetAddr6IsIPv4Ev(g8);
    int32_t * v1;
    if (((char)&v1 & (char)&v1) == 0) {
        // bb
        function_45d0();
        // branch -> 0x44f2
    }
    // 0x44f2
    int16_t v2; // bp+68
    int32_t v3 = &v2; // 0x44f7
    g4 = v3;
    int16_t * v4 = (int16_t *)&g10; // bp+28
    _ZNK8CService11GetSockAddrEP8sockaddrPj(g8, v3, (int32_t *)&v4);
    if (((char)&v1 & (char)&v1) == 0) {
        // bb20
        function_45a8();
        // branch -> 0x453c
    }
    // 0x453c
    if (v2 != 2) {
        // bb22
        function_45a8();
        // branch -> 0x4544
    }
    // 0x4544
    int32_t result;
    return result;
}

// Address range: 0x45a2 - 0x45a4
int32_t function_45a2(void) {
    // 0x45a2
    return function_45c1();
}

// Address range: 0x45a8 - 0x45bc
int32_t function_45a8(void) {
    // 0x45a8
    int32_t v1;
    int32_t result = v1; // 0x45b5
    if (v1 != -1) {
        // bb
        result = function_4669();
        // branch -> 0x45b5
    }
    // 0x45b5
    return result;
}

// Address range: 0x45c1 - 0x45d0
int32_t function_45c1(void) {
    int32_t v1 = g2; // 0x45c3
    int32_t result = v1; // 0x45cb
    if ((char)v1 != 0) {
        // bb
        result = function_4496();
        // branch -> 0x45cb
    }
    // 0x45cb
    return result;
}

// Address range: 0x45d0 - 0x45dc
int32_t function_45d0(void) {
    // 0x45d0
    int32_t v1;
    int32_t result = v1; // 0x45d9
    if (v1 == -1) {
        // bb
        result = function_45e9();
        // branch -> 0x45d9
    }
    // 0x45d9
    return result;
}

// Address range: 0x45e9 - 0x45f0
int32_t function_45e9(void) {
    // 0x45e9
    return g2;
}

// Address range: 0x45f5 - 0x45f7
int32_t function_45f5(void) {
    // 0x45f5
    return function_45c1();
}

// Address range: 0x4664 - 0x4669
int32_t function_4664(void) {
    // 0x4664
    return 0;
}

// Address range: 0x4669 - 0x466c
int32_t function_4669(void) {
    // 0x4669
    return g2;
}

// Address range: 0x4671 - 0x467e
int32_t function_4671(void) {
    // 0x4671
    return 0;
}

// Address range: 0x46a3 - 0x46a8
int32_t function_46a3(void) {
    // 0x46a3
    return function_45c1();
}

// Address range: 0x46d7 - 0x46dc
int32_t function_46d7(void) {
    // 0x46d7
    return function_4496();
}

// Address range: 0x46dc - 0x46e0
int32_t function_46dc(void) {
    // 0x46dc
    return g2;
}

// Address range: 0x46e5 - 0x46e6
int32_t function_46e5(void) {
    // 0x46e5
    return g2;
}

// Address range: 0x46f7 - 0x46f9
int32_t function_46f7(void) {
    // 0x46f7
    return function_46e5();
}

// Address range: 0x4722 - 0x4727
int32_t function_4722(void) {
    // 0x4722
    return function_44e2();
}

// Address range: 0x4727 - 0x4729
int32_t function_4727(void) {
    // 0x4727
    return function_46e5();
}

// Address range: 0x4729 - 0x4734
int32_t function_4729(void) {
    int32_t result = 0; // eax
    int32_t * v1 = (int32_t *)(result - 4); // 0x4729
    *v1 = *v1 - 1;
    return result;
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x4740 - 0x47a3
// Line range:    505 - 531
// Demangled:     ConnectSocketByName(CService &, unsigned int &, char const *, int, int)
bool _Z19ConnectSocketByNameR8CServiceRjPKcii(struct CService addr, int32_t hSocketRet, char * pszDest, int32_t portDefault, int32_t nTimeout) {
    // 0x4740
    return (uint32_t)(int32_t)pszDest % 2 != 0;
}

// Address range: 0x4822 - 0x4827
int32_t function_4822(void) {
    // 0x4822
    return function_b7104826();
}

// Address range: 0x486c - 0x486f
int32_t function_486c(int16_t a1) {
    // 0x486c
    return 0;
}

// Address range: 0x48a8 - 0x48a9
int32_t function_48a8(void) {
    // 0x48a8
    return 0;
}

// Address range: 0x48a9 - 0x48aa
int32_t function_48a9(void) {
    // 0x48a9
    return g2;
}

// Address range: 0x48b0 - 0x48d2
int32_t function_48b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)0x24948bd8; // 0x48b0
    uint32_t v2 = *v1; // 0x48b0
    int32_t v3 = v2 - 1; // 0x48b0
    unsigned char v4 = llvm_ctpop_i8((char)v3); // 0x48b0
    *v1 = v3;
    int32_t v5 = v4 % 2 == 0 ? 4 : 0; // 0x48b6
    int32_t v6 = v2 % 16 > 16 ? 16 : 0; // 0x48b6
    int32_t v7 = v3 == 0 ? 64 : 0; // 0x48b6
    int32_t v8 = (int32_t)false | v7 | v3 >> 31 & 128 | (v2 & -v2) / 0x80000000 & 2048 | v6 | v5 | 2; // bp-4
    int32_t v9 = 0; // eax
    *(char *)v9 = (char)v9 + *(char *)&g2;
    char * v10 = (char *)51; // 0x48b9
    unsigned char v11 = *v10; // 0x48b9
    unsigned char v12 = (char)(v9 / 256) + v11; // 0x48b9
    *v10 = v12;
    int32_t v13 = v12 < v11; // 0x48bc
    int32_t v14 = v9 + (int32_t)&g12 + v13; // 0x48bc
    g2 = v14;
    int32_t result = v14; // 0x48d1
    if (v14 != 0) {
        // bb
        result = function_49a3(v8);
        // branch -> 0x48c7
    }
    // 0x48c7
    return result;
}

// Address range: 0x48d8 - 0x4967
int32_t function_48d8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, uint16_t a8) {
    int32_t v1 = &a4; // 0x48d8
    CService10(v1, "0.0.0.0:0", false);
    *(int32_t *)g4 = a4;
    *(int32_t *)(g4 + 4) = a5;
    *(int32_t *)(g4 + 8) = a6;
    *(int32_t *)(g4 + (int32_t)&g53) = a7;
    g2 = a8;
    *(int16_t *)(g4 + (int32_t)&g10) = a8;
    g4 = 0;
    if (a3 == 0) {
        // bb
        function_48a9();
        // branch -> 0x492f
    }
    // 0x492f
    g5 = a1;
    int32_t v2; // bp+68
    g7 = &v2;
    int32_t v3; // bp+80
    g2 = &v3;
    bool v4 = ConnectSocketDirectly(v1, (int32_t)"0.0.0.0:0", 0); // 0x493b
    int32_t result = v4; // 0x493b
    g2 = result;
    if (!v4) {
        // 0x494b
        return function_48a9();
    }
    // 0x4944
    if (a3 == 5) {
        // 0x4958
        return result;
    }
    // 0x494b
    return function_48a9();
}

// Address range: 0x4985 - 0x49a3
int32_t function_4985(int32_t * a1, int32_t a2) {
    // 0x4985
    int32_t v1;
    if ((char)v1 == 0) {
        // bb
        function_48a9();
        // branch -> 0x498f
    }
    // 0x498f
    g2 = a2;
    *a1 = a2;
    return function_48a9();
}

// Address range: 0x49a3 - 0x49a4
int32_t function_49a3(int32_t a1) {
    // 0x49a3
    return g2;
}

// Address range: 0x49a9 - 0x49aa
int32_t function_49a9(void) {
    // 0x49a9
    return 0;
}

// Address range: 0x49b4 - 0x49b5
int32_t function_49b4(void) {
    // 0x49b4
    return g2;
}

// Address range: 0x49b5 - 0x49b6
int32_t function_49b5(void) {
    // 0x49b5
    return 0;
}

// Address range: 0x49b6 - 0x49b7
int32_t function_49b6(void) {
    // 0x49b6
    return g2;
}

// Address range: 0x49c6 - 0x49cc
int32_t function_49c6(void) {
    // 0x49c6
    return function_49b4();
}

// Address range: 0x49cc - 0x49ce
int32_t function_49cc(void) {
    // 0x49cc
    return function_49b4();
}

// Address range: 0x49da - 0x49dc
int32_t function_49da(void) {
    // 0x49da
    return function_49b6();
}

// From module:   /parallelcoin/src/netbase.cpp
// Address range: 0x49e0 - 0x4b5d
// Line range:    421 - 26
// Demangled:     SetProxy(Network, CService, int)
bool _Z8SetProxy7Network8CServicei(uint32_t net, struct CService_3 addrProxy, int32_t nSocksVersion) {
    int32_t v1 = addrProxy.e0;
    g8 = net;
    int32_t v2 = v1; // bp-112
    g2 = 0;
    int16_t v3;
    if (net >= 4) {
        // bb
        int32_t v4;
        int32_t v5;
        function_4ba1(v1, nSocksVersion, v5, v4, (int32_t)v3);
        // branch -> 0x4a5b
    }
    // 0x4a5b
    int32_t v6; // esi
    int32_t v7; // bp-84
    int32_t v8;
    int32_t * v9;
    if (v8 == 4) {
        // 0x4aa8
        if (v8 != 0) {
            // 0x4aac
            _ZNK8CNetAddr7IsValidEv((int32_t)&v2);
            if ((char)&v9 == 0) {
                // 0x4a70
                return false;
            }
        }
        // 0x4ac0
        g6 = &v7;
        v7 = &g19;
        _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(&v7);
        v6 = g8 * 8 * ((int32_t)&g16 + 1);
        *(int32_t *)(v6 + (int32_t)"tex_unlock(m)") = v2;
        *(int32_t *)(v6 + (int32_t)"unlock(m)") = nSocksVersion;
        *(int32_t *)(v6 + (int32_t)"ck(m)") = 0;
        *(int32_t *)(v6 + (int32_t)"thread_mutex_destroy(&m)") = (int32_t)v3;
        // branch -> 0x4a70
        // 0x4a70
        return true;
    }
    // 0x4a65
    int32_t v10; // ecx
    if (v8 == 0) {
        // 0x4ac0
        g6 = &v7;
        v7 = &g19;
        _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(&v7);
        v6 = g8 * 8 * ((int32_t)&g16 + 1);
        *(int32_t *)(v6 + (int32_t)"tex_unlock(m)") = v2;
        *(int32_t *)(v6 + (int32_t)"unlock(m)") = nSocksVersion;
        *(int32_t *)(v6 + (int32_t)"ck(m)") = v10;
        *(int32_t *)(v6 + (int32_t)"thread_mutex_destroy(&m)") = (int32_t)v3;
        // branch -> 0x4a70
        // 0x4a70
        return true;
    }
    bool result = false; // 0x4aa0
    if (v8 == 5) {
        // 0x4aac
        _ZNK8CNetAddr7IsValidEv((int32_t)&v2);
        if ((char)&v9 != 0) {
            // 0x4ac0
            g6 = &v7;
            v7 = &g19;
            _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(&v7);
            v6 = g8 * 8 * ((int32_t)&g16 + 1);
            *(int32_t *)(v6 + (int32_t)"tex_unlock(m)") = v2;
            *(int32_t *)(v6 + (int32_t)"unlock(m)") = nSocksVersion;
            *(int32_t *)(v6 + (int32_t)"ck(m)") = v10;
            *(int32_t *)(v6 + (int32_t)"thread_mutex_destroy(&m)") = (int32_t)v3;
            result = true;
            // branch -> 0x4a70
        } else {
            result = false;
        }
    }
    // 0x4a70
    return result;
}

// Address range: 0x4b8d - 0x4b9c
int32_t function_4b8d(void) {
    // 0x4b8d
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x47cc8a40); // 0x4b8d
    *v2 = *v2 + 1;
    int32_t result = 0; // eax
    *(int32_t *)result = 2 * result;
    char v3 = *(char *)&g2; // 0x4b95
    *(char *)result = (char)result + v3;
    return result;
}

// Address range: 0x4b9c - 0x4b9d
int32_t function_4b9c(void) {
    // 0x4b9c
    return g2;
}

// Address range: 0x4ba1 - 0x4bc0
int32_t function_4ba1(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4ba1
    return g2;
}

// Address range: 0x4bcb - 0x4bcc
int32_t function_4bcb(void) {
    // 0x4bcb
    return 0;
}

// From module:   /parallelcoin/src/netbase.h
// Address range: 0x4bf0 - 0x4c83
// Line range:    1102 - 98
// Demangled:     CService::GetKey() const
void _ZNK8CService6GetKeyEv(struct CService * this) {
    // 0x4bf0
    g8 = (int32_t)this;
    int32_t v1 = 0; // bp-17
    *(int32_t *)this = 0;
    *(int32_t *)(g8 + 4) = 0;
    *(int32_t *)(g8 + 8) = 0;
    _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(g8, 0, 18, (char *)&v1);
    int32_t v2 = *(int32_t *)g8; // 0x4c42
    *(int32_t *)v2 = *(int32_t *)g4;
    *(int32_t *)(v2 + 4) = *(int32_t *)(g4 + 4);
    *(int32_t *)(v2 + 8) = *(int32_t *)(g4 + 8);
    int32_t v3 = *(int32_t *)(g4 + (int32_t)&g53); // 0x4c54
    *(int32_t *)(v2 + (int32_t)&g53) = v3;
    char v4 = *(char *)(g4 + (int32_t)&g11); // 0x4c5c
    *(char *)(*(int32_t *)g8 + (int32_t)&g10) = v4;
    int32_t v5 = *(int32_t *)g8; // 0x4c63
    int16_t v6 = *(int16_t *)(g4 + (int32_t)&g10); // 0x4c65
    *(char *)(v5 + (int32_t)&g11) = (char)v6;
}

// Address range: 0x4c8b - 0x4c8c
int32_t function_4c8b(void) {
    // 0x4c8b
    return 0;
}

// Address range: 0x4cb0 - 0x4cda
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD1Ev(int32_t * a1) {
    // 0x4cb0
    *a1 = (int32_t)&g34;
    return 0;
}

// Address range: 0x5050 - 0x5075
// From class:    N5boost10lock_errorE
// Type:          virtual member function
// Demangled:     boost::lock_error::what() const
int32_t _ZNK5boost10lock_error4whatEv(void) {
    // 0x5050
    return (int32_t)"boost::lock_error";
}

// Address range: 0x5080 - 0x50a5
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::thread_resource_error::what() const
int32_t _ZNK5boost21thread_resource_error4whatEv(void) {
    // 0x5080
    return (int32_t)"boost::thread_resource_error";
}

// Address range: 0x50b0 - 0x50da
// Demangled:     boost::detail::sp_counted_base::~sp_counted_base()
int32_t _ZN5boost6detail15sp_counted_baseD1Ev(int32_t * a1) {
    // 0x50b0
    *a1 = (int32_t)&g49;
    return 0;
}

// Address range: 0x50e0 - 0x5130
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_base::destroy()
int32_t _ZN5boost6detail15sp_counted_base7destroyEv(int32_t * a1) {
    // 0x50e0
    if (a1 == NULL) {
        // 0x5118
        return 0;
    }
    // 0x50f8
    return *(int32_t *)(*a1 + 4);
}

// Address range: 0x5140 - 0x516a
// Demangled:     boost::system::error_category::~error_category()
int32_t _ZN5boost6system14error_categoryD1Ev(int32_t * a1) {
    // 0x5140
    *a1 = (int32_t)&g27;
    return 0;
}

// Address range: 0x5170 - 0x51a4
// Demangled:     boost::system::error_category::default_error_condition(int) const
int32_t _ZNK5boost6system14error_category23default_error_conditionEi(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t result = (int32_t)a1;
    *a1 = a3;
    *(int32_t *)(result + 4) = a2;
    return result;
}

// Address range: 0x51b0 - 0x520f
// Demangled:     boost::system::error_category::equivalent(int, boost::system::error_condition const &) const
int32_t _ZNK5boost6system14error_category10equivalentEiRKNS0_15error_conditionE(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t result = 0; // 0x520d
    int32_t v1;
    if (*(int32_t *)(a3 + 4) == v1) {
        // 0x5208
        int32_t v2;
        result = *(int32_t *)a3 == v2;
        // branch -> 0x51f4
    }
    // 0x51f4
    int32_t v3;
    if (v3 != 0x24848900) {
        // 0x520f
    }
    // 0x5201
    return result;
}

// Address range: 0x5220 - 0x525f
// Demangled:     boost::system::error_category::equivalent(boost::system::error_code const &, int) const
int32_t _ZNK5boost6system14error_category10equivalentERKNS0_10error_codeEi(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t result = 0; // 0x5252
    if (*(int32_t *)((int32_t)a2 + 4) == a1) {
        // 0x5258
        result = *a2 == a3;
        // branch -> 0x5241
    }
    // 0x5241
    return result;
}

// Address range: 0x5270 - 0x529a
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::~sp_counted_impl_p()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED1Ev(int32_t * a1) {
    // 0x5270
    *a1 = (int32_t)&g49;
    return 0;
}

// Address range: 0x52a0 - 0x52f5
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::dispose()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE7disposeEv(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g53); // 0x52b3
    if (v1 == 0) {
        // 0x52d8
        return 0;
    }
    // 0x52ba
    return *(int32_t *)(*(int32_t *)v1 + 4);
}

// Address range: 0x5300 - 0x5325
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::get_deleter(std::type_info const &)
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEE11get_deleterERKSt9type_info(void) {
    // 0x5300
    return 0;
}

// Address range: 0x5330 - 0x535e
// From class:    N5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEEE
// Type:          virtual member function
// Demangled:     boost::detail::sp_counted_impl_p<boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_> >::~sp_counted_impl_p()
int32_t _ZN5boost6detail17sp_counted_impl_pINS_16exception_detail10clone_implINS2_10bad_alloc_EEEED0Ev(int32_t * a1) {
    // 0x5330
    *a1 = (int32_t)&g49;
    return (int32_t)a1;
}

// Address range: 0x5363 - 0x5368
int32_t function_5363(int32_t a1) {
    // 0x5363
    return g2;
}

// Address range: 0x5370 - 0x539e
// Demangled:     boost::detail::sp_counted_base::~sp_counted_base()
int32_t _ZN5boost6detail15sp_counted_baseD0Ev(int32_t * a1) {
    // 0x5370
    *a1 = (int32_t)&g49;
    return (int32_t)a1;
}

// Address range: 0x53a3 - 0x53a8
int32_t function_53a3(int32_t a1) {
    // 0x53a3
    return g2;
}

// Address range: 0x53b0 - 0x53de
// Demangled:     boost::exception_detail::clone_base::~clone_base()
int32_t _ZN5boost16exception_detail10clone_baseD0Ev(int32_t * a1) {
    // 0x53b0
    *a1 = (int32_t)&g34;
    return (int32_t)a1;
}

// Address range: 0x53e3 - 0x53e4
int32_t function_53e3(int32_t a1) {
    // 0x53e3
    return g2;
}

// Address range: 0x53f0 - 0x541e
// Demangled:     boost::system::error_category::~error_category()
int32_t _ZN5boost6system14error_categoryD0Ev(int32_t * a1) {
    // 0x53f0
    *a1 = (int32_t)&g27;
    return (int32_t)a1;
}

// Address range: 0x5423 - 0x5424
int32_t function_5423(int32_t a1) {
    // 0x5423
    return g2;
}

// Address range: 0x5430 - 0x545e
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_exception::~thread_exception()
int32_t _ZN5boost16thread_exceptionD1Ev(int32_t * a1) {
    // 0x5430
    *a1 = (int32_t)&g29;
    return (int32_t)a1;
}

// Address range: 0x5463 - 0x5464
int32_t function_5463(int32_t a1) {
    // 0x5463
    return g2;
}

// Address range: 0x5470 - 0x5477
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(a1 - (int32_t)&g13); // 0x5475
    return result;
}

// Address range: 0x5480 - 0x549c
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE7rethrowEv(int32_t a1) {
    // 0x5480
    return 0;
}

// Address range: 0x54a2 - 0x54a3
int32_t function_54a2(void) {
    // 0x54a2
    return 0;
}

// Address range: 0x5b70 - 0x5b9e
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockC2EP15pthread_mutex_t_part_20(void) {
    // 0x5b70
    return 0;
}

// Address range: 0x5ba4 - 0x5bd2
int32_t _ZN5boost7pthread25pthread_mutex_scoped_lockD2Ev_part_21(void) {
    // 0x5ba4
    return 0;
}

// Address range: 0x5bd8 - 0x5c0b
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED2Ev_part_104(void) {
    // 0x5bd8
    return 0;
}

// Address range: 0x5c10 - 0x5c27
// Demangled:     AnnotatedMixin<boost::recursive_mutex>::~AnnotatedMixin()
int32_t _ZN14AnnotatedMixinIN5boost15recursive_mutexEED1Ev(int32_t a1) {
    // 0x5c10
    return 0;
}

// Address range: 0x5c2b - 0x5c32
int32_t function_5c2b(void) {
    // 0x5c2b
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 - 0x7cde8a40); // 0x5c2b
    *v2 = *v2 + 1;
    return 0;
}

// Address range: 0x5c3a - 0x5c51
int32_t function_5c3a(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x74c48a40; // 0x5c3a
    *v1 = *v1 + 1;
    int32_t v2 = 0x24848900; // 0x5c43
    g2 = v2;
    int32_t result = v2; // 0x5c50
    if (v2 != 0) {
        // bb
        result = function_5c75();
        // branch -> 0x5c4c
    }
    // 0x5c4c
    return result;
}

// Address range: 0x5c75 - 0x5c76
int32_t function_5c75(void) {
    // 0x5c75
    return g2;
}

// Address range: 0x5ca0 - 0x5cbd
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_resource_error::~thread_resource_error()
int32_t _ZN5boost21thread_resource_errorD0Ev(int32_t * a1) {
    // 0x5ca0
    *a1 = (int32_t)&g29;
    return 0;
}

// Address range: 0x5cc1 - 0x5cdc
int32_t function_5cc1(int32_t a1) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x5cc1
    *v1 = *v1 - 1;
    int32_t result = 0x24848900; // 0x5cc7
    if (result == 0) {
        // 0x5ccf
        // branch -> 0x5cdc
    }
    // 0x5cdc
    return result;
}

// Address range: 0x5cf0 - 0x5d31
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::lock_error::~lock_error()
int32_t _ZN5boost10lock_errorD0Ev(int32_t * a1) {
    // 0x5cf0
    *a1 = (int32_t)&g29;
    return 0;
}

// Address range: 0x5d40 - 0x5d6e
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_resource_error::~thread_resource_error()
int32_t _ZN5boost21thread_resource_errorD1Ev(int32_t * a1) {
    // 0x5d40
    *a1 = (int32_t)&g29;
    return (int32_t)a1;
}

// Address range: 0x5d73 - 0x5d78
int32_t function_5d73(int32_t a1) {
    // 0x5d73
    return g2;
}

// Address range: 0x5d80 - 0x5db8
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::lock_error::~lock_error()
int32_t _ZN5boost10lock_errorD1Ev(int32_t * a1) {
    // 0x5d80
    *a1 = (int32_t)&g29;
    return (int32_t)a1;
}

// Address range: 0x5dc0 - 0x5ddd
// From class:    N5boost16thread_exceptionE
// Type:          constructor
// Demangled:     boost::thread_exception::~thread_exception()
int32_t _ZN5boost16thread_exceptionD0Ev(int32_t * a1) {
    // 0x5dc0
    *a1 = (int32_t)&g29;
    return 0;
}

// Address range: 0x5e10 - 0x5e38
// From class:    N5boost6system12system_errorE
// Type:          constructor
// Demangled:     boost::system::system_error::~system_error()
int32_t _ZN5boost6system12system_errorD0Ev(int32_t * a1) {
    // 0x5e10
    *a1 = (int32_t)&g28;
    return (int32_t)a1 + (int32_t)&g10;
}

// Address range: 0x5e60 - 0x5e67
int32_t _ZThn24_NK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(a1 - (int32_t)&g13); // 0x5e65
    return result;
}

// Address range: 0x5e70 - 0x5e8c
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::clone() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_10bad_alloc_EE5cloneEv(int32_t a1) {
    // 0x5e70
    return 0;
}

// Address range: 0x5e90 - 0x5ee7
int32_t function_5e90(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 - 0x37ff383d); // 0x5e90
    *v2 = *v2 - 1;
    int32_t v3 = 0; // ebx
    char * v4 = (char *)(v3 - 0x3f7afbba); // 0x5e98
    char v5 = (char)v1 + *v4; // 0x5e98
    *v4 = v5;
    *(int32_t *)(v3 + 4) = 0;
    if (v5 != 0) {
        // 0x5ea3
        // branch -> 0x5eab
    }
    int32_t v6 = 0; // esi
    *(int32_t *)v3 = (int32_t)&g46;
    *(int32_t *)(v3 + 8) = *(int32_t *)(v6 + 8);
    int32_t v7 = *(int32_t *)(v6 + (int32_t)&g53); // 0x5ec2
    *(int32_t *)(v3 + (int32_t)&g53) = v7;
    int32_t v8 = *(int32_t *)(v6 + (int32_t)&g10); // 0x5ec8
    *(int32_t *)(v3 + (int32_t)&g12) = (int32_t)&g47;
    *(int32_t *)(v3 + (int32_t)&g13) = (int32_t)&g48;
    *(int32_t *)(v3 + (int32_t)&g10) = v8;
    int32_t result = v3 + (int32_t)&g13; // 0x5edc
    if (a1 != 0x24848900) {
        // 0x5ee7
        return result;
    }
    // 0x5ee1
    return result;
}

// Address range: 0x5f00 - 0x5f07
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2(a1 - (int32_t)&g15); // 0x5f05
    return result;
}

// Address range: 0x5f10 - 0x5f2c
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          virtual member function
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE5cloneEv2(int32_t a1) {
    // 0x5f10
    return 0;
}

// Address range: 0x5f30 - 0x5f94
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_5f30(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x4468bc3; // 0x5f30
    *v1 = *v1 - 1;
    int32_t v2 = 0; // ebx
    *(int32_t *)v2 = (int32_t)&g30;
    *(int32_t *)(v2 + 8) = (int32_t)&g31;
    *(int32_t *)(v2 + 4) = 0;
    int32_t v3 = 0; // esi
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g53); // 0x5f46
    *(int32_t *)(v2 + (int32_t)&g53) = v4;
    if (v4 != 0) {
        // 0x5f50
        // branch -> 0x5f58
    }
    int32_t v5 = *(int32_t *)(v3 + (int32_t)&g10); // 0x5f58
    *(int32_t *)(v2 + 8) = (int32_t)&g36;
    *(int32_t *)(v2 + (int32_t)&g10) = v5;
    int32_t v6 = *(int32_t *)(v3 + (int32_t)&g12); // 0x5f70
    *(int32_t *)(v2 + (int32_t)&g12) = v6;
    int32_t v7 = *(int32_t *)(v3 + (int32_t)&g13); // 0x5f76
    *(int32_t *)v2 = (int32_t)&g35;
    *(int32_t *)(v2 + (int32_t)&g15) = (int32_t)&g37;
    *(int32_t *)(v2 + (int32_t)&g13) = v7;
    int32_t result = v2 + (int32_t)&g15; // 0x5f89
    if (a1 != 0x24848900) {
        // 0x5f94
        return result;
    }
    // 0x5f8e
    return result;
}

// Address range: 0x5fc0 - 0x5fc7
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv(a1 - (int32_t)&g15); // 0x5fc5
    return result;
}

// Address range: 0x5fd0 - 0x5fec
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::thread_resource_error> >::clone() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE5cloneEv(int32_t a1) {
    // 0x5fd0
    return 0;
}

// Address range: 0x5ff0 - 0x6054
// From class:    N5boost21thread_resource_errorE
// Type:          constructor
int32_t function_5ff0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)0x4468bc3; // 0x5ff0
    *v1 = *v1 - 1;
    int32_t v2 = 0; // ebx
    *(int32_t *)v2 = (int32_t)&g38;
    *(int32_t *)(v2 + 8) = (int32_t)&g31;
    *(int32_t *)(v2 + 4) = 0;
    int32_t v3 = 0; // esi
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g53); // 0x6006
    *(int32_t *)(v2 + (int32_t)&g53) = v4;
    if (v4 != 0) {
        // 0x6010
        // branch -> 0x6018
    }
    int32_t v5 = *(int32_t *)(v3 + (int32_t)&g10); // 0x6018
    *(int32_t *)(v2 + 8) = (int32_t)&g42;
    *(int32_t *)(v2 + (int32_t)&g10) = v5;
    int32_t v6 = *(int32_t *)(v3 + (int32_t)&g12); // 0x6030
    *(int32_t *)(v2 + (int32_t)&g12) = v6;
    int32_t v7 = *(int32_t *)(v3 + (int32_t)&g13); // 0x6036
    *(int32_t *)v2 = (int32_t)&g41;
    *(int32_t *)(v2 + (int32_t)&g15) = (int32_t)&g43;
    *(int32_t *)(v2 + (int32_t)&g13) = v7;
    int32_t result = v2 + (int32_t)&g15; // 0x6049
    if (a1 != 0x24848900) {
        // 0x6054
        return result;
    }
    // 0x604e
    return result;
}

// Address range: 0x6080 - 0x60d6
// From class:    N5boost6system12system_errorE
// Type:          virtual member function
// Demangled:     boost::system::system_error::what() const
int32_t _ZNK5boost6system12system_error4whatEv(int32_t a1) {
    int32_t result = *(int32_t *)(a1 + (int32_t)&g10); // 0x609f
    if (*(int32_t *)(result - 12) == 0) {
        // 0x60d0
        return 0;
    }
    // 0x60a9
    return result;
}

// Address range: 0x60dd - 0x60e0
int32_t function_60dd(void) {
    // 0x60dd
    return 0;
}

// Address range: 0x60ff - 0x6100
int32_t function_60ff(void) {
    // 0x60ff
    return g2;
}

// Address range: 0x6130 - 0x6138
int32_t function_6130(void) {
    // 0x6130
    return 0;
}

// Address range: 0x6150 - 0x6152
int32_t function_6150(void) {
    // 0x6150
    return function_60ff();
}

// Address range: 0x6152 - 0x6153
int32_t function_6152(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x6152
    return g2;
}

// Address range: 0x6163 - 0x6164
int32_t function_6163(void) {
    // 0x6163
    return g2;
}

// Address range: 0x6174 - 0x6175
int32_t function_6174(void) {
    // 0x6174
    return 0;
}

// Address range: 0x617a - 0x617f
int32_t function_617a(void) {
    // 0x617a
    return 0;
}

// Address range: 0x6180 - 0x6182
int32_t function_6180(void) {
    // 0x6180
    return function_6163();
}

// Address range: 0x6183 - 0x6186
int32_t function_6183(void) {
    // 0x6183
    return 0;
}

// Address range: 0x61a0 - 0x6225
// Demangled:     boost::shared_ptr<boost::exception_detail::clone_base const>::~shared_ptr()
int32_t _ZN5boost10shared_ptrIKNS_16exception_detail10clone_baseEED1Ev(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x61bb
    if (v1 == 0) {
        // 0x61d3
        return 0;
    }
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x61c9
    int32_t v3 = *v2 - 1; // 0x61c9
    *v2 = v3;
    if (v3 != 0) {
        // 0x61d3
        return 0;
    }
    int32_t * v4 = (int32_t *)(v1 + 8); // 0x61f8
    int32_t v5 = *v4; // 0x61f8
    *v4 = v5 - 1;
    if (v5 == 1) {
        // 0x6202
        return *(int32_t *)(*(int32_t *)v1 + (int32_t)&g53);
    }
    // 0x61d3
    return 0;
}

// Address range: 0x6230 - 0x6280
// From class:    N5boost6system12system_errorE
// Type:          constructor
// Demangled:     boost::system::system_error::~system_error()
int32_t _ZN5boost6system12system_errorD1Ev(int32_t * a1) {
    int32_t result = *(int32_t *)((int32_t)a1 + (int32_t)&g10); // 0x624b
    *a1 = (int32_t)&g28;
    if (result != 12) {
        // 0x6280
        return result;
    }
    // 0x625f
    return 0;
}

// Address range: 0x62a5 - 0x62a7
int32_t function_62a5(void) {
    // 0x62a5
    return 0;
}

// Address range: 0x62a7 - 0x62a8
int32_t function_62a7(int32_t a1) {
    // 0x62a7
    return g2;
}

// Address range: 0x62ac - 0x62b7
int32_t function_62ac(void) {
    int32_t result = 0; // eax
    int32_t * v1 = (int32_t *)(result - 4); // 0x62ac
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x62c0 - 0x6311
// Demangled:     boost::exception::~exception()
int32_t _ZN5boost9exceptionD1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x62d4
    *a1 = (int32_t)&g31;
    if (v2 == 0) {
        // 0x62ed
        return 0;
    }
    // 0x62e1
    if ((char)v2 != 0) {
        // 0x6308
        *(int32_t *)(v1 + 4) = 0;
        // branch -> 0x62ed
    }
    // 0x62ed
    return 0;
}

// Address range: 0x6317 - 0x631a
int32_t function_6317(void) {
    // 0x6317
    return 0;
}

// Address range: 0x6330 - 0x633a
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D1Ev(int32_t a1) {
    // 0x6330
    return function_c670(a1 - (int32_t)&g12);
}

// Address range: 0x6340 - 0x6367
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::bad_alloc_::~bad_alloc_()
int32_t _ZN5boost16exception_detail10bad_alloc_D1Ev(int32_t * a1) {
    // 0x6340
    *a1 = (int32_t)&g44;
    int32_t result = (int32_t)a1 + (int32_t)&g12; // 0x635a
    *(int32_t *)result = (int32_t)&g45;
    return result;
}

// Address range: 0x636b - 0x6386
int32_t function_636b(int32_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x651c2444); // 0x636b
    *v2 = *v2 - 1;
    int32_t result = 0x24848900; // 0x6371
    g2 = result;
    if (result != 0) {
        // 0x6386
        return result;
    }
    // 0x6379
    return function_c600(v1);
}

// Address range: 0x6390 - 0x639a
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED1Ev(int32_t a1) {
    // 0x6390
    return function_c730(a1 - 8);
}

// Address range: 0x63a0 - 0x63e7
// From class:    N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::thread_resource_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g39;
    int32_t v2 = v1 + 8; // 0x63ba
    *(int32_t *)v2 = (int32_t)&g40;
    unknown_c660(v2);
    *(int32_t *)v1 = (int32_t)&g29;
    return 0;
}

// Address range: 0x63ec - 0x63ed
int32_t function_63ec(void) {
    // 0x63ec
    return g2;
}

// Address range: 0x6400 - 0x640a
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t a1) {
    // 0x6400
    return function_c810(a1 - 8);
}

// Address range: 0x6410 - 0x6457
// From class:    N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g32;
    int32_t v2 = v1 + 8; // 0x642a
    *(int32_t *)v2 = (int32_t)&g33;
    unknown_c6d0(v2);
    *(int32_t *)v1 = (int32_t)&g29;
    return 0;
}

// Address range: 0x645c - 0x645d
int32_t function_645c(void) {
    // 0x645c
    return g2;
}

// Address range: 0x6470 - 0x647a
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1) {
    // 0x6470
    return function_c900(a1 - (int32_t)&g13);
}

// Address range: 0x6480 - 0x648a
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t a1) {
    // 0x6480
    return function_c900(a1 - (int32_t)&g12);
}

// Address range: 0x6490 - 0x64be
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g13) = (int32_t)&g34;
    *(int32_t *)v1 = (int32_t)&g44;
    *(int32_t *)(v1 + (int32_t)&g12) = (int32_t)&g45;
    return v1 + (int32_t)&g12;
}

// Address range: 0x64c2 - 0x64e2
int32_t function_64c2(int32_t a1) {
    int32_t v1 = 0; // ebx
    int32_t * v2 = (int32_t *)(v1 + 0x651c2444); // 0x64c2
    *v2 = *v2 - 1;
    int32_t result = 0x24848900; // 0x64c8
    g2 = result;
    if (result != 0) {
        // 0x64dd
        return result;
    }
    // 0x64d0
    return function_c750(v1);
}

// Address range: 0x64f0 - 0x64f7
int32_t _ZThn24_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev((int32_t *)(a1 - (int32_t)&g13)); // 0x64f5
    return result;
}

// Address range: 0x6500 - 0x6507
int32_t _ZThn20_N5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev((int32_t *)(a1 - (int32_t)&g12)); // 0x6505
    return result;
}

// Address range: 0x6510 - 0x653e
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::bad_alloc_>::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_10bad_alloc_EED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g13) = (int32_t)&g34;
    *(int32_t *)v1 = (int32_t)&g44;
    *(int32_t *)(v1 + (int32_t)&g12) = (int32_t)&g45;
    return v1 + (int32_t)&g12;
}

// Address range: 0x6570 - 0x6577
int32_t _ZThn20_N5boost16exception_detail10bad_alloc_D0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10bad_alloc_D0Ev((int32_t *)(a1 - (int32_t)&g12)); // 0x6575
    return result;
}

// Address range: 0x6580 - 0x65a7
// From class:    N5boost16exception_detail10bad_alloc_E
// Type:          constructor
// Demangled:     boost::exception_detail::bad_alloc_::~bad_alloc_()
int32_t _ZN5boost16exception_detail10bad_alloc_D0Ev(int32_t * a1) {
    // 0x6580
    *a1 = (int32_t)&g44;
    int32_t result = (int32_t)a1 + (int32_t)&g12; // 0x659a
    *(int32_t *)result = (int32_t)&g45;
    return result;
}

// Address range: 0x65ab - 0x65ce
int32_t function_65ab(int32_t a1) {
    int32_t v1 = 0; // ecx
    int32_t * v2 = (int32_t *)(v1 + 0x7ce8241c); // 0x65ab
    *v2 = *v2 - 1;
    char * v3 = (char *)0x651c2444; // 0x65b3
    *v3 = (char)v1 + *v3;
    int32_t result = 0x24848900; // 0x65b9
    if (result == 0) {
        // 0x65c1
        // branch -> 0x65ce
    }
    // 0x65ce
    return result;
}

// Address range: 0x65e0 - 0x65e7
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev((int32_t *)(a1 - (int32_t)&g15)); // 0x65e5
    return result;
}

// Address range: 0x65f0 - 0x65f7
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t a1) {
    // 0x65f0
    return _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev((int32_t *)(a1 - 8));
}

// Address range: 0x6600 - 0x6656
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g15) = (int32_t)&g34;
    *(int32_t *)v1 = (int32_t)&g32;
    *(int32_t *)(v1 + 8) = (int32_t)&g33;
    unknown_c8a0(v1 + 8);
    *(int32_t *)v1 = (int32_t)&g29;
    return 0;
}

// Address range: 0x665b - 0x665c
int32_t function_665b(int32_t a1) {
    // 0x665b
    return g2;
}

// Address range: 0x6660 - 0x666a
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1) {
    // 0x6660
    return function_cce0(a1 - (int32_t)&g15);
}

// Address range: 0x6670 - 0x667a
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t a1) {
    // 0x6670
    return function_cce0(a1 - 8);
}

// Address range: 0x6680 - 0x66ce
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g15) = (int32_t)&g34;
    *(int32_t *)v1 = (int32_t)&g32;
    *(int32_t *)(v1 + 8) = (int32_t)&g33;
    unknown_c940(v1 + 8);
    *(int32_t *)v1 = (int32_t)&g29;
    return 0;
}

// Address range: 0x66d3 - 0x66d4
int32_t function_66d3(void) {
    // 0x66d3
    return g2;
}

// Address range: 0x66e0 - 0x66e7
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t a1) {
    // 0x66e0
    return _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev((int32_t *)(a1 - 8));
}

// Address range: 0x66f0 - 0x6725
// From class:    N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g32;
    int32_t v2 = v1 + 8; // 0x670a
    *(int32_t *)v2 = (int32_t)&g33;
    int32_t result = unknown_c9a0(v2); // eax
    *(int32_t *)v1 = (int32_t)&g29;
    return result;
}

// Address range: 0x6750 - 0x6757
int32_t _ZThn8_N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev(int32_t a1) {
    // 0x6750
    return _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev((int32_t *)(a1 - 8));
}

// Address range: 0x6760 - 0x67af
// From class:    N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::thread_resource_error>::~error_info_injector()
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = (int32_t)&g39;
    int32_t v2 = v1 + 8; // 0x677a
    *(int32_t *)v2 = (int32_t)&g40;
    unknown_ca10(v2);
    *(int32_t *)v1 = (int32_t)&g29;
    return 0;
}

// Address range: 0x67b4 - 0x67b5
int32_t function_67b4(int32_t a1) {
    // 0x67b4
    return g2;
}

// Address range: 0x67c0 - 0x67ca
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t a1) {
    // 0x67c0
    return function_cfa0(a1 - (int32_t)&g15);
}

// Address range: 0x67d0 - 0x67da
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t a1) {
    // 0x67d0
    return function_cfa0(a1 - 8);
}

// Address range: 0x67e0 - 0x6838
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::thread_resource_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED1Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g15) = (int32_t)&g34;
    *(int32_t *)v1 = (int32_t)&g39;
    *(int32_t *)(v1 + 8) = (int32_t)&g40;
    unknown_caa0(v1 + 8);
    *(int32_t *)v1 = (int32_t)&g29;
    return 0;
}

// Address range: 0x6840 - 0x6847
int32_t _ZThn28_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t a1) {
    int32_t result = _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev((int32_t *)(a1 - (int32_t)&g15)); // 0x6845
    return result;
}

// Address range: 0x6850 - 0x6857
int32_t _ZThn8_N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t a1) {
    // 0x6850
    return _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev((int32_t *)(a1 - 8));
}

// Address range: 0x6860 - 0x68b6
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::thread_resource_error> >::~clone_impl()
int32_t _ZN5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEED0Ev(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + (int32_t)&g15) = (int32_t)&g34;
    *(int32_t *)v1 = (int32_t)&g39;
    *(int32_t *)(v1 + 8) = (int32_t)&g40;
    unknown_cb00(v1 + 8);
    *(int32_t *)v1 = (int32_t)&g29;
    return 0;
}

// Address range: 0x68bb - 0x68bc
int32_t function_68bb(int32_t a1) {
    // 0x68bb
    return g2;
}

// Address range: 0x68c0 - 0x68f1
// Demangled:     boost::exception::~exception()
int32_t _ZN5boost9exceptionD0Ev(int32_t a1) {
    // 0x68c0
    unknown_cb80(a1);
    return 0;
}

// Address range: 0x68f6 - 0x68fb
int32_t function_68f6(void) {
    // 0x68f6
    return g2;
}

// Address range: 0x6900 - 0x6920
// Demangled:     myclosesocket(unsigned int &)
int32_t _Z13myclosesocketRj(int32_t * a1) {
    // 0x6900
    g2 = (int32_t)&g52;
    int32_t result = (int32_t)&g52; // 0x691d
    if (*a1 == -1) {
        // bb
        result = function_692b(0x24848900);
        // branch -> 0x691d
    }
    // 0x691d
    return result;
}

// Address range: 0x692b - 0x6942
int32_t function_692b(int32_t a1) {
    // 0x692b
    if (a1 != 0x24848900) {
        // 0x693d
        return g2;
    }
    // 0x6938
    return g2;
}

// Address range: 0x6da0 - 0x6de5
// Demangled:     boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr()
int32_t _ZN5boost16exception_detail12refcount_ptrINS0_20error_info_containerEED1Ev(int32_t * a1) {
    int32_t v1 = *a1; // 0x6db4
    if (v1 == 0) {
        // 0x6dc6
        return 0;
    }
    // 0x6dba
    if ((char)v1 != 0) {
        // 0x6dd8
        *a1 = 0;
        // branch -> 0x6dc6
    }
    // 0x6dc6
    return 0;
}

// Address range: 0x6df0 - 0x6ef4
// Demangled:     boost::exception_detail::copy_boost_exception(boost::exception *, boost::exception const *)
int32_t _ZN5boost16exception_detail20copy_boost_exceptionEPNS_9exceptionEPKS1_(int32_t a1, int32_t a2) {
    // 0x6df0
    if (*(int32_t *)(a2 + 4) != 0) {
        // 0x6e2a
        int32_t v1;
        if (v1 != 0) {
            // 0x6e49
            // branch -> 0x6e51
        }
        // 0x6e51
        // branch -> 0x6e79
    }
    int32_t v2 = 0; // edi
    int32_t v3 = *(int32_t *)(a2 + (int32_t)&g53); // 0x6e79
    *(int32_t *)(a1 + (int32_t)&g53) = v3;
    int32_t v4 = *(int32_t *)(a2 + (int32_t)&g10); // 0x6e7f
    *(int32_t *)(a1 + (int32_t)&g10) = v4;
    *(int32_t *)(a1 + 8) = *(int32_t *)(a2 + 8);
    int32_t v5 = *(int32_t *)(a1 + 4); // 0x6e8b
    if (v5 != 0) {
        // 0x6e92
        *(int32_t *)g9 = v5;
        // branch -> 0x6e9a
    }
    // 0x6e9a
    *(int32_t *)(a1 + 4) = v2;
    if (v2 != 0) {
        // 0x6ea1
        *(int32_t *)g9 = v2;
        // branch -> 0x6ea9
    }
    int32_t v6 = *(int32_t *)(g9 + (int32_t)&g12); // 0x6ea9
    if (v6 != 0) {
        // 0x6eb1
        *(int32_t *)g9 = v6;
        // branch -> 0x6eb9
    }
    int32_t result = *(int32_t *)(g9 + (int32_t)&g15) ^ 0x24848900; // 0x6ebd
    if (result != 0) {
        // 0x6ef4
        return result;
    }
    // 0x6ec6
    return result;
}

// Address range: 0x6efa - 0x6efb
int32_t function_6efa(void) {
    // 0x6efa
    return 0;
}

// Address range: 0x6f03 - 0x6f04
int32_t function_6f03(void) {
    // 0x6f03
    return g2;
}

// Address range: 0x6f17 - 0x6f1b
int32_t function_6f17(void) {
    // 0x6f17
    return function_6f03();
}

// Address range: 0x6f20 - 0x6f90
// From class:    N5boost21thread_resource_errorE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::thread_resource_error>::error_info_injector(boost::exception_detail::error_info_injector<boost::thread_resource_error> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEC1ERKS3_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1; // ebx
    *a1 = (int32_t)&g38;
    *(int32_t *)(v1 + 8) = (int32_t)&g31;
    *(int32_t *)(v1 + 4) = *(int32_t *)(a2 + 4);
    int32_t v2 = *(int32_t *)(a2 + (int32_t)&g53); // 0x6f4c
    *(int32_t *)(v1 + (int32_t)&g53) = v2;
    if (v2 != 0) {
        // 0x6f56
        // branch -> 0x6f5e
    }
    int32_t v3 = *(int32_t *)(a2 + (int32_t)&g10); // 0x6f5e
    *(int32_t *)(v1 + 8) = (int32_t)&g40;
    *(int32_t *)(v1 + (int32_t)&g10) = v3;
    int32_t v4 = *(int32_t *)(a2 + (int32_t)&g12); // 0x6f6b
    *(int32_t *)(v1 + (int32_t)&g12) = v4;
    int32_t v5 = *(int32_t *)(a2 + (int32_t)&g13); // 0x6f71
    *(int32_t *)v1 = (int32_t)&g39;
    *(int32_t *)(v1 + (int32_t)&g13) = v5;
    return 0;
}

// Address range: 0x6fb0 - 0x6fb7
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv(a1 - (int32_t)&g15); // 0x6fb5
    return result;
}

// Address range: 0x6fc0 - 0x7020
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
// Type:          constructor
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::thread_resource_error> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEE7rethrowEv(int32_t a1) {
    int32_t result = unknown_ded0(0, a1); // 0x6fea
    *NULL = 0;
    *(int32_t *)8 = (int32_t)&g42;
    g15 = &g43;
    return result;
}

// Address range: 0x7030 - 0x704c
// Demangled:     void boost::throw_exception<boost::thread_resource_error>(boost::thread_resource_error const &)
int32_t _ZN5boost15throw_exceptionINS_21thread_resource_errorEEEvRKT_(int32_t a1) {
    // 0x7030
    return 0;
}

// Address range: 0x7070 - 0x707b
int32_t function_7070(void) {
    // 0x7070
    return -0x76ffff7b;
}

// Address range: 0x70e1 - 0x70e2
int32_t function_70e1(void) {
    // 0x70e1
    return g2;
}

// Address range: 0x7100 - 0x711a
int32_t function_7100(int32_t a1) {
    int32_t v1 = 0; // ecx
    char * v2 = (char *)(v1 - 0x76e3dbbc); // 0x7107
    *v2 = *v2 + (char)v1;
    unknown_d3d0();
    g2 = a1;
    return function_70e1();
}

// Address range: 0x7120 - 0x713f
// Demangled:     boost::recursive_mutex::recursive_mutex()
int32_t _ZN5boost15recursive_mutexC1Ev(int32_t a1) {
    // 0x7120
    return 0;
}

// Address range: 0x715e - 0x7184
int32_t function_715e(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x74da8a40; // 0x715e
    *v1 = *v1 + 1;
    int32_t v2 = 0x24848900; // 0x7167
    g2 = v2;
    int32_t v3 = 0; // ebx
    *(char *)(v3 + 72) = 0;
    *(int32_t *)(v3 + (int32_t)&g22) = 0;
    int32_t result; // 0x7183
    if (v2 != 0) {
        // bb
        result = function_720a();
        // branch -> 0x717f
    } else {
        // 0x715e
        result = g2;
        // branch -> 0x717f
    }
    // 0x717f
    return result;
}

// Address range: 0x71d4 - 0x71d5
int32_t function_71d4(void) {
    // 0x71d4
    return g2;
}

// Address range: 0x71eb - 0x720a
// From class:    N5boost21thread_resource_errorE
// Type:          constructor
int32_t function_71eb(void) {
    int32_t * v1 = (int32_t *)-0x38d3dba4; // 0x71eb
    *v1 = *v1 - 1;
    int32_t v2 = 0; // eax
    unsigned char v3 = (char)v2 & (char)&g17; // 0x71f2
    int32_t v4 = (int32_t)v3 | v2 & -256; // 0x71f2
    v2 = v4;
    char * v5 = (char *)v4; // 0x71f4
    *v5 = *v5 + v3;
    char * v6 = (char *)v2; // 0x71f6
    *v6 = *v6 + (char)v2;
    g2 = unknown_e150(0);
    return function_71d4();
}

// Address range: 0x720a - 0x720b
int32_t function_720a(void) {
    // 0x720a
    return g2;
}

// Address range: 0x7210 - 0x7280
// From class:    N5boost10lock_errorE
// Type:          constructor
// Demangled:     boost::exception_detail::error_info_injector<boost::lock_error>::error_info_injector(boost::exception_detail::error_info_injector<boost::lock_error> const &)
int32_t _ZN5boost16exception_detail19error_info_injectorINS_10lock_errorEEC1ERKS3_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1; // ebx
    *a1 = (int32_t)&g30;
    *(int32_t *)(v1 + 8) = (int32_t)&g31;
    *(int32_t *)(v1 + 4) = *(int32_t *)(a2 + 4);
    int32_t v2 = *(int32_t *)(a2 + (int32_t)&g53); // 0x723c
    *(int32_t *)(v1 + (int32_t)&g53) = v2;
    if (v2 != 0) {
        // 0x7246
        // branch -> 0x724e
    }
    int32_t v3 = *(int32_t *)(a2 + (int32_t)&g10); // 0x724e
    *(int32_t *)(v1 + 8) = (int32_t)&g33;
    *(int32_t *)(v1 + (int32_t)&g10) = v3;
    int32_t v4 = *(int32_t *)(a2 + (int32_t)&g12); // 0x725b
    *(int32_t *)(v1 + (int32_t)&g12) = v4;
    int32_t v5 = *(int32_t *)(a2 + (int32_t)&g13); // 0x7261
    *(int32_t *)v1 = (int32_t)&g32;
    *(int32_t *)(v1 + (int32_t)&g13) = v5;
    return 0;
}

// Address range: 0x72a0 - 0x72a7
int32_t _ZThn28_NK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1) {
    int32_t result = _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(a1 - (int32_t)&g15); // 0x72a5
    return result;
}

// Address range: 0x72b0 - 0x72cc
// From class:    N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
// Type:          virtual member function
// Demangled:     boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error> >::rethrow() const
int32_t _ZNK5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEE7rethrowEv(int32_t a1) {
    // 0x72b0
    return 0;
}

// Address range: 0x72d0 - 0x72d7
int32_t function_72d0(void) {
    int32_t * v1 = (int32_t *)-0x76fbdb8c; // 0x72d0
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x7320 - 0x733c
// Demangled:     void boost::throw_exception<boost::lock_error>(boost::lock_error const &)
int32_t _ZN5boost15throw_exceptionINS_10lock_errorEEEvRKT_(int32_t a1) {
    // 0x7320
    return 0;
}

// Address range: 0x736a - 0x736b
int32_t function_736a(void) {
    // 0x736a
    return 0;
}

// Address range: 0x73d1 - 0x73d2
int32_t function_73d1(void) {
    // 0x73d1
    return g2;
}

// Address range: 0x73f0 - 0x740a
int32_t function_73f0(int32_t a1) {
    int32_t v1 = 0; // ecx
    char * v2 = (char *)(v1 - 0x76e3dbbc); // 0x73f7
    *v2 = *v2 + (char)v1;
    unknown_d730();
    g2 = a1;
    return function_73d1();
}

// Address range: 0x7410 - 0x74dc
// From class:    N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
// Type:          constructor
int32_t _ZN5boost16exception_detail13get_bad_allocILi42EEENS_10shared_ptrIKNS0_10clone_baseEEEv(int32_t * a1) {
    // 0x74b9
    g2 = 0;
    function_7530((int32_t)&g46, 0, (int32_t)"boost::exception_ptr boost::exception_detail::get_bad_alloc() [with int Dummy = 42, boost::exception_ptr = boost::shared_ptr<const boost::exception_detail::clone_base>]", (int32_t)"/usr/include/boost/exception/detail/exception_ptr.hpp", 81, (int32_t)&g47, (int32_t)&g48, (int32_t)&g44, 0, 0, 0, -1, (int32_t)&g45, 0, 0x24848900, 0, 0);
    *a1 = 0;
    *(int32_t *)((int32_t)a1 + 4) = (int32_t)&g50;
    *(int32_t *)&g51 = (int32_t)"N5boost6detail15sp_counted_baseE" + 1;
    int32_t v1; // bp-52
    return &v1;
}

// Address range: 0x7508 - 0x752c
int32_t function_7508(int32_t a1, int32_t a2, int32_t a3, int32_t result, int32_t a5, int32_t a6, char * a7, int32_t a8, int32_t a9, int32_t a10) {
    int32_t * v1 = (int32_t *)-0x4017dbcc; // 0x7508
    *v1 = *v1 - 1;
    *a7 = *a7 + (char)(int32_t)a7;
    g2 = result;
    if (a8 != 0x24848900) {
        // bb
        result = function_75fb();
        // branch -> 0x7524
    }
    // 0x7524
    return result;
}

// Address range: 0x7530 - 0x7537
int32_t function_7530(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17) {
    // 0x7530
    return g2;
}

// Address range: 0x75f6 - 0x75fb
int32_t function_75f6(void) {
    // 0x75f6
    return 0;
}

// Address range: 0x75fb - 0x75fc
int32_t function_75fb(void) {
    // 0x75fb
    return g2;
}

// Address range: 0x7616 - 0x7617
int32_t function_7616(void) {
    // 0x7616
    return 0;
}

// Address range: 0x761f - 0x7620
int32_t function_761f(void) {
    // 0x761f
    return g2;
}

// Address range: 0x764a - 0x7651
int32_t function_764a(void) {
    int32_t * v1 = (int32_t *)-0x762f143d; // 0x764a
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x7656 - 0x7658
int32_t function_7656(void) {
    // 0x7656
    return function_761f();
}

// Address range: 0x7660 - 0x76b8
int32_t _ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_S8_(int32_t result, int32_t a2, int32_t a3) {
    // 0x7660
    return result;
}

// Address range: 0x76d0 - 0x78a5
// Demangled:     std::vector<CNetAddr, std::allocator<CNetAddr> >::_M_insert_aux(__gnu_cxx::__normal_iterator<CNetAddr *, std::vector<CNetAddr, std::allocator<CNetAddr> > >, CNetAddr const &)
int32_t _ZNSt6vectorI8CNetAddrSaIS0_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS0_S2_EERKS0_(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    g8 = v1;
    g4 = a2;
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x76ef
    int32_t v3; // ecx
    int32_t v4; // edi
    int32_t v5; // 0x7812
    if (v2 == *(int32_t *)(v1 + 8)) {
        int32_t v6 = *a1; // 0x77b0
        g7 = v6;
        int32_t v7 = v2 - v6; // 0x77b2
        int32_t v8 = v7 / 16; // 0x77b4
        g2 = v8;
        if (v7 < 16) {
            int32_t v9 = function_78c3(0x24848900); // 0x77b9
            g2 = v9;
            v8 = v9;
            // branch -> 0x77bf
        }
        int32_t v10 = v8; // 0x77ef
        if (v8 < 2 * v8 | -1 * v8 == 0) {
            int32_t v11 = function_78d7(); // 0x77c4
            g2 = v11;
            v10 = v11;
            // branch -> 0x77ca
        }
        int32_t v12 = g4 - g7; // 0x77cc
        int32_t v13 = v12 - v12 % 16 + v10; // 0x77ef
        int32_t v14 = g4; // 0x780c
        if (v13 != 0) {
            // 0x77f3
            v4 = 0;
            *(int32_t *)v13 = *(int32_t *)v4;
            *(int32_t *)(v13 + 4) = *(int32_t *)(v4 + 4);
            *(int32_t *)(v13 + 8) = *(int32_t *)(v4 + 8);
            int32_t v15 = *(int32_t *)(v4 + (int32_t)&g53); // 0x7804
            *(int32_t *)(v13 + (int32_t)&g53) = v15;
            v14 = g4;
            // branch -> 0x780a
        }
        int32_t v16 = *(int32_t *)g8; // 0x780a
        int32_t v17 = v14; // 0x7859
        int32_t v18 = v10 + (int32_t)&g10;
        if (v16 != v14) {
            // 0x7810
            v3 = v16;
            v5 = g2;
            int32_t v19 = v16; // 0x781c
            // branch -> 0x7818
            int32_t v20; // 0x783f
            while (true) {
                // 0x7818
                v20 = v14;
                int32_t v21 = 0; // 0x7835
                int32_t v22 = v19; // 0x7832
                if (v5 != 0) {
                    // 0x781c
                    *(int32_t *)v5 = *(int32_t *)v19;
                    *(int32_t *)(v5 + 4) = *(int32_t *)(v3 + 4);
                    *(int32_t *)(v5 + 8) = *(int32_t *)(v3 + 8);
                    int32_t v23 = *(int32_t *)(v3 + (int32_t)&g53); // 0x782c
                    *(int32_t *)(v5 + (int32_t)&g53) = v23;
                    v20 = g4;
                    v21 = v5;
                    v22 = v3;
                    // branch -> 0x7832
                }
                int32_t v24 = v22 + (int32_t)&g10; // 0x7832
                v3 = v24;
                if (v24 == v20) {
                    // break -> 0x783c
                    break;
                }
                v14 = v20;
                v19 = v24;
                v5 = v21 + (int32_t)&g10;
                // continue -> 0x7818
            }
            // 0x783c
            v17 = v20;
            v18 = (v20 - (v16 + (int32_t)&g10) + 32 & -16) + g2;
            // branch -> 0x784e
        }
        int32_t v25 = *(int32_t *)(g8 + 4); // 0x784e
        if (v25 != v17) {
            // 0x7855
            v5 = v18;
            v3 = v17;
            int32_t v26 = v25; // 0x788022
            // branch -> 0x7860
            while (true) {
                int32_t v27 = v26; // 0x788b
                int32_t v28 = 0; // 0x787d
                int32_t v29 = v17; // 0x787a
                if (v18 != 0) {
                    // 0x7864
                    *(int32_t *)v18 = *(int32_t *)v17;
                    *(int32_t *)(v5 + 4) = *(int32_t *)(v3 + 4);
                    *(int32_t *)(v5 + 8) = *(int32_t *)(v3 + 8);
                    int32_t v30 = *(int32_t *)(v3 + (int32_t)&g53); // 0x7874
                    *(int32_t *)(v5 + 12) = v30;
                    v27 = v25;
                    v28 = v5;
                    v29 = v3;
                    // branch -> 0x787a
                }
                int32_t v31 = v29 + (int32_t)&g10; // 0x787a
                v3 = v31;
                int32_t v32 = v28 + 16; // 0x787d
                v5 = v32;
                if (v27 == v31) {
                    // break -> 0x7884
                    break;
                }
                v26 = v27;
                v17 = v31;
                v18 = v32;
                // continue -> 0x7860
            }
            // 0x7884
            // branch -> 0x7898
        }
        // 0x7898
        int32_t result; // 0x78a2
        if (*(int32_t *)g8 == 0) {
            // bb51
            result = function_78ae();
            // branch -> 0x789e
        } else {
            // 0x7898
            result = g2;
            // branch -> 0x789e
        }
        // 0x789e
        return result;
    }
    // 0x76fb
    v5 = 0;
    int32_t v33 = (int32_t)&g10; // 0x771b
    if (v2 != 0) {
        // 0x7701
        *(int32_t *)v2 = *(int32_t *)(v2 - 16);
        *(int32_t *)(v2 + 4) = *(int32_t *)(v2 - 12);
        *(int32_t *)(v2 + 8) = *(int32_t *)(v2 - 8);
        int32_t v34 = *(int32_t *)(v2 - 4); // 0x7712
        *(int32_t *)(v2 + (int32_t)&g53) = v34;
        int32_t v35 = *(int32_t *)(g8 + 4); // 0x7718
        v5 = v35;
        v1 = g8;
        v33 = v35 + (int32_t)&g10;
        // branch -> 0x771b
    }
    // 0x771b
    *(int32_t *)(v1 + 4) = v33;
    int32_t v36 = *(int32_t *)v4; // 0x7721
    int32_t v37 = v5 - 16; // 0x7723
    v3 = v37;
    int32_t v38 = v37 - g4; // 0x7728
    int32_t v39 = *(int32_t *)(v4 + 4); // 0x7731
    int32_t v40 = *(int32_t *)(v4 + 8); // 0x773a
    int32_t v41 = *(int32_t *)(v4 + (int32_t)&g53); // 0x7741
    if (v38 < 16) {
        // 0x7778
        *(int32_t *)g4 = v36;
        *(int32_t *)(g4 + 4) = v39;
        *(int32_t *)(g4 + 8) = v40;
        *(int32_t *)(g4 + (int32_t)&g53) = v41;
        return 0;
    }
    int32_t v42 = 0; // eax
    int32_t v43 = v38 / 16; // esi
    int32_t v44 = 0; // 0x7754
    // branch -> 0x7750
    while (true) {
        // 0x7750
        *(int32_t *)(v5 - 16 + v44) = *(int32_t *)(v44 - 16 + v37);
        int32_t v45 = v42; // 0x7758
        int32_t v46 = *(int32_t *)(v3 - 12 + v45); // 0x7758
        *(int32_t *)(v45 - 12 + v5) = v46;
        int32_t v47 = v42; // 0x7760
        int32_t v48 = *(int32_t *)(v3 - 8 + v47); // 0x7760
        *(int32_t *)(v47 - 8 + v5) = v48;
        int32_t v49 = v42; // 0x7768
        int32_t v50 = *(int32_t *)(v3 - 4 + v49); // 0x7768
        *(int32_t *)(v49 - 4 + v5) = v50;
        int32_t v51 = v42 - (int32_t)&g10; // 0x7770
        v42 = v51;
        int32_t v52 = v43 - 1; // 0x7773
        v43 = v52;
        if (v52 == 0) {
            // 0x7778
            // branch -> 0x7778
            // 0x7778
            *(int32_t *)g4 = v36;
            *(int32_t *)(g4 + 4) = v39;
            *(int32_t *)(g4 + 8) = v40;
            *(int32_t *)(g4 + (int32_t)&g53) = v41;
            return 0;
        }
        // 0x7750
        v44 = v51;
        v37 = v3;
        // branch -> 0x7750
    }
}

// Address range: 0x78ae - 0x78c3
int32_t function_78ae(void) {
    // 0x78ae
    *(int32_t *)g8 = g2;
    int32_t v1;
    int32_t result = g2 + v1; // eax
    *(int32_t *)(g8 + 4) = 0;
    *(int32_t *)(g8 + 8) = result;
    return result;
}

// Address range: 0x78c3 - 0x78d7
int32_t function_78c3(int32_t a1) {
    // 0x78c3
    return g2;
}

// Address range: 0x78d7 - 0x7908
int32_t function_78d7(void) {
    // 0x78d7
    return 0;
}

// Address range: 0x7908 - 0x790d
int32_t function_7908(void) {
    // 0x7908
    return g2;
}

// Address range: 0x7910 - 0x7961
// Demangled:     boost::unique_lock<AnnotatedMixin<boost::recursive_mutex> >::~unique_lock()
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEED1Ev(int32_t * a1) {
    // 0x7910
    if (*(char *)((int32_t)a1 + 4) == 0) {
        // 0x792b
        return 0;
    }
    int32_t v1 = *a1; // 0x7940
    g4 = v1;
    int32_t v2 = v1; // 0x7956
    if (a1 != NULL) {
        // bb
        function_798b(v1);
        v2 = g4;
        // branch -> 0x794e
    }
    int32_t * v3 = (int32_t *)(v2 + (int32_t)&g22); // 0x794e
    int32_t v4 = *v3 - 1; // 0x7951
    g2 = v4;
    *v3 = v4;
    if (v4 == 0) {
        // bb106
        function_7980();
        // branch -> 0x795b
    }
    // 0x795b
    return g4 + (int32_t)&g13;
}

// Address range: 0x7980 - 0x7986
int32_t function_7980(void) {
    // 0x7980
    *(char *)(g4 + 72) = 0;
    return g2;
}

// Address range: 0x7986 - 0x7987
int32_t function_7986(int32_t a1) {
    // 0x7986
    return g2;
}

// Address range: 0x798b - 0x7995
int32_t function_798b(int32_t a1) {
    // 0x798b
    unknown_d480();
    return unknown_d4e8();
}

// Address range: 0x79a0 - 0x7a6c
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::_M_insert_aux(__gnu_cxx::__normal_iterator<unsigned char *, std::vector<unsigned char, std::allocator<unsigned char> > >, unsigned char const &)
int32_t _ZNSt6vectorIhSaIhEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPhS1_EERKh(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g4; // 0x79a3
    g4 = v1;
    int32_t v3 = g8; // 0x79bb
    g8 = a2;
    int32_t v4 = g6; // 0x79c3
    int32_t v5 = *(int32_t *)(v1 + 4); // 0x79c7
    int32_t v6 = g3; // 0x79cd
    if (v5 == *(int32_t *)(v1 + 8)) {
        int32_t v7 = *a1; // 0x7a38
        int32_t v8 = v5 - v7; // 0x7a3a
        g2 = v8;
        int32_t result = v8; // 0x7a69
        if (v8 == -1) {
            // bb
            result = function_7af8(0x24848900);
            a2 = g8;
            // branch -> 0x7a45
        }
        // 0x7a45
        g3 = 1;
        g6 = a2 - v7;
        if (result != 0) {
            int32_t v9 = 2 * result; // 0x7a54
            g6 = v9;
            g3 = result < v9 | -1 * result == 0 ? v9 : -1;
            // branch -> 0x7a61
        }
        // 0x7a61
        return result;
    }
    int32_t v10 = 0; // ecx
    int32_t v11 = 1; // 0x79e2
    if (v5 != 0) {
        // 0x79d9
        *(char *)v5 = *(char *)(v5 - 1);
        int32_t v12 = *(int32_t *)(g4 + 4); // 0x79df
        v10 = v12;
        v1 = g4;
        v11 = v12 + 1;
        // branch -> 0x79e2
    }
    // 0x79e2
    *(int32_t *)(v1 + 4) = v11;
    if (v10 - 1 - g8 != 0) {
        // 0x7a20
        // branch -> 0x79f2
    }
    // 0x79f2
    *(char *)g8 = *(char *)a3;
    g4 = v2;
    g8 = v3;
    g6 = v4;
    g3 = v6;
    return 0;
}

// Address range: 0x7ae3 - 0x7af1
int32_t function_7ae3(void) {
    int32_t * v1 = (int32_t *)-0x7610fec5; // 0x7ae3
    *v1 = *v1 - 1;
    // 0x7aef
    return 0;
    // 0x7aeb
    *(int32_t *)8 = 0;
    int32_t result; // eax
    return result;
}

// Address range: 0x7af3 - 0x7af4
int32_t function_7af3(void) {
    // 0x7af3
    return g2;
}

// Address range: 0x7af8 - 0x7aff
int32_t function_7af8(int32_t a1) {
    // 0x7af8
    return g2;
}

// Address range: 0x7b10 - 0x7db1
// Demangled:     std::vector<CService, std::allocator<CService> >::_M_fill_insert(__gnu_cxx::__normal_iterator<CService *, std::vector<CService, std::allocator<CService> > >, unsigned int, CService const &)
int32_t _ZNSt6vectorI8CServiceSaIS0_EE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPS0_S2_EEjRKS0_(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    g6 = a3;
    g8 = v1;
    g4 = a2;
    if (a3 == 0) {
        // 0x7c50
        return 0;
    }
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x7b3b
    g7 = v2;
    int32_t result; // 0x7cd1
    if (0x38e38e39 * (*(int32_t *)(v1 + 8) - v2) / 2 >= a3) {
        int32_t v3 = *(int32_t *)a4; // 0x7b53
        int32_t v4 = *(int32_t *)(a4 + 4); // 0x7b5a
        int32_t v5 = *(int32_t *)(a4 + 8); // 0x7b61
        int32_t v6 = *(int32_t *)(a4 + (int32_t)&g53); // 0x7b68
        uint16_t v7 = *(int16_t *)(a4 + (int32_t)&g10); // 0x7b6f
        int32_t v8 = 0x38e38e39 * (v2 - a2) / 2; // 0x7b79
        g3 = v8;
        int32_t v9 = v8; // 0x7b8c
        if (v8 > a3) {
            // bb
            function_7e08(v3, v4, v5, v6, v7, 0x24848900);
            v2 = g7;
            v9 = g3;
            // branch -> 0x7b8c
        }
        int32_t v10 = a3 - v9; // 0x7b8c
        result = v2;
        if (v10 == 0) {
            // branch -> 0x7bcb
        } else {
            // branch -> 0x7b98
            while (true) {
                int32_t v11 = 0; // 0x7bc0
                if (v2 != 0) {
                    // 0x7b9c
                    *(int32_t *)v2 = v3;
                    *(int32_t *)(result + 4) = v4;
                    *(int32_t *)(result + 8) = v5;
                    *(int32_t *)(result + 12) = v6;
                    *(int16_t *)(result + 16) = v7;
                    v11 = result;
                    // branch -> 0x7bc0
                }
                int32_t v12 = v11 + 18; // 0x7bc0
                result = v12;
                int32_t v13 = v10 - 1; // 0x7bc3
                v10 = v13;
                if (v13 == 0) {
                    // break -> 0x7bc8
                    break;
                }
                v10 = v13;
                v2 = v12;
                // continue -> 0x7b98
            }
            // 0x7bc8
            v2 = g7;
            // branch -> 0x7bcb
        }
        int32_t v14 = v2 + 18 * v10; // 0x7bd4
        g2 = v14;
        *(int32_t *)(g8 + 4) = v14;
        int32_t v15; // 0x7bda
        if (v2 == g4) {
            // bb71
            v15 = function_7ee3();
            g2 = v15;
            // branch -> 0x7be0
        } else {
            // 0x7bcb
            v15 = g2;
            // branch -> 0x7be0
        }
        int32_t v16 = g4; // 0x7be0
        v10 = v16;
        int32_t v17 = v15; // 0x7bee
        // branch -> 0x7be8
        while (true) {
            int32_t v18 = 0; // 0x7c0d
            int32_t v19 = v16; // 0x7c0a
            if (v17 != 0) {
                // 0x7bec
                *(int32_t *)v17 = *(int32_t *)v16;
                *(int32_t *)(g2 + 4) = *(int32_t *)(v10 + 4);
                *(int32_t *)(g2 + 8) = *(int32_t *)(v10 + 8);
                *(int32_t *)(g2 + 12) = *(int32_t *)(v10 + 12);
                *(int16_t *)(g2 + 16) = *(int16_t *)(v10 + 16);
                v18 = g2;
                v19 = v10;
                // branch -> 0x7c0a
            }
            int32_t v20 = v19 + 18; // 0x7c0a
            v10 = v20;
            int32_t v21 = v18 + 18; // 0x7c0d
            g2 = v21;
            if (g7 == v20) {
                // break -> 0x7c14
                break;
            }
            v16 = v20;
            v17 = v21;
            // continue -> 0x7be8
        }
        int32_t * v22 = (int32_t *)(g8 + 4); // 0x7c22
        *v22 = *v22 + 18 * g3;
        g5 = v6;
        result = v7;
        *(int32_t *)g4 = v3;
        *(int32_t *)(g4 + 4) = v4;
        *(int32_t *)(g4 + 8) = v5;
        *(int32_t *)(g4 + 12) = g5;
        *(int16_t *)(g4 + 16) = (int16_t)result;
        int32_t v23 = g4 + 18; // 0x7c47
        g4 = v23;
        // branch -> 0x7c38
        while (g7 != v23) {
            // 0x7c38
            *(int32_t *)v23 = v3;
            *(int32_t *)(g4 + 4) = v4;
            *(int32_t *)(g4 + 8) = v5;
            *(int32_t *)(g4 + 12) = g5;
            *(int16_t *)(g4 + 16) = (int16_t)result;
            v23 = g4 + 18;
            g4 = v23;
            // continue -> 0x7c38
        }
        // 0x7c50
        // branch -> 0x7c50
        // 0x7c50
        return result;
    }
    int32_t v24 = *a1; // 0x7c70
    g2 = v24;
    int32_t v25 = 0x38e38e39 * (v2 - v24) / 2; // 0x7c7b
    uint32_t v26 = v25; // 0x7c8f
    if (0xe38e38e - v25 < a3) {
        int32_t v27 = function_7f03(0x24848900); // 0x7c85
        g2 = v27;
        v24 = v27;
        v26 = v25;
        // branch -> 0x7c8b
    }
    uint32_t v28 = (v26 >= a3 ? v26 : a3) + v26; // 0x7c92
    g7 = v28;
    if (v28 < v26) {
        int32_t v29 = function_7dd0(); // 0x7c94
        g2 = v29;
        v24 = v29;
        // branch -> 0x7c9a
    }
    if (v28 >= 0xe38e38f) {
        int32_t v30 = function_7dd0(); // 0x7ca0
        g2 = v30;
        v24 = v30;
        // branch -> 0x7ca6
    }
    int32_t v31 = 0x38e38e39 * (g4 - v24) / 2; // 0x7cac
    g5 = v31;
    if (v28 != 0) {
        // bb77
        function_7ef7();
        v31 = g5;
        // branch -> 0x7cba
    }
    // 0x7cba
    result = 18 * v31;
    int32_t v32 = a3; // edx
    int32_t v33 = a3; // 0x7cfe10
    // branch -> 0x7cd8
    while (true) {
        int32_t v34 = v33; // 0x7cfe
        int32_t v35 = 0; // 0x7cfb
        if (result != 0) {
            // 0x7cdc
            *(int32_t *)result = *(int32_t *)a4;
            *(int32_t *)(result + 4) = *(int32_t *)(a4 + 4);
            *(int32_t *)(result + 8) = *(int32_t *)(a4 + 8);
            int32_t v36 = *(int32_t *)(a4 + (int32_t)&g53); // 0x7ced
            *(int32_t *)(result + 12) = v36;
            uint16_t v37 = *(int16_t *)(a4 + (int32_t)&g10); // 0x7cf3
            g5 = v37;
            *(int16_t *)(result + 16) = v37;
            v34 = v32;
            v35 = result;
            // branch -> 0x7cfb
        }
        int32_t v38 = v34 - 1; // 0x7cfe
        v32 = v38;
        if (v38 == 0) {
            // break -> 0x7d03
            break;
        }
        v33 = v38;
        result = v35 + 18;
        // continue -> 0x7cd8
    }
    int32_t v39 = *(int32_t *)g8; // 0x7d03
    result = 0;
    int32_t v40 = g4; // 0x7d63
    int32_t v41 = 0; // 0x7d5c
    if (v39 != g4) {
        // 0x7d0d
        v32 = v39;
        int32_t v42 = g4; // 0x7d3816
        int32_t v43 = v39; // 0x7d14
        int32_t v44 = 0; // 0x7d16
        // branch -> 0x7d10
        int32_t v45; // 0x7d3f
        while (true) {
            // 0x7d10
            v45 = v42;
            int32_t v46 = 0; // 0x7d35
            int32_t v47 = v43; // 0x7d32
            if (v44 != 0) {
                // 0x7d14
                *(int32_t *)v44 = *(int32_t *)v43;
                *(int32_t *)(result + 4) = *(int32_t *)(v32 + 4);
                *(int32_t *)(result + 8) = *(int32_t *)(v32 + 8);
                *(int32_t *)(result + 12) = *(int32_t *)(v32 + 12);
                uint16_t v48 = *(int16_t *)(v32 + 16); // 0x7d2a
                g5 = v48;
                *(int16_t *)(result + 16) = v48;
                v45 = g4;
                v46 = result;
                v47 = v32;
                // branch -> 0x7d32
            }
            int32_t v49 = v47 + 18; // 0x7d32
            v32 = v49;
            int32_t v50 = v46 + 18; // 0x7d35
            result = v50;
            if (v45 == v49) {
                // break -> 0x7d3c
                break;
            }
            v42 = v45;
            v43 = v49;
            v44 = v50;
            // continue -> 0x7d10
        }
        uint32_t v51 = v45 - (v39 + 18); // 0x7d45
        v40 = v45;
        v41 = v51 - v51 % 2 + 18;
        // branch -> 0x7d56
    }
    int32_t v52 = *(int32_t *)(g8 + 4); // 0x7d59
    int32_t v53 = v41 + 18 * a3; // 0x7d5c
    g3 = v53;
    if (v52 != v40) {
        // 0x7d63
        v32 = v40;
        result = v53;
        int32_t v54 = v52; // 0x7d9025
        // branch -> 0x7d68
        int32_t v55; // 0x7d97
        while (true) {
            // 0x7d68
            v55 = v54;
            int32_t v56 = 0; // 0x7d8d
            int32_t v57 = v40; // 0x7d8a
            if (v53 != 0) {
                // 0x7d6c
                *(int32_t *)v53 = *(int32_t *)v40;
                *(int32_t *)(result + 4) = *(int32_t *)(v32 + 4);
                *(int32_t *)(result + 8) = *(int32_t *)(v32 + 8);
                *(int32_t *)(result + 12) = *(int32_t *)(v32 + 12);
                uint16_t v58 = *(int16_t *)(v32 + 16); // 0x7d82
                g5 = v58;
                *(int16_t *)(result + 16) = v58;
                v55 = v52;
                v56 = result;
                v57 = v32;
                // branch -> 0x7d8a
            }
            int32_t v59 = v57 + 18; // 0x7d8a
            v32 = v59;
            int32_t v60 = v56 + 18; // 0x7d8d
            result = v60;
            if (v55 == v59) {
                // break -> 0x7d94
                break;
            }
            v54 = v55;
            v40 = v59;
            v53 = v60;
            // continue -> 0x7d68
        }
        // 0x7d94
        g3 += 2 * (v55 - (g4 + 18)) / 2 + 18;
        // branch -> 0x7da8
    }
    int32_t v61 = *(int32_t *)g8; // 0x7da8
    int32_t result2 = v61; // 0x7dae
    if (v61 == 0) {
        // bb78
        result2 = function_7db6();
        // branch -> 0x7dae
    }
    // 0x7dae
    return result2;
}

// Address range: 0x7db6 - 0x7dcb
int32_t function_7db6(void) {
    // 0x7db6
    *(int32_t *)(g8 + 4) = g3;
    int32_t v1 = 0; // eax
    *(int32_t *)g8 = v1;
    int32_t v2;
    int32_t result = v1 + v2; // 0x7dbf
    *(int32_t *)(g8 + 8) = result;
    return result;
}

// Address range: 0x7dd0 - 0x7e01
int32_t function_7dd0(void) {
    // 0x7dd0
    g7 = -4;
    return g2;
}

// Address range: 0x7e08 - 0x7ee3
int32_t function_7e08(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint16_t a5, int32_t a6) {
    int32_t result = g7; // 0x7e0b
    int32_t v1 = 18 * g6; // 0x7e0d
    int32_t v2 = result - v1; // 0x7e0f
    int32_t v3; // 0x7e53
    if (v1 == 0) {
        // 0x7e08
        v3 = g8;
        // branch -> 0x7e4f
    } else {
        // branch -> 0x7e20
        while (true) {
            int32_t v4 = result; // 0x7e48
            int32_t v5 = 0; // 0x7e45
            if (result != 0) {
                // 0x7e24
                *(int32_t *)result = *(int32_t *)v2;
                *(int32_t *)(result + 4) = *(int32_t *)(v2 + 4);
                *(int32_t *)(result + 8) = *(int32_t *)(v2 + 8);
                *(int32_t *)(result + 12) = *(int32_t *)(v2 + 12);
                *(int16_t *)(result + 16) = *(int16_t *)(v2 + 16);
                v4 = g7;
                v5 = result;
                // branch -> 0x7e42
            }
            int32_t v6 = v2 + 18; // 0x7e42
            v2 = v6;
            if (v4 == v6) {
                // break -> 0x7e4c
                break;
            }
            result = v5 + 18;
            v2 = v6;
            // continue -> 0x7e20
        }
        int32_t v7 = g8; // 0x7e4c
        v3 = v7;
        result = *(int32_t *)(v7 + 4);
        // branch -> 0x7e4f
    }
    // 0x7e4f
    *(int32_t *)(v3 + 4) = result + v1;
    int32_t v8 = g4; // 0x7e58
    int32_t v9 = (v2 - v8) / 2; // 0x7e5a
    int32_t v10; // 0x7ed7
    if (0x38e38e39 * v9 >= 1) {
        // 0x7e66
        result = 0;
        int32_t v11 = 0; // 0x7e74
        // branch -> 0x7e70
        while (true) {
            int32_t v12 = v11 - 18; // 0x7e70
            *(int32_t *)(v12 + g7) = *(int32_t *)(v12 + v2);
            int32_t v13 = result; // 0x7e78
            *(int32_t *)(v13 - 14 + g7) = *(int32_t *)(v2 - 14 + v13);
            int32_t v14 = result; // 0x7e80
            *(int32_t *)(v14 - 10 + g7) = *(int32_t *)(v2 - 10 + v14);
            int32_t v15 = result; // 0x7e88
            *(int32_t *)(v15 - 6 + g7) = *(int32_t *)(v2 - 6 + v15);
            int32_t v16 = result; // 0x7e90
            *(int16_t *)(v16 - 2 + g7) = *(int16_t *)(v2 - 2 + v16);
            int32_t v17 = result - 18; // 0x7e9a
            result = v17;
            if (v17 != -2 * v9) {
                // 0x7e70
                v11 = v17;
                // branch -> 0x7e70
                continue;
            } else {
                // 0x7ea1
                v8 = g4;
                // branch -> 0x7ea1
                // 0x7ea1
                g7 = v8 + v1;
                g3 = a1;
                result = a5;
                g8 = a3;
                int32_t v18 = v8; // 0x7ec8
                int32_t v19 = a1; // 0x7ec8
                // branch -> 0x7ec8
                while (true) {
                    // 0x7ec8
                    *(int32_t *)v18 = v19;
                    *(int32_t *)(g4 + 4) = a2;
                    *(int32_t *)(g4 + 8) = g8;
                    *(int32_t *)(g4 + 12) = a4;
                    *(int16_t *)(g4 + 16) = (int16_t)result;
                    v10 = g4 + 18;
                    g4 = v10;
                    if (g7 == v10) {
                        // 0x7ede
                        return result;
                    }
                  lab_0x7ec8:
                    // 0x7ec8
                    v18 = v10;
                    v19 = g3;
                    // branch -> 0x7ec8
                }
            }
        }
    }
    // 0x7ea1
    g7 = v8 + v1;
    g3 = a1;
    result = a5;
    g8 = a3;
    // branch -> 0x7ec8
    while (true) {
        // 0x7ec8
        *(int32_t *)v8 = a1;
        *(int32_t *)(g4 + 4) = a2;
        *(int32_t *)(g4 + 8) = g8;
        *(int32_t *)(g4 + 12) = a4;
        *(int16_t *)(g4 + 16) = (int16_t)result;
        v10 = g4 + 18;
        g4 = v10;
        if (g7 != v10) {
            goto lab_0x7ec8;
        }
        // 0x7ede
        return result;
    }
}

// Address range: 0x7ee3 - 0x7ef2
int32_t function_7ee3(void) {
    // 0x7ee3
    g7 = 9 * g3;
    int32_t result = g2 + 18 * g3; // 0x7ee7
    *(int32_t *)(g8 + 4) = result;
    return result;
}

// Address range: 0x7ef2 - 0x7ef3
int32_t function_7ef2(void) {
    // 0x7ef2
    return g2;
}

// Address range: 0x7ef7 - 0x7f03
int32_t function_7ef7(void) {
    // 0x7ef7
    return g2;
}

// Address range: 0x7f03 - 0x7f0a
int32_t function_7f03(int32_t a1) {
    // 0x7f03
    return g2;
}

// Address range: 0x7f10 - 0x7f35
// Demangled:     boost::unique_lock<AnnotatedMixin<boost::recursive_mutex> >::lock()
int32_t _ZN5boost11unique_lockI14AnnotatedMixinINS_15recursive_mutexEEE4lockEv(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t result = 0; // 0x7f32
    if (*(char *)(v1 + 4) != 0) {
        // bb
        result = function_7ff1(0x24848900, g4, g8, g6);
        // branch -> 0x7f30
    }
    // 0x7f30
    g4 = *(int32_t *)v1;
    return result;
}

// Address range: 0x7f4f - 0x7f5e
int32_t function_7f4f(void) {
    // 0x7f4f
    g7 = 1;
    if (g2 == *(int32_t *)(g4 + 76)) {
        // bb
        g2 = function_7fac();
        // branch -> 0x7f59
    }
    // 0x7f59
    return function_7f74();
}

// Address range: 0x7f60 - 0x7f67
int32_t function_7f60(void) {
    // 0x7f60
    return g2;
}

// Address range: 0x7f74 - 0x7f8b
int32_t function_7f74(void) {
    // 0x7f74
    if ((char)g7 != 0) {
        // bb
        g2 = function_7f60();
        // branch -> 0x7f78
    }
    int32_t * v1 = (int32_t *)(g4 + (int32_t)&g22); // 0x7f78
    *v1 = *v1 + 1;
    *(char *)(g4 + 72) = 1;
    *(int32_t *)(g4 + 76) = g2;
    return g2;
}

// Address range: 0x7f94 - 0x7fac
int32_t function_7f94(int32_t a1) {
    // 0x7f94
    *(char *)(g6 + 4) = 1;
    return a1 ^ 0x24848900;
}

// Address range: 0x7fac - 0x7fe7
int32_t function_7fac(void) {
    int32_t * v1 = (int32_t *)(g4 + (int32_t)&g22); // 0x7fac
    *v1 = *v1 + 1;
    if (g2 == 0) {
        // bb
        function_7f94(g4);
        // branch -> 0x7fbc
    }
    // 0x7fbc
    return unknown_dab4();
}

// Address range: 0x7ff1 - 0x801f
// From class:    N5boost10lock_errorE
// Type:          constructor
int32_t function_7ff1(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x7ff1
    int32_t v1; // bp+20
    int32_t v2 = &v1; // 0x7ff1
    v1 = (int32_t)&g30;
    g8 = unknown_f230(v2);
    return unknown_dc90(v2);
}

// Address range: 0x802e - 0x8034
int32_t function_802e(void) {
    // 0x802e
    return 0;
}

// Address range: 0x8040 - 0x80ec
// Demangled:     std::vector<unsigned char, std::allocator<unsigned char> >::_M_fill_insert(__gnu_cxx::__normal_iterator<unsigned char *, std::vector<unsigned char, std::allocator<unsigned char> > >, unsigned int, unsigned char const &)
int32_t _ZNSt6vectorIhSaIhEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPhS1_EEjRKh(int32_t a1, int32_t a2, uint32_t a3, char * a4) {
    int32_t v1 = g4; // 0x8043
    g4 = a3;
    g7 = (int32_t)a4;
    int32_t v2 = g8; // 0x805b
    g8 = a1;
    g6 = a2;
    if (a3 == 0) {
        // bb
        function_81c1(0x24848900);
        a1 = g8;
        // branch -> 0x8077
    }
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x8077
    g3 = v3;
    int32_t v4 = *(int32_t *)(a1 + 8) - v3; // 0x807d
    g2 = v4;
    if (v4 < a3) {
        // bb20
        g2 = function_80f8();
        v3 = g3;
        // branch -> 0x8083
    }
    // 0x8083
    g5 = (int32_t)*(char *)g7;
    int32_t v5 = v3 - g6; // 0x8088
    g7 = v5;
    if (v5 <= a3) {
        // bb21
        function_81e8();
        v3 = g3;
        // branch -> 0x8092
    }
    // 0x8092
    g2 = a3;
    if (a3 != 0) {
        // bb22
        function_8240(a3);
        // branch -> 0x80a8
    }
    int32_t v6 = v3 + a3; // 0x80ac
    g2 = v6;
    int32_t v7 = v3 - a3 - g6; // 0x80ae
    g7 = v7;
    *(int32_t *)(g8 + 4) = v6;
    if (v7 != 0) {
        // bb23
        function_8290();
        // branch -> 0x80b9
    }
    // 0x80b9
    g4 = v1;
    g8 = v2;
    return 0;
}

// Address range: 0x80f8 - 0x8138
int32_t function_80f8(void) {
    // 0x80f8
    g2 = g8;
    int32_t v1 = g3 - g8; // 0x80fa
    int32_t v2 = g4; // 0x8100
    int32_t result = g8; // 0x8115
    int32_t v3 = v2; // 0x810a
    uint32_t v4 = v1; // 0x8117
    if (v2 > -1 - v1) {
        int32_t v5 = function_82c8(); // 0x8102
        g2 = v5;
        result = v5;
        v3 = g4;
        v4 = v1;
        // branch -> 0x8108
    }
    int32_t v6 = v4 >= v3 ? v4 : v3; // 0x810c
    int32_t v7 = v6 + v4; // 0x8117
    g3 = v7;
    if (v7 >= v4) {
        // bb9
        result = function_82b0(v6);
        // branch -> 0x812d
    }
    // 0x812d
    return result;
}

// Address range: 0x8143 - 0x8175
int32_t function_8143(int32_t a1) {
    unsigned char v1 = *(char *)&g7; // 0x814b
    g7 = 0;
    int32_t result = g8; // 0x816a
    if (g6 == g8) {
        // bb
        result = function_817e(g3 + a1, (int32_t)v1, g4);
        // branch -> 0x8166
    }
    // 0x8166
    return result;
}

// Address range: 0x817e - 0x819c
int32_t function_817e(int32_t a1, int32_t a2, int32_t a3) {
    // 0x817e
    g7 = g3 + g7 + g4;
    g4 = 0;
    int32_t v1 = *(int32_t *)(g8 + 4) - g6; // 0x8187
    int32_t result = v1; // 0x818e
    if (v1 == 0) {
        // bb
        result = function_81a5();
        // branch -> 0x818b
    }
    // 0x818b
    g4 = result;
    return result;
}

// Address range: 0x81a5 - 0x81b0
int32_t function_81a5(void) {
    // 0x81a5
    g2 = g8;
    g4 += g7;
    int32_t result = g8; // 0x81ad
    if (g8 == 0) {
        // bb
        result = function_81b5();
        // branch -> 0x81ad
    }
    // 0x81ad
    return result;
}

// Address range: 0x81b5 - 0x81c1
int32_t function_81b5(void) {
    // 0x81b5
    *(int32_t *)g8 = g3;
    int32_t v1;
    g3 += v1;
    *(int32_t *)(g8 + 4) = g4;
    *(int32_t *)(g8 + 8) = g3;
    return g2;
}

// Address range: 0x81c1 - 0x81e6
int32_t function_81c1(int32_t a1) {
    int32_t v1 = a1 ^ 0x24848900; // 0x81c5
    g2 = v1;
    int32_t result = v1; // 0x81e5
    if (v1 != 0) {
        // bb
        result = function_82c3();
        // branch -> 0x81d2
    }
    // 0x81d2
    return result;
}

// Address range: 0x81e8 - 0x8204
int32_t function_81e8(void) {
    // 0x81e8
    g5 = g4 - g7;
    return g2;
}

// Address range: 0x8208 - 0x823e
int32_t function_8208(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x74dfdbac; // 0x8208
    *v1 = *v1 - 1;
    int32_t v2 = 0; // esi
    int32_t * v3 = (int32_t *)(v2 + 4); // 0x8211
    int32_t v4 = *v3; // 0x8211
    g2 = v4;
    int32_t v5 = 0; // edx
    *v3 = v4;
    int32_t v6; // 0x821b
    if (v5 != 0) {
        // bb
        v6 = function_8270();
        // branch -> 0x821b
    } else {
        // 0x8208
        v6 = g2;
        // branch -> 0x821b
    }
    // 0x821b
    *(int32_t *)(v2 + 4) = v5 + v6;
    int32_t v7 = a1 ^ 0x24848900; // 0x8224
    g2 = v7;
    int32_t result = v7; // 0x8239
    if (v7 != 0) {
        // bb102
        result = function_82c3();
        // branch -> 0x8231
    }
    // 0x8231
    return result;
}

// Address range: 0x8240 - 0x8253
int32_t function_8240(int32_t a1) {
    // 0x8240
    return g2;
}

// Address range: 0x8257 - 0x826d
int32_t function_8257(int32_t a1) {
    int32_t * v1 = (int32_t *)-0x49f0fbba; // 0x8257
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x8270 - 0x827b
int32_t function_8270(void) {
    // 0x8270
    return g2;
}

// Address range: 0x827f - 0x8289
int32_t function_827f(void) {
    int32_t * v1 = (int32_t *)0x548b0446; // 0x827f
    *v1 = *v1 - 1;
    return 0;
}

// Address range: 0x8290 - 0x82b0
int32_t function_8290(void) {
    // 0x8290
    g5 = (uint32_t)g5 % 256;
    return g2;
}

// Address range: 0x82b0 - 0x82c3
int32_t function_82b0(int32_t a1) {
    // 0x82b0
    if (g3 != 0) {
        // bb
        function_82d4();
        // branch -> 0x82b4
    }
    // 0x82b4
    g3 = 0;
    return function_8143(0);
}

// Address range: 0x82c3 - 0x82c8
int32_t function_82c3(void) {
    // 0x82c3
    return g2;
}

// Address range: 0x82c8 - 0x82d4
int32_t function_82c8(void) {
    // 0x82c8
    return g2;
}

// Address range: 0x82d4 - 0x82dd
int32_t function_82d4(void) {
    // 0x82d4
    return g2;
}

// Address range: 0x82e0 - 0x82f7
int32_t _GLOBAL__sub_I_nConnectTimeout(void) {
    // 0x82e0
    return 0;
}

// Address range: 0x8325 - 0x8326
int32_t function_8325(void) {
    // 0x8325
    return g2;
}

// Address range: 0x8338 - 0x833e
int32_t function_8338(void) {
    // 0x8338
    return 0;
}

// Address range: 0x8342 - 0x8348
int32_t function_8342(void) {
    // 0x8342
    return 0;
}

// Address range: 0x8358 - 0x8359
int32_t function_8358(void) {
    // 0x8358
    return 0;
}

// Address range: 0x839f - 0x83b2
int32_t function_839f(int32_t a1) {
    int32_t * v1 = (int32_t *)0x651c2444; // 0x839f
    *v1 = *v1 - 1;
    int32_t v2 = 0x24848900; // 0x83a5
    g2 = v2;
    int32_t result = v2; // 0x83b1
    if (v2 != 0) {
        // bb
        result = function_83e7();
        // branch -> 0x83ad
    }
    // 0x83ad
    return result;
}

// Address range: 0x83e2 - 0x83e7
int32_t function_83e2(void) {
    // 0x83e2
    return function_8325();
}

// Address range: 0x83e7 - 0x83ec
int32_t function_83e7(void) {
    // 0x83e7
    return g2;
}

// Address range: 0xc600 - 0xc601
int32_t function_c600(int32_t a1) {
    // 0xc600
    return g2;
}

// Address range: 0xc670 - 0xc671
int32_t function_c670(int32_t a1) {
    // 0xc670
    return g2;
}

// Address range: 0xc730 - 0xc731
int32_t function_c730(int32_t a1) {
    // 0xc730
    return g2;
}

// Address range: 0xc750 - 0xc751
int32_t function_c750(int32_t a1) {
    // 0xc750
    return g2;
}

// Address range: 0xc810 - 0xc811
int32_t function_c810(int32_t a1) {
    // 0xc810
    return g2;
}

// Address range: 0xc900 - 0xc901
int32_t function_c900(int32_t a1) {
    // 0xc900
    return g2;
}

// Address range: 0xcce0 - 0xcce1
int32_t function_cce0(int32_t a1) {
    // 0xcce0
    return g2;
}

// Address range: 0xcfa0 - 0xcfa1
int32_t function_cfa0(int32_t a1) {
    // 0xcfa0
    return g2;
}

// Address range: 0xb7104826 - 0xb7104827
int32_t function_b7104826(void) {
    // 0xb7104826
    return g2;
}

// Address range: 0xf8c1f889 - 0xf8c1f88a
int32_t function_f8c1f889(void) {
    // 0xf8c1f889
    return g2;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected language: C++
// Detected functions: 535
// Decompilation date: 2018-06-10 00:19:43
